/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/exercises/imageProcessing.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.5.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-05-04T22:49Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.5.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( _i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.5
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2020-03-14
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
					dataPriv.get( this, "events" ) || Object.create( null )
				)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px";
				tr.style.height = "1px";
				trChild.style.height = "9px";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = (
					dataPriv.get( cur, "events" ) || Object.create( null )
				)[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script
			if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			if ( typeof props.top === "number" ) {
				props.top += "px";
			}
			if ( typeof props.left === "number" ) {
				props.left += "px";
			}
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./src/exercises/imageProcessing.ts":
/*!******************************************!*\
  !*** ./src/exercises/imageProcessing.ts ***!
  \******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../structures/Matrix */ "./src/structures/Matrix.ts");
/* harmony import */ var _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../structures/RationalNumber */ "./src/structures/RationalNumber.ts");
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




function imageDataToRGBA(imageData) {
  var imgR = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
  var imgG = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
  var imgB = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
  var imgA = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
  var idx = 0;

  for (var x = 0; x < imageData.width; x++) {
    imgR[x] = [];
    imgG[x] = [];
    imgB[x] = [];
    imgA[x] = [];

    for (var y = 0; y < imageData.height; y++) {
      imgR.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
      imgG.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
      imgB.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
      imgA.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
    }
  }

  return [imgR, imgG, imgB, imgA];
}

function imageDataFromRGBA(rgba) {
  var imgR = rgba[0];
  var imgG = rgba[1];
  var imgB = rgba[2];
  var imgA = rgba[3];
  var width = imgR.m;
  var height = imgR.n;
  var imageData = new ImageData(width, height);
  var idx = 0;

  for (var x = 0; x < width; x++) {
    for (var y = 0; y < height; y++) {
      imageData.data[idx++] = imgR.elements[x][y].toNumber();
      imageData.data[idx++] = imgG.elements[x][y].toNumber();
      imageData.data[idx++] = imgB.elements[x][y].toNumber();
      imageData.data[idx++] = imgA.elements[x][y].toNumber();
    }
  }

  return imageData;
}

$(document).ready(function () {
  var canvas1 = $("#canvas1")[0];
  var ctx1 = canvas1.getContext("2d");
  var image = new Image();

  image.onload = function () {
    canvas1.height = image.height;
    canvas1.width = image.width;
    ctx1.drawImage(image, 0, 0);
    var imgData1 = ctx1.getImageData(0, 0, image.width, image.height);
    var rgba = imageDataToRGBA(imgData1); // duplicate

    var imgData2 = imageDataFromRGBA(rgba);
    var canvas2 = $("#canvas2")[0];
    var ctx2 = canvas2.getContext("2d");
    canvas2.height = imgData2.height;
    canvas2.width = imgData2.width;
    ctx2.putImageData(imgData2, 0, 0); // convolute

    var canvas3 = $("#canvas3")[0];
    var ctx3 = canvas3.getContext("2d");
    var kernel = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](3, 3);
    /*
    kernel.elements[0][0] = new RationalNumber(0);
    kernel.elements[0][1] = new RationalNumber(-1);
    kernel.elements[0][2] = new RationalNumber(0);
    kernel.elements[1][0] = new RationalNumber(-1);
    kernel.elements[1][1] = new RationalNumber(5);
    kernel.elements[1][2] = new RationalNumber(-1);
    kernel.elements[2][0] = new RationalNumber(0);
    kernel.elements[2][1] = new RationalNumber(-1);
    kernel.elements[2][2] = new RationalNumber(0);
    */

    /*
    kernel.elements[0][0] = new RationalNumber(-1);
    kernel.elements[0][1] = new RationalNumber(-1);
    kernel.elements[0][2] = new RationalNumber(-1);
    kernel.elements[1][0] = new RationalNumber(-1);
    kernel.elements[1][1] = new RationalNumber(8);
    kernel.elements[1][2] = new RationalNumber(-1);
    kernel.elements[2][0] = new RationalNumber(-1);
    kernel.elements[2][1] = new RationalNumber(-1);
    kernel.elements[2][2] = new RationalNumber(-1);
    */

    /*
    kernel.elements[0][0] = new RationalNumber(0);
    kernel.elements[0][1] = new RationalNumber(0);
    kernel.elements[0][2] = new RationalNumber(0);
    kernel.elements[1][0] = new RationalNumber(0);
    kernel.elements[1][1] = new RationalNumber(1);
    kernel.elements[1][2] = new RationalNumber(0);
    kernel.elements[2][0] = new RationalNumber(0);
    kernel.elements[2][1] = new RationalNumber(0);
    kernel.elements[2][2] = new RationalNumber(0);
    //*/
    //*

    kernel.elements[0][0] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
    kernel.elements[0][1] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](-1);
    kernel.elements[0][2] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
    kernel.elements[1][0] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
    kernel.elements[1][1] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](2);
    kernel.elements[1][2] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
    kernel.elements[2][0] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
    kernel.elements[2][1] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
    kernel.elements[2][2] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0); //*/
    // const newRgba: [Matrix, Matrix, Matrix, Matrix] = [rgba[0].convolute(kernel), rgba[1].convolute(kernel), rgba[2].convolute(kernel), rgba[3].convolute(kernel)];

    for (var i = 0; i < rgba[0].m; i++) {
      for (var j = 0; j < rgba[0].n; j++) {
        rgba[0].elements[i][j] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        rgba[2].elements[i][j] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
      }
    }

    var newRgba = [rgba[0], rgba[1].convolute(kernel), rgba[2], rgba[3]];
    var imgData3 = imageDataFromRGBA(newRgba);
    canvas3.height = imgData3.height;
    canvas3.width = imgData3.width;
    ctx3.putImageData(imgData3, 0, 0);
  };

  image.src = "data:image/png;base64," + encodedImg; // Other ways of doing it

  var imgSrc = $("#imgSource").attr("src").replace("data:image/png;base64,", "");
  var binSrc = atob(imgSrc);
  var img = Uint8Array.from(binSrc, function (c) {
    return c.charCodeAt(0);
  }); // reverse

  var binDest = "";

  var _iterator = _createForOfIteratorHelper(img),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var i = _step.value;
      binDest += String.fromCharCode(i);
    } // String.fromCharCode.apply(null, img); // throww "Maximum call stack size exceeded"

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var imgDest = btoa(binDest);
  $("#imgDestination").attr("src", "data:image/png;base64," + imgDest);
});
var encodedImg = "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";
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./src/structures/ArithmeticEvaluator.ts":
/*!***********************************************!*\
  !*** ./src/structures/ArithmeticEvaluator.ts ***!
  \***********************************************/
/*! exports provided: ArithmeticEvaluator, TokenType, Token, Lexer, Parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArithmeticEvaluator", function() { return ArithmeticEvaluator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenType", function() { return TokenType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lexer", function() { return Lexer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony import */ var _Queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Queue */ "./src/structures/Queue.ts");
/* harmony import */ var _RationalNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RationalNumber */ "./src/structures/RationalNumber.ts");
/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Stack */ "./src/structures/Stack.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var ArithmeticEvaluator = /*#__PURE__*/function () {
  function ArithmeticEvaluator() {
    _classCallCheck(this, ArithmeticEvaluator);
  }

  _createClass(ArithmeticEvaluator, null, [{
    key: "toReversePolishNotation",
    value: function toReversePolishNotation(code) {
      var tokens = code.match(/\(|\)|\d+(\.\d+)?|\w+|[\+\-\*\/\^]/g);
      var i = 0;
      var outputQueue = new _Queue__WEBPACK_IMPORTED_MODULE_0__["Queue"]();
      var operatorStack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();

      while (i < tokens.length) {
        if (this.isNumber(tokens[i])) {
          outputQueue.enqueue(tokens[i]);
        } else if (this.isOperator(tokens[i])) {
          var op1 = tokens[i];

          while (!operatorStack.isEmpty() && this.isOperator(operatorStack.peek())) {
            if (this.isLeftAssociativeOperator(op1) && this.precedence(op1) <= this.precedence(operatorStack.peek()) || this.isRightAssociativeOperator(op1) && this.precedence(op1) < this.precedence(operatorStack.peek())) {
              outputQueue.enqueue(operatorStack.pop());
            } else {
              break;
            }
          }

          operatorStack.push(op1);
        } else if (tokens[i] === "(") {
          operatorStack.push(tokens[i]);
        } else if (tokens[i] === ")") {
          while (!operatorStack.isEmpty() && operatorStack.peek() !== "(") {
            outputQueue.enqueue(operatorStack.pop());
          }

          if (!operatorStack.isEmpty() && operatorStack.peek() === "(") {
            operatorStack.pop();
          } else {
            throw new Error("Mismatched parentheses.");
          }
        }

        i++;
      }

      while (!operatorStack.isEmpty()) {
        if (operatorStack.peek() === "(") {
          throw new Error("Mismatched parentheses.");
        } else {
          outputQueue.enqueue(operatorStack.pop());
        }
      }

      return outputQueue.toArray();
    }
  }, {
    key: "evaluateFromRPN",
    value: function evaluateFromRPN(tokens) {
      var stack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();

      for (var i = 0; i < tokens.length; i++) {
        if (!this.isOperator(tokens[i])) {
          stack.push(parseFloat(tokens[i]));
        } else {
          var op1 = stack.pop();
          var op2 = stack.pop();

          switch (tokens[i]) {
            case "+":
              stack.push(op2 + op1);
              break;

            case "-":
              stack.push(op2 - op1);
              break;

            case "*":
              stack.push(op2 * op1);
              break;

            case "/":
              stack.push(op2 / op1);
              break;

            case "^":
              stack.push(Math.pow(op2, op1));
              break;
          }
        }
      }

      return stack.pop();
    }
  }, {
    key: "isNumber",
    value: function isNumber(code) {
      return /^\d/.test(code);
    }
  }, {
    key: "isOperator",
    value: function isOperator(code) {
      return /[\+\-\*\/\^]/.test(code);
    }
  }, {
    key: "isLeftAssociativeOperator",
    value: function isLeftAssociativeOperator(operator) {
      return /[\+\-\*\/]/.test(operator);
    }
  }, {
    key: "isRightAssociativeOperator",
    value: function isRightAssociativeOperator(operator) {
      return /[\^]/.test(operator);
    }
  }, {
    key: "precedence",
    value: function precedence(operator) {
      if (/[\+\-]/.test(operator)) {
        return 1;
      }

      if (/[\*\/]/.test(operator)) {
        return 2;
      }

      if (/[\^]/.test(operator)) {
        return 3;
      }

      throw new Error("Unknown operator.");
    }
  }]);

  return ArithmeticEvaluator;
}();
var TokenType;

(function (TokenType) {
  TokenType[TokenType["Plus"] = 0] = "Plus";
  TokenType[TokenType["Minus"] = 1] = "Minus";
  TokenType[TokenType["Multiply"] = 2] = "Multiply";
  TokenType[TokenType["Divide"] = 3] = "Divide";
  TokenType[TokenType["Exponent"] = 4] = "Exponent";
  TokenType[TokenType["Number"] = 5] = "Number";
  TokenType[TokenType["LParen"] = 6] = "LParen";
  TokenType[TokenType["RParen"] = 7] = "RParen";
  TokenType[TokenType["End"] = 8] = "End";
  TokenType[TokenType["Unknown"] = 9] = "Unknown";
})(TokenType || (TokenType = {}));

var Token = function Token(type, value) {
  _classCallCheck(this, Token);

  _defineProperty(this, "type", void 0);

  _defineProperty(this, "value", void 0);

  this.type = type;
  this.value = value;
};
var Lexer = /*#__PURE__*/function () {
  function Lexer(input) {
    _classCallCheck(this, Lexer);

    _defineProperty(this, "tokens", void 0);

    _defineProperty(this, "tokenIndex", void 0);

    this.tokens = input.replace(" ", "").match(/\(|\)|\d+(\.\d+)?|[\+\-\*\/\^]/g);
    this.tokenIndex = 0;
  }

  _createClass(Lexer, [{
    key: "getNextToken",
    value: function getNextToken() {
      if (this.tokens.length === this.tokenIndex) {
        return new Token(TokenType.End);
      }

      var input = this.tokens[this.tokenIndex++];
      return this.getToken(input);
    }
  }, {
    key: "getCurrentToken",
    value: function getCurrentToken() {
      if (this.tokens.length - 1 === this.tokenIndex) {
        return new Token(TokenType.End);
      }

      var input = this.tokens[this.tokenIndex];
      return this.getToken(input);
    }
  }, {
    key: "revert",
    value: function revert() {
      if (this.tokenIndex <= 0) {
        throw Error("Index out of range");
      }

      this.tokenIndex--;
    }
  }, {
    key: "getToken",
    value: function getToken(input) {
      if (/\+/.test(input)) {
        return new Token(TokenType.Plus);
      }

      if (/\-/.test(input)) {
        return new Token(TokenType.Minus);
      }

      if (/\*/.test(input)) {
        return new Token(TokenType.Multiply);
      }

      if (/\//.test(input)) {
        return new Token(TokenType.Divide);
      }

      if (/\^/.test(input)) {
        return new Token(TokenType.Exponent);
      }

      if (/\d+(\.\d+)?/.test(input)) {
        return new Token(TokenType.Number, parseFloat(input));
      }

      if (/\(/.test(input)) {
        return new Token(TokenType.LParen);
      }

      if (/\)/.test(input)) {
        return new Token(TokenType.RParen);
      }

      return new Token(TokenType.Unknown);
    }
  }]);

  return Lexer;
}();
var Parser = /*#__PURE__*/function () {
  function Parser() {
    _classCallCheck(this, Parser);

    _defineProperty(this, "lex", void 0);
  }

  _createClass(Parser, [{
    key: "parse",
    value: function parse(code) {
      this.lex = new Lexer(code);
      var expression = this.fourthOrderOperators();
      var token = this.lex.getCurrentToken(); // is already advanced because of number()

      if (token.type === TokenType.End) {
        return expression;
      }

      throw Error("End expected");
    } // addition and substraction

  }, {
    key: "fourthOrderOperators",
    value: function fourthOrderOperators() {
      var component1 = this.thirdOrderOperators();
      var token = this.lex.getNextToken();

      while (token.type === TokenType.Plus || token.type === TokenType.Minus) {
        var component2 = this.thirdOrderOperators();

        if (token.type === TokenType.Plus) {
          component1 = component1.add(component2);
        } else if (token.type === TokenType.Minus) {
          component1 = component1.sub(component2);
        }

        token = this.lex.getNextToken();
      }

      this.lex.revert();
      return component1;
    } // multiplication and division

  }, {
    key: "thirdOrderOperators",
    value: function thirdOrderOperators() {
      var factor1 = this.secondOrderOperators();
      var token = this.lex.getNextToken();

      while (token.type === TokenType.Multiply || token.type === TokenType.Divide) {
        var factor2 = this.secondOrderOperators();

        if (token.type === TokenType.Multiply) {
          factor1 = factor1.mult(factor2);
        } else if (token.type === TokenType.Divide) {
          factor1 = factor1.div(factor2);
        }

        token = this.lex.getNextToken();
      }

      this.lex.revert();
      return factor1;
    } // exponents and roots

  }, {
    key: "secondOrderOperators",
    value: function secondOrderOperators() {
      var factor1 = this.firstOrderOperators();
      var token = this.lex.getNextToken();

      while (token.type === TokenType.Exponent) {
        var factor2 = this.firstOrderOperators();
        factor1 = factor1.exp(factor2);
        token = this.lex.getNextToken();
      }

      this.lex.revert();
      return factor1;
    } // numbers and parantheses

  }, {
    key: "firstOrderOperators",
    value: function firstOrderOperators() {
      var value = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](1);
      var token = this.lex.getNextToken();

      if (token.type === TokenType.Plus || token.type === TokenType.Minus) {
        if (token.type === TokenType.Minus) {
          value = value.mult(-1);
        }

        token = this.lex.getNextToken();
      }

      if (token.type === TokenType.LParen) {
        value = value.mult(this.fourthOrderOperators());
        token = this.lex.getNextToken();

        if (token.type !== TokenType.RParen) {
          throw Error("Unbalanced parenthesis");
        }
      } else {
        if (token.type === TokenType.Number) {
          value = value.mult(token.value);
        } else {
          throw Error("Not a number");
        }
      }

      return value;
    }
  }]);

  return Parser;
}();
/*
	public static evaluate(expresion: string): RationalNumber {
	var digitPattern = new RegExp('0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9');
	var signPattern = new RegExp('\+|\-');
	var numberPattern = new RegExp('[' + signPattern + ']' + '{' + digitPattern + '}');
	var factorPattern = new RegExp(numberPattern + '|\(' + expressionPattern + '\)');
	var componentPattern = new RegExp(factorPattern + '[{( \* | \/ )' + factorPattern + '}]');
	var expressionPattern = new RegExp(componentPattern + '[{( \+ | \-)' + componentPattern + '}]');
}*/

/*
exprr: 4thORDER+;
4thORDER: component1=3rdORDER ((PLUS|MINUS) component2=3rdORDER)+;
3rdORDER: factor1=2NDORDER ((MULTIPLY|DIVIDE) factor1=2ndORDER)+
2ndORDER: factor1=1stORDER (EXPONENT factor2=1stORDER)+
1stORDER: (PLUS|MINUS|empty) (LPAREN value=4thORDER RPAREN| NUMBER)
*/

/***/ }),

/***/ "./src/structures/Matrix.ts":
/*!**********************************!*\
  !*** ./src/structures/Matrix.ts ***!
  \**********************************/
/*! exports provided: Matrix, MatrixIdentity, MatrixElimination, MatrixPermutation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix", function() { return Matrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatrixIdentity", function() { return MatrixIdentity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatrixElimination", function() { return MatrixElimination; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatrixPermutation", function() { return MatrixPermutation; });
/* harmony import */ var _RationalNumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RationalNumber */ "./src/structures/RationalNumber.ts");
/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector */ "./src/structures/Vector.ts");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var Matrix = /*#__PURE__*/function () {
  _createClass(Matrix, null, [{
    key: "augment",
    value: function augment(A, B) {
      if (A.m !== B.m) {
        throw new Error("The two matrices (vector) must have the same number of rows (elements).");
      }

      var ret = null;

      if (B instanceof Matrix) {
        ret = new Matrix(A.m, B.n + A.n);

        for (var i = 0; i < A.m; i++) {
          for (var j = 0; j < A.n; j++) {
            ret.elements[i][j] = A.elements[i][j];
          }
        }

        for (var _i = 0; _i < B.m; _i++) {
          for (var _j = 0; _j < B.n; _j++) {
            ret.elements[_i][A.n + _j] = B.elements[_i][_j];
          }
        }
      } else {
        if (B instanceof _Vector__WEBPACK_IMPORTED_MODULE_1__["Vector"]) {
          ret = new Matrix(A.m, A.n + 1);

          for (var _i2 = 0; _i2 < A.m; _i2++) {
            for (var _j2 = 0; _j2 < A.n; _j2++) {
              ret.elements[_i2][_j2] = A.elements[_i2][_j2];
            }
          }

          for (var _j3 = 0; _j3 < B.m; _j3++) {
            ret.elements[_j3][A.n] = B.elements[_j3];
          }
        }
      }

      return ret;
    } // row-multiplying transformations

  }, {
    key: "multiplication",
    value: function multiplication(n, row1, row2, mult) {
      if (n < row1 || n < row2) {
        throw new Error("Column index must be less or equalt than matrix size.");
      }

      var matrix = new MatrixIdentity(n);
      matrix.elements[row1][row2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](mult);
      return matrix;
    }
  }, {
    key: "randomSquare",
    value: function randomSquare() {
      var matrix = new Matrix(Math.floor(Math.random() * 4) + 3, Math.floor(Math.random() * 4) + 3); // minimum size 3x3 matrix

      for (var i = 0; i < matrix.m; i++) {
        for (var j = 0; j < matrix.n; j++) {
          matrix.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](Math.floor(Math.random() * 100 - 50));
        }
      }

      return matrix;
    }
  }, {
    key: "random2",
    value: function random2() {
      var numberOfUnknowns = Math.floor(Math.random() * 4 + 3); // between 3 and 7 unknonws

      var unknowns = [];

      for (var i = 0; i < numberOfUnknowns; i++) {
        unknowns[i] = Math.floor(Math.random() * 20 - 10);
      } // todo: change below


      var matrix = new Matrix(Math.floor(Math.random() * 4) + 3, Math.floor(Math.random() * 4) + 3);
      return matrix;
    }
  }]);

  function Matrix(m, n) {
    _classCallCheck(this, Matrix);

    _defineProperty(this, "m", void 0);

    _defineProperty(this, "n", void 0);

    _defineProperty(this, "elements", void 0);

    this.m = m;
    this.n = n;
    this.elements = [];

    for (var i = 0; i < this.m; i++) {
      this.elements[i] = [];
    }
  }

  _createClass(Matrix, [{
    key: "equals",
    value: function equals(M) {
      if (this.m !== M.m || this.n !== M.n) {
        return false;
      }

      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          if (!this.elements[i][j].equals(M.elements[i][j])) {
            return false;
          }
        }
      }

      return true;
    }
  }, {
    key: "add",
    value: function add(x) {
      if (this.m !== x.m || this.n !== x.n) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new Matrix(this.m, this.n);

      for (var i = 0; i < res.m; i++) {
        for (var j = 0; j < res.n; j++) {
          res.elements[i][j] = this.elements[i][j].add(x.elements[i][j]);
        }
      }

      return res;
    }
  }, {
    key: "sub",
    value: function sub(x) {
      if (this.m !== x.m || this.n !== x.n) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new Matrix(this.m, this.n);

      for (var i = 0; i < res.m; i++) {
        for (var j = 0; j < res.n; j++) {
          res.elements[i][j] = this.elements[i][j].sub(x.elements[i][j]);
        }
      }

      return res;
    }
  }, {
    key: "mult",
    value: function mult(x) {
      var res = null;

      if (typeof x === "number") {
        res = new Matrix(this.m, this.n);

        for (var i = 0; i < res.m; i++) {
          for (var j = 0; j < res.n; j++) {
            res.elements[i][j] = this.elements[i][j].mult(x);
          }
        }
      } else if (x instanceof _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"]) {
        res = new Matrix(this.m, this.n);

        for (var _i3 = 0; _i3 < res.m; _i3++) {
          for (var _j4 = 0; _j4 < res.n; _j4++) {
            res.elements[_i3][_j4] = this.elements[_i3][_j4].mult(x);
          }
        }
      } else {
        if (x instanceof Matrix) {
          if (this.n !== x.m) {
            throw new Error("Mismatched dimensions.");
          }

          res = new Matrix(this.m, x.n);

          for (var _i4 = 0; _i4 < res.m; _i4++) {
            for (var _j5 = 0; _j5 < res.n; _j5++) {
              var sum = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);

              for (var k = 0; k < this.n; k++) {
                sum = sum.add(this.elements[_i4][k].mult(x.elements[k][_j5]));
              }

              res.elements[_i4][_j5] = sum;
            }
          }
        }
      }

      return res;
    }
  }, {
    key: "vectorProduct",
    value: function vectorProduct(v) {
      if (this.n !== v.m) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new _Vector__WEBPACK_IMPORTED_MODULE_1__["ColumnVector"](v.m);

      for (var i = 0; i < this.m; i++) {
        var sum = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);

        for (var j = 0; j < this.n; j++) {
          sum = sum.add(this.elements[i][j].mult(v.elements[j]));
        }

        res.elements[i] = sum;
      }

      return res;
    }
  }, {
    key: "transpose",
    value: function transpose() {
      var ret = new Matrix(this.n, this.m);

      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          ret.elements[j][i] = this.elements[i][j];
        }
      }

      return ret;
    }
  }, {
    key: "deepCopy",
    value: function deepCopy() {
      var ret = new Matrix(this.m, this.n);

      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          ret.elements[i][j] = this.elements[i][j];
        }
      }

      return ret;
    }
  }, {
    key: "switchRows",
    value: function switchRows(idx1, idx2) {
      if (this.m < idx1 || this.m < idx2) {
        return;
      }

      for (var i = 0; i < this.n; i++) {
        var tmp = this.elements[idx1][i];
        this.elements[idx1][i] = this.elements[idx2][i];
        this.elements[idx2][i] = tmp;
      }
    }
  }, {
    key: "multiplyRow",
    value: function multiplyRow(idx, scalar) {
      if (this.m < idx) {
        return;
      }

      for (var i = 0; i < this.n; i++) {
        this.elements[idx][i] = this.elements[idx][i].mult(scalar).simplifiedForm();
      }
    }
  }, {
    key: "addRows",
    value: function addRows(idx1, idx2, scalar) {
      if (this.m < idx1 || this.m < idx2) {
        return;
      }

      for (var i = 0; i < this.n; i++) {
        this.elements[idx1][i] = this.elements[idx2][i].mult(scalar).add(this.elements[idx1][i]).simplifiedForm();
      }
    }
  }, {
    key: "addRow1ToRow2",
    value: function addRow1ToRow2(idx1, scalar1, idx2, scalar2) {
      if (this.m < idx1 || this.m < idx2) {
        return;
      }

      for (var i = 0; i < this.n; i++) {
        this.elements[idx2][i] = this.elements[idx2][i].mult(scalar2).add(this.elements[idx1][i].mult(scalar1)).simplifiedForm();
      }
    } // a square matrix is a matrix with the same number of rows and columns

  }, {
    key: "isSquare",
    value: function isSquare() {
      return this.m === this.n;
    } // a diagonal matrix is a matrix in which the entries outside the main diagonal are all zero

  }, {
    key: "isDiagonal",
    value: function isDiagonal() {
      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          if (i === j) {
            continue;
          }

          if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
            return false;
          }
        }
      }

      return true;
    } // the identity matrix of size n is the n × n square matrix with ones on the main diagonal and zeros elsewhere
    // [ALIASES]: unit matrix

  }, {
    key: "isIdentity",
    value: function isIdentity() {
      if (this.m !== this.n) {
        throw new Error("Not a square matrix.");
      }

      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          if (i === j) {
            if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1))) {
              return false;
            }

            continue;
          }

          if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
            return false;
          }
        }
      }

      return true;
    } // a matrix is normal if it commutes with its conjugate transpose

  }, {
    key: "isNormal",
    value: function isNormal() {
      throw new Error("Not implemented");
    } // the conjugate transpose of an m-by-n matrix A with complex entries is the n-by-m matrix A∗ obtained from A
    // by taking the transpose and then taking the complex conjugate of each entry
    // [ALIASES]: Hermitian transpose

  }, {
    key: "toConjugateTranspose",
    value: function toConjugateTranspose() {
      throw new Error("Not implemented");
    }
  }, {
    key: "isUpperTriangular",
    value: function isUpperTriangular() {
      // todo: check if definition is valid for a non square matrix
      // if (this.m !== this.n) { throw new Error("Not a square matrix."); }
      for (var i = 1; i < this.m; i++) {
        for (var j = 0; j < i; j++) {
          if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
            return false;
          }
        }
      }

      return true;
    }
  }, {
    key: "isLowerTriangular",
    value: function isLowerTriangular() {
      // todo: check if definition is valid for a non square matrix
      // if (this.m !== this.n) { throw new Error("Not a square matrix."); }
      for (var i = 0; i < this.m; i++) {
        for (var j = i + 1; j < this.n; j++) {
          if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
            return false;
          }
        }
      }

      return true;
    } // a symmetric matrix is a square matrix that is equal to its transpose

  }, {
    key: "isSymmetric",
    value: function isSymmetric() {
      if (this.m !== this.n) {
        throw new Error("Not a square matrix.");
      }

      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          if (!this.elements[i][j].equals(this.elements[j][i])) {
            return false;
          }
        }
      }

      return true;
    } // an orthogonal matrix is a square matrix with real entries whose columns and rows are orthogonal unit vectors
    // [ALIASES]: real orthogonal matrix

  }, {
    key: "isOrthogonal",
    value: function isOrthogonal() {
      var MT = this.transpose();
      return this.mult(MT).isIdentity();
    }
  }, {
    key: "isRowEchelonForm",
    value: function isRowEchelonForm() {
      var foundZeroRow = false; // all nonzero rows (rows with at least one nonzero element) are above any rows of all zeroes
      // (all zero rows, if any, belong at the bottom of the matrix)

      for (var i = 0; i < this.m; i++) {
        if (this.isZeroRow(i)) {
          foundZeroRow = true;
        } else {
          if (foundZeroRow) {
            return false;
          }
        } // if current row is not zero, but a previous row is zero, then matrix is not in row echelon form

      } // the leading coefficient (the first nonzero number from the left, also called the pivot) of a nonzero row
      // is always strictly to the right of the leading coefficient of the row above it


      var previousIdx = -1;

      for (var _i5 = 0; _i5 < this.m; _i5++) {
        var currentPivotIdx = this.rowPivotPosition(_i5);

        if (0 > currentPivotIdx) {
          continue;
        } // this is a zero row, no pivot
        // leading coefficient must be 1


        if (!this.elements[_i5][currentPivotIdx].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1))) {
          return false;
        }

        if (previousIdx < currentPivotIdx) {
          previousIdx = currentPivotIdx;
        } else {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "isReducedRowEchelonForm",
    value: function isReducedRowEchelonForm() {
      if (!this.isRowEchelonForm()) {
        return false;
      } // each leading coefficient is the only nonzero entry in its column


      for (var i = 0; i < this.m; i++) {
        var pivotPosition = this.rowPivotPosition(i);

        if (1 < this.numberOfNonZeroElementForColumn(pivotPosition)) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "toReducedRowEchelonForm",
    value: function toReducedRowEchelonForm() {
      var res = this.deepCopy();
      var lead = 0;

      for (var r = 0; r < res.m; r++) {
        if (res.n <= lead) {
          break;
        }

        var i = r;

        while (res.elements[i][lead].equals(0)) {
          i++;

          if (res.m === i) {
            i = r;
            lead++;

            if (res.n === lead) {
              lead--;
              break;
            }
          }
        }

        res.switchRows(i, r);

        if (!res.elements[r][lead].equals(0)) {
          res.multiplyRow(r, res.elements[r][lead].reciprocal());
        }

        for (var j = 0; j < res.m; j++) {
          if (j !== r) {
            res.addRows(j, r, res.elements[j][lead].opposite());
          }
        }

        lead++;
      }

      return res;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      // todo: implement an optimized version, like A=PLU
      if (this.m !== this.n) {
        throw new Error("Determinant can only be calculated on a square matrix");
      }

      if (this.m === 1) {
        return this.elements[0][0];
      }

      var ret = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);

      for (var i = 0; i < this.n; i++) {
        var minor = this.elements[0][i].mult(this.cofactor(0, i).determinant());
        ret = ret.add(minor.mult(Math.pow(-1, i)));
      }

      return ret;
    }
  }, {
    key: "convolute",
    value: function convolute(kernel) {
      if (kernel.m !== kernel.n) {
        throw new Error("Kernel is not a square matrix.");
      }

      if (kernel.m % 2 === 0) {
        throw new Error("Kernel is not an even size matrix.");
      }

      var sz = Math.floor(kernel.m / 2);
      var res = new Matrix(this.m, this.n);

      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          res.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);

          for (var ti = 0; ti < kernel.m; ti++) {
            if (i + ti - sz < 0 || i + ti - sz >= this.m) {
              continue;
            }

            for (var tj = 0; tj < kernel.n; tj++) {
              if (j + tj - sz < 0 || j + tj - sz >= this.n) {
                continue;
              }

              res.elements[i][j] = res.elements[i][j].add(this.elements[i + ti - sz][j + tj - sz].mult(kernel.elements[ti][tj]));
            }
          }
        }
      }

      return res;
    }
  }, {
    key: "isZeroRow",
    value: function isZeroRow(rowId) {
      for (var j = 0; j < this.n; j++) {
        if (!this.elements[rowId][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "rowPivotPosition",
    value: function rowPivotPosition(rowId) {
      for (var j = 0; j < this.n; j++) {
        if (!this.elements[rowId][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
          return j;
        }
      }

      return -1;
    }
  }, {
    key: "numberOfNonZeroElementForColumn",
    value: function numberOfNonZeroElementForColumn(columnId) {
      var acc = 0;

      for (var j = 0; j < this.m; j++) {
        if (!this.elements[j][columnId].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
          acc++;
        }
      }

      return acc;
    }
  }, {
    key: "cofactor",
    value: function cofactor(rowId, columnId) {
      var ret = new Matrix(this.m - 1, this.n - 1);
      var rowOffset = 0;

      for (var i = 0; i < this.m - 1; i++) {
        if (i === rowId) {
          rowOffset = 1;
        }

        var columnOffset = 0;

        for (var j = 0; j < this.n - 1; j++) {
          if (j === columnId) {
            columnOffset = 1;
          }

          ret.elements[i][j] = this.elements[i + rowOffset][j + columnOffset];
        }
      }

      return ret;
    }
  }]);

  return Matrix;
}();
var MatrixIdentity = /*#__PURE__*/function (_Matrix) {
  _inherits(MatrixIdentity, _Matrix);

  var _super = _createSuper(MatrixIdentity);

  function MatrixIdentity(m) {
    var _this;

    _classCallCheck(this, MatrixIdentity);

    _this = _super.call(this, m, m);
    _this.elements = [];

    for (var i = 0; i < _this.m; i++) {
      _this.elements[i] = [];

      for (var j = 0; j < _this.m; j++) {
        if (i === j) {
          _this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
        } else {
          _this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
        }
      }
    }

    return _this;
  }

  return MatrixIdentity;
}(Matrix); // elimination - multiply on the left (E*A); Row-addition transformations
// to mult*(row2 of Matrix A) add (row1 of Matrix A)

var MatrixElimination = /*#__PURE__*/function (_Matrix2) {
  _inherits(MatrixElimination, _Matrix2);

  var _super2 = _createSuper(MatrixElimination);

  function MatrixElimination(m, r1, r2, mult) {
    var _this2;

    _classCallCheck(this, MatrixElimination);

    if (m < r1 || m < r2) {
      throw new Error("Column index must be less than or equal to the matrix size.");
    }

    _this2 = _super2.call(this, m, m);

    _defineProperty(_assertThisInitialized(_this2), "row1", void 0);

    _defineProperty(_assertThisInitialized(_this2), "row2", void 0);

    _this2.row1 = r1;
    _this2.row2 = r2;
    _this2.elements = [];

    for (var i = 0; i < _this2.m; i++) {
      _this2.elements[i] = [];

      for (var j = 0; j < _this2.m; j++) {
        if (i === j) {
          _this2.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
        } else {
          _this2.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
        }
      }
    }

    if (typeof mult === "number") {
      _this2.elements[r1][r2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](mult);
    } else {
      if (mult instanceof _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"]) {
        _this2.elements[r1][r2] = mult;
      }
    }

    return _this2;
  }

  return MatrixElimination;
}(Matrix); // permutation - multiply on the right (A*P); Row-switching transformations

var MatrixPermutation = /*#__PURE__*/function (_Matrix3) {
  _inherits(MatrixPermutation, _Matrix3);

  var _super3 = _createSuper(MatrixPermutation);

  function MatrixPermutation(m, row1, row2) {
    var _this3;

    _classCallCheck(this, MatrixPermutation);

    if (m < row1 || m < row2) {
      throw new Error("Column index must be less than or equal to the matrix size.");
    }

    _this3 = _super3.call(this, m, m);
    _this3.elements = [];

    for (var i = 0; i < _this3.m; i++) {
      _this3.elements[i] = [];

      for (var j = 0; j < _this3.m; j++) {
        if (i === j) {
          _this3.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
        } else {
          _this3.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
        }
      }
    }

    _this3.elements[row1][row1] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
    _this3.elements[row1][row2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
    _this3.elements[row2][row2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
    _this3.elements[row2][row1] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
    return _this3;
  }

  return MatrixPermutation;
}(Matrix);

/***/ }),

/***/ "./src/structures/Queue.ts":
/*!*********************************!*\
  !*** ./src/structures/Queue.ts ***!
  \*********************************/
/*! exports provided: Queue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Queue", function() { return Queue; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Queue = /*#__PURE__*/function () {
  function Queue() {
    _classCallCheck(this, Queue);

    _defineProperty(this, "queue", void 0);

    this.queue = [];
  }

  _createClass(Queue, [{
    key: "isEmpty",
    value: function isEmpty() {
      return this.queue.length === 0;
    }
  }, {
    key: "enqueue",
    value: function enqueue(element) {
      this.queue.push(element);
    }
  }, {
    key: "dequeue",
    value: function dequeue() {
      if (this.isEmpty()) {
        throw new Error("Queue is empty");
      }

      return this.queue.shift();
    }
  }, {
    key: "peek",
    value: function peek() {
      if (this.isEmpty()) {
        throw new Error("Queue is empty");
      }

      return this.queue[0];
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return this.queue;
    }
  }]);

  return Queue;
}();

/***/ }),

/***/ "./src/structures/RationalNumber.ts":
/*!******************************************!*\
  !*** ./src/structures/RationalNumber.ts ***!
  \******************************************/
/*! exports provided: RationalNumber */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RationalNumber", function() { return RationalNumber; });
/* harmony import */ var _ArithmeticEvaluator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArithmeticEvaluator */ "./src/structures/ArithmeticEvaluator.ts");
/* harmony import */ var _Queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Queue */ "./src/structures/Queue.ts");
/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Stack */ "./src/structures/Stack.ts");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var RationalNumber = /*#__PURE__*/function () {
  _createClass(RationalNumber, null, [{
    key: "toReversePolishNotation",
    value: function toReversePolishNotation(code) {
      var tokens = code.match(/\(|\)|\d+(\.\d+)?|\w+|[\+\-\*\/\^]/g);
      var i = 0;
      var outputQueue = new _Queue__WEBPACK_IMPORTED_MODULE_1__["Queue"]();
      var operatorStack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();

      while (i < tokens.length) {
        if (this.isNumber(tokens[i])) {
          outputQueue.enqueue(tokens[i]);
        } else if (this.isOperator(tokens[i])) {
          var op1 = tokens[i];

          while (!operatorStack.isEmpty() && this.isOperator(operatorStack.peek())) {
            if (this.isLeftAssociativeOperator(op1) && this.precedence(op1) <= this.precedence(operatorStack.peek()) || this.isRightAssociativeOperator(op1) && this.precedence(op1) < this.precedence(operatorStack.peek())) {
              outputQueue.enqueue(operatorStack.pop());
            } else {
              break;
            }
          }

          operatorStack.push(op1);
        } else if (tokens[i] === "(") {
          operatorStack.push(tokens[i]);
        } else if (tokens[i] === ")") {
          while (!operatorStack.isEmpty() && operatorStack.peek() !== "(") {
            outputQueue.enqueue(operatorStack.pop());
          }

          if (!operatorStack.isEmpty() && operatorStack.peek() === "(") {
            operatorStack.pop();
          } else {
            throw new Error("Mismatched parentheses.");
          }
        }

        i++;
      }

      while (!operatorStack.isEmpty()) {
        if (operatorStack.peek() === "(") {
          throw new Error("Mismatched parentheses.");
        } else {
          outputQueue.enqueue(operatorStack.pop());
        }
      }

      return outputQueue.toArray();
    }
  }, {
    key: "fromString",
    value: function fromString(code) {
      var p = new _ArithmeticEvaluator__WEBPACK_IMPORTED_MODULE_0__["Parser"]();
      return p.parse(code);
    }
  }, {
    key: "greatestCommonDivisor",
    value: function greatestCommonDivisor(a, b) {
      return b ? RationalNumber.greatestCommonDivisor(b, a % b) : a;
    }
  }, {
    key: "leastCommonMultiple",
    value: function leastCommonMultiple(a, b) {
      return Math.abs(a * b / RationalNumber.greatestCommonDivisor(a, b));
    }
  }, {
    key: "isNumber",
    value: function isNumber(code) {
      return /^\d/.test(code);
    }
  }, {
    key: "isOperator",
    value: function isOperator(code) {
      return /[\+\-\*\/\^]/.test(code);
    }
  }, {
    key: "isLeftAssociativeOperator",
    value: function isLeftAssociativeOperator(operator) {
      return /[\+\-\*\/]/.test(operator);
    }
  }, {
    key: "isRightAssociativeOperator",
    value: function isRightAssociativeOperator(operator) {
      return /[\^]/.test(operator);
    }
  }, {
    key: "precedence",
    value: function precedence(operator) {
      if (/[\+\-]/.test(operator)) {
        return 1;
      }

      if (/[\*\/]/.test(operator)) {
        return 2;
      }

      if (/[\^]/.test(operator)) {
        return 3;
      }

      throw new Error("Unknown operator.");
    }
  }, {
    key: "evaluateFromRPN",
    value: function evaluateFromRPN(tokens) {
      var stack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();

      for (var i = 0; i < tokens.length; i++) {
        if (!this.isOperator(tokens[i])) {
          stack.push(new RationalNumber(parseFloat(tokens[i])));
        } else {
          var op1 = stack.pop();
          var op2 = stack.pop();

          switch (tokens[i]) {
            case "+":
              stack.push(op2.add(op1));
              break;

            case "-":
              stack.push(op2.sub(op1));
              break;

            case "*":
              stack.push(op2.mult(op1));
              break;

            case "/":
              stack.push(op2.div(op1));
              break;

            case "^":
              stack.push(op2.exp(op1.toNumber()));
              break;
          }
        }
      }

      return stack.pop().simplifiedForm();
    }
  }]);

  function RationalNumber(n) {
    var d = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    _classCallCheck(this, RationalNumber);

    _defineProperty(this, "numerator", void 0);

    _defineProperty(this, "denominator", void 0);

    if (d === 0) {
      throw new Error("Division by zero!");
    } // todo: potential for overflow. When Math.sign becomes available in TypeScript use it instead of the multiplication


    var sign = n * d >= 0 ? 1 : -1;
    this.numerator = sign * Math.abs(n);
    this.denominator = Math.abs(d);
  }

  _createClass(RationalNumber, [{
    key: "simplifiedForm",
    value: function simplifiedForm() {
      var gcd = RationalNumber.greatestCommonDivisor(this.numerator, this.denominator);
      return new RationalNumber(this.numerator / gcd, this.denominator / gcd);
    }
  }, {
    key: "equals",
    value: function equals(x) {
      var rn1 = this.simplifiedForm();

      if (typeof x === "number") {
        return rn1.numerator === x && rn1.denominator === 1;
      } else {
        var rn2 = x.simplifiedForm();
        return rn1.numerator === rn2.numerator && rn1.denominator === rn2.denominator;
      }
    }
  }, {
    key: "lt",
    value: function lt(x) {
      var rn1 = this.simplifiedForm();

      if (typeof x === "number") {
        return rn1.numerator < x * rn1.denominator;
      } else {
        var rn2 = x.simplifiedForm();
        return rn1.numerator * rn2.denominator < rn2.numerator * rn1.denominator;
      }
    }
  }, {
    key: "le",
    value: function le(x) {
      var rn1 = this.simplifiedForm();

      if (typeof x === "number") {
        return rn1.numerator <= x * rn1.denominator;
      } else {
        var rn2 = x.simplifiedForm();
        return rn1.numerator * rn2.denominator <= rn2.numerator * rn1.denominator;
      }
    }
  }, {
    key: "gt",
    value: function gt(x) {
      var rn1 = this.simplifiedForm();

      if (typeof x === "number") {
        return rn1.numerator > x * rn1.denominator;
      } else {
        var rn2 = x.simplifiedForm();
        return rn1.numerator * rn2.denominator > rn2.numerator * rn1.denominator;
      }
    }
  }, {
    key: "ge",
    value: function ge(x) {
      var rn1 = this.simplifiedForm();

      if (typeof x === "number") {
        return rn1.numerator >= x * rn1.denominator;
      } else {
        var rn2 = x.simplifiedForm();
        return rn1.numerator * rn2.denominator >= rn2.numerator * rn1.denominator;
      }
    } // multiplicative inverse

  }, {
    key: "reciprocal",
    value: function reciprocal() {
      if (this.denominator === 0) {
        throw new Error("Division by zero!");
      }

      return new RationalNumber(this.denominator, this.numerator);
    } // additive inverse

  }, {
    key: "opposite",
    value: function opposite() {
      return new RationalNumber(this.numerator * -1, this.denominator);
    }
  }, {
    key: "add",
    value: function add(x) {
      if (typeof x === "number") {
        return new RationalNumber(this.numerator + x * this.denominator, this.denominator);
      } else {
        var lcm = RationalNumber.leastCommonMultiple(this.denominator, x.denominator);
        var n1 = this.numerator * lcm / this.denominator;
        var n2 = x.numerator * lcm / x.denominator;
        return new RationalNumber(n1 + n2, lcm);
      }
    }
  }, {
    key: "sub",
    value: function sub(x) {
      if (typeof x === "number") {
        return new RationalNumber(this.numerator - x * this.denominator, this.denominator);
      } else {
        var lcm = RationalNumber.leastCommonMultiple(this.denominator, x.denominator);
        var n1 = this.numerator * lcm / this.denominator;
        var n2 = x.numerator * lcm / x.denominator;
        return new RationalNumber(n1 - n2, lcm);
      }
    }
  }, {
    key: "mult",
    value: function mult(x) {
      if (typeof x === "number") {
        return new RationalNumber(this.numerator * x, this.denominator);
      } else {
        return new RationalNumber(this.numerator * x.numerator, x.denominator * this.denominator);
      }
    }
  }, {
    key: "div",
    value: function div(x) {
      if (typeof x === "number") {
        return new RationalNumber(this.numerator, this.denominator * x);
      } else {
        return new RationalNumber(this.numerator * x.denominator, x.numerator * this.denominator);
      }
    }
  }, {
    key: "exp",
    value: function exp(x) {
      if (typeof x === "number") {
        return new RationalNumber(Math.pow(this.numerator, x), Math.pow(this.denominator, x));
      } else {
        if (this.denominator !== 1) {
          throw Error("Exponentiation with rational powers not supported.");
        }

        return new RationalNumber(Math.pow(this.numerator, x.numerator), Math.pow(this.denominator, x.numerator));
      }
    }
  }, {
    key: "toNumber",
    value: function toNumber() {
      return this.numerator / this.denominator;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.numerator.toString() + (1 === this.denominator ? "" : "/" + this.denominator.toString());
    }
  }, {
    key: "deepCopy",
    value: function deepCopy() {
      return new RationalNumber(this.numerator, this.denominator);
    }
  }]);

  return RationalNumber;
}();

/***/ }),

/***/ "./src/structures/Stack.ts":
/*!*********************************!*\
  !*** ./src/structures/Stack.ts ***!
  \*********************************/
/*! exports provided: Stack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stack", function() { return Stack; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Stack = /*#__PURE__*/function () {
  function Stack() {
    _classCallCheck(this, Stack);

    _defineProperty(this, "stack", void 0);

    this.stack = [];
  }

  _createClass(Stack, [{
    key: "isEmpty",
    value: function isEmpty() {
      return this.stack.length === 0;
    }
  }, {
    key: "push",
    value: function push(element) {
      this.stack.push(element);
    }
  }, {
    key: "pop",
    value: function pop() {
      if (this.isEmpty()) {
        throw new Error("Stack is empty");
      }

      return this.stack.pop();
    }
  }, {
    key: "peek",
    value: function peek() {
      if (this.isEmpty()) {
        throw new Error("Stack is empty");
      }

      return this.stack[this.stack.length - 1];
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return this.stack;
    }
  }]);

  return Stack;
}();

/***/ }),

/***/ "./src/structures/Vector.ts":
/*!**********************************!*\
  !*** ./src/structures/Vector.ts ***!
  \**********************************/
/*! exports provided: Vector, ColumnVector, RowVector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return Vector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColumnVector", function() { return ColumnVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RowVector", function() { return RowVector; });
/* harmony import */ var _Matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix */ "./src/structures/Matrix.ts");
/* harmony import */ var _RationalNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RationalNumber */ "./src/structures/RationalNumber.ts");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var Vector = /*#__PURE__*/function () {
  _createClass(Vector, null, [{
    key: "areLinearlyIndependent",
    value: function areLinearlyIndependent(vectors) {
      var m = vectors.length;

      if (0 === m) {
        return true;
      }

      var n = vectors[0].m;

      for (var i = 1; i < vectors.length; i++) {
        if (n !== vectors[i].m) {
          throw new Error("Mismatched dimensions.");
        }
      }

      if (m > n) {
        return false;
      }

      throw new Error("Not implemented.");
    }
  }]);

  function Vector(n) {
    _classCallCheck(this, Vector);

    _defineProperty(this, "m", void 0);

    _defineProperty(this, "elements", void 0);

    if (typeof n === "number") {
      this.m = n;
      this.elements = [];
    } else if (n instanceof Array) {
      this.m = n.length;
      this.elements = [];

      for (var i = 0; i < this.m; i++) {
        this.elements[i] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](n[i]);
      }
    }
  }

  _createClass(Vector, [{
    key: "add",
    value: function add(x) {
      if (this.m !== x.m) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new Vector(this.m);

      for (var i = 0; i < res.m; i++) {
        res.elements[i] = this.elements[i].add(x.elements[i]);
      }

      return res;
    }
  }, {
    key: "sub",
    value: function sub(x) {
      if (this.m !== x.m) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new Vector(this.m);

      for (var i = 0; i < res.m; i++) {
        res.elements[i] = this.elements[i].sub(x.elements[i]);
      }

      return res;
    }
  }, {
    key: "mult",
    value: function mult(x) {
      var res = new Vector(this.m);

      for (var i = 0; i < res.m; i++) {
        res.elements[i] = this.elements[i].mult(x);
      }

      return res;
    } // [ALIASES]: innerProduct, projectionProduct, scalarProduct

  }, {
    key: "dotProduct",
    value: function dotProduct(x) {
      if (this.m !== x.m) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);

      for (var i = 0; i < x.m; i++) {
        res = res.add(this.elements[i].mult(x.elements[i]));
      }

      return res;
    } // [ALIASES]: directedAreaProduct, vectorProduct

  }, {
    key: "crossProduct",
    value: function crossProduct(x) {
      throw new Error("Not implemented.");
    } // [ALIASES]: magnitude, norm

  }, {
    key: "length",
    value: function length() {
      var length = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);

      for (var i = 0; i < this.m; i++) {
        length.add(this.elements[i]);
      }

      return length;
    }
  }, {
    key: "deepCopy",
    value: function deepCopy() {
      var ret = new Vector(this.m);

      for (var i = 0; i < this.m; i++) {
        ret.elements[i] = this.elements[i];
      }

      return ret;
    }
  }, {
    key: "toMatrix",
    value: function toMatrix() {
      var ret = new _Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](this.m, 1);

      for (var i = 0; i < this.m; i++) {
        ret.elements[i][0] = this.elements[i];
      }

      return ret;
    }
  }]);

  return Vector;
}();
var ColumnVector = /*#__PURE__*/function (_Vector) {
  _inherits(ColumnVector, _Vector);

  var _super = _createSuper(ColumnVector);

  function ColumnVector() {
    _classCallCheck(this, ColumnVector);

    return _super.apply(this, arguments);
  }

  return ColumnVector;
}(Vector);
var RowVector = /*#__PURE__*/function (_Vector2) {
  _inherits(RowVector, _Vector2);

  var _super2 = _createSuper(RowVector);

  function RowVector() {
    _classCallCheck(this, RowVector);

    return _super2.apply(this, arguments);
  }

  _createClass(RowVector, [{
    key: "matrixProduct",
    value: function matrixProduct(m) {
      if (this.m !== m.n) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new RowVector(this.m);

      for (var i = 0; i < this.m; i++) {
        var sum = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);

        for (var j = 0; j < m.n; j++) {
          sum = sum.add(m.elements[i][j].mult(this.elements[i]));
        }

        res.elements[i] = sum;
      }

      return res;
    }
  }]);

  return RowVector;
}(Vector);

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXhlcmNpc2VzL2ltYWdlUHJvY2Vzc2luZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9Bcml0aG1ldGljRXZhbHVhdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9zdHJ1Y3R1cmVzL01hdHJpeC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9RdWV1ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9SYXRpb25hbE51bWJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9TdGFjay50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9WZWN0b3IudHMiXSwibmFtZXMiOlsiaW1hZ2VEYXRhVG9SR0JBIiwiaW1hZ2VEYXRhIiwiaW1nUiIsIk1hdHJpeCIsIndpZHRoIiwiaGVpZ2h0IiwiaW1nRyIsImltZ0IiLCJpbWdBIiwiaWR4IiwieCIsInkiLCJlbGVtZW50cyIsIlJhdGlvbmFsTnVtYmVyIiwiZGF0YSIsImltYWdlRGF0YUZyb21SR0JBIiwicmdiYSIsIm0iLCJuIiwiSW1hZ2VEYXRhIiwidG9OdW1iZXIiLCIkIiwiZG9jdW1lbnQiLCJyZWFkeSIsImNhbnZhczEiLCJjdHgxIiwiZ2V0Q29udGV4dCIsImltYWdlIiwiSW1hZ2UiLCJvbmxvYWQiLCJkcmF3SW1hZ2UiLCJpbWdEYXRhMSIsImdldEltYWdlRGF0YSIsImltZ0RhdGEyIiwiY2FudmFzMiIsImN0eDIiLCJwdXRJbWFnZURhdGEiLCJjYW52YXMzIiwiY3R4MyIsImtlcm5lbCIsImkiLCJqIiwibmV3UmdiYSIsImNvbnZvbHV0ZSIsImltZ0RhdGEzIiwic3JjIiwiZW5jb2RlZEltZyIsImltZ1NyYyIsImF0dHIiLCJyZXBsYWNlIiwiYmluU3JjIiwiYXRvYiIsImltZyIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwiYyIsImNoYXJDb2RlQXQiLCJiaW5EZXN0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiaW1nRGVzdCIsImJ0b2EiLCJBcml0aG1ldGljRXZhbHVhdG9yIiwiY29kZSIsInRva2VucyIsIm1hdGNoIiwib3V0cHV0UXVldWUiLCJRdWV1ZSIsIm9wZXJhdG9yU3RhY2siLCJTdGFjayIsImxlbmd0aCIsImlzTnVtYmVyIiwiZW5xdWV1ZSIsImlzT3BlcmF0b3IiLCJvcDEiLCJpc0VtcHR5IiwicGVlayIsImlzTGVmdEFzc29jaWF0aXZlT3BlcmF0b3IiLCJwcmVjZWRlbmNlIiwiaXNSaWdodEFzc29jaWF0aXZlT3BlcmF0b3IiLCJwb3AiLCJwdXNoIiwiRXJyb3IiLCJ0b0FycmF5Iiwic3RhY2siLCJwYXJzZUZsb2F0Iiwib3AyIiwidGVzdCIsIm9wZXJhdG9yIiwiVG9rZW5UeXBlIiwiVG9rZW4iLCJ0eXBlIiwidmFsdWUiLCJMZXhlciIsImlucHV0IiwidG9rZW5JbmRleCIsIkVuZCIsImdldFRva2VuIiwiUGx1cyIsIk1pbnVzIiwiTXVsdGlwbHkiLCJEaXZpZGUiLCJFeHBvbmVudCIsIk51bWJlciIsIkxQYXJlbiIsIlJQYXJlbiIsIlVua25vd24iLCJQYXJzZXIiLCJsZXgiLCJleHByZXNzaW9uIiwiZm91cnRoT3JkZXJPcGVyYXRvcnMiLCJ0b2tlbiIsImdldEN1cnJlbnRUb2tlbiIsImNvbXBvbmVudDEiLCJ0aGlyZE9yZGVyT3BlcmF0b3JzIiwiZ2V0TmV4dFRva2VuIiwiY29tcG9uZW50MiIsImFkZCIsInN1YiIsInJldmVydCIsImZhY3RvcjEiLCJzZWNvbmRPcmRlck9wZXJhdG9ycyIsImZhY3RvcjIiLCJtdWx0IiwiZGl2IiwiZmlyc3RPcmRlck9wZXJhdG9ycyIsImV4cCIsIkEiLCJCIiwicmV0IiwiVmVjdG9yIiwicm93MSIsInJvdzIiLCJtYXRyaXgiLCJNYXRyaXhJZGVudGl0eSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsIm51bWJlck9mVW5rbm93bnMiLCJ1bmtub3ducyIsIk0iLCJlcXVhbHMiLCJyZXMiLCJzdW0iLCJrIiwidiIsIkNvbHVtblZlY3RvciIsImlkeDEiLCJpZHgyIiwidG1wIiwic2NhbGFyIiwic2ltcGxpZmllZEZvcm0iLCJzY2FsYXIxIiwic2NhbGFyMiIsIk1UIiwidHJhbnNwb3NlIiwiaXNJZGVudGl0eSIsImZvdW5kWmVyb1JvdyIsImlzWmVyb1JvdyIsInByZXZpb3VzSWR4IiwiY3VycmVudFBpdm90SWR4Iiwicm93UGl2b3RQb3NpdGlvbiIsImlzUm93RWNoZWxvbkZvcm0iLCJwaXZvdFBvc2l0aW9uIiwibnVtYmVyT2ZOb25aZXJvRWxlbWVudEZvckNvbHVtbiIsImRlZXBDb3B5IiwibGVhZCIsInIiLCJzd2l0Y2hSb3dzIiwibXVsdGlwbHlSb3ciLCJyZWNpcHJvY2FsIiwiYWRkUm93cyIsIm9wcG9zaXRlIiwibWlub3IiLCJjb2ZhY3RvciIsImRldGVybWluYW50Iiwic3oiLCJ0aSIsInRqIiwicm93SWQiLCJjb2x1bW5JZCIsImFjYyIsInJvd09mZnNldCIsImNvbHVtbk9mZnNldCIsIk1hdHJpeEVsaW1pbmF0aW9uIiwicjEiLCJyMiIsIk1hdHJpeFBlcm11dGF0aW9uIiwicXVldWUiLCJlbGVtZW50Iiwic2hpZnQiLCJwIiwicGFyc2UiLCJhIiwiYiIsImdyZWF0ZXN0Q29tbW9uRGl2aXNvciIsImFicyIsImQiLCJzaWduIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJnY2QiLCJybjEiLCJybjIiLCJsY20iLCJsZWFzdENvbW1vbk11bHRpcGxlIiwibjEiLCJuMiIsInRvU3RyaW5nIiwidmVjdG9ycyIsIkFycmF5IiwiUm93VmVjdG9yIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNLEtBQTBCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsWUFBWTs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsSUFBSTs7QUFFcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNM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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZixTQUFTOztBQUVUO0FBQ0EsUUFBUSxpQ0FBaUM7QUFDekMsUUFBUSxvQkFBb0I7QUFDNUIsUUFBUSxzQ0FBc0M7QUFDOUMsUUFBUTtBQUNSLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLDRDQUE0QztBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFFBQVEsR0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLDBCQUEwQix3QkFBd0I7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0Msc0NBQXNDO0FBQzlFLG9DQUFvQyx1Q0FBdUM7QUFDM0Usb0NBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7OztBQUdBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsY0FBYyxxQ0FBcUM7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QixXQUFXLGtCQUFrQjtBQUM3QixjQUFjO0FBQ2QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLG1CQUFtQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSxhQUFhOztBQUViOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7O0FBRUEsV0FBVztBQUNYLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsc0RBQXNEO0FBQ3BFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQsZUFBZSw2REFBNkQ7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRixDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLElBQTBDO0FBQy9DLENBQUMsaUNBQWtCLEVBQUUsbUNBQUU7QUFDdkI7QUFDQSxFQUFFO0FBQUEsb0dBQUU7QUFDSjs7Ozs7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZuVkQ7QUFDQTs7QUFFQSxTQUFTQSxlQUFULENBQXlCQyxTQUF6QixFQUFpRjtBQUNoRixNQUFNQyxJQUFZLEdBQUcsSUFBSUMseURBQUosQ0FBV0YsU0FBUyxDQUFDRyxLQUFyQixFQUE0QkgsU0FBUyxDQUFDSSxNQUF0QyxDQUFyQjtBQUNBLE1BQU1DLElBQVksR0FBRyxJQUFJSCx5REFBSixDQUFXRixTQUFTLENBQUNHLEtBQXJCLEVBQTRCSCxTQUFTLENBQUNJLE1BQXRDLENBQXJCO0FBQ0EsTUFBTUUsSUFBWSxHQUFHLElBQUlKLHlEQUFKLENBQVdGLFNBQVMsQ0FBQ0csS0FBckIsRUFBNEJILFNBQVMsQ0FBQ0ksTUFBdEMsQ0FBckI7QUFDQSxNQUFNRyxJQUFZLEdBQUcsSUFBSUwseURBQUosQ0FBV0YsU0FBUyxDQUFDRyxLQUFyQixFQUE0QkgsU0FBUyxDQUFDSSxNQUF0QyxDQUFyQjtBQUNBLE1BQUlJLEdBQVcsR0FBRyxDQUFsQjs7QUFDQSxPQUFLLElBQUlDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHVCxTQUFTLENBQUNHLEtBQXRDLEVBQTZDTSxDQUFDLEVBQTlDLEVBQW1EO0FBQ2xEUixRQUFJLENBQUNRLENBQUQsQ0FBSixHQUFVLEVBQVY7QUFBY0osUUFBSSxDQUFDSSxDQUFELENBQUosR0FBVSxFQUFWO0FBQWNILFFBQUksQ0FBQ0csQ0FBRCxDQUFKLEdBQVUsRUFBVjtBQUFjRixRQUFJLENBQUNFLENBQUQsQ0FBSixHQUFVLEVBQVY7O0FBQzFDLFNBQUssSUFBSUMsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUdWLFNBQVMsQ0FBQ0ksTUFBdEMsRUFBOENNLENBQUMsRUFBL0MsRUFBbUQ7QUFDbERULFVBQUksQ0FBQ1UsUUFBTCxDQUFjRixDQUFkLEVBQWlCQyxDQUFqQixJQUFzQixJQUFJRSx5RUFBSixDQUFtQlosU0FBUyxDQUFDYSxJQUFWLENBQWVMLEdBQUcsRUFBbEIsQ0FBbkIsQ0FBdEI7QUFDQUgsVUFBSSxDQUFDTSxRQUFMLENBQWNGLENBQWQsRUFBaUJDLENBQWpCLElBQXNCLElBQUlFLHlFQUFKLENBQW1CWixTQUFTLENBQUNhLElBQVYsQ0FBZUwsR0FBRyxFQUFsQixDQUFuQixDQUF0QjtBQUNBRixVQUFJLENBQUNLLFFBQUwsQ0FBY0YsQ0FBZCxFQUFpQkMsQ0FBakIsSUFBc0IsSUFBSUUseUVBQUosQ0FBbUJaLFNBQVMsQ0FBQ2EsSUFBVixDQUFlTCxHQUFHLEVBQWxCLENBQW5CLENBQXRCO0FBQ0FELFVBQUksQ0FBQ0ksUUFBTCxDQUFjRixDQUFkLEVBQWlCQyxDQUFqQixJQUFzQixJQUFJRSx5RUFBSixDQUFtQlosU0FBUyxDQUFDYSxJQUFWLENBQWVMLEdBQUcsRUFBbEIsQ0FBbkIsQ0FBdEI7QUFDQTtBQUNEOztBQUNELFNBQU8sQ0FBQ1AsSUFBRCxFQUFPSSxJQUFQLEVBQWFDLElBQWIsRUFBbUJDLElBQW5CLENBQVA7QUFDQTs7QUFDRCxTQUFTTyxpQkFBVCxDQUEyQkMsSUFBM0IsRUFBOEU7QUFDN0UsTUFBTWQsSUFBWSxHQUFHYyxJQUFJLENBQUMsQ0FBRCxDQUF6QjtBQUNBLE1BQU1WLElBQVksR0FBR1UsSUFBSSxDQUFDLENBQUQsQ0FBekI7QUFDQSxNQUFNVCxJQUFZLEdBQUdTLElBQUksQ0FBQyxDQUFELENBQXpCO0FBQ0EsTUFBTVIsSUFBWSxHQUFHUSxJQUFJLENBQUMsQ0FBRCxDQUF6QjtBQUNBLE1BQU1aLEtBQWEsR0FBR0YsSUFBSSxDQUFDZSxDQUEzQjtBQUNBLE1BQU1aLE1BQWMsR0FBR0gsSUFBSSxDQUFDZ0IsQ0FBNUI7QUFDQSxNQUFNakIsU0FBb0IsR0FBRyxJQUFJa0IsU0FBSixDQUFjZixLQUFkLEVBQXFCQyxNQUFyQixDQUE3QjtBQUNBLE1BQUlJLEdBQVcsR0FBRyxDQUFsQjs7QUFDQSxPQUFLLElBQUlDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHTixLQUE1QixFQUFtQ00sQ0FBQyxFQUFwQyxFQUF5QztBQUN4QyxTQUFLLElBQUlDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHTixNQUE1QixFQUFvQ00sQ0FBQyxFQUFyQyxFQUF5QztBQUN4Q1YsZUFBUyxDQUFDYSxJQUFWLENBQWVMLEdBQUcsRUFBbEIsSUFBd0JQLElBQUksQ0FBQ1UsUUFBTCxDQUFjRixDQUFkLEVBQWlCQyxDQUFqQixFQUFvQlMsUUFBcEIsRUFBeEI7QUFDQW5CLGVBQVMsQ0FBQ2EsSUFBVixDQUFlTCxHQUFHLEVBQWxCLElBQXdCSCxJQUFJLENBQUNNLFFBQUwsQ0FBY0YsQ0FBZCxFQUFpQkMsQ0FBakIsRUFBb0JTLFFBQXBCLEVBQXhCO0FBQ0FuQixlQUFTLENBQUNhLElBQVYsQ0FBZUwsR0FBRyxFQUFsQixJQUF3QkYsSUFBSSxDQUFDSyxRQUFMLENBQWNGLENBQWQsRUFBaUJDLENBQWpCLEVBQW9CUyxRQUFwQixFQUF4QjtBQUNBbkIsZUFBUyxDQUFDYSxJQUFWLENBQWVMLEdBQUcsRUFBbEIsSUFBd0JELElBQUksQ0FBQ0ksUUFBTCxDQUFjRixDQUFkLEVBQWlCQyxDQUFqQixFQUFvQlMsUUFBcEIsRUFBeEI7QUFDQTtBQUNEOztBQUNELFNBQU9uQixTQUFQO0FBQ0E7O0FBRURvQixDQUFDLENBQUNDLFFBQUQsQ0FBRCxDQUFZQyxLQUFaLENBQWtCLFlBQU07QUFDdkIsTUFBTUMsT0FBMEIsR0FBR0gsQ0FBQyxDQUFDLFVBQUQsQ0FBRCxDQUFjLENBQWQsQ0FBbkM7QUFDQSxNQUFNSSxJQUE4QixHQUFHRCxPQUFPLENBQUNFLFVBQVIsQ0FBbUIsSUFBbkIsQ0FBdkM7QUFDQSxNQUFNQyxLQUF1QixHQUFHLElBQUlDLEtBQUosRUFBaEM7O0FBQ0FELE9BQUssQ0FBQ0UsTUFBTixHQUFlLFlBQU07QUFDcEJMLFdBQU8sQ0FBQ25CLE1BQVIsR0FBaUJzQixLQUFLLENBQUN0QixNQUF2QjtBQUNBbUIsV0FBTyxDQUFDcEIsS0FBUixHQUFnQnVCLEtBQUssQ0FBQ3ZCLEtBQXRCO0FBQ0FxQixRQUFJLENBQUNLLFNBQUwsQ0FBZUgsS0FBZixFQUFzQixDQUF0QixFQUF5QixDQUF6QjtBQUNBLFFBQU1JLFFBQW1CLEdBQUdOLElBQUksQ0FBQ08sWUFBTCxDQUFrQixDQUFsQixFQUFxQixDQUFyQixFQUF3QkwsS0FBSyxDQUFDdkIsS0FBOUIsRUFBcUN1QixLQUFLLENBQUN0QixNQUEzQyxDQUE1QjtBQUNBLFFBQU1XLElBQUksR0FBR2hCLGVBQWUsQ0FBQytCLFFBQUQsQ0FBNUIsQ0FMb0IsQ0FNcEI7O0FBQ0EsUUFBTUUsUUFBbUIsR0FBR2xCLGlCQUFpQixDQUFDQyxJQUFELENBQTdDO0FBQ0EsUUFBTWtCLE9BQTBCLEdBQUdiLENBQUMsQ0FBQyxVQUFELENBQUQsQ0FBYyxDQUFkLENBQW5DO0FBQ0EsUUFBTWMsSUFBOEIsR0FBR0QsT0FBTyxDQUFDUixVQUFSLENBQW1CLElBQW5CLENBQXZDO0FBQ0FRLFdBQU8sQ0FBQzdCLE1BQVIsR0FBaUI0QixRQUFRLENBQUM1QixNQUExQjtBQUNBNkIsV0FBTyxDQUFDOUIsS0FBUixHQUFnQjZCLFFBQVEsQ0FBQzdCLEtBQXpCO0FBQ0ErQixRQUFJLENBQUNDLFlBQUwsQ0FBa0JILFFBQWxCLEVBQTRCLENBQTVCLEVBQStCLENBQS9CLEVBWm9CLENBYXBCOztBQUNBLFFBQU1JLE9BQTBCLEdBQUdoQixDQUFDLENBQUMsVUFBRCxDQUFELENBQWMsQ0FBZCxDQUFuQztBQUNBLFFBQU1pQixJQUE4QixHQUFHRCxPQUFPLENBQUNYLFVBQVIsQ0FBbUIsSUFBbkIsQ0FBdkM7QUFDQSxRQUFNYSxNQUFjLEdBQUcsSUFBSXBDLHlEQUFKLENBQVcsQ0FBWCxFQUFjLENBQWQsQ0FBdkI7QUFDQTs7Ozs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7OztBQVdBOztBQUNBb0MsVUFBTSxDQUFDM0IsUUFBUCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixJQUF3QixJQUFJQyx5RUFBSixDQUFtQixDQUFuQixDQUF4QjtBQUNBMEIsVUFBTSxDQUFDM0IsUUFBUCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixJQUF3QixJQUFJQyx5RUFBSixDQUFtQixDQUFDLENBQXBCLENBQXhCO0FBQ0EwQixVQUFNLENBQUMzQixRQUFQLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLElBQXdCLElBQUlDLHlFQUFKLENBQW1CLENBQW5CLENBQXhCO0FBQ0EwQixVQUFNLENBQUMzQixRQUFQLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLElBQXdCLElBQUlDLHlFQUFKLENBQW1CLENBQW5CLENBQXhCO0FBQ0EwQixVQUFNLENBQUMzQixRQUFQLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLElBQXdCLElBQUlDLHlFQUFKLENBQW1CLENBQW5CLENBQXhCO0FBQ0EwQixVQUFNLENBQUMzQixRQUFQLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLElBQXdCLElBQUlDLHlFQUFKLENBQW1CLENBQW5CLENBQXhCO0FBQ0EwQixVQUFNLENBQUMzQixRQUFQLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLElBQXdCLElBQUlDLHlFQUFKLENBQW1CLENBQW5CLENBQXhCO0FBQ0EwQixVQUFNLENBQUMzQixRQUFQLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLElBQXdCLElBQUlDLHlFQUFKLENBQW1CLENBQW5CLENBQXhCO0FBQ0EwQixVQUFNLENBQUMzQixRQUFQLENBQWdCLENBQWhCLEVBQW1CLENBQW5CLElBQXdCLElBQUlDLHlFQUFKLENBQW1CLENBQW5CLENBQXhCLENBM0RvQixDQTREcEI7QUFDQTs7QUFDQSxTQUFLLElBQUkyQixDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBR3hCLElBQUksQ0FBQyxDQUFELENBQUosQ0FBUUMsQ0FBcEMsRUFBdUN1QixDQUFDLEVBQXhDLEVBQTRDO0FBQzNDLFdBQUssSUFBSUMsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUd6QixJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVFFLENBQXBDLEVBQXVDdUIsQ0FBQyxFQUF4QyxFQUE0QztBQUMzQ3pCLFlBQUksQ0FBQyxDQUFELENBQUosQ0FBUUosUUFBUixDQUFpQjRCLENBQWpCLEVBQW9CQyxDQUFwQixJQUF5QixJQUFJNUIseUVBQUosQ0FBbUIsQ0FBbkIsQ0FBekI7QUFDQUcsWUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRSixRQUFSLENBQWlCNEIsQ0FBakIsRUFBb0JDLENBQXBCLElBQXlCLElBQUk1Qix5RUFBSixDQUFtQixDQUFuQixDQUF6QjtBQUNBO0FBQ0Q7O0FBQ0QsUUFBTTZCLE9BQXlDLEdBQUcsQ0FBQzFCLElBQUksQ0FBQyxDQUFELENBQUwsRUFBVUEsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRMkIsU0FBUixDQUFrQkosTUFBbEIsQ0FBVixFQUFxQ3ZCLElBQUksQ0FBQyxDQUFELENBQXpDLEVBQThDQSxJQUFJLENBQUMsQ0FBRCxDQUFsRCxDQUFsRDtBQUNBLFFBQU00QixRQUFtQixHQUFHN0IsaUJBQWlCLENBQUMyQixPQUFELENBQTdDO0FBQ0FMLFdBQU8sQ0FBQ2hDLE1BQVIsR0FBaUJ1QyxRQUFRLENBQUN2QyxNQUExQjtBQUNBZ0MsV0FBTyxDQUFDakMsS0FBUixHQUFnQndDLFFBQVEsQ0FBQ3hDLEtBQXpCO0FBQ0FrQyxRQUFJLENBQUNGLFlBQUwsQ0FBa0JRLFFBQWxCLEVBQTRCLENBQTVCLEVBQStCLENBQS9CO0FBQ0EsR0F6RUQ7O0FBMEVBakIsT0FBSyxDQUFDa0IsR0FBTixHQUFZLDJCQUEyQkMsVUFBdkMsQ0E5RXVCLENBZ0Z2Qjs7QUFDQSxNQUFNQyxNQUFjLEdBQUcxQixDQUFDLENBQUMsWUFBRCxDQUFELENBQWdCMkIsSUFBaEIsQ0FBcUIsS0FBckIsRUFBNEJDLE9BQTVCLENBQW9DLHdCQUFwQyxFQUE4RCxFQUE5RCxDQUF2QjtBQUNBLE1BQU1DLE1BQWMsR0FBR0MsSUFBSSxDQUFDSixNQUFELENBQTNCO0FBQ0EsTUFBTUssR0FBRyxHQUFHQyxVQUFVLENBQUNDLElBQVgsQ0FBZ0JKLE1BQWhCLEVBQXdCLFVBQUNLLENBQUQ7QUFBQSxXQUFPQSxDQUFDLENBQUNDLFVBQUYsQ0FBYSxDQUFiLENBQVA7QUFBQSxHQUF4QixDQUFaLENBbkZ1QixDQW9GdkI7O0FBQ0EsTUFBSUMsT0FBZSxHQUFHLEVBQXRCOztBQXJGdUIsNkNBc0ZQTCxHQXRGTztBQUFBOztBQUFBO0FBc0Z2Qix3REFBcUI7QUFBQSxVQUFWWixDQUFVO0FBQ3BCaUIsYUFBTyxJQUFJQyxNQUFNLENBQUNDLFlBQVAsQ0FBb0JuQixDQUFwQixDQUFYO0FBQ0EsS0F4RnNCLENBeUZ2Qjs7QUF6RnVCO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBMEZ2QixNQUFNb0IsT0FBTyxHQUFHQyxJQUFJLENBQUNKLE9BQUQsQ0FBcEI7QUFDQXBDLEdBQUMsQ0FBQyxpQkFBRCxDQUFELENBQXFCMkIsSUFBckIsQ0FBMEIsS0FBMUIsRUFBaUMsMkJBQTJCWSxPQUE1RDtBQUVBLENBN0ZEO0FBK0ZBLElBQU1kLFVBQWtCLEdBQUcsMDY0S0FBM0IsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdklBO0FBQ0E7QUFDQTtBQUVPLElBQU1nQixtQkFBYjtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsNENBQ3VDQyxJQUR2QyxFQUMrRDtBQUM3RCxVQUFNQyxNQUFnQixHQUFHRCxJQUFJLENBQUNFLEtBQUwsQ0FBVyxxQ0FBWCxDQUF6QjtBQUNBLFVBQUl6QixDQUFTLEdBQUcsQ0FBaEI7QUFDQSxVQUFNMEIsV0FBMEIsR0FBRyxJQUFJQyw0Q0FBSixFQUFuQztBQUNBLFVBQU1DLGFBQTRCLEdBQUcsSUFBSUMsNENBQUosRUFBckM7O0FBQ0EsYUFBTzdCLENBQUMsR0FBR3dCLE1BQU0sQ0FBQ00sTUFBbEIsRUFBMEI7QUFDekIsWUFBSSxLQUFLQyxRQUFMLENBQWNQLE1BQU0sQ0FBQ3hCLENBQUQsQ0FBcEIsQ0FBSixFQUE4QjtBQUM3QjBCLHFCQUFXLENBQUNNLE9BQVosQ0FBb0JSLE1BQU0sQ0FBQ3hCLENBQUQsQ0FBMUI7QUFDQSxTQUZELE1BRU8sSUFBSSxLQUFLaUMsVUFBTCxDQUFnQlQsTUFBTSxDQUFDeEIsQ0FBRCxDQUF0QixDQUFKLEVBQWdDO0FBQ3RDLGNBQUlrQyxHQUFXLEdBQUdWLE1BQU0sQ0FBQ3hCLENBQUQsQ0FBeEI7O0FBQ0EsaUJBQU8sQ0FBQzRCLGFBQWEsQ0FBQ08sT0FBZCxFQUFELElBQTRCLEtBQUtGLFVBQUwsQ0FBZ0JMLGFBQWEsQ0FBQ1EsSUFBZCxFQUFoQixDQUFuQyxFQUEwRTtBQUN6RSxnQkFBSyxLQUFLQyx5QkFBTCxDQUErQkgsR0FBL0IsS0FBd0MsS0FBS0ksVUFBTCxDQUFnQkosR0FBaEIsS0FBd0IsS0FBS0ksVUFBTCxDQUFnQlYsYUFBYSxDQUFDUSxJQUFkLEVBQWhCLENBQWpFLElBQ0YsS0FBS0csMEJBQUwsQ0FBZ0NMLEdBQWhDLEtBQXlDLEtBQUtJLFVBQUwsQ0FBZ0JKLEdBQWhCLElBQXVCLEtBQUtJLFVBQUwsQ0FBZ0JWLGFBQWEsQ0FBQ1EsSUFBZCxFQUFoQixDQURsRSxFQUMyRztBQUMxR1YseUJBQVcsQ0FBQ00sT0FBWixDQUFvQkosYUFBYSxDQUFDWSxHQUFkLEVBQXBCO0FBQ0EsYUFIRCxNQUdPO0FBQ047QUFDQTtBQUNEOztBQUNEWix1QkFBYSxDQUFDYSxJQUFkLENBQW1CUCxHQUFuQjtBQUNBLFNBWE0sTUFXQSxJQUFJVixNQUFNLENBQUN4QixDQUFELENBQU4sS0FBYyxHQUFsQixFQUF1QjtBQUM3QjRCLHVCQUFhLENBQUNhLElBQWQsQ0FBbUJqQixNQUFNLENBQUN4QixDQUFELENBQXpCO0FBQ0EsU0FGTSxNQUVBLElBQUl3QixNQUFNLENBQUN4QixDQUFELENBQU4sS0FBYyxHQUFsQixFQUF1QjtBQUM3QixpQkFBTyxDQUFDNEIsYUFBYSxDQUFDTyxPQUFkLEVBQUQsSUFBNEJQLGFBQWEsQ0FBQ1EsSUFBZCxPQUF5QixHQUE1RCxFQUFpRTtBQUNoRVYsdUJBQVcsQ0FBQ00sT0FBWixDQUFvQkosYUFBYSxDQUFDWSxHQUFkLEVBQXBCO0FBQ0E7O0FBQ0QsY0FBSSxDQUFDWixhQUFhLENBQUNPLE9BQWQsRUFBRCxJQUE0QlAsYUFBYSxDQUFDUSxJQUFkLE9BQXlCLEdBQXpELEVBQThEO0FBQzdEUix5QkFBYSxDQUFDWSxHQUFkO0FBQ0EsV0FGRCxNQUVPO0FBQ04sa0JBQU0sSUFBSUUsS0FBSixDQUFVLHlCQUFWLENBQU47QUFDQTtBQUNEOztBQUNEMUMsU0FBQztBQUNEOztBQUNELGFBQU8sQ0FBQzRCLGFBQWEsQ0FBQ08sT0FBZCxFQUFSLEVBQWlDO0FBQ2hDLFlBQUlQLGFBQWEsQ0FBQ1EsSUFBZCxPQUF5QixHQUE3QixFQUFrQztBQUNqQyxnQkFBTSxJQUFJTSxLQUFKLENBQVUseUJBQVYsQ0FBTjtBQUNBLFNBRkQsTUFFTztBQUNOaEIscUJBQVcsQ0FBQ00sT0FBWixDQUFvQkosYUFBYSxDQUFDWSxHQUFkLEVBQXBCO0FBQ0E7QUFDRDs7QUFDRCxhQUFPZCxXQUFXLENBQUNpQixPQUFaLEVBQVA7QUFDQTtBQTFDRjtBQUFBO0FBQUEsb0NBMkMrQm5CLE1BM0MvQixFQTJDeUQ7QUFDdkQsVUFBTW9CLEtBQW9CLEdBQUcsSUFBSWYsNENBQUosRUFBN0I7O0FBQ0EsV0FBSyxJQUFJN0IsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUd3QixNQUFNLENBQUNNLE1BQW5DLEVBQTJDOUIsQ0FBQyxFQUE1QyxFQUFnRDtBQUMvQyxZQUFJLENBQUMsS0FBS2lDLFVBQUwsQ0FBZ0JULE1BQU0sQ0FBQ3hCLENBQUQsQ0FBdEIsQ0FBTCxFQUFpQztBQUNoQzRDLGVBQUssQ0FBQ0gsSUFBTixDQUFXSSxVQUFVLENBQUNyQixNQUFNLENBQUN4QixDQUFELENBQVAsQ0FBckI7QUFDQSxTQUZELE1BRU87QUFDTixjQUFJa0MsR0FBVyxHQUFHVSxLQUFLLENBQUNKLEdBQU4sRUFBbEI7QUFDQSxjQUFJTSxHQUFXLEdBQUdGLEtBQUssQ0FBQ0osR0FBTixFQUFsQjs7QUFDQSxrQkFBUWhCLE1BQU0sQ0FBQ3hCLENBQUQsQ0FBZDtBQUNDLGlCQUFLLEdBQUw7QUFBVTRDLG1CQUFLLENBQUNILElBQU4sQ0FBV0ssR0FBRyxHQUFHWixHQUFqQjtBQUNUOztBQUNELGlCQUFLLEdBQUw7QUFBVVUsbUJBQUssQ0FBQ0gsSUFBTixDQUFXSyxHQUFHLEdBQUdaLEdBQWpCO0FBQ1Q7O0FBQ0QsaUJBQUssR0FBTDtBQUFVVSxtQkFBSyxDQUFDSCxJQUFOLENBQVdLLEdBQUcsR0FBR1osR0FBakI7QUFDVDs7QUFDRCxpQkFBSyxHQUFMO0FBQVVVLG1CQUFLLENBQUNILElBQU4sQ0FBV0ssR0FBRyxHQUFHWixHQUFqQjtBQUNUOztBQUNELGlCQUFLLEdBQUw7QUFBVVUsbUJBQUssQ0FBQ0gsSUFBTixVQUFXSyxHQUFYLEVBQWtCWixHQUFsQjtBQUNUO0FBVkY7QUFZQTtBQUNEOztBQUNELGFBQU9VLEtBQUssQ0FBQ0osR0FBTixFQUFQO0FBQ0E7QUFsRUY7QUFBQTtBQUFBLDZCQW1FeUJqQixJQW5FekIsRUFtRWdEO0FBQzlDLGFBQU8sTUFBTXdCLElBQU4sQ0FBV3hCLElBQVgsQ0FBUDtBQUNBO0FBckVGO0FBQUE7QUFBQSwrQkFzRTJCQSxJQXRFM0IsRUFzRWtEO0FBQ2hELGFBQU8sZUFBZXdCLElBQWYsQ0FBb0J4QixJQUFwQixDQUFQO0FBQ0E7QUF4RUY7QUFBQTtBQUFBLDhDQXlFMEN5QixRQXpFMUMsRUF5RXFFO0FBQ25FLGFBQU8sYUFBYUQsSUFBYixDQUFrQkMsUUFBbEIsQ0FBUDtBQUNBO0FBM0VGO0FBQUE7QUFBQSwrQ0E0RTJDQSxRQTVFM0MsRUE0RXNFO0FBQ3BFLGFBQU8sT0FBT0QsSUFBUCxDQUFZQyxRQUFaLENBQVA7QUFDQTtBQTlFRjtBQUFBO0FBQUEsK0JBK0UyQkEsUUEvRTNCLEVBK0VxRDtBQUNuRCxVQUFJLFNBQVNELElBQVQsQ0FBY0MsUUFBZCxDQUFKLEVBQTZCO0FBQzNCLGVBQU8sQ0FBUDtBQUNEOztBQUNELFVBQUksU0FBU0QsSUFBVCxDQUFjQyxRQUFkLENBQUosRUFBNkI7QUFDM0IsZUFBTyxDQUFQO0FBQ0Q7O0FBQ0QsVUFBSSxPQUFPRCxJQUFQLENBQVlDLFFBQVosQ0FBSixFQUEyQjtBQUN6QixlQUFPLENBQVA7QUFDRDs7QUFDRCxZQUFNLElBQUlOLEtBQUosQ0FBVSxtQkFBVixDQUFOO0FBQ0E7QUExRkY7O0FBQUE7QUFBQTtBQTZGTyxJQUFLTyxTQUFaOztXQUFZQSxTO0FBQUFBLFcsQ0FBQUEsUztBQUFBQSxXLENBQUFBLFM7QUFBQUEsVyxDQUFBQSxTO0FBQUFBLFcsQ0FBQUEsUztBQUFBQSxXLENBQUFBLFM7QUFBQUEsVyxDQUFBQSxTO0FBQUFBLFcsQ0FBQUEsUztBQUFBQSxXLENBQUFBLFM7QUFBQUEsVyxDQUFBQSxTO0FBQUFBLFcsQ0FBQUEsUztHQUFBQSxTLEtBQUFBLFM7O0FBQ0wsSUFBTUMsS0FBYixHQUdDLGVBQVlDLElBQVosRUFBNkJDLEtBQTdCLEVBQTZDO0FBQUE7O0FBQUE7O0FBQUE7O0FBQzVDLE9BQUtELElBQUwsR0FBWUEsSUFBWjtBQUNBLE9BQUtDLEtBQUwsR0FBYUEsS0FBYjtBQUNBLENBTkY7QUFRTyxJQUFNQyxLQUFiO0FBR0MsaUJBQVlDLEtBQVosRUFBMkI7QUFBQTs7QUFBQTs7QUFBQTs7QUFDMUIsU0FBSzlCLE1BQUwsR0FBYzhCLEtBQUssQ0FBQzdDLE9BQU4sQ0FBYyxHQUFkLEVBQW1CLEVBQW5CLEVBQXVCZ0IsS0FBdkIsQ0FBNkIsaUNBQTdCLENBQWQ7QUFDQSxTQUFLOEIsVUFBTCxHQUFrQixDQUFsQjtBQUNBOztBQU5GO0FBQUE7QUFBQSxtQ0FPOEI7QUFDNUIsVUFBSSxLQUFLL0IsTUFBTCxDQUFZTSxNQUFaLEtBQXVCLEtBQUt5QixVQUFoQyxFQUE0QztBQUMzQyxlQUFPLElBQUlMLEtBQUosQ0FBVUQsU0FBUyxDQUFDTyxHQUFwQixDQUFQO0FBQ0E7O0FBQ0QsVUFBSUYsS0FBYSxHQUFHLEtBQUs5QixNQUFMLENBQVksS0FBSytCLFVBQUwsRUFBWixDQUFwQjtBQUNBLGFBQU8sS0FBS0UsUUFBTCxDQUFjSCxLQUFkLENBQVA7QUFDQTtBQWJGO0FBQUE7QUFBQSxzQ0FjaUM7QUFDL0IsVUFBSSxLQUFLOUIsTUFBTCxDQUFZTSxNQUFaLEdBQXFCLENBQXJCLEtBQTJCLEtBQUt5QixVQUFwQyxFQUFnRDtBQUMvQyxlQUFPLElBQUlMLEtBQUosQ0FBVUQsU0FBUyxDQUFDTyxHQUFwQixDQUFQO0FBQ0E7O0FBQ0QsVUFBSUYsS0FBYSxHQUFHLEtBQUs5QixNQUFMLENBQVksS0FBSytCLFVBQWpCLENBQXBCO0FBQ0EsYUFBTyxLQUFLRSxRQUFMLENBQWNILEtBQWQsQ0FBUDtBQUNBO0FBcEJGO0FBQUE7QUFBQSw2QkFxQnVCO0FBQ3JCLFVBQUksS0FBS0MsVUFBTCxJQUFtQixDQUF2QixFQUEwQjtBQUFFLGNBQU1iLEtBQUssQ0FBQyxvQkFBRCxDQUFYO0FBQW9DOztBQUNoRSxXQUFLYSxVQUFMO0FBQ0E7QUF4QkY7QUFBQTtBQUFBLDZCQXlCa0JELEtBekJsQixFQXlCd0M7QUFDdEMsVUFBSSxLQUFLUCxJQUFMLENBQVVPLEtBQVYsQ0FBSixFQUFzQjtBQUNyQixlQUFPLElBQUlKLEtBQUosQ0FBVUQsU0FBUyxDQUFDUyxJQUFwQixDQUFQO0FBQ0E7O0FBQ0QsVUFBSSxLQUFLWCxJQUFMLENBQVVPLEtBQVYsQ0FBSixFQUFzQjtBQUNyQixlQUFPLElBQUlKLEtBQUosQ0FBVUQsU0FBUyxDQUFDVSxLQUFwQixDQUFQO0FBQ0E7O0FBQ0QsVUFBSSxLQUFLWixJQUFMLENBQVVPLEtBQVYsQ0FBSixFQUFzQjtBQUNyQixlQUFPLElBQUlKLEtBQUosQ0FBVUQsU0FBUyxDQUFDVyxRQUFwQixDQUFQO0FBQ0E7O0FBQ0QsVUFBSSxLQUFLYixJQUFMLENBQVVPLEtBQVYsQ0FBSixFQUFzQjtBQUNyQixlQUFPLElBQUlKLEtBQUosQ0FBVUQsU0FBUyxDQUFDWSxNQUFwQixDQUFQO0FBQ0E7O0FBQ0QsVUFBSSxLQUFLZCxJQUFMLENBQVVPLEtBQVYsQ0FBSixFQUFzQjtBQUNyQixlQUFPLElBQUlKLEtBQUosQ0FBVUQsU0FBUyxDQUFDYSxRQUFwQixDQUFQO0FBQ0E7O0FBQ0QsVUFBSSxjQUFjZixJQUFkLENBQW1CTyxLQUFuQixDQUFKLEVBQStCO0FBQzlCLGVBQU8sSUFBSUosS0FBSixDQUFVRCxTQUFTLENBQUNjLE1BQXBCLEVBQTRCbEIsVUFBVSxDQUFDUyxLQUFELENBQXRDLENBQVA7QUFDQTs7QUFDRCxVQUFJLEtBQUtQLElBQUwsQ0FBVU8sS0FBVixDQUFKLEVBQXNCO0FBQ3JCLGVBQU8sSUFBSUosS0FBSixDQUFVRCxTQUFTLENBQUNlLE1BQXBCLENBQVA7QUFDQTs7QUFDRCxVQUFJLEtBQUtqQixJQUFMLENBQVVPLEtBQVYsQ0FBSixFQUFzQjtBQUNyQixlQUFPLElBQUlKLEtBQUosQ0FBVUQsU0FBUyxDQUFDZ0IsTUFBcEIsQ0FBUDtBQUNBOztBQUNELGFBQU8sSUFBSWYsS0FBSixDQUFVRCxTQUFTLENBQUNpQixPQUFwQixDQUFQO0FBQ0E7QUFuREY7O0FBQUE7QUFBQTtBQXFETyxJQUFNQyxNQUFiO0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSwwQkFFYzVDLElBRmQsRUFFNEM7QUFDMUMsV0FBSzZDLEdBQUwsR0FBVyxJQUFJZixLQUFKLENBQVU5QixJQUFWLENBQVg7QUFDQSxVQUFNOEMsVUFBMEIsR0FBRyxLQUFLQyxvQkFBTCxFQUFuQztBQUNBLFVBQU1DLEtBQVksR0FBRyxLQUFLSCxHQUFMLENBQVNJLGVBQVQsRUFBckIsQ0FIMEMsQ0FHTzs7QUFDakQsVUFBSUQsS0FBSyxDQUFDcEIsSUFBTixLQUFlRixTQUFTLENBQUNPLEdBQTdCLEVBQWtDO0FBQ2pDLGVBQU9hLFVBQVA7QUFDQTs7QUFDRCxZQUFNM0IsS0FBSyxDQUFDLGNBQUQsQ0FBWDtBQUNBLEtBVkYsQ0FXQzs7QUFYRDtBQUFBO0FBQUEsMkNBWWdEO0FBQzlDLFVBQUkrQixVQUEwQixHQUFHLEtBQUtDLG1CQUFMLEVBQWpDO0FBQ0EsVUFBSUgsS0FBWSxHQUFHLEtBQUtILEdBQUwsQ0FBU08sWUFBVCxFQUFuQjs7QUFDQSxhQUFPSixLQUFLLENBQUNwQixJQUFOLEtBQWVGLFNBQVMsQ0FBQ1MsSUFBekIsSUFBaUNhLEtBQUssQ0FBQ3BCLElBQU4sS0FBZUYsU0FBUyxDQUFDVSxLQUFqRSxFQUF3RTtBQUN2RSxZQUFJaUIsVUFBMEIsR0FBRyxLQUFLRixtQkFBTCxFQUFqQzs7QUFDQSxZQUFJSCxLQUFLLENBQUNwQixJQUFOLEtBQWVGLFNBQVMsQ0FBQ1MsSUFBN0IsRUFBbUM7QUFDbENlLG9CQUFVLEdBQUdBLFVBQVUsQ0FBQ0ksR0FBWCxDQUFlRCxVQUFmLENBQWI7QUFDQSxTQUZELE1BRU8sSUFBSUwsS0FBSyxDQUFDcEIsSUFBTixLQUFlRixTQUFTLENBQUNVLEtBQTdCLEVBQW9DO0FBQzFDYyxvQkFBVSxHQUFHQSxVQUFVLENBQUNLLEdBQVgsQ0FBZUYsVUFBZixDQUFiO0FBQ0E7O0FBQ0RMLGFBQUssR0FBRyxLQUFLSCxHQUFMLENBQVNPLFlBQVQsRUFBUjtBQUNBOztBQUNELFdBQUtQLEdBQUwsQ0FBU1csTUFBVDtBQUNBLGFBQU9OLFVBQVA7QUFDQSxLQTFCRixDQTJCQzs7QUEzQkQ7QUFBQTtBQUFBLDBDQTRCK0M7QUFDN0MsVUFBSU8sT0FBdUIsR0FBRyxLQUFLQyxvQkFBTCxFQUE5QjtBQUNBLFVBQUlWLEtBQVksR0FBRyxLQUFLSCxHQUFMLENBQVNPLFlBQVQsRUFBbkI7O0FBQ0EsYUFBT0osS0FBSyxDQUFDcEIsSUFBTixLQUFlRixTQUFTLENBQUNXLFFBQXpCLElBQXFDVyxLQUFLLENBQUNwQixJQUFOLEtBQWVGLFNBQVMsQ0FBQ1ksTUFBckUsRUFBNkU7QUFDNUUsWUFBSXFCLE9BQXVCLEdBQUcsS0FBS0Qsb0JBQUwsRUFBOUI7O0FBQ0EsWUFBSVYsS0FBSyxDQUFDcEIsSUFBTixLQUFlRixTQUFTLENBQUNXLFFBQTdCLEVBQXVDO0FBQ3RDb0IsaUJBQU8sR0FBR0EsT0FBTyxDQUFDRyxJQUFSLENBQWFELE9BQWIsQ0FBVjtBQUNBLFNBRkQsTUFFTyxJQUFJWCxLQUFLLENBQUNwQixJQUFOLEtBQWVGLFNBQVMsQ0FBQ1ksTUFBN0IsRUFBcUM7QUFDM0NtQixpQkFBTyxHQUFHQSxPQUFPLENBQUNJLEdBQVIsQ0FBWUYsT0FBWixDQUFWO0FBQ0E7O0FBQ0RYLGFBQUssR0FBRyxLQUFLSCxHQUFMLENBQVNPLFlBQVQsRUFBUjtBQUNBOztBQUNELFdBQUtQLEdBQUwsQ0FBU1csTUFBVDtBQUNBLGFBQU9DLE9BQVA7QUFDQSxLQTFDRixDQTJDQzs7QUEzQ0Q7QUFBQTtBQUFBLDJDQTRDZ0Q7QUFDOUMsVUFBSUEsT0FBdUIsR0FBRyxLQUFLSyxtQkFBTCxFQUE5QjtBQUNBLFVBQUlkLEtBQVksR0FBRyxLQUFLSCxHQUFMLENBQVNPLFlBQVQsRUFBbkI7O0FBQ0EsYUFBT0osS0FBSyxDQUFDcEIsSUFBTixLQUFlRixTQUFTLENBQUNhLFFBQWhDLEVBQTBDO0FBQ3pDLFlBQUlvQixPQUF1QixHQUFHLEtBQUtHLG1CQUFMLEVBQTlCO0FBQ0FMLGVBQU8sR0FBR0EsT0FBTyxDQUFDTSxHQUFSLENBQVlKLE9BQVosQ0FBVjtBQUNBWCxhQUFLLEdBQUcsS0FBS0gsR0FBTCxDQUFTTyxZQUFULEVBQVI7QUFDQTs7QUFDRCxXQUFLUCxHQUFMLENBQVNXLE1BQVQ7QUFDQSxhQUFPQyxPQUFQO0FBQ0EsS0F0REYsQ0F1REM7O0FBdkREO0FBQUE7QUFBQSwwQ0F3RCtDO0FBQzdDLFVBQUk1QixLQUFxQixHQUFHLElBQUkvRSw4REFBSixDQUFtQixDQUFuQixDQUE1QjtBQUNBLFVBQUlrRyxLQUFZLEdBQUcsS0FBS0gsR0FBTCxDQUFTTyxZQUFULEVBQW5COztBQUNBLFVBQUlKLEtBQUssQ0FBQ3BCLElBQU4sS0FBZUYsU0FBUyxDQUFDUyxJQUF6QixJQUFpQ2EsS0FBSyxDQUFDcEIsSUFBTixLQUFlRixTQUFTLENBQUNVLEtBQTlELEVBQXFFO0FBQ3BFLFlBQUlZLEtBQUssQ0FBQ3BCLElBQU4sS0FBZUYsU0FBUyxDQUFDVSxLQUE3QixFQUFvQztBQUNuQ1AsZUFBSyxHQUFHQSxLQUFLLENBQUMrQixJQUFOLENBQVcsQ0FBQyxDQUFaLENBQVI7QUFDQTs7QUFDRFosYUFBSyxHQUFHLEtBQUtILEdBQUwsQ0FBU08sWUFBVCxFQUFSO0FBQ0E7O0FBQ0QsVUFBSUosS0FBSyxDQUFDcEIsSUFBTixLQUFlRixTQUFTLENBQUNlLE1BQTdCLEVBQXFDO0FBQ3BDWixhQUFLLEdBQUdBLEtBQUssQ0FBQytCLElBQU4sQ0FBVyxLQUFLYixvQkFBTCxFQUFYLENBQVI7QUFDQUMsYUFBSyxHQUFHLEtBQUtILEdBQUwsQ0FBU08sWUFBVCxFQUFSOztBQUNBLFlBQUlKLEtBQUssQ0FBQ3BCLElBQU4sS0FBZUYsU0FBUyxDQUFDZ0IsTUFBN0IsRUFBcUM7QUFDcEMsZ0JBQU12QixLQUFLLENBQUMsd0JBQUQsQ0FBWDtBQUNBO0FBQ0QsT0FORCxNQU1PO0FBQ04sWUFBSTZCLEtBQUssQ0FBQ3BCLElBQU4sS0FBZUYsU0FBUyxDQUFDYyxNQUE3QixFQUFxQztBQUNwQ1gsZUFBSyxHQUFHQSxLQUFLLENBQUMrQixJQUFOLENBQVdaLEtBQUssQ0FBQ25CLEtBQWpCLENBQVI7QUFDQSxTQUZELE1BRU87QUFDTixnQkFBTVYsS0FBSyxDQUFDLGNBQUQsQ0FBWDtBQUNBO0FBQ0Q7O0FBQ0QsYUFBT1UsS0FBUDtBQUNBO0FBL0VGOztBQUFBO0FBQUE7QUFrRkE7Ozs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNQQTtBQUNBO0FBRU8sSUFBTXpGLE1BQWI7QUFBQTtBQUFBO0FBQUEsNEJBQ3VCNEgsQ0FEdkIsRUFDa0NDLENBRGxDLEVBQzhEO0FBQzVELFVBQUlELENBQUMsQ0FBQzlHLENBQUYsS0FBUStHLENBQUMsQ0FBQy9HLENBQWQsRUFBaUI7QUFBRSxjQUFNLElBQUlpRSxLQUFKLENBQVUseUVBQVYsQ0FBTjtBQUE2Rjs7QUFDaEgsVUFBSStDLEdBQVcsR0FBRyxJQUFsQjs7QUFDQSxVQUFJRCxDQUFDLFlBQVk3SCxNQUFqQixFQUF5QjtBQUN4QjhILFdBQUcsR0FBRyxJQUFJOUgsTUFBSixDQUFXNEgsQ0FBQyxDQUFDOUcsQ0FBYixFQUFnQitHLENBQUMsQ0FBQzlHLENBQUYsR0FBTTZHLENBQUMsQ0FBQzdHLENBQXhCLENBQU47O0FBQ0EsYUFBSyxJQUFJc0IsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUd1RixDQUFDLENBQUM5RyxDQUE5QixFQUFpQ3VCLENBQUMsRUFBbEMsRUFBc0M7QUFDckMsZUFBSyxJQUFJQyxDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBR3NGLENBQUMsQ0FBQzdHLENBQTlCLEVBQWlDdUIsQ0FBQyxFQUFsQyxFQUFzQztBQUNyQ3dGLGVBQUcsQ0FBQ3JILFFBQUosQ0FBYTRCLENBQWIsRUFBZ0JDLENBQWhCLElBQXFCc0YsQ0FBQyxDQUFDbkgsUUFBRixDQUFXNEIsQ0FBWCxFQUFjQyxDQUFkLENBQXJCO0FBQ0E7QUFDRDs7QUFDRCxhQUFLLElBQUlELEVBQVMsR0FBRyxDQUFyQixFQUF3QkEsRUFBQyxHQUFHd0YsQ0FBQyxDQUFDL0csQ0FBOUIsRUFBaUN1QixFQUFDLEVBQWxDLEVBQXNDO0FBQ3JDLGVBQUssSUFBSUMsRUFBUyxHQUFHLENBQXJCLEVBQXdCQSxFQUFDLEdBQUd1RixDQUFDLENBQUM5RyxDQUE5QixFQUFpQ3VCLEVBQUMsRUFBbEMsRUFBc0M7QUFDckN3RixlQUFHLENBQUNySCxRQUFKLENBQWE0QixFQUFiLEVBQWdCdUYsQ0FBQyxDQUFDN0csQ0FBRixHQUFNdUIsRUFBdEIsSUFBMkJ1RixDQUFDLENBQUNwSCxRQUFGLENBQVc0QixFQUFYLEVBQWNDLEVBQWQsQ0FBM0I7QUFDQTtBQUNEO0FBQ0QsT0FaRCxNQVlPO0FBQ04sWUFBSXVGLENBQUMsWUFBWUUsOENBQWpCLEVBQXlCO0FBQ3hCRCxhQUFHLEdBQUcsSUFBSTlILE1BQUosQ0FBVzRILENBQUMsQ0FBQzlHLENBQWIsRUFBZ0I4RyxDQUFDLENBQUM3RyxDQUFGLEdBQU0sQ0FBdEIsQ0FBTjs7QUFDQSxlQUFLLElBQUlzQixHQUFTLEdBQUcsQ0FBckIsRUFBd0JBLEdBQUMsR0FBR3VGLENBQUMsQ0FBQzlHLENBQTlCLEVBQWlDdUIsR0FBQyxFQUFsQyxFQUFzQztBQUNyQyxpQkFBSyxJQUFJQyxHQUFTLEdBQUcsQ0FBckIsRUFBd0JBLEdBQUMsR0FBR3NGLENBQUMsQ0FBQzdHLENBQTlCLEVBQWlDdUIsR0FBQyxFQUFsQyxFQUFzQztBQUNyQ3dGLGlCQUFHLENBQUNySCxRQUFKLENBQWE0QixHQUFiLEVBQWdCQyxHQUFoQixJQUFxQnNGLENBQUMsQ0FBQ25ILFFBQUYsQ0FBVzRCLEdBQVgsRUFBY0MsR0FBZCxDQUFyQjtBQUNBO0FBQ0Q7O0FBQ0QsZUFBSyxJQUFJQSxHQUFTLEdBQUcsQ0FBckIsRUFBd0JBLEdBQUMsR0FBR3VGLENBQUMsQ0FBQy9HLENBQTlCLEVBQWlDd0IsR0FBQyxFQUFsQyxFQUFzQztBQUNyQ3dGLGVBQUcsQ0FBQ3JILFFBQUosQ0FBYTZCLEdBQWIsRUFBZ0JzRixDQUFDLENBQUM3RyxDQUFsQixJQUF1QjhHLENBQUMsQ0FBQ3BILFFBQUYsQ0FBVzZCLEdBQVgsQ0FBdkI7QUFDQTtBQUNEO0FBQ0Q7O0FBQ0QsYUFBT3dGLEdBQVA7QUFDQSxLQTlCRixDQStCQzs7QUEvQkQ7QUFBQTtBQUFBLG1DQWdDOEIvRyxDQWhDOUIsRUFnQ3lDaUgsSUFoQ3pDLEVBZ0N1REMsSUFoQ3ZELEVBZ0NxRVQsSUFoQ3JFLEVBZ0MyRjtBQUN6RixVQUFJekcsQ0FBQyxHQUFHaUgsSUFBSixJQUFZakgsQ0FBQyxHQUFHa0gsSUFBcEIsRUFBMEI7QUFBRSxjQUFNLElBQUlsRCxLQUFKLENBQVUsdURBQVYsQ0FBTjtBQUEyRTs7QUFDdkcsVUFBTW1ELE1BQWMsR0FBRyxJQUFJQyxjQUFKLENBQW1CcEgsQ0FBbkIsQ0FBdkI7QUFDQW1ILFlBQU0sQ0FBQ3pILFFBQVAsQ0FBZ0J1SCxJQUFoQixFQUFzQkMsSUFBdEIsSUFBOEIsSUFBSXZILDhEQUFKLENBQW1COEcsSUFBbkIsQ0FBOUI7QUFDQSxhQUFPVSxNQUFQO0FBQ0E7QUFyQ0Y7QUFBQTtBQUFBLG1DQXNDc0M7QUFDcEMsVUFBTUEsTUFBYyxHQUFHLElBQUlsSSxNQUFKLENBQVdvSSxJQUFJLENBQUNDLEtBQUwsQ0FBV0QsSUFBSSxDQUFDRSxNQUFMLEtBQWdCLENBQTNCLElBQWdDLENBQTNDLEVBQThDRixJQUFJLENBQUNDLEtBQUwsQ0FBV0QsSUFBSSxDQUFDRSxNQUFMLEtBQWdCLENBQTNCLElBQWdDLENBQTlFLENBQXZCLENBRG9DLENBQ3FFOztBQUN6RyxXQUFLLElBQUlqRyxDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRzZGLE1BQU0sQ0FBQ3BILENBQW5DLEVBQXNDdUIsQ0FBQyxFQUF2QyxFQUEyQztBQUMxQyxhQUFLLElBQUlDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHNEYsTUFBTSxDQUFDbkgsQ0FBbkMsRUFBc0N1QixDQUFDLEVBQXZDLEVBQTJDO0FBQzFDNEYsZ0JBQU0sQ0FBQ3pILFFBQVAsQ0FBZ0I0QixDQUFoQixFQUFtQkMsQ0FBbkIsSUFBd0IsSUFBSTVCLDhEQUFKLENBQW1CMEgsSUFBSSxDQUFDQyxLQUFMLENBQVdELElBQUksQ0FBQ0UsTUFBTCxLQUFnQixHQUFoQixHQUFzQixFQUFqQyxDQUFuQixDQUF4QjtBQUNBO0FBQ0Q7O0FBQ0QsYUFBT0osTUFBUDtBQUNBO0FBOUNGO0FBQUE7QUFBQSw4QkErQ2lDO0FBQy9CLFVBQU1LLGdCQUF3QixHQUFHSCxJQUFJLENBQUNDLEtBQUwsQ0FBV0QsSUFBSSxDQUFDRSxNQUFMLEtBQWdCLENBQWhCLEdBQW9CLENBQS9CLENBQWpDLENBRCtCLENBQ3FDOztBQUNwRSxVQUFNRSxRQUFrQixHQUFHLEVBQTNCOztBQUNBLFdBQUssSUFBSW5HLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHa0csZ0JBQTVCLEVBQThDbEcsQ0FBQyxFQUEvQyxFQUFtRDtBQUNsRG1HLGdCQUFRLENBQUNuRyxDQUFELENBQVIsR0FBYytGLElBQUksQ0FBQ0MsS0FBTCxDQUFXRCxJQUFJLENBQUNFLE1BQUwsS0FBZ0IsRUFBaEIsR0FBcUIsRUFBaEMsQ0FBZDtBQUNBLE9BTDhCLENBTS9COzs7QUFDQSxVQUFNSixNQUFjLEdBQUcsSUFBSWxJLE1BQUosQ0FBV29JLElBQUksQ0FBQ0MsS0FBTCxDQUFXRCxJQUFJLENBQUNFLE1BQUwsS0FBZ0IsQ0FBM0IsSUFBZ0MsQ0FBM0MsRUFBOENGLElBQUksQ0FBQ0MsS0FBTCxDQUFXRCxJQUFJLENBQUNFLE1BQUwsS0FBZ0IsQ0FBM0IsSUFBZ0MsQ0FBOUUsQ0FBdkI7QUFDQSxhQUFPSixNQUFQO0FBQ0E7QUF4REY7O0FBNERDLGtCQUFZcEgsQ0FBWixFQUF1QkMsQ0FBdkIsRUFBa0M7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFDakMsU0FBS0QsQ0FBTCxHQUFTQSxDQUFUO0FBQ0EsU0FBS0MsQ0FBTCxHQUFTQSxDQUFUO0FBQ0EsU0FBS04sUUFBTCxHQUFnQixFQUFoQjs7QUFDQSxTQUFLLElBQUk0QixDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLdkIsQ0FBakMsRUFBb0N1QixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDLFdBQUs1QixRQUFMLENBQWM0QixDQUFkLElBQW1CLEVBQW5CO0FBQ0E7QUFDRDs7QUFuRUY7QUFBQTtBQUFBLDJCQW9FZW9HLENBcEVmLEVBb0VtQztBQUNqQyxVQUFJLEtBQUszSCxDQUFMLEtBQVcySCxDQUFDLENBQUMzSCxDQUFiLElBQWtCLEtBQUtDLENBQUwsS0FBVzBILENBQUMsQ0FBQzFILENBQW5DLEVBQXNDO0FBQ3JDLGVBQU8sS0FBUDtBQUNBOztBQUNELFdBQUssSUFBSXNCLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt2QixDQUFqQyxFQUFvQ3VCLENBQUMsRUFBckMsRUFBeUM7QUFDeEMsYUFBSyxJQUFJQyxDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLdkIsQ0FBakMsRUFBb0N1QixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDLGNBQUksQ0FBQyxLQUFLN0IsUUFBTCxDQUFjNEIsQ0FBZCxFQUFpQkMsQ0FBakIsRUFBb0JvRyxNQUFwQixDQUEyQkQsQ0FBQyxDQUFDaEksUUFBRixDQUFXNEIsQ0FBWCxFQUFjQyxDQUFkLENBQTNCLENBQUwsRUFBbUQ7QUFBRSxtQkFBTyxLQUFQO0FBQWU7QUFDcEU7QUFDRDs7QUFDRCxhQUFPLElBQVA7QUFDQTtBQTlFRjtBQUFBO0FBQUEsd0JBK0VZL0IsQ0EvRVosRUErRStCO0FBQzdCLFVBQUksS0FBS08sQ0FBTCxLQUFXUCxDQUFDLENBQUNPLENBQWIsSUFBa0IsS0FBS0MsQ0FBTCxLQUFXUixDQUFDLENBQUNRLENBQW5DLEVBQXNDO0FBQUUsY0FBTSxJQUFJZ0UsS0FBSixDQUFVLHdCQUFWLENBQU47QUFBNEM7O0FBQ3BGLFVBQU00RCxHQUFXLEdBQUcsSUFBSTNJLE1BQUosQ0FBVyxLQUFLYyxDQUFoQixFQUFtQixLQUFLQyxDQUF4QixDQUFwQjs7QUFDQSxXQUFLLElBQUlzQixDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBR3NHLEdBQUcsQ0FBQzdILENBQWhDLEVBQW1DdUIsQ0FBQyxFQUFwQyxFQUF3QztBQUN2QyxhQUFLLElBQUlDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHcUcsR0FBRyxDQUFDNUgsQ0FBaEMsRUFBbUN1QixDQUFDLEVBQXBDLEVBQXdDO0FBQ3ZDcUcsYUFBRyxDQUFDbEksUUFBSixDQUFhNEIsQ0FBYixFQUFnQkMsQ0FBaEIsSUFBcUIsS0FBSzdCLFFBQUwsQ0FBYzRCLENBQWQsRUFBaUJDLENBQWpCLEVBQW9CNEUsR0FBcEIsQ0FBd0IzRyxDQUFDLENBQUNFLFFBQUYsQ0FBVzRCLENBQVgsRUFBY0MsQ0FBZCxDQUF4QixDQUFyQjtBQUNBO0FBQ0Q7O0FBQ0QsYUFBT3FHLEdBQVA7QUFDQTtBQXhGRjtBQUFBO0FBQUEsd0JBeUZZcEksQ0F6RlosRUF5RitCO0FBQzdCLFVBQUksS0FBS08sQ0FBTCxLQUFXUCxDQUFDLENBQUNPLENBQWIsSUFBa0IsS0FBS0MsQ0FBTCxLQUFXUixDQUFDLENBQUNRLENBQW5DLEVBQXNDO0FBQUUsY0FBTSxJQUFJZ0UsS0FBSixDQUFVLHdCQUFWLENBQU47QUFBNEM7O0FBQ3BGLFVBQU00RCxHQUFXLEdBQUcsSUFBSTNJLE1BQUosQ0FBVyxLQUFLYyxDQUFoQixFQUFtQixLQUFLQyxDQUF4QixDQUFwQjs7QUFDQSxXQUFLLElBQUlzQixDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBR3NHLEdBQUcsQ0FBQzdILENBQWhDLEVBQW1DdUIsQ0FBQyxFQUFwQyxFQUF3QztBQUN2QyxhQUFLLElBQUlDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHcUcsR0FBRyxDQUFDNUgsQ0FBaEMsRUFBbUN1QixDQUFDLEVBQXBDLEVBQXdDO0FBQ3ZDcUcsYUFBRyxDQUFDbEksUUFBSixDQUFhNEIsQ0FBYixFQUFnQkMsQ0FBaEIsSUFBcUIsS0FBSzdCLFFBQUwsQ0FBYzRCLENBQWQsRUFBaUJDLENBQWpCLEVBQW9CNkUsR0FBcEIsQ0FBd0I1RyxDQUFDLENBQUNFLFFBQUYsQ0FBVzRCLENBQVgsRUFBY0MsQ0FBZCxDQUF4QixDQUFyQjtBQUNBO0FBQ0Q7O0FBQ0QsYUFBT3FHLEdBQVA7QUFDQTtBQWxHRjtBQUFBO0FBQUEseUJBbUdhcEksQ0FuR2IsRUFtRzBEO0FBQ3hELFVBQUlvSSxHQUFXLEdBQUcsSUFBbEI7O0FBQ0EsVUFBSSxPQUFPcEksQ0FBUCxLQUFhLFFBQWpCLEVBQTJCO0FBQzFCb0ksV0FBRyxHQUFHLElBQUkzSSxNQUFKLENBQVcsS0FBS2MsQ0FBaEIsRUFBbUIsS0FBS0MsQ0FBeEIsQ0FBTjs7QUFDQSxhQUFLLElBQUlzQixDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBR3NHLEdBQUcsQ0FBQzdILENBQWhDLEVBQW1DdUIsQ0FBQyxFQUFwQyxFQUF3QztBQUN2QyxlQUFLLElBQUlDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHcUcsR0FBRyxDQUFDNUgsQ0FBaEMsRUFBbUN1QixDQUFDLEVBQXBDLEVBQXdDO0FBQ3ZDcUcsZUFBRyxDQUFDbEksUUFBSixDQUFhNEIsQ0FBYixFQUFnQkMsQ0FBaEIsSUFBcUIsS0FBSzdCLFFBQUwsQ0FBYzRCLENBQWQsRUFBaUJDLENBQWpCLEVBQW9Ca0YsSUFBcEIsQ0FBeUJqSCxDQUF6QixDQUFyQjtBQUNBO0FBQ0Q7QUFDRCxPQVBELE1BT08sSUFBSUEsQ0FBQyxZQUFZRyw4REFBakIsRUFBaUM7QUFDdkNpSSxXQUFHLEdBQUcsSUFBSTNJLE1BQUosQ0FBVyxLQUFLYyxDQUFoQixFQUFtQixLQUFLQyxDQUF4QixDQUFOOztBQUNBLGFBQUssSUFBSXNCLEdBQVMsR0FBRyxDQUFyQixFQUF3QkEsR0FBQyxHQUFHc0csR0FBRyxDQUFDN0gsQ0FBaEMsRUFBbUN1QixHQUFDLEVBQXBDLEVBQXdDO0FBQ3ZDLGVBQUssSUFBSUMsR0FBUyxHQUFHLENBQXJCLEVBQXdCQSxHQUFDLEdBQUdxRyxHQUFHLENBQUM1SCxDQUFoQyxFQUFtQ3VCLEdBQUMsRUFBcEMsRUFBd0M7QUFDdkNxRyxlQUFHLENBQUNsSSxRQUFKLENBQWE0QixHQUFiLEVBQWdCQyxHQUFoQixJQUFxQixLQUFLN0IsUUFBTCxDQUFjNEIsR0FBZCxFQUFpQkMsR0FBakIsRUFBb0JrRixJQUFwQixDQUF5QmpILENBQXpCLENBQXJCO0FBQ0E7QUFDRDtBQUNELE9BUE0sTUFPQTtBQUNOLFlBQUlBLENBQUMsWUFBWVAsTUFBakIsRUFBeUI7QUFDeEIsY0FBSSxLQUFLZSxDQUFMLEtBQVdSLENBQUMsQ0FBQ08sQ0FBakIsRUFBb0I7QUFBRSxrQkFBTSxJQUFJaUUsS0FBSixDQUFVLHdCQUFWLENBQU47QUFBNEM7O0FBQ2xFNEQsYUFBRyxHQUFHLElBQUkzSSxNQUFKLENBQVcsS0FBS2MsQ0FBaEIsRUFBbUJQLENBQUMsQ0FBQ1EsQ0FBckIsQ0FBTjs7QUFDQSxlQUFLLElBQUlzQixHQUFTLEdBQUcsQ0FBckIsRUFBd0JBLEdBQUMsR0FBR3NHLEdBQUcsQ0FBQzdILENBQWhDLEVBQW1DdUIsR0FBQyxFQUFwQyxFQUF3QztBQUN2QyxpQkFBSyxJQUFJQyxHQUFTLEdBQUcsQ0FBckIsRUFBd0JBLEdBQUMsR0FBR3FHLEdBQUcsQ0FBQzVILENBQWhDLEVBQW1DdUIsR0FBQyxFQUFwQyxFQUF3QztBQUN2QyxrQkFBSXNHLEdBQW1CLEdBQUcsSUFBSWxJLDhEQUFKLENBQW1CLENBQW5CLENBQTFCOztBQUNBLG1CQUFLLElBQUltSSxDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLOUgsQ0FBakMsRUFBb0M4SCxDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDRCxtQkFBRyxHQUFHQSxHQUFHLENBQUMxQixHQUFKLENBQVEsS0FBS3pHLFFBQUwsQ0FBYzRCLEdBQWQsRUFBaUJ3RyxDQUFqQixFQUFvQnJCLElBQXBCLENBQXlCakgsQ0FBQyxDQUFDRSxRQUFGLENBQVdvSSxDQUFYLEVBQWN2RyxHQUFkLENBQXpCLENBQVIsQ0FBTjtBQUNBOztBQUNEcUcsaUJBQUcsQ0FBQ2xJLFFBQUosQ0FBYTRCLEdBQWIsRUFBZ0JDLEdBQWhCLElBQXFCc0csR0FBckI7QUFDQTtBQUNEO0FBQ0Q7QUFDRDs7QUFDRCxhQUFPRCxHQUFQO0FBQ0E7QUFuSUY7QUFBQTtBQUFBLGtDQW9Jc0JHLENBcEl0QixFQW9JcUQ7QUFDbkQsVUFBSSxLQUFLL0gsQ0FBTCxLQUFXK0gsQ0FBQyxDQUFDaEksQ0FBakIsRUFBb0I7QUFBRSxjQUFNLElBQUlpRSxLQUFKLENBQVUsd0JBQVYsQ0FBTjtBQUE0Qzs7QUFDbEUsVUFBTTRELEdBQWlCLEdBQUcsSUFBSUksb0RBQUosQ0FBaUJELENBQUMsQ0FBQ2hJLENBQW5CLENBQTFCOztBQUNBLFdBQUssSUFBSXVCLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt2QixDQUFqQyxFQUFvQ3VCLENBQUMsRUFBckMsRUFBeUM7QUFDeEMsWUFBSXVHLEdBQW1CLEdBQUcsSUFBSWxJLDhEQUFKLENBQW1CLENBQW5CLENBQTFCOztBQUNBLGFBQUssSUFBSTRCLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt2QixDQUFqQyxFQUFvQ3VCLENBQUMsRUFBckMsRUFBeUM7QUFDeENzRyxhQUFHLEdBQUdBLEdBQUcsQ0FBQzFCLEdBQUosQ0FBUSxLQUFLekcsUUFBTCxDQUFjNEIsQ0FBZCxFQUFpQkMsQ0FBakIsRUFBb0JrRixJQUFwQixDQUF5QnNCLENBQUMsQ0FBQ3JJLFFBQUYsQ0FBVzZCLENBQVgsQ0FBekIsQ0FBUixDQUFOO0FBQ0E7O0FBQ0RxRyxXQUFHLENBQUNsSSxRQUFKLENBQWE0QixDQUFiLElBQWtCdUcsR0FBbEI7QUFDQTs7QUFDRCxhQUFPRCxHQUFQO0FBQ0E7QUEvSUY7QUFBQTtBQUFBLGdDQWdKNEI7QUFDMUIsVUFBTWIsR0FBVyxHQUFHLElBQUk5SCxNQUFKLENBQVcsS0FBS2UsQ0FBaEIsRUFBbUIsS0FBS0QsQ0FBeEIsQ0FBcEI7O0FBQ0EsV0FBSyxJQUFJdUIsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUcsS0FBS3ZCLENBQWpDLEVBQW9DdUIsQ0FBQyxFQUFyQyxFQUF5QztBQUN4QyxhQUFLLElBQUlDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt2QixDQUFqQyxFQUFvQ3VCLENBQUMsRUFBckMsRUFBeUM7QUFDeEN3RixhQUFHLENBQUNySCxRQUFKLENBQWE2QixDQUFiLEVBQWdCRCxDQUFoQixJQUFxQixLQUFLNUIsUUFBTCxDQUFjNEIsQ0FBZCxFQUFpQkMsQ0FBakIsQ0FBckI7QUFDQTtBQUNEOztBQUNELGFBQU93RixHQUFQO0FBQ0E7QUF4SkY7QUFBQTtBQUFBLCtCQXlKMkI7QUFDekIsVUFBTUEsR0FBVyxHQUFHLElBQUk5SCxNQUFKLENBQVcsS0FBS2MsQ0FBaEIsRUFBbUIsS0FBS0MsQ0FBeEIsQ0FBcEI7O0FBQ0EsV0FBSyxJQUFJc0IsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUcsS0FBS3ZCLENBQWpDLEVBQW9DdUIsQ0FBQyxFQUFyQyxFQUF5QztBQUN4QyxhQUFLLElBQUlDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt2QixDQUFqQyxFQUFvQ3VCLENBQUMsRUFBckMsRUFBeUM7QUFDeEN3RixhQUFHLENBQUNySCxRQUFKLENBQWE0QixDQUFiLEVBQWdCQyxDQUFoQixJQUFxQixLQUFLN0IsUUFBTCxDQUFjNEIsQ0FBZCxFQUFpQkMsQ0FBakIsQ0FBckI7QUFDQTtBQUNEOztBQUNELGFBQU93RixHQUFQO0FBQ0E7QUFqS0Y7QUFBQTtBQUFBLCtCQWtLbUJrQixJQWxLbkIsRUFrS2lDQyxJQWxLakMsRUFrS3FEO0FBQ25ELFVBQUksS0FBS25JLENBQUwsR0FBU2tJLElBQVQsSUFBaUIsS0FBS2xJLENBQUwsR0FBU21JLElBQTlCLEVBQW9DO0FBQUU7QUFBUzs7QUFDL0MsV0FBSyxJQUFJNUcsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUcsS0FBS3RCLENBQWpDLEVBQW9Dc0IsQ0FBQyxFQUFyQyxFQUF5QztBQUN4QyxZQUFNNkcsR0FBbUIsR0FBRyxLQUFLekksUUFBTCxDQUFjdUksSUFBZCxFQUFvQjNHLENBQXBCLENBQTVCO0FBQ0EsYUFBSzVCLFFBQUwsQ0FBY3VJLElBQWQsRUFBb0IzRyxDQUFwQixJQUF5QixLQUFLNUIsUUFBTCxDQUFjd0ksSUFBZCxFQUFvQjVHLENBQXBCLENBQXpCO0FBQ0EsYUFBSzVCLFFBQUwsQ0FBY3dJLElBQWQsRUFBb0I1RyxDQUFwQixJQUF5QjZHLEdBQXpCO0FBQ0E7QUFDRDtBQXpLRjtBQUFBO0FBQUEsZ0NBMEtvQjVJLEdBMUtwQixFQTBLaUM2SSxNQTFLakMsRUEwSytEO0FBQzdELFVBQUksS0FBS3JJLENBQUwsR0FBU1IsR0FBYixFQUFrQjtBQUFFO0FBQVM7O0FBQzdCLFdBQUssSUFBSStCLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt0QixDQUFqQyxFQUFvQ3NCLENBQUMsRUFBckMsRUFBeUM7QUFDeEMsYUFBSzVCLFFBQUwsQ0FBY0gsR0FBZCxFQUFtQitCLENBQW5CLElBQXdCLEtBQUs1QixRQUFMLENBQWNILEdBQWQsRUFBbUIrQixDQUFuQixFQUFzQm1GLElBQXRCLENBQTJCMkIsTUFBM0IsRUFBbUNDLGNBQW5DLEVBQXhCO0FBQ0E7QUFDRDtBQS9LRjtBQUFBO0FBQUEsNEJBZ0xnQkosSUFoTGhCLEVBZ0w4QkMsSUFoTDlCLEVBZ0w0Q0UsTUFoTDVDLEVBZ0wwRTtBQUN4RSxVQUFJLEtBQUtySSxDQUFMLEdBQVNrSSxJQUFULElBQWlCLEtBQUtsSSxDQUFMLEdBQVNtSSxJQUE5QixFQUFvQztBQUFFO0FBQVM7O0FBQy9DLFdBQUssSUFBSTVHLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt0QixDQUFqQyxFQUFvQ3NCLENBQUMsRUFBckMsRUFBeUM7QUFDeEMsYUFBSzVCLFFBQUwsQ0FBY3VJLElBQWQsRUFBb0IzRyxDQUFwQixJQUF5QixLQUFLNUIsUUFBTCxDQUFjd0ksSUFBZCxFQUFvQjVHLENBQXBCLEVBQXVCbUYsSUFBdkIsQ0FBNEIyQixNQUE1QixFQUFvQ2pDLEdBQXBDLENBQXdDLEtBQUt6RyxRQUFMLENBQWN1SSxJQUFkLEVBQW9CM0csQ0FBcEIsQ0FBeEMsRUFBZ0UrRyxjQUFoRSxFQUF6QjtBQUNBO0FBQ0Q7QUFyTEY7QUFBQTtBQUFBLGtDQXNMc0JKLElBdEx0QixFQXNMb0NLLE9BdExwQyxFQXNMNkRKLElBdEw3RCxFQXNMMkVLLE9BdEwzRSxFQXNMMEc7QUFDeEcsVUFBSSxLQUFLeEksQ0FBTCxHQUFTa0ksSUFBVCxJQUFpQixLQUFLbEksQ0FBTCxHQUFTbUksSUFBOUIsRUFBb0M7QUFBRTtBQUFTOztBQUMvQyxXQUFLLElBQUk1RyxDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLdEIsQ0FBakMsRUFBb0NzQixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDLGFBQUs1QixRQUFMLENBQWN3SSxJQUFkLEVBQW9CNUcsQ0FBcEIsSUFBeUIsS0FBSzVCLFFBQUwsQ0FBY3dJLElBQWQsRUFBb0I1RyxDQUFwQixFQUF1Qm1GLElBQXZCLENBQTRCOEIsT0FBNUIsRUFBcUNwQyxHQUFyQyxDQUF5QyxLQUFLekcsUUFBTCxDQUFjdUksSUFBZCxFQUFvQjNHLENBQXBCLEVBQXVCbUYsSUFBdkIsQ0FBNEI2QixPQUE1QixDQUF6QyxFQUErRUQsY0FBL0UsRUFBekI7QUFDQTtBQUNELEtBM0xGLENBNExDOztBQTVMRDtBQUFBO0FBQUEsK0JBNkw0QjtBQUMxQixhQUFPLEtBQUt0SSxDQUFMLEtBQVcsS0FBS0MsQ0FBdkI7QUFDQSxLQS9MRixDQWdNQzs7QUFoTUQ7QUFBQTtBQUFBLGlDQWlNOEI7QUFDNUIsV0FBSyxJQUFJc0IsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUcsS0FBS3ZCLENBQWpDLEVBQW9DdUIsQ0FBQyxFQUFyQyxFQUF5QztBQUN4QyxhQUFLLElBQUlDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt2QixDQUFqQyxFQUFvQ3VCLENBQUMsRUFBckMsRUFBeUM7QUFDeEMsY0FBSUQsQ0FBQyxLQUFLQyxDQUFWLEVBQWE7QUFDWjtBQUNBOztBQUNELGNBQUksQ0FBQyxLQUFLN0IsUUFBTCxDQUFjNEIsQ0FBZCxFQUFpQkMsQ0FBakIsRUFBb0JvRyxNQUFwQixDQUEyQixJQUFJaEksOERBQUosQ0FBbUIsQ0FBbkIsQ0FBM0IsQ0FBTCxFQUF3RDtBQUFFLG1CQUFPLEtBQVA7QUFBZTtBQUN6RTtBQUNEOztBQUNELGFBQU8sSUFBUDtBQUNBLEtBM01GLENBNE1DO0FBQ0E7O0FBN01EO0FBQUE7QUFBQSxpQ0E4TThCO0FBQzVCLFVBQUksS0FBS0ksQ0FBTCxLQUFXLEtBQUtDLENBQXBCLEVBQXVCO0FBQUUsY0FBTSxJQUFJZ0UsS0FBSixDQUFVLHNCQUFWLENBQU47QUFBMEM7O0FBQ25FLFdBQUssSUFBSTFDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt2QixDQUFqQyxFQUFvQ3VCLENBQUMsRUFBckMsRUFBeUM7QUFDeEMsYUFBSyxJQUFJQyxDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLdkIsQ0FBakMsRUFBb0N1QixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDLGNBQUlELENBQUMsS0FBS0MsQ0FBVixFQUFhO0FBQ1osZ0JBQUksQ0FBQyxLQUFLN0IsUUFBTCxDQUFjNEIsQ0FBZCxFQUFpQkMsQ0FBakIsRUFBb0JvRyxNQUFwQixDQUEyQixJQUFJaEksOERBQUosQ0FBbUIsQ0FBbkIsQ0FBM0IsQ0FBTCxFQUF3RDtBQUFFLHFCQUFPLEtBQVA7QUFBZTs7QUFDekU7QUFDQTs7QUFDRCxjQUFJLENBQUMsS0FBS0QsUUFBTCxDQUFjNEIsQ0FBZCxFQUFpQkMsQ0FBakIsRUFBb0JvRyxNQUFwQixDQUEyQixJQUFJaEksOERBQUosQ0FBbUIsQ0FBbkIsQ0FBM0IsQ0FBTCxFQUF3RDtBQUFFLG1CQUFPLEtBQVA7QUFBZTtBQUN6RTtBQUNEOztBQUNELGFBQU8sSUFBUDtBQUNBLEtBMU5GLENBMk5DOztBQTNORDtBQUFBO0FBQUEsK0JBNE40QjtBQUMxQixZQUFNLElBQUlxRSxLQUFKLENBQVUsaUJBQVYsQ0FBTjtBQUNBLEtBOU5GLENBK05DO0FBQ0E7QUFDQTs7QUFqT0Q7QUFBQTtBQUFBLDJDQWtPdUM7QUFDckMsWUFBTSxJQUFJQSxLQUFKLENBQVUsaUJBQVYsQ0FBTjtBQUNBO0FBcE9GO0FBQUE7QUFBQSx3Q0FxT3FDO0FBQ25DO0FBQ0E7QUFDQSxXQUFLLElBQUkxQyxDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLdkIsQ0FBakMsRUFBb0N1QixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDLGFBQUssSUFBSUMsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUdELENBQTVCLEVBQStCQyxDQUFDLEVBQWhDLEVBQW9DO0FBQ25DLGNBQUksQ0FBQyxLQUFLN0IsUUFBTCxDQUFjNEIsQ0FBZCxFQUFpQkMsQ0FBakIsRUFBb0JvRyxNQUFwQixDQUEyQixJQUFJaEksOERBQUosQ0FBbUIsQ0FBbkIsQ0FBM0IsQ0FBTCxFQUF3RDtBQUFFLG1CQUFPLEtBQVA7QUFBZTtBQUN6RTtBQUNEOztBQUNELGFBQU8sSUFBUDtBQUNBO0FBOU9GO0FBQUE7QUFBQSx3Q0ErT3FDO0FBQ25DO0FBQ0E7QUFDQSxXQUFLLElBQUkyQixDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLdkIsQ0FBakMsRUFBb0N1QixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDLGFBQUssSUFBSUMsQ0FBUyxHQUFHRCxDQUFDLEdBQUcsQ0FBekIsRUFBNEJDLENBQUMsR0FBRyxLQUFLdkIsQ0FBckMsRUFBd0N1QixDQUFDLEVBQXpDLEVBQTZDO0FBQzVDLGNBQUksQ0FBQyxLQUFLN0IsUUFBTCxDQUFjNEIsQ0FBZCxFQUFpQkMsQ0FBakIsRUFBb0JvRyxNQUFwQixDQUEyQixJQUFJaEksOERBQUosQ0FBbUIsQ0FBbkIsQ0FBM0IsQ0FBTCxFQUF3RDtBQUFFLG1CQUFPLEtBQVA7QUFBZTtBQUN6RTtBQUNEOztBQUNELGFBQU8sSUFBUDtBQUNBLEtBeFBGLENBeVBDOztBQXpQRDtBQUFBO0FBQUEsa0NBMFArQjtBQUM3QixVQUFJLEtBQUtJLENBQUwsS0FBVyxLQUFLQyxDQUFwQixFQUF1QjtBQUFFLGNBQU0sSUFBSWdFLEtBQUosQ0FBVSxzQkFBVixDQUFOO0FBQTBDOztBQUNuRSxXQUFLLElBQUkxQyxDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLdkIsQ0FBakMsRUFBb0N1QixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDLGFBQUssSUFBSUMsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUcsS0FBS3ZCLENBQWpDLEVBQW9DdUIsQ0FBQyxFQUFyQyxFQUF5QztBQUN4QyxjQUFJLENBQUMsS0FBSzdCLFFBQUwsQ0FBYzRCLENBQWQsRUFBaUJDLENBQWpCLEVBQW9Cb0csTUFBcEIsQ0FBMkIsS0FBS2pJLFFBQUwsQ0FBYzZCLENBQWQsRUFBaUJELENBQWpCLENBQTNCLENBQUwsRUFBc0Q7QUFBRSxtQkFBTyxLQUFQO0FBQWU7QUFDdkU7QUFDRDs7QUFDRCxhQUFPLElBQVA7QUFDQSxLQWxRRixDQW1RQztBQUNBOztBQXBRRDtBQUFBO0FBQUEsbUNBcVFnQztBQUM5QixVQUFNa0gsRUFBVSxHQUFHLEtBQUtDLFNBQUwsRUFBbkI7QUFDQSxhQUFPLEtBQUtoQyxJQUFMLENBQVUrQixFQUFWLEVBQWNFLFVBQWQsRUFBUDtBQUNBO0FBeFFGO0FBQUE7QUFBQSx1Q0F5UW9DO0FBQ2xDLFVBQUlDLFlBQXFCLEdBQUcsS0FBNUIsQ0FEa0MsQ0FFbEM7QUFDQTs7QUFDQSxXQUFLLElBQUlySCxDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLdkIsQ0FBakMsRUFBb0N1QixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDLFlBQUksS0FBS3NILFNBQUwsQ0FBZXRILENBQWYsQ0FBSixFQUF1QjtBQUN0QnFILHNCQUFZLEdBQUcsSUFBZjtBQUNBLFNBRkQsTUFFTztBQUNOLGNBQUlBLFlBQUosRUFBa0I7QUFBRSxtQkFBTyxLQUFQO0FBQWU7QUFDbkMsU0FMdUMsQ0FLdkM7O0FBQ0QsT0FWaUMsQ0FXbEM7QUFDQTs7O0FBQ0EsVUFBSUUsV0FBbUIsR0FBRyxDQUFDLENBQTNCOztBQUNBLFdBQUssSUFBSXZILEdBQVMsR0FBRyxDQUFyQixFQUF3QkEsR0FBQyxHQUFHLEtBQUt2QixDQUFqQyxFQUFvQ3VCLEdBQUMsRUFBckMsRUFBeUM7QUFDeEMsWUFBTXdILGVBQXVCLEdBQUcsS0FBS0MsZ0JBQUwsQ0FBc0J6SCxHQUF0QixDQUFoQzs7QUFDQSxZQUFJLElBQUl3SCxlQUFSLEVBQXlCO0FBQUU7QUFBVyxTQUZFLENBRUY7QUFDdEM7OztBQUNBLFlBQUksQ0FBQyxLQUFLcEosUUFBTCxDQUFjNEIsR0FBZCxFQUFpQndILGVBQWpCLEVBQWtDbkIsTUFBbEMsQ0FBeUMsSUFBSWhJLDhEQUFKLENBQW1CLENBQW5CLENBQXpDLENBQUwsRUFBc0U7QUFBRSxpQkFBTyxLQUFQO0FBQWU7O0FBQ3ZGLFlBQUlrSixXQUFXLEdBQUdDLGVBQWxCLEVBQW1DO0FBQ2xDRCxxQkFBVyxHQUFHQyxlQUFkO0FBQ0EsU0FGRCxNQUVPO0FBQUUsaUJBQU8sS0FBUDtBQUFlO0FBQ3hCOztBQUNELGFBQU8sSUFBUDtBQUNBO0FBalNGO0FBQUE7QUFBQSw4Q0FrUzJDO0FBQ3pDLFVBQUksQ0FBQyxLQUFLRSxnQkFBTCxFQUFMLEVBQThCO0FBQUUsZUFBTyxLQUFQO0FBQWUsT0FETixDQUV6Qzs7O0FBQ0EsV0FBSyxJQUFJMUgsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUcsS0FBS3ZCLENBQWpDLEVBQW9DdUIsQ0FBQyxFQUFyQyxFQUF5QztBQUN4QyxZQUFNMkgsYUFBcUIsR0FBRyxLQUFLRixnQkFBTCxDQUFzQnpILENBQXRCLENBQTlCOztBQUNBLFlBQUksSUFBSSxLQUFLNEgsK0JBQUwsQ0FBcUNELGFBQXJDLENBQVIsRUFBNkQ7QUFBRSxpQkFBTyxLQUFQO0FBQWU7QUFDOUU7O0FBQ0QsYUFBTyxJQUFQO0FBQ0E7QUExU0Y7QUFBQTtBQUFBLDhDQTJTMEM7QUFDeEMsVUFBTXJCLEdBQVcsR0FBRyxLQUFLdUIsUUFBTCxFQUFwQjtBQUNBLFVBQUlDLElBQVksR0FBRyxDQUFuQjs7QUFDQSxXQUFLLElBQUlDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHekIsR0FBRyxDQUFDN0gsQ0FBaEMsRUFBbUNzSixDQUFDLEVBQXBDLEVBQXdDO0FBQ3ZDLFlBQUl6QixHQUFHLENBQUM1SCxDQUFKLElBQVNvSixJQUFiLEVBQW1CO0FBQ2xCO0FBQ0E7O0FBQ0QsWUFBSTlILENBQVMsR0FBRytILENBQWhCOztBQUNBLGVBQU96QixHQUFHLENBQUNsSSxRQUFKLENBQWE0QixDQUFiLEVBQWdCOEgsSUFBaEIsRUFBc0J6QixNQUF0QixDQUE2QixDQUE3QixDQUFQLEVBQXdDO0FBQ3ZDckcsV0FBQzs7QUFDRCxjQUFJc0csR0FBRyxDQUFDN0gsQ0FBSixLQUFVdUIsQ0FBZCxFQUFpQjtBQUNoQkEsYUFBQyxHQUFHK0gsQ0FBSjtBQUNBRCxnQkFBSTs7QUFDSixnQkFBSXhCLEdBQUcsQ0FBQzVILENBQUosS0FBVW9KLElBQWQsRUFBb0I7QUFDbkJBLGtCQUFJO0FBQ0o7QUFDQTtBQUNEO0FBQ0Q7O0FBQ0R4QixXQUFHLENBQUMwQixVQUFKLENBQWVoSSxDQUFmLEVBQWtCK0gsQ0FBbEI7O0FBQ0EsWUFBSSxDQUFDekIsR0FBRyxDQUFDbEksUUFBSixDQUFhMkosQ0FBYixFQUFnQkQsSUFBaEIsRUFBc0J6QixNQUF0QixDQUE2QixDQUE3QixDQUFMLEVBQXNDO0FBQ3JDQyxhQUFHLENBQUMyQixXQUFKLENBQWdCRixDQUFoQixFQUFtQnpCLEdBQUcsQ0FBQ2xJLFFBQUosQ0FBYTJKLENBQWIsRUFBZ0JELElBQWhCLEVBQXNCSSxVQUF0QixFQUFuQjtBQUNBOztBQUNELGFBQUssSUFBSWpJLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHcUcsR0FBRyxDQUFDN0gsQ0FBaEMsRUFBbUN3QixDQUFDLEVBQXBDLEVBQXdDO0FBQ3ZDLGNBQUlBLENBQUMsS0FBSzhILENBQVYsRUFBYTtBQUNaekIsZUFBRyxDQUFDNkIsT0FBSixDQUFZbEksQ0FBWixFQUFlOEgsQ0FBZixFQUFrQnpCLEdBQUcsQ0FBQ2xJLFFBQUosQ0FBYTZCLENBQWIsRUFBZ0I2SCxJQUFoQixFQUFzQk0sUUFBdEIsRUFBbEI7QUFDQTtBQUNEOztBQUNETixZQUFJO0FBQ0o7O0FBQ0QsYUFBT3hCLEdBQVA7QUFDQTtBQTFVRjtBQUFBO0FBQUEsa0NBMlVzQztBQUNwQztBQUNBLFVBQUksS0FBSzdILENBQUwsS0FBVyxLQUFLQyxDQUFwQixFQUF1QjtBQUN0QixjQUFNLElBQUlnRSxLQUFKLENBQVUsdURBQVYsQ0FBTjtBQUNBOztBQUNELFVBQUksS0FBS2pFLENBQUwsS0FBVyxDQUFmLEVBQWtCO0FBQ2pCLGVBQU8sS0FBS0wsUUFBTCxDQUFjLENBQWQsRUFBaUIsQ0FBakIsQ0FBUDtBQUNBOztBQUNELFVBQUlxSCxHQUFtQixHQUFHLElBQUlwSCw4REFBSixDQUFtQixDQUFuQixDQUExQjs7QUFDQSxXQUFLLElBQUkyQixDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLdEIsQ0FBakMsRUFBb0NzQixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDLFlBQU1xSSxLQUFxQixHQUFHLEtBQUtqSyxRQUFMLENBQWMsQ0FBZCxFQUFpQjRCLENBQWpCLEVBQW9CbUYsSUFBcEIsQ0FBeUIsS0FBS21ELFFBQUwsQ0FBYyxDQUFkLEVBQWlCdEksQ0FBakIsRUFBb0J1SSxXQUFwQixFQUF6QixDQUE5QjtBQUNBOUMsV0FBRyxHQUFHQSxHQUFHLENBQUNaLEdBQUosQ0FBUXdELEtBQUssQ0FBQ2xELElBQU4sVUFBWSxDQUFDLENBQWIsRUFBbUJuRixDQUFuQixFQUFSLENBQU47QUFDQTs7QUFDRCxhQUFPeUYsR0FBUDtBQUNBO0FBelZGO0FBQUE7QUFBQSw4QkEwVmtCMUYsTUExVmxCLEVBMFYwQztBQUN4QyxVQUFJQSxNQUFNLENBQUN0QixDQUFQLEtBQWFzQixNQUFNLENBQUNyQixDQUF4QixFQUEyQjtBQUFFLGNBQU0sSUFBSWdFLEtBQUosQ0FBVSxnQ0FBVixDQUFOO0FBQW9EOztBQUNqRixVQUFJM0MsTUFBTSxDQUFDdEIsQ0FBUCxHQUFXLENBQVgsS0FBaUIsQ0FBckIsRUFBd0I7QUFBRSxjQUFNLElBQUlpRSxLQUFKLENBQVUsb0NBQVYsQ0FBTjtBQUF3RDs7QUFDbEYsVUFBTThGLEVBQUUsR0FBR3pDLElBQUksQ0FBQ0MsS0FBTCxDQUFXakcsTUFBTSxDQUFDdEIsQ0FBUCxHQUFXLENBQXRCLENBQVg7QUFDQSxVQUFNNkgsR0FBVyxHQUFHLElBQUkzSSxNQUFKLENBQVcsS0FBS2MsQ0FBaEIsRUFBbUIsS0FBS0MsQ0FBeEIsQ0FBcEI7O0FBQ0EsV0FBSyxJQUFJc0IsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUcsS0FBS3ZCLENBQWpDLEVBQW9DdUIsQ0FBQyxFQUFyQyxFQUF5QztBQUN4QyxhQUFLLElBQUlDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt2QixDQUFqQyxFQUFvQ3VCLENBQUMsRUFBckMsRUFBeUM7QUFDeENxRyxhQUFHLENBQUNsSSxRQUFKLENBQWE0QixDQUFiLEVBQWdCQyxDQUFoQixJQUFxQixJQUFJNUIsOERBQUosQ0FBbUIsQ0FBbkIsQ0FBckI7O0FBQ0EsZUFBSyxJQUFJb0ssRUFBVSxHQUFHLENBQXRCLEVBQXlCQSxFQUFFLEdBQUcxSSxNQUFNLENBQUN0QixDQUFyQyxFQUF3Q2dLLEVBQUUsRUFBMUMsRUFBOEM7QUFDN0MsZ0JBQUl6SSxDQUFDLEdBQUd5SSxFQUFKLEdBQVNELEVBQVQsR0FBYyxDQUFkLElBQW1CeEksQ0FBQyxHQUFHeUksRUFBSixHQUFTRCxFQUFULElBQWUsS0FBSy9KLENBQTNDLEVBQThDO0FBQzdDO0FBQ0E7O0FBQ0QsaUJBQUssSUFBSWlLLEVBQVUsR0FBRyxDQUF0QixFQUF5QkEsRUFBRSxHQUFHM0ksTUFBTSxDQUFDckIsQ0FBckMsRUFBd0NnSyxFQUFFLEVBQTFDLEVBQThDO0FBQzdDLGtCQUFJekksQ0FBQyxHQUFHeUksRUFBSixHQUFTRixFQUFULEdBQWMsQ0FBZCxJQUFtQnZJLENBQUMsR0FBR3lJLEVBQUosR0FBU0YsRUFBVCxJQUFlLEtBQUs5SixDQUEzQyxFQUE4QztBQUM3QztBQUNBOztBQUNENEgsaUJBQUcsQ0FBQ2xJLFFBQUosQ0FBYTRCLENBQWIsRUFBZ0JDLENBQWhCLElBQXFCcUcsR0FBRyxDQUFDbEksUUFBSixDQUFhNEIsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUI0RSxHQUFuQixDQUF1QixLQUFLekcsUUFBTCxDQUFjNEIsQ0FBQyxHQUFHeUksRUFBSixHQUFTRCxFQUF2QixFQUEyQnZJLENBQUMsR0FBR3lJLEVBQUosR0FBU0YsRUFBcEMsRUFBd0NyRCxJQUF4QyxDQUE2Q3BGLE1BQU0sQ0FBQzNCLFFBQVAsQ0FBZ0JxSyxFQUFoQixFQUFvQkMsRUFBcEIsQ0FBN0MsQ0FBdkIsQ0FBckI7QUFDQTtBQUNEO0FBQ0Q7QUFDRDs7QUFDRCxhQUFPcEMsR0FBUDtBQUNBO0FBaFhGO0FBQUE7QUFBQSw4QkFrWG1CcUMsS0FsWG5CLEVBa1gyQztBQUN6QyxXQUFLLElBQUkxSSxDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLdkIsQ0FBakMsRUFBb0N1QixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDLFlBQUksQ0FBQyxLQUFLN0IsUUFBTCxDQUFjdUssS0FBZCxFQUFxQjFJLENBQXJCLEVBQXdCb0csTUFBeEIsQ0FBK0IsSUFBSWhJLDhEQUFKLENBQW1CLENBQW5CLENBQS9CLENBQUwsRUFBNEQ7QUFBRSxpQkFBTyxLQUFQO0FBQWU7QUFDN0U7O0FBQ0QsYUFBTyxJQUFQO0FBQ0E7QUF2WEY7QUFBQTtBQUFBLHFDQXdYMEJzSyxLQXhYMUIsRUF3WGlEO0FBQy9DLFdBQUssSUFBSTFJLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt2QixDQUFqQyxFQUFvQ3VCLENBQUMsRUFBckMsRUFBeUM7QUFDeEMsWUFBSSxDQUFDLEtBQUs3QixRQUFMLENBQWN1SyxLQUFkLEVBQXFCMUksQ0FBckIsRUFBd0JvRyxNQUF4QixDQUErQixJQUFJaEksOERBQUosQ0FBbUIsQ0FBbkIsQ0FBL0IsQ0FBTCxFQUE0RDtBQUFFLGlCQUFPNEIsQ0FBUDtBQUFXO0FBQ3pFOztBQUNELGFBQU8sQ0FBQyxDQUFSO0FBQ0E7QUE3WEY7QUFBQTtBQUFBLG9EQThYeUMySSxRQTlYekMsRUE4WG1FO0FBQ2pFLFVBQUlDLEdBQVcsR0FBRyxDQUFsQjs7QUFDQSxXQUFLLElBQUk1SSxDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLeEIsQ0FBakMsRUFBb0N3QixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDLFlBQUksQ0FBQyxLQUFLN0IsUUFBTCxDQUFjNkIsQ0FBZCxFQUFpQjJJLFFBQWpCLEVBQTJCdkMsTUFBM0IsQ0FBa0MsSUFBSWhJLDhEQUFKLENBQW1CLENBQW5CLENBQWxDLENBQUwsRUFBK0Q7QUFBRXdLLGFBQUc7QUFBSztBQUN6RTs7QUFDRCxhQUFPQSxHQUFQO0FBQ0E7QUFwWUY7QUFBQTtBQUFBLDZCQXFZa0JGLEtBcllsQixFQXFZaUNDLFFBcllqQyxFQXFZMkQ7QUFDekQsVUFBTW5ELEdBQVcsR0FBRyxJQUFJOUgsTUFBSixDQUFXLEtBQUtjLENBQUwsR0FBUyxDQUFwQixFQUF1QixLQUFLQyxDQUFMLEdBQVMsQ0FBaEMsQ0FBcEI7QUFDQSxVQUFJb0ssU0FBaUIsR0FBRyxDQUF4Qjs7QUFDQSxXQUFLLElBQUk5SSxDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLdkIsQ0FBTCxHQUFTLENBQXJDLEVBQXdDdUIsQ0FBQyxFQUF6QyxFQUE2QztBQUM1QyxZQUFJQSxDQUFDLEtBQUsySSxLQUFWLEVBQWlCO0FBQ2hCRyxtQkFBUyxHQUFHLENBQVo7QUFDQTs7QUFDRCxZQUFJQyxZQUFvQixHQUFHLENBQTNCOztBQUNBLGFBQUssSUFBSTlJLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt2QixDQUFMLEdBQVMsQ0FBckMsRUFBd0N1QixDQUFDLEVBQXpDLEVBQTZDO0FBQzVDLGNBQUlBLENBQUMsS0FBSzJJLFFBQVYsRUFBb0I7QUFDbkJHLHdCQUFZLEdBQUcsQ0FBZjtBQUNBOztBQUNEdEQsYUFBRyxDQUFDckgsUUFBSixDQUFhNEIsQ0FBYixFQUFnQkMsQ0FBaEIsSUFBcUIsS0FBSzdCLFFBQUwsQ0FBYzRCLENBQUMsR0FBRzhJLFNBQWxCLEVBQTZCN0ksQ0FBQyxHQUFHOEksWUFBakMsQ0FBckI7QUFDQTtBQUNEOztBQUNELGFBQU90RCxHQUFQO0FBQ0E7QUFyWkY7O0FBQUE7QUFBQTtBQXdaTyxJQUFNSyxjQUFiO0FBQUE7O0FBQUE7O0FBQ0MsMEJBQVlySCxDQUFaLEVBQXVCO0FBQUE7O0FBQUE7O0FBQ3RCLDhCQUFNQSxDQUFOLEVBQVNBLENBQVQ7QUFDQSxVQUFLTCxRQUFMLEdBQWdCLEVBQWhCOztBQUNBLFNBQUssSUFBSTRCLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLE1BQUt2QixDQUFqQyxFQUFvQ3VCLENBQUMsRUFBckMsRUFBeUM7QUFDeEMsWUFBSzVCLFFBQUwsQ0FBYzRCLENBQWQsSUFBbUIsRUFBbkI7O0FBQ0EsV0FBSyxJQUFJQyxDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxNQUFLeEIsQ0FBakMsRUFBb0N3QixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDLFlBQUlELENBQUMsS0FBS0MsQ0FBVixFQUFhO0FBQ1osZ0JBQUs3QixRQUFMLENBQWM0QixDQUFkLEVBQWlCQyxDQUFqQixJQUFzQixJQUFJNUIsOERBQUosQ0FBbUIsQ0FBbkIsQ0FBdEI7QUFDQSxTQUZELE1BRU87QUFBRSxnQkFBS0QsUUFBTCxDQUFjNEIsQ0FBZCxFQUFpQkMsQ0FBakIsSUFBc0IsSUFBSTVCLDhEQUFKLENBQW1CLENBQW5CLENBQXRCO0FBQThDO0FBQ3ZEO0FBQ0Q7O0FBVnFCO0FBV3RCOztBQVpGO0FBQUEsRUFBb0NWLE1BQXBDLEUsQ0FlQTtBQUNBOztBQUNPLElBQU1xTCxpQkFBYjtBQUFBOztBQUFBOztBQUdDLDZCQUFZdkssQ0FBWixFQUF1QndLLEVBQXZCLEVBQW1DQyxFQUFuQyxFQUErQy9ELElBQS9DLEVBQThFO0FBQUE7O0FBQUE7O0FBQzdFLFFBQUkxRyxDQUFDLEdBQUd3SyxFQUFKLElBQVV4SyxDQUFDLEdBQUd5SyxFQUFsQixFQUFzQjtBQUFFLFlBQU0sSUFBSXhHLEtBQUosQ0FBVSw2REFBVixDQUFOO0FBQWlGOztBQUN6RyxnQ0FBTWpFLENBQU4sRUFBU0EsQ0FBVDs7QUFGNkU7O0FBQUE7O0FBRzdFLFdBQUtrSCxJQUFMLEdBQVlzRCxFQUFaO0FBQ0EsV0FBS3JELElBQUwsR0FBWXNELEVBQVo7QUFDQSxXQUFLOUssUUFBTCxHQUFnQixFQUFoQjs7QUFDQSxTQUFLLElBQUk0QixDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxPQUFLdkIsQ0FBakMsRUFBb0N1QixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDLGFBQUs1QixRQUFMLENBQWM0QixDQUFkLElBQW1CLEVBQW5COztBQUNBLFdBQUssSUFBSUMsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUcsT0FBS3hCLENBQWpDLEVBQW9Dd0IsQ0FBQyxFQUFyQyxFQUF5QztBQUN4QyxZQUFJRCxDQUFDLEtBQUtDLENBQVYsRUFBYTtBQUNaLGlCQUFLN0IsUUFBTCxDQUFjNEIsQ0FBZCxFQUFpQkMsQ0FBakIsSUFBc0IsSUFBSTVCLDhEQUFKLENBQW1CLENBQW5CLENBQXRCO0FBQ0EsU0FGRCxNQUVPO0FBQUUsaUJBQUtELFFBQUwsQ0FBYzRCLENBQWQsRUFBaUJDLENBQWpCLElBQXNCLElBQUk1Qiw4REFBSixDQUFtQixDQUFuQixDQUF0QjtBQUE4QztBQUN2RDtBQUNEOztBQUNELFFBQUksT0FBTzhHLElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFDN0IsYUFBSy9HLFFBQUwsQ0FBYzZLLEVBQWQsRUFBa0JDLEVBQWxCLElBQXdCLElBQUk3Syw4REFBSixDQUFtQjhHLElBQW5CLENBQXhCO0FBQ0EsS0FGRCxNQUVPO0FBQ04sVUFBSUEsSUFBSSxZQUFZOUcsOERBQXBCLEVBQW9DO0FBQUUsZUFBS0QsUUFBTCxDQUFjNkssRUFBZCxFQUFrQkMsRUFBbEIsSUFBd0IvRCxJQUF4QjtBQUErQjtBQUNyRTs7QUFsQjRFO0FBbUI3RTs7QUF0QkY7QUFBQSxFQUF1Q3hILE1BQXZDLEUsQ0F5QkE7O0FBQ08sSUFBTXdMLGlCQUFiO0FBQUE7O0FBQUE7O0FBQ0MsNkJBQVkxSyxDQUFaLEVBQXVCa0gsSUFBdkIsRUFBcUNDLElBQXJDLEVBQW1EO0FBQUE7O0FBQUE7O0FBQ2xELFFBQUluSCxDQUFDLEdBQUdrSCxJQUFKLElBQVlsSCxDQUFDLEdBQUdtSCxJQUFwQixFQUEwQjtBQUFFLFlBQU0sSUFBSWxELEtBQUosQ0FBVSw2REFBVixDQUFOO0FBQWlGOztBQUM3RyxnQ0FBTWpFLENBQU4sRUFBU0EsQ0FBVDtBQUNBLFdBQUtMLFFBQUwsR0FBZ0IsRUFBaEI7O0FBQ0EsU0FBSyxJQUFJNEIsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUcsT0FBS3ZCLENBQWpDLEVBQW9DdUIsQ0FBQyxFQUFyQyxFQUF5QztBQUN4QyxhQUFLNUIsUUFBTCxDQUFjNEIsQ0FBZCxJQUFtQixFQUFuQjs7QUFDQSxXQUFLLElBQUlDLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLE9BQUt4QixDQUFqQyxFQUFvQ3dCLENBQUMsRUFBckMsRUFBeUM7QUFDeEMsWUFBSUQsQ0FBQyxLQUFLQyxDQUFWLEVBQWE7QUFDWixpQkFBSzdCLFFBQUwsQ0FBYzRCLENBQWQsRUFBaUJDLENBQWpCLElBQXNCLElBQUk1Qiw4REFBSixDQUFtQixDQUFuQixDQUF0QjtBQUNBLFNBRkQsTUFFTztBQUFFLGlCQUFLRCxRQUFMLENBQWM0QixDQUFkLEVBQWlCQyxDQUFqQixJQUFzQixJQUFJNUIsOERBQUosQ0FBbUIsQ0FBbkIsQ0FBdEI7QUFBOEM7QUFDdkQ7QUFDRDs7QUFDRCxXQUFLRCxRQUFMLENBQWN1SCxJQUFkLEVBQW9CQSxJQUFwQixJQUE0QixJQUFJdEgsOERBQUosQ0FBbUIsQ0FBbkIsQ0FBNUI7QUFDQSxXQUFLRCxRQUFMLENBQWN1SCxJQUFkLEVBQW9CQyxJQUFwQixJQUE0QixJQUFJdkgsOERBQUosQ0FBbUIsQ0FBbkIsQ0FBNUI7QUFDQSxXQUFLRCxRQUFMLENBQWN3SCxJQUFkLEVBQW9CQSxJQUFwQixJQUE0QixJQUFJdkgsOERBQUosQ0FBbUIsQ0FBbkIsQ0FBNUI7QUFDQSxXQUFLRCxRQUFMLENBQWN3SCxJQUFkLEVBQW9CRCxJQUFwQixJQUE0QixJQUFJdEgsOERBQUosQ0FBbUIsQ0FBbkIsQ0FBNUI7QUFma0Q7QUFnQmxEOztBQWpCRjtBQUFBLEVBQXVDVixNQUF2QyxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdGNPLElBQU1nRSxLQUFiO0FBRUMsbUJBQWM7QUFBQTs7QUFBQTs7QUFDYixTQUFLeUgsS0FBTCxHQUFhLEVBQWI7QUFDQTs7QUFKRjtBQUFBO0FBQUEsOEJBSzJCO0FBQ3pCLGFBQU8sS0FBS0EsS0FBTCxDQUFXdEgsTUFBWCxLQUFzQixDQUE3QjtBQUNBO0FBUEY7QUFBQTtBQUFBLDRCQVFnQnVILE9BUmhCLEVBUWtDO0FBQ2hDLFdBQUtELEtBQUwsQ0FBVzNHLElBQVgsQ0FBZ0I0RyxPQUFoQjtBQUNBO0FBVkY7QUFBQTtBQUFBLDhCQVdxQjtBQUNuQixVQUFJLEtBQUtsSCxPQUFMLEVBQUosRUFBb0I7QUFBRSxjQUFNLElBQUlPLEtBQUosQ0FBVSxnQkFBVixDQUFOO0FBQW9DOztBQUMxRCxhQUFPLEtBQUswRyxLQUFMLENBQVdFLEtBQVgsRUFBUDtBQUNBO0FBZEY7QUFBQTtBQUFBLDJCQWVrQjtBQUNoQixVQUFJLEtBQUtuSCxPQUFMLEVBQUosRUFBb0I7QUFBRSxjQUFNLElBQUlPLEtBQUosQ0FBVSxnQkFBVixDQUFOO0FBQW9DOztBQUMxRCxhQUFPLEtBQUswRyxLQUFMLENBQVcsQ0FBWCxDQUFQO0FBQ0E7QUFsQkY7QUFBQTtBQUFBLDhCQW1CdUI7QUFDckIsYUFBTyxLQUFLQSxLQUFaO0FBQ0E7QUFyQkY7O0FBQUE7QUFBQSxJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBRU8sSUFBTS9LLGNBQWI7QUFBQTtBQUFBO0FBQUEsNENBQ3VDa0QsSUFEdkMsRUFDK0Q7QUFDN0QsVUFBTUMsTUFBZ0IsR0FBR0QsSUFBSSxDQUFDRSxLQUFMLENBQVcscUNBQVgsQ0FBekI7QUFDQSxVQUFJekIsQ0FBUyxHQUFHLENBQWhCO0FBQ0EsVUFBTTBCLFdBQTBCLEdBQUcsSUFBSUMsNENBQUosRUFBbkM7QUFDQSxVQUFNQyxhQUE0QixHQUFHLElBQUlDLDRDQUFKLEVBQXJDOztBQUNBLGFBQU83QixDQUFDLEdBQUd3QixNQUFNLENBQUNNLE1BQWxCLEVBQTBCO0FBQ3pCLFlBQUksS0FBS0MsUUFBTCxDQUFjUCxNQUFNLENBQUN4QixDQUFELENBQXBCLENBQUosRUFBOEI7QUFDN0IwQixxQkFBVyxDQUFDTSxPQUFaLENBQW9CUixNQUFNLENBQUN4QixDQUFELENBQTFCO0FBQ0EsU0FGRCxNQUVPLElBQUksS0FBS2lDLFVBQUwsQ0FBZ0JULE1BQU0sQ0FBQ3hCLENBQUQsQ0FBdEIsQ0FBSixFQUFnQztBQUN0QyxjQUFNa0MsR0FBVyxHQUFHVixNQUFNLENBQUN4QixDQUFELENBQTFCOztBQUNBLGlCQUFPLENBQUM0QixhQUFhLENBQUNPLE9BQWQsRUFBRCxJQUE0QixLQUFLRixVQUFMLENBQWdCTCxhQUFhLENBQUNRLElBQWQsRUFBaEIsQ0FBbkMsRUFBMEU7QUFDekUsZ0JBQUssS0FBS0MseUJBQUwsQ0FBK0JILEdBQS9CLEtBQXdDLEtBQUtJLFVBQUwsQ0FBZ0JKLEdBQWhCLEtBQXdCLEtBQUtJLFVBQUwsQ0FBZ0JWLGFBQWEsQ0FBQ1EsSUFBZCxFQUFoQixDQUFqRSxJQUNGLEtBQUtHLDBCQUFMLENBQWdDTCxHQUFoQyxLQUF5QyxLQUFLSSxVQUFMLENBQWdCSixHQUFoQixJQUF1QixLQUFLSSxVQUFMLENBQWdCVixhQUFhLENBQUNRLElBQWQsRUFBaEIsQ0FEbEUsRUFDMkc7QUFDMUdWLHlCQUFXLENBQUNNLE9BQVosQ0FBb0JKLGFBQWEsQ0FBQ1ksR0FBZCxFQUFwQjtBQUNBLGFBSEQsTUFHTztBQUNOO0FBQ0E7QUFDRDs7QUFDRFosdUJBQWEsQ0FBQ2EsSUFBZCxDQUFtQlAsR0FBbkI7QUFDQSxTQVhNLE1BV0EsSUFBSVYsTUFBTSxDQUFDeEIsQ0FBRCxDQUFOLEtBQWMsR0FBbEIsRUFBdUI7QUFDN0I0Qix1QkFBYSxDQUFDYSxJQUFkLENBQW1CakIsTUFBTSxDQUFDeEIsQ0FBRCxDQUF6QjtBQUNBLFNBRk0sTUFFQSxJQUFJd0IsTUFBTSxDQUFDeEIsQ0FBRCxDQUFOLEtBQWMsR0FBbEIsRUFBdUI7QUFDN0IsaUJBQU8sQ0FBQzRCLGFBQWEsQ0FBQ08sT0FBZCxFQUFELElBQTRCUCxhQUFhLENBQUNRLElBQWQsT0FBeUIsR0FBNUQsRUFBaUU7QUFDaEVWLHVCQUFXLENBQUNNLE9BQVosQ0FBb0JKLGFBQWEsQ0FBQ1ksR0FBZCxFQUFwQjtBQUNBOztBQUNELGNBQUksQ0FBQ1osYUFBYSxDQUFDTyxPQUFkLEVBQUQsSUFBNEJQLGFBQWEsQ0FBQ1EsSUFBZCxPQUF5QixHQUF6RCxFQUE4RDtBQUM3RFIseUJBQWEsQ0FBQ1ksR0FBZDtBQUNBLFdBRkQsTUFFTztBQUNOLGtCQUFNLElBQUlFLEtBQUosQ0FBVSx5QkFBVixDQUFOO0FBQ0E7QUFDRDs7QUFDRDFDLFNBQUM7QUFDRDs7QUFDRCxhQUFPLENBQUM0QixhQUFhLENBQUNPLE9BQWQsRUFBUixFQUFpQztBQUNoQyxZQUFJUCxhQUFhLENBQUNRLElBQWQsT0FBeUIsR0FBN0IsRUFBa0M7QUFDakMsZ0JBQU0sSUFBSU0sS0FBSixDQUFVLHlCQUFWLENBQU47QUFDQSxTQUZELE1BRU87QUFDTmhCLHFCQUFXLENBQUNNLE9BQVosQ0FBb0JKLGFBQWEsQ0FBQ1ksR0FBZCxFQUFwQjtBQUNBO0FBQ0Q7O0FBQ0QsYUFBT2QsV0FBVyxDQUFDaUIsT0FBWixFQUFQO0FBQ0E7QUExQ0Y7QUFBQTtBQUFBLCtCQTJDMEJwQixJQTNDMUIsRUEyQ3dEO0FBQ3RELFVBQU1nSSxDQUFTLEdBQUcsSUFBSXBGLDJEQUFKLEVBQWxCO0FBQ0EsYUFBT29GLENBQUMsQ0FBQ0MsS0FBRixDQUFRakksSUFBUixDQUFQO0FBQ0E7QUE5Q0Y7QUFBQTtBQUFBLDBDQStDcUNrSSxDQS9DckMsRUErQ2dEQyxDQS9DaEQsRUErQ21FO0FBQ2pFLGFBQU9BLENBQUMsR0FBR3JMLGNBQWMsQ0FBQ3NMLHFCQUFmLENBQXFDRCxDQUFyQyxFQUF3Q0QsQ0FBQyxHQUFHQyxDQUE1QyxDQUFILEdBQW9ERCxDQUE1RDtBQUNBO0FBakRGO0FBQUE7QUFBQSx3Q0FrRG1DQSxDQWxEbkMsRUFrRDhDQyxDQWxEOUMsRUFrRGlFO0FBQy9ELGFBQU8zRCxJQUFJLENBQUM2RCxHQUFMLENBQVNILENBQUMsR0FBR0MsQ0FBSixHQUFRckwsY0FBYyxDQUFDc0wscUJBQWYsQ0FBcUNGLENBQXJDLEVBQXdDQyxDQUF4QyxDQUFqQixDQUFQO0FBQ0E7QUFwREY7QUFBQTtBQUFBLDZCQXFEeUJuSSxJQXJEekIsRUFxRGdEO0FBQzlDLGFBQU8sTUFBTXdCLElBQU4sQ0FBV3hCLElBQVgsQ0FBUDtBQUNBO0FBdkRGO0FBQUE7QUFBQSwrQkF3RDJCQSxJQXhEM0IsRUF3RGtEO0FBQ2hELGFBQU8sZUFBZXdCLElBQWYsQ0FBb0J4QixJQUFwQixDQUFQO0FBQ0E7QUExREY7QUFBQTtBQUFBLDhDQTJEMEN5QixRQTNEMUMsRUEyRHFFO0FBQ25FLGFBQU8sYUFBYUQsSUFBYixDQUFrQkMsUUFBbEIsQ0FBUDtBQUNBO0FBN0RGO0FBQUE7QUFBQSwrQ0E4RDJDQSxRQTlEM0MsRUE4RHNFO0FBQ3BFLGFBQU8sT0FBT0QsSUFBUCxDQUFZQyxRQUFaLENBQVA7QUFDQTtBQWhFRjtBQUFBO0FBQUEsK0JBaUUyQkEsUUFqRTNCLEVBaUVxRDtBQUNuRCxVQUFJLFNBQVNELElBQVQsQ0FBY0MsUUFBZCxDQUFKLEVBQTZCO0FBQzVCLGVBQU8sQ0FBUDtBQUNBOztBQUNELFVBQUksU0FBU0QsSUFBVCxDQUFjQyxRQUFkLENBQUosRUFBNkI7QUFDNUIsZUFBTyxDQUFQO0FBQ0E7O0FBQ0QsVUFBSSxPQUFPRCxJQUFQLENBQVlDLFFBQVosQ0FBSixFQUEyQjtBQUMxQixlQUFPLENBQVA7QUFDQTs7QUFDRCxZQUFNLElBQUlOLEtBQUosQ0FBVSxtQkFBVixDQUFOO0FBQ0E7QUE1RUY7QUFBQTtBQUFBLG9DQTZFZ0NsQixNQTdFaEMsRUE2RWtFO0FBQ2hFLFVBQU1vQixLQUE0QixHQUFHLElBQUlmLDRDQUFKLEVBQXJDOztBQUNBLFdBQUssSUFBSTdCLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHd0IsTUFBTSxDQUFDTSxNQUFuQyxFQUEyQzlCLENBQUMsRUFBNUMsRUFBZ0Q7QUFDL0MsWUFBSSxDQUFDLEtBQUtpQyxVQUFMLENBQWdCVCxNQUFNLENBQUN4QixDQUFELENBQXRCLENBQUwsRUFBaUM7QUFDaEM0QyxlQUFLLENBQUNILElBQU4sQ0FBVyxJQUFJcEUsY0FBSixDQUFtQndFLFVBQVUsQ0FBQ3JCLE1BQU0sQ0FBQ3hCLENBQUQsQ0FBUCxDQUE3QixDQUFYO0FBQ0EsU0FGRCxNQUVPO0FBQ04sY0FBTWtDLEdBQW1CLEdBQUdVLEtBQUssQ0FBQ0osR0FBTixFQUE1QjtBQUNBLGNBQU1NLEdBQW1CLEdBQUdGLEtBQUssQ0FBQ0osR0FBTixFQUE1Qjs7QUFDQSxrQkFBUWhCLE1BQU0sQ0FBQ3hCLENBQUQsQ0FBZDtBQUNDLGlCQUFLLEdBQUw7QUFBVTRDLG1CQUFLLENBQUNILElBQU4sQ0FBV0ssR0FBRyxDQUFDK0IsR0FBSixDQUFRM0MsR0FBUixDQUFYO0FBQ1Q7O0FBQ0QsaUJBQUssR0FBTDtBQUFVVSxtQkFBSyxDQUFDSCxJQUFOLENBQVdLLEdBQUcsQ0FBQ2dDLEdBQUosQ0FBUTVDLEdBQVIsQ0FBWDtBQUNUOztBQUNELGlCQUFLLEdBQUw7QUFBVVUsbUJBQUssQ0FBQ0gsSUFBTixDQUFXSyxHQUFHLENBQUNxQyxJQUFKLENBQVNqRCxHQUFULENBQVg7QUFDVDs7QUFDRCxpQkFBSyxHQUFMO0FBQVVVLG1CQUFLLENBQUNILElBQU4sQ0FBV0ssR0FBRyxDQUFDc0MsR0FBSixDQUFRbEQsR0FBUixDQUFYO0FBQ1Q7O0FBQ0QsaUJBQUssR0FBTDtBQUFVVSxtQkFBSyxDQUFDSCxJQUFOLENBQVdLLEdBQUcsQ0FBQ3dDLEdBQUosQ0FBUXBELEdBQUcsQ0FBQ3RELFFBQUosRUFBUixDQUFYO0FBQ1Q7QUFWRjtBQVlBO0FBQ0Q7O0FBQ0QsYUFBT2dFLEtBQUssQ0FBQ0osR0FBTixHQUFZdUUsY0FBWixFQUFQO0FBQ0E7QUFwR0Y7O0FBdUdDLDBCQUFZckksQ0FBWixFQUFzQztBQUFBLFFBQWZtTCxDQUFlLHVFQUFILENBQUc7O0FBQUE7O0FBQUE7O0FBQUE7O0FBQ3JDLFFBQUlBLENBQUMsS0FBSyxDQUFWLEVBQWE7QUFDWixZQUFNLElBQUluSCxLQUFKLENBQVUsbUJBQVYsQ0FBTjtBQUNBLEtBSG9DLENBSXJDOzs7QUFDQSxRQUFNb0gsSUFBWSxHQUFHcEwsQ0FBQyxHQUFHbUwsQ0FBSixJQUFTLENBQVQsR0FBYSxDQUFiLEdBQWlCLENBQUMsQ0FBdkM7QUFDQSxTQUFLRSxTQUFMLEdBQWlCRCxJQUFJLEdBQUcvRCxJQUFJLENBQUM2RCxHQUFMLENBQVNsTCxDQUFULENBQXhCO0FBQ0EsU0FBS3NMLFdBQUwsR0FBbUJqRSxJQUFJLENBQUM2RCxHQUFMLENBQVNDLENBQVQsQ0FBbkI7QUFDQTs7QUEvR0Y7QUFBQTtBQUFBLHFDQWdIeUM7QUFDdkMsVUFBTUksR0FBVyxHQUFHNUwsY0FBYyxDQUFDc0wscUJBQWYsQ0FBcUMsS0FBS0ksU0FBMUMsRUFBcUQsS0FBS0MsV0FBMUQsQ0FBcEI7QUFDQSxhQUFPLElBQUkzTCxjQUFKLENBQW1CLEtBQUswTCxTQUFMLEdBQWlCRSxHQUFwQyxFQUF5QyxLQUFLRCxXQUFMLEdBQW1CQyxHQUE1RCxDQUFQO0FBQ0E7QUFuSEY7QUFBQTtBQUFBLDJCQXFIZS9MLENBckhmLEVBcUhvRDtBQUNsRCxVQUFNZ00sR0FBbUIsR0FBRyxLQUFLbkQsY0FBTCxFQUE1Qjs7QUFDQSxVQUFJLE9BQU83SSxDQUFQLEtBQWEsUUFBakIsRUFBMkI7QUFDMUIsZUFBT2dNLEdBQUcsQ0FBQ0gsU0FBSixLQUFrQjdMLENBQWxCLElBQXVCZ00sR0FBRyxDQUFDRixXQUFKLEtBQW9CLENBQWxEO0FBQ0EsT0FGRCxNQUVPO0FBQ04sWUFBTUcsR0FBbUIsR0FBR2pNLENBQUMsQ0FBQzZJLGNBQUYsRUFBNUI7QUFDQSxlQUFPbUQsR0FBRyxDQUFDSCxTQUFKLEtBQWtCSSxHQUFHLENBQUNKLFNBQXRCLElBQW1DRyxHQUFHLENBQUNGLFdBQUosS0FBb0JHLEdBQUcsQ0FBQ0gsV0FBbEU7QUFDQTtBQUNEO0FBN0hGO0FBQUE7QUFBQSx1QkE4SFc5TCxDQTlIWCxFQThIZ0Q7QUFDOUMsVUFBTWdNLEdBQW1CLEdBQUcsS0FBS25ELGNBQUwsRUFBNUI7O0FBQ0EsVUFBSSxPQUFPN0ksQ0FBUCxLQUFhLFFBQWpCLEVBQTJCO0FBQzFCLGVBQU9nTSxHQUFHLENBQUNILFNBQUosR0FBZ0I3TCxDQUFDLEdBQUdnTSxHQUFHLENBQUNGLFdBQS9CO0FBQ0EsT0FGRCxNQUVPO0FBQ04sWUFBTUcsR0FBbUIsR0FBR2pNLENBQUMsQ0FBQzZJLGNBQUYsRUFBNUI7QUFDQSxlQUFPbUQsR0FBRyxDQUFDSCxTQUFKLEdBQWdCSSxHQUFHLENBQUNILFdBQXBCLEdBQWtDRyxHQUFHLENBQUNKLFNBQUosR0FBZ0JHLEdBQUcsQ0FBQ0YsV0FBN0Q7QUFDQTtBQUNEO0FBdElGO0FBQUE7QUFBQSx1QkF1SVc5TCxDQXZJWCxFQXVJZ0Q7QUFDOUMsVUFBTWdNLEdBQW1CLEdBQUcsS0FBS25ELGNBQUwsRUFBNUI7O0FBQ0EsVUFBSSxPQUFPN0ksQ0FBUCxLQUFhLFFBQWpCLEVBQTJCO0FBQzFCLGVBQU9nTSxHQUFHLENBQUNILFNBQUosSUFBaUI3TCxDQUFDLEdBQUdnTSxHQUFHLENBQUNGLFdBQWhDO0FBQ0EsT0FGRCxNQUVPO0FBQ04sWUFBTUcsR0FBbUIsR0FBR2pNLENBQUMsQ0FBQzZJLGNBQUYsRUFBNUI7QUFDQSxlQUFPbUQsR0FBRyxDQUFDSCxTQUFKLEdBQWdCSSxHQUFHLENBQUNILFdBQXBCLElBQW1DRyxHQUFHLENBQUNKLFNBQUosR0FBZ0JHLEdBQUcsQ0FBQ0YsV0FBOUQ7QUFDQTtBQUNEO0FBL0lGO0FBQUE7QUFBQSx1QkFnSlc5TCxDQWhKWCxFQWdKZ0Q7QUFDOUMsVUFBTWdNLEdBQW1CLEdBQUcsS0FBS25ELGNBQUwsRUFBNUI7O0FBQ0EsVUFBSSxPQUFPN0ksQ0FBUCxLQUFhLFFBQWpCLEVBQTJCO0FBQzFCLGVBQU9nTSxHQUFHLENBQUNILFNBQUosR0FBZ0I3TCxDQUFDLEdBQUdnTSxHQUFHLENBQUNGLFdBQS9CO0FBQ0EsT0FGRCxNQUVPO0FBQ04sWUFBTUcsR0FBbUIsR0FBR2pNLENBQUMsQ0FBQzZJLGNBQUYsRUFBNUI7QUFDQSxlQUFPbUQsR0FBRyxDQUFDSCxTQUFKLEdBQWdCSSxHQUFHLENBQUNILFdBQXBCLEdBQWtDRyxHQUFHLENBQUNKLFNBQUosR0FBZ0JHLEdBQUcsQ0FBQ0YsV0FBN0Q7QUFDQTtBQUNEO0FBeEpGO0FBQUE7QUFBQSx1QkF5Slc5TCxDQXpKWCxFQXlKZ0Q7QUFDOUMsVUFBTWdNLEdBQW1CLEdBQUcsS0FBS25ELGNBQUwsRUFBNUI7O0FBQ0EsVUFBSSxPQUFPN0ksQ0FBUCxLQUFhLFFBQWpCLEVBQTJCO0FBQzFCLGVBQU9nTSxHQUFHLENBQUNILFNBQUosSUFBaUI3TCxDQUFDLEdBQUdnTSxHQUFHLENBQUNGLFdBQWhDO0FBQ0EsT0FGRCxNQUVPO0FBQ04sWUFBTUcsR0FBbUIsR0FBR2pNLENBQUMsQ0FBQzZJLGNBQUYsRUFBNUI7QUFDQSxlQUFPbUQsR0FBRyxDQUFDSCxTQUFKLEdBQWdCSSxHQUFHLENBQUNILFdBQXBCLElBQW1DRyxHQUFHLENBQUNKLFNBQUosR0FBZ0JHLEdBQUcsQ0FBQ0YsV0FBOUQ7QUFDQTtBQUNELEtBaktGLENBbUtDOztBQW5LRDtBQUFBO0FBQUEsaUNBb0txQztBQUNuQyxVQUFJLEtBQUtBLFdBQUwsS0FBcUIsQ0FBekIsRUFBNEI7QUFBRSxjQUFNLElBQUl0SCxLQUFKLENBQVUsbUJBQVYsQ0FBTjtBQUF1Qzs7QUFDckUsYUFBTyxJQUFJckUsY0FBSixDQUFtQixLQUFLMkwsV0FBeEIsRUFBcUMsS0FBS0QsU0FBMUMsQ0FBUDtBQUNBLEtBdktGLENBd0tDOztBQXhLRDtBQUFBO0FBQUEsK0JBeUttQztBQUNqQyxhQUFPLElBQUkxTCxjQUFKLENBQW1CLEtBQUswTCxTQUFMLEdBQWtCLENBQUMsQ0FBdEMsRUFBMEMsS0FBS0MsV0FBL0MsQ0FBUDtBQUNBO0FBM0tGO0FBQUE7QUFBQSx3QkE0S1k5TCxDQTVLWixFQTRLd0Q7QUFDdEQsVUFBSSxPQUFPQSxDQUFQLEtBQWEsUUFBakIsRUFBMkI7QUFDMUIsZUFBTyxJQUFJRyxjQUFKLENBQW9CLEtBQUswTCxTQUFMLEdBQWlCN0wsQ0FBQyxHQUFHLEtBQUs4TCxXQUE5QyxFQUE0RCxLQUFLQSxXQUFqRSxDQUFQO0FBQ0EsT0FGRCxNQUVPO0FBQ04sWUFBTUksR0FBVyxHQUFHL0wsY0FBYyxDQUFDZ00sbUJBQWYsQ0FBbUMsS0FBS0wsV0FBeEMsRUFBcUQ5TCxDQUFDLENBQUM4TCxXQUF2RCxDQUFwQjtBQUNBLFlBQU1NLEVBQVUsR0FBRyxLQUFLUCxTQUFMLEdBQWlCSyxHQUFqQixHQUF1QixLQUFLSixXQUEvQztBQUNBLFlBQU1PLEVBQVUsR0FBR3JNLENBQUMsQ0FBQzZMLFNBQUYsR0FBY0ssR0FBZCxHQUFvQmxNLENBQUMsQ0FBQzhMLFdBQXpDO0FBQ0EsZUFBTyxJQUFJM0wsY0FBSixDQUFtQmlNLEVBQUUsR0FBR0MsRUFBeEIsRUFBNEJILEdBQTVCLENBQVA7QUFDQTtBQUNEO0FBckxGO0FBQUE7QUFBQSx3QkFzTFlsTSxDQXRMWixFQXNMd0Q7QUFDdEQsVUFBSSxPQUFPQSxDQUFQLEtBQWEsUUFBakIsRUFBMkI7QUFDMUIsZUFBTyxJQUFJRyxjQUFKLENBQW9CLEtBQUswTCxTQUFMLEdBQWlCN0wsQ0FBQyxHQUFHLEtBQUs4TCxXQUE5QyxFQUE0RCxLQUFLQSxXQUFqRSxDQUFQO0FBQ0EsT0FGRCxNQUVPO0FBQ04sWUFBTUksR0FBVyxHQUFHL0wsY0FBYyxDQUFDZ00sbUJBQWYsQ0FBbUMsS0FBS0wsV0FBeEMsRUFBcUQ5TCxDQUFDLENBQUM4TCxXQUF2RCxDQUFwQjtBQUNBLFlBQU1NLEVBQVUsR0FBRyxLQUFLUCxTQUFMLEdBQWlCSyxHQUFqQixHQUF1QixLQUFLSixXQUEvQztBQUNBLFlBQU1PLEVBQVUsR0FBR3JNLENBQUMsQ0FBQzZMLFNBQUYsR0FBY0ssR0FBZCxHQUFvQmxNLENBQUMsQ0FBQzhMLFdBQXpDO0FBQ0EsZUFBTyxJQUFJM0wsY0FBSixDQUFtQmlNLEVBQUUsR0FBR0MsRUFBeEIsRUFBNEJILEdBQTVCLENBQVA7QUFDQTtBQUNEO0FBL0xGO0FBQUE7QUFBQSx5QkFnTWFsTSxDQWhNYixFQWdNeUQ7QUFDdkQsVUFBSSxPQUFPQSxDQUFQLEtBQWEsUUFBakIsRUFBMkI7QUFDMUIsZUFBTyxJQUFJRyxjQUFKLENBQW9CLEtBQUswTCxTQUFMLEdBQWlCN0wsQ0FBckMsRUFBeUMsS0FBSzhMLFdBQTlDLENBQVA7QUFDQSxPQUZELE1BRU87QUFDTixlQUFPLElBQUkzTCxjQUFKLENBQW9CLEtBQUswTCxTQUFMLEdBQWlCN0wsQ0FBQyxDQUFDNkwsU0FBdkMsRUFBbUQ3TCxDQUFDLENBQUM4TCxXQUFGLEdBQWdCLEtBQUtBLFdBQXhFLENBQVA7QUFDQTtBQUNEO0FBdE1GO0FBQUE7QUFBQSx3QkF1TVk5TCxDQXZNWixFQXVNd0Q7QUFDdEQsVUFBSSxPQUFPQSxDQUFQLEtBQWEsUUFBakIsRUFBMkI7QUFDMUIsZUFBTyxJQUFJRyxjQUFKLENBQW9CLEtBQUswTCxTQUF6QixFQUFxQyxLQUFLQyxXQUFMLEdBQW1COUwsQ0FBeEQsQ0FBUDtBQUNBLE9BRkQsTUFFTztBQUNOLGVBQU8sSUFBSUcsY0FBSixDQUFvQixLQUFLMEwsU0FBTCxHQUFpQjdMLENBQUMsQ0FBQzhMLFdBQXZDLEVBQXFEOUwsQ0FBQyxDQUFDNkwsU0FBRixHQUFjLEtBQUtDLFdBQXhFLENBQVA7QUFDQTtBQUNEO0FBN01GO0FBQUE7QUFBQSx3QkE4TVk5TCxDQTlNWixFQThNd0Q7QUFDdEQsVUFBSSxPQUFPQSxDQUFQLEtBQWEsUUFBakIsRUFBMkI7QUFDMUIsZUFBTyxJQUFJRyxjQUFKLFVBQW1CLEtBQUswTCxTQUF4QixFQUFxQzdMLENBQXJDLFlBQXdDLEtBQUs4TCxXQUE3QyxFQUE0RDlMLENBQTVELEVBQVA7QUFDQSxPQUZELE1BRU87QUFDTixZQUFJLEtBQUs4TCxXQUFMLEtBQXFCLENBQXpCLEVBQTRCO0FBQUUsZ0JBQU10SCxLQUFLLENBQUMsb0RBQUQsQ0FBWDtBQUFvRTs7QUFDbEcsZUFBTyxJQUFJckUsY0FBSixVQUFtQixLQUFLMEwsU0FBeEIsRUFBcUM3TCxDQUFDLENBQUM2TCxTQUF2QyxZQUFrRCxLQUFLQyxXQUF2RCxFQUFzRTlMLENBQUMsQ0FBQzZMLFNBQXhFLEVBQVA7QUFDQTtBQUNEO0FBck5GO0FBQUE7QUFBQSwrQkFzTjJCO0FBQ3pCLGFBQU8sS0FBS0EsU0FBTCxHQUFpQixLQUFLQyxXQUE3QjtBQUNBO0FBeE5GO0FBQUE7QUFBQSwrQkF5TjJCO0FBQ3pCLGFBQU8sS0FBS0QsU0FBTCxDQUFlUyxRQUFmLE1BQTZCLE1BQU0sS0FBS1IsV0FBWCxHQUF5QixFQUF6QixHQUE4QixNQUFNLEtBQUtBLFdBQUwsQ0FBaUJRLFFBQWpCLEVBQWpFLENBQVA7QUFDQTtBQTNORjtBQUFBO0FBQUEsK0JBNE5tQztBQUNqQyxhQUFPLElBQUluTSxjQUFKLENBQW1CLEtBQUswTCxTQUF4QixFQUFtQyxLQUFLQyxXQUF4QyxDQUFQO0FBQ0E7QUE5TkY7O0FBQUE7QUFBQSxJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSk8sSUFBTW5JLEtBQWI7QUFFQyxtQkFBYztBQUFBOztBQUFBOztBQUNiLFNBQUtlLEtBQUwsR0FBYSxFQUFiO0FBQ0E7O0FBSkY7QUFBQTtBQUFBLDhCQUsyQjtBQUN6QixhQUFPLEtBQUtBLEtBQUwsQ0FBV2QsTUFBWCxLQUFzQixDQUE3QjtBQUNBO0FBUEY7QUFBQTtBQUFBLHlCQVFhdUgsT0FSYixFQVErQjtBQUM3QixXQUFLekcsS0FBTCxDQUFXSCxJQUFYLENBQWdCNEcsT0FBaEI7QUFDQTtBQVZGO0FBQUE7QUFBQSwwQkFXaUI7QUFDZixVQUFJLEtBQUtsSCxPQUFMLEVBQUosRUFBb0I7QUFBRSxjQUFNLElBQUlPLEtBQUosQ0FBVSxnQkFBVixDQUFOO0FBQW9DOztBQUMxRCxhQUFPLEtBQUtFLEtBQUwsQ0FBV0osR0FBWCxFQUFQO0FBQ0E7QUFkRjtBQUFBO0FBQUEsMkJBZWtCO0FBQ2hCLFVBQUksS0FBS0wsT0FBTCxFQUFKLEVBQW9CO0FBQUUsY0FBTSxJQUFJTyxLQUFKLENBQVUsZ0JBQVYsQ0FBTjtBQUFvQzs7QUFDMUQsYUFBTyxLQUFLRSxLQUFMLENBQVcsS0FBS0EsS0FBTCxDQUFXZCxNQUFYLEdBQW9CLENBQS9CLENBQVA7QUFDQTtBQWxCRjtBQUFBO0FBQUEsOEJBbUJ1QjtBQUNyQixhQUFPLEtBQUtjLEtBQVo7QUFDQTtBQXJCRjs7QUFBQTtBQUFBLEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFFTyxJQUFNOEMsTUFBYjtBQUFBO0FBQUE7QUFBQSwyQ0FDc0MrRSxPQUR0QyxFQUNrRTtBQUNoRSxVQUFNaE0sQ0FBUyxHQUFHZ00sT0FBTyxDQUFDM0ksTUFBMUI7O0FBQ0EsVUFBSSxNQUFNckQsQ0FBVixFQUFhO0FBQUUsZUFBTyxJQUFQO0FBQWM7O0FBQzdCLFVBQU1DLENBQVMsR0FBRytMLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBV2hNLENBQTdCOztBQUNBLFdBQUssSUFBSXVCLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHeUssT0FBTyxDQUFDM0ksTUFBcEMsRUFBNEM5QixDQUFDLEVBQTdDLEVBQWlEO0FBQ2hELFlBQUl0QixDQUFDLEtBQUsrTCxPQUFPLENBQUN6SyxDQUFELENBQVAsQ0FBV3ZCLENBQXJCLEVBQXdCO0FBQUUsZ0JBQU0sSUFBSWlFLEtBQUosQ0FBVSx3QkFBVixDQUFOO0FBQTRDO0FBQ3RFOztBQUNELFVBQUlqRSxDQUFDLEdBQUdDLENBQVIsRUFBVztBQUFFLGVBQU8sS0FBUDtBQUFlOztBQUM1QixZQUFNLElBQUlnRSxLQUFKLENBQVUsa0JBQVYsQ0FBTjtBQUNBO0FBVkY7O0FBY0Msa0JBQVloRSxDQUFaLEVBQW9CO0FBQUE7O0FBQUE7O0FBQUE7O0FBQ25CLFFBQUksT0FBT0EsQ0FBUCxLQUFhLFFBQWpCLEVBQTJCO0FBQzFCLFdBQUtELENBQUwsR0FBU0MsQ0FBVDtBQUNBLFdBQUtOLFFBQUwsR0FBZ0IsRUFBaEI7QUFDQSxLQUhELE1BR08sSUFBSU0sQ0FBQyxZQUFZZ00sS0FBakIsRUFBd0I7QUFDOUIsV0FBS2pNLENBQUwsR0FBU0MsQ0FBQyxDQUFDb0QsTUFBWDtBQUNBLFdBQUsxRCxRQUFMLEdBQWdCLEVBQWhCOztBQUNBLFdBQUssSUFBSTRCLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt2QixDQUFqQyxFQUFvQ3VCLENBQUMsRUFBckMsRUFBeUM7QUFDeEMsYUFBSzVCLFFBQUwsQ0FBYzRCLENBQWQsSUFBbUIsSUFBSTNCLDhEQUFKLENBQW1CSyxDQUFDLENBQUNzQixDQUFELENBQXBCLENBQW5CO0FBQ0E7QUFDRDtBQUNEOztBQXpCRjtBQUFBO0FBQUEsd0JBMEJZOUIsQ0ExQlosRUEwQitCO0FBQzdCLFVBQUksS0FBS08sQ0FBTCxLQUFXUCxDQUFDLENBQUNPLENBQWpCLEVBQW9CO0FBQUUsY0FBTSxJQUFJaUUsS0FBSixDQUFVLHdCQUFWLENBQU47QUFBNEM7O0FBQ2xFLFVBQU00RCxHQUFXLEdBQUcsSUFBSVosTUFBSixDQUFXLEtBQUtqSCxDQUFoQixDQUFwQjs7QUFDQSxXQUFLLElBQUl1QixDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBR3NHLEdBQUcsQ0FBQzdILENBQWhDLEVBQW1DdUIsQ0FBQyxFQUFwQyxFQUF3QztBQUN2Q3NHLFdBQUcsQ0FBQ2xJLFFBQUosQ0FBYTRCLENBQWIsSUFBa0IsS0FBSzVCLFFBQUwsQ0FBYzRCLENBQWQsRUFBaUI2RSxHQUFqQixDQUFxQjNHLENBQUMsQ0FBQ0UsUUFBRixDQUFXNEIsQ0FBWCxDQUFyQixDQUFsQjtBQUNBOztBQUNELGFBQU9zRyxHQUFQO0FBQ0E7QUFqQ0Y7QUFBQTtBQUFBLHdCQWtDWXBJLENBbENaLEVBa0MrQjtBQUM3QixVQUFJLEtBQUtPLENBQUwsS0FBV1AsQ0FBQyxDQUFDTyxDQUFqQixFQUFvQjtBQUFFLGNBQU0sSUFBSWlFLEtBQUosQ0FBVSx3QkFBVixDQUFOO0FBQTRDOztBQUNsRSxVQUFNNEQsR0FBVyxHQUFHLElBQUlaLE1BQUosQ0FBVyxLQUFLakgsQ0FBaEIsQ0FBcEI7O0FBQ0EsV0FBSyxJQUFJdUIsQ0FBUyxHQUFHLENBQXJCLEVBQXdCQSxDQUFDLEdBQUdzRyxHQUFHLENBQUM3SCxDQUFoQyxFQUFtQ3VCLENBQUMsRUFBcEMsRUFBd0M7QUFDdkNzRyxXQUFHLENBQUNsSSxRQUFKLENBQWE0QixDQUFiLElBQWtCLEtBQUs1QixRQUFMLENBQWM0QixDQUFkLEVBQWlCOEUsR0FBakIsQ0FBcUI1RyxDQUFDLENBQUNFLFFBQUYsQ0FBVzRCLENBQVgsQ0FBckIsQ0FBbEI7QUFDQTs7QUFDRCxhQUFPc0csR0FBUDtBQUNBO0FBekNGO0FBQUE7QUFBQSx5QkEwQ2FwSSxDQTFDYixFQTBDd0M7QUFDdEMsVUFBTW9JLEdBQVcsR0FBRyxJQUFJWixNQUFKLENBQVcsS0FBS2pILENBQWhCLENBQXBCOztBQUNBLFdBQUssSUFBSXVCLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHc0csR0FBRyxDQUFDN0gsQ0FBaEMsRUFBbUN1QixDQUFDLEVBQXBDLEVBQXdDO0FBQ3ZDc0csV0FBRyxDQUFDbEksUUFBSixDQUFhNEIsQ0FBYixJQUFrQixLQUFLNUIsUUFBTCxDQUFjNEIsQ0FBZCxFQUFpQm1GLElBQWpCLENBQXNCakgsQ0FBdEIsQ0FBbEI7QUFDQTs7QUFDRCxhQUFPb0ksR0FBUDtBQUNBLEtBaERGLENBaURDOztBQWpERDtBQUFBO0FBQUEsK0JBa0RtQnBJLENBbERuQixFQWtEOEM7QUFDNUMsVUFBSSxLQUFLTyxDQUFMLEtBQVdQLENBQUMsQ0FBQ08sQ0FBakIsRUFBb0I7QUFBRSxjQUFNLElBQUlpRSxLQUFKLENBQVUsd0JBQVYsQ0FBTjtBQUE0Qzs7QUFDbEUsVUFBSTRELEdBQW1CLEdBQUcsSUFBSWpJLDhEQUFKLENBQW1CLENBQW5CLENBQTFCOztBQUNBLFdBQUssSUFBSTJCLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHOUIsQ0FBQyxDQUFDTyxDQUE5QixFQUFpQ3VCLENBQUMsRUFBbEMsRUFBc0M7QUFDckNzRyxXQUFHLEdBQUdBLEdBQUcsQ0FBQ3pCLEdBQUosQ0FBUSxLQUFLekcsUUFBTCxDQUFjNEIsQ0FBZCxFQUFpQm1GLElBQWpCLENBQXNCakgsQ0FBQyxDQUFDRSxRQUFGLENBQVc0QixDQUFYLENBQXRCLENBQVIsQ0FBTjtBQUNBOztBQUNELGFBQU9zRyxHQUFQO0FBQ0EsS0F6REYsQ0EwREM7O0FBMUREO0FBQUE7QUFBQSxpQ0EyRHFCcEksQ0EzRHJCLEVBMkR3QztBQUN0QyxZQUFNLElBQUl3RSxLQUFKLENBQVUsa0JBQVYsQ0FBTjtBQUNBLEtBN0RGLENBOERDOztBQTlERDtBQUFBO0FBQUEsNkJBK0RpQztBQUMvQixVQUFNWixNQUFzQixHQUFHLElBQUl6RCw4REFBSixDQUFtQixDQUFuQixDQUEvQjs7QUFDQSxXQUFLLElBQUkyQixDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLdkIsQ0FBakMsRUFBb0N1QixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDOEIsY0FBTSxDQUFDK0MsR0FBUCxDQUFXLEtBQUt6RyxRQUFMLENBQWM0QixDQUFkLENBQVg7QUFDQTs7QUFDRCxhQUFPOEIsTUFBUDtBQUNBO0FBckVGO0FBQUE7QUFBQSwrQkFzRTJCO0FBQ3pCLFVBQU0yRCxHQUFXLEdBQUcsSUFBSUMsTUFBSixDQUFXLEtBQUtqSCxDQUFoQixDQUFwQjs7QUFDQSxXQUFLLElBQUl1QixDQUFTLEdBQUcsQ0FBckIsRUFBd0JBLENBQUMsR0FBRyxLQUFLdkIsQ0FBakMsRUFBb0N1QixDQUFDLEVBQXJDLEVBQXlDO0FBQ3hDeUYsV0FBRyxDQUFDckgsUUFBSixDQUFhNEIsQ0FBYixJQUFrQixLQUFLNUIsUUFBTCxDQUFjNEIsQ0FBZCxDQUFsQjtBQUNBOztBQUNELGFBQU95RixHQUFQO0FBQ0E7QUE1RUY7QUFBQTtBQUFBLCtCQTZFMkI7QUFDekIsVUFBTUEsR0FBVyxHQUFHLElBQUk5SCw4Q0FBSixDQUFXLEtBQUtjLENBQWhCLEVBQW1CLENBQW5CLENBQXBCOztBQUNBLFdBQUssSUFBSXVCLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt2QixDQUFqQyxFQUFvQ3VCLENBQUMsRUFBckMsRUFBeUM7QUFDeEN5RixXQUFHLENBQUNySCxRQUFKLENBQWE0QixDQUFiLEVBQWdCLENBQWhCLElBQXFCLEtBQUs1QixRQUFMLENBQWM0QixDQUFkLENBQXJCO0FBQ0E7O0FBQ0QsYUFBT3lGLEdBQVA7QUFDQTtBQW5GRjs7QUFBQTtBQUFBO0FBcUZPLElBQU1pQixZQUFiO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUEsRUFBa0NoQixNQUFsQztBQUVPLElBQU1pRixTQUFiO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSxrQ0FDc0JsTSxDQUR0QixFQUM0QztBQUMxQyxVQUFJLEtBQUtBLENBQUwsS0FBV0EsQ0FBQyxDQUFDQyxDQUFqQixFQUFvQjtBQUFFLGNBQU0sSUFBSWdFLEtBQUosQ0FBVSx3QkFBVixDQUFOO0FBQTRDOztBQUNsRSxVQUFNNEQsR0FBYyxHQUFHLElBQUlxRSxTQUFKLENBQWMsS0FBS2xNLENBQW5CLENBQXZCOztBQUNBLFdBQUssSUFBSXVCLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHLEtBQUt2QixDQUFqQyxFQUFvQ3VCLENBQUMsRUFBckMsRUFBeUM7QUFDeEMsWUFBSXVHLEdBQW1CLEdBQUcsSUFBSWxJLDhEQUFKLENBQW1CLENBQW5CLENBQTFCOztBQUNBLGFBQUssSUFBSTRCLENBQVMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHeEIsQ0FBQyxDQUFDQyxDQUE5QixFQUFpQ3VCLENBQUMsRUFBbEMsRUFBc0M7QUFDckNzRyxhQUFHLEdBQUdBLEdBQUcsQ0FBQzFCLEdBQUosQ0FBUXBHLENBQUMsQ0FBQ0wsUUFBRixDQUFXNEIsQ0FBWCxFQUFjQyxDQUFkLEVBQWlCa0YsSUFBakIsQ0FBc0IsS0FBSy9HLFFBQUwsQ0FBYzRCLENBQWQsQ0FBdEIsQ0FBUixDQUFOO0FBQ0E7O0FBQ0RzRyxXQUFHLENBQUNsSSxRQUFKLENBQWE0QixDQUFiLElBQWtCdUcsR0FBbEI7QUFDQTs7QUFDRCxhQUFPRCxHQUFQO0FBQ0E7QUFaRjs7QUFBQTtBQUFBLEVBQStCWixNQUEvQixFIiwiZmlsZSI6Ii4vaW1hZ2VQcm9jZXNzaW5nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvZXhlcmNpc2VzL2ltYWdlUHJvY2Vzc2luZy50c1wiKTtcbiIsIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My41LjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIwLTA1LTA0VDIyOjQ5WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBmbGF0ID0gYXJyLmZsYXQgPyBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuZmxhdC5jYWxsKCBhcnJheSApO1xufSA6IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0cmV0dXJuIGFyci5jb25jYXQuYXBwbHkoIFtdLCBhcnJheSApO1xufTtcblxuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9uY2U6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksIHZhbCxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuXHRcdFx0XHQvLyBPbiB0aGUgb3RoZXIgaGFuZCwganVzdCB1c2luZyBgZ2V0QXR0cmlidXRlYCBpcyBub3QgZW5vdWdoIGFzXG5cdFx0XHRcdC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcblx0XHRcdFx0Ly8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvaHRtbC9pc3N1ZXMvMjM2OVxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuXHRcdFx0XHQvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG5cdFx0XHRcdC8vIGBqUXVlcnkuZ2xvYmFsRXZhbGAgc28gdGhhdCBpdCBjYW4gZmFrZSBhIG5vbmNlLWNvbnRhaW5pbmcgbm9kZVxuXHRcdFx0XHQvLyB2aWEgYW4gb2JqZWN0LlxuXHRcdFx0XHR2YWwgPSBub2RlWyBpIF0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIGkgKTtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSggaSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjUuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXZlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICggaSArIDEgKSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0b2RkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIHByb3ZpZGVkIGNvbnRleHQ7IGZhbGxzIGJhY2sgdG8gdGhlIGdsb2JhbCBvbmVcblx0Ly8gaWYgbm90IHNwZWNpZmllZC5cblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUsIG9wdGlvbnMsIGRvYyApIHtcblx0XHRET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSwgZG9jICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGZsYXQoIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuNVxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pzLmZvdW5kYXRpb24vXG4gKlxuICogRGF0ZTogMjAyMC0wMy0xNFxuICovXG4oIGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRub25uYXRpdmVTZWxlY3RvckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoIHt9ICkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoTmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0WyBpIF0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxcIiArXG5cdFx0XCJpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jaWRlbnQtdG9rZW4tZGlhZ3JhbVxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCI/fFxcXFxcXFxcW15cXFxcclxcXFxuXFxcXGZdfFtcXFxcdy1dfFteXFwwLVxcXFx4N2ZdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblxuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XVxuXHRcdC8vIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblxuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgK1xuXHRcdHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJodG1sID0gL0hUTUwkL2ksXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fFxcXFxcXFxcKFteXFxcXHJcXFxcblxcXFxmXSlcIiwgXCJnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIGVzY2FwZSwgbm9uSGV4ICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlLnNsaWNlKCAxICkgLSAweDEwMDAwO1xuXG5cdFx0cmV0dXJuIG5vbkhleCA/XG5cblx0XHRcdC8vIFN0cmlwIHRoZSBiYWNrc2xhc2ggcHJlZml4IGZyb20gYSBub24taGV4IGVzY2FwZSBzZXF1ZW5jZVxuXHRcdFx0bm9uSGV4IDpcblxuXHRcdFx0Ly8gUmVwbGFjZSBhIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIHRoZSBlbmNvZGVkIFVuaWNvZGUgY29kZSBwb2ludFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMStcblx0XHRcdC8vIEZvciB2YWx1ZXMgb3V0c2lkZSB0aGUgQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lIChCTVApLCBtYW51YWxseSBjb25zdHJ1Y3QgYVxuXHRcdFx0Ly8gc3Vycm9nYXRlIHBhaXJcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgK1xuXHRcdFx0XHRjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KCBhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApICksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hOYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbCggZWxzICkgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICggdGFyZ2V0WyBqKysgXSA9IGVsc1sgaSsrIF0gKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAoIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAoIG0gPSBtYXRjaFsgMSBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKCBlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApICkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMiBdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIG0gPSBtYXRjaFsgMyBdICkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCAhcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSApICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOCBvbmx5XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdCggbm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkgKSB7XG5cblx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cblx0XHRcdFx0Ly8gcVNBIGNvbnNpZGVycyBlbGVtZW50cyBvdXRzaWRlIGEgc2NvcGluZyByb290IHdoZW4gZXZhbHVhdGluZyBjaGlsZCBvclxuXHRcdFx0XHQvLyBkZXNjZW5kYW50IGNvbWJpbmF0b3JzLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LlxuXHRcdFx0XHQvLyBJbiBzdWNoIGNhc2VzLCB3ZSB3b3JrIGFyb3VuZCB0aGUgYmVoYXZpb3IgYnkgcHJlZml4aW5nIGV2ZXJ5IHNlbGVjdG9yIGluIHRoZVxuXHRcdFx0XHQvLyBsaXN0IHdpdGggYW4gSUQgc2VsZWN0b3IgcmVmZXJlbmNpbmcgdGhlIHNjb3BlIGNvbnRleHQuXG5cdFx0XHRcdC8vIFRoZSB0ZWNobmlxdWUgaGFzIHRvIGJlIHVzZWQgYXMgd2VsbCB3aGVuIGEgbGVhZGluZyBjb21iaW5hdG9yIGlzIHVzZWRcblx0XHRcdFx0Ly8gYXMgc3VjaCBzZWxlY3RvcnMgYXJlIG5vdCByZWNvZ25pemVkIGJ5IHF1ZXJ5U2VsZWN0b3JBbGwuXG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHRlY2huaXF1ZS5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggcmRlc2NlbmQudGVzdCggc2VsZWN0b3IgKSB8fCByY29tYmluYXRvcnMudGVzdCggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gV2UgY2FuIHVzZSA6c2NvcGUgaW5zdGVhZCBvZiB0aGUgSUQgaGFjayBpZiB0aGUgYnJvd3NlclxuXHRcdFx0XHRcdC8vIHN1cHBvcnRzIGl0ICYgaWYgd2UncmUgbm90IGNoYW5naW5nIHRoZSBjb250ZXh0LlxuXHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAhPT0gY29udGV4dCB8fCAhc3VwcG9ydC5zY29wZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRcdGlmICggKCBuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkgKSApIHtcblx0XHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsICggbmlkID0gZXhwYW5kbyApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbIGkgXSA9ICggbmlkID8gXCIjXCIgKyBuaWQgOiBcIjpzY29wZVwiICkgKyBcIiBcIiArXG5cdFx0XHRcdFx0XHRcdHRvU2VsZWN0b3IoIGdyb3Vwc1sgaSBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoIGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUgKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmaWVsZHNldFwiICk7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoIFwifFwiICksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbIGkgXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5uZXh0U2libGluZyApICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuICggbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIgKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbICggaiA9IG1hdGNoSW5kZXhlc1sgaSBdICkgXSApIHtcblx0XHRcdFx0XHRzZWVkWyBqIF0gPSAhKCBtYXRjaGVzWyBqIF0gPSBzZWVkWyBqIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5hbWVzcGFjZSA9IGVsZW0ubmFtZXNwYWNlVVJJLFxuXHRcdGRvY0VsZW0gPSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggZG9jID09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggcHJlZmVycmVkRG9jICE9IGRvY3VtZW50ICYmXG5cdFx0KCBzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldyApICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSAxMSssIEVkZ2UgMTIgLSAxOCssIENocm9tZSA8PTE2IC0gMjUgb25seSwgRmlyZWZveCA8PTMuNiAtIDMxIG9ubHksXG5cdC8vIFNhZmFyaSA0IC0gNSBvbmx5LCBPcGVyYSA8PTExLjYgLSAxMi54IG9ubHlcblx0Ly8gSUUvRWRnZSAmIG9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIDpzY29wZSBwc2V1ZG8tY2xhc3MuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjAgb25seVxuXHQvLyBTYWZhcmkgNi4wIHN1cHBvcnRzIDpzY29wZSBidXQgaXQncyBhbiBhbGlhcyBvZiA6cm9vdCB0aGVyZS5cblx0c3VwcG9ydC5zY29wZSA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXHRcdHJldHVybiB0eXBlb2YgZWwucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0IWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOnNjb3BlIGZpZWxkc2V0IGRpdlwiICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKCBcImNsYXNzTmFtZVwiICk7XG5cdH0gKTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudCggXCJcIiApICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCIqXCIgKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbIFwiSURcIiBdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFsgXCJUQUdcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbIFwiQ0xBU1NcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoICggc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSApICkge1xuXG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0XHR2YXIgaW5wdXQ7XG5cblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIlttc2FsbG93Y2FwdHVyZV49JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbc2VsZWN0ZWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwifj1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHRcdC8vIElFIDExL0VkZ2UgZG9uJ3QgZmluZCBlbGVtZW50cyBvbiBhIGBbbmFtZT0nJ11gIHF1ZXJ5IGluIHNvbWUgY2FzZXMuXG5cdFx0XHQvLyBBZGRpbmcgYSB0ZW1wb3JhcnkgYXR0cmlidXRlIHRvIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHNlbGVjdGlvbiB3b3Jrc1xuXHRcdFx0Ly8gYXJvdW5kIHRoZSBpc3N1ZS5cblx0XHRcdC8vIEludGVyZXN0aW5nbHksIElFIDEwICYgb2xkZXIgZG9uJ3Qgc2VlbSB0byBoYXZlIHRoZSBpc3N1ZS5cblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIlwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW25hbWU9JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqbmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKj1cIiArXG5cdFx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmNoZWNrZWRcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmNoZWNrZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLiMuK1srfl1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9My42IC0gNSBvbmx5XG5cdFx0XHQvLyBPbGQgRmlyZWZveCBkb2Vzbid0IHRocm93IG9uIGEgYmFkbHktZXNjYXBlZCBpZGVudGlmaWVyLlxuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbCggXCJcXFxcXFxmXCIgKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIltcXFxcclxcXFxuXFxcXGZdXCIgKTtcblx0XHR9ICk7XG5cblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmVuYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpkaXNhYmxlZFwiICkubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IE9wZXJhIDEwIC0gMTEgb25seVxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiKiw6eFwiICk7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCIsLio6XCIgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoICggbWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yICkgKSApICkge1xuXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oIFwifFwiICkgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbiggXCJ8XCIgKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSApO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoICggYiA9IGIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCggIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSApICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGEgPT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRjb250YWlucyggcHJlZmVycmVkRG9jLCBhICkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYiA9PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGIgKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdHJldHVybiBhID09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5wYXJlbnROb2RlICkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbIGkgXSA9PT0gYnBbIGkgXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFsgaSBdLCBicFsgaSBdICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdGFwWyBpIF0gPT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbIGkgXSA9PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHRzZXREb2N1bWVudCggZWxlbSApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXG5cdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQoIHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApICkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuICggc2VsICsgXCJcIiApLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKCBub2RlID0gZWxlbVsgaSsrIF0gKSApIHtcblxuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWyAzIF0gPSAoIG1hdGNoWyAzIF0gfHwgbWF0Y2hbIDQgXSB8fFxuXHRcdFx0XHRtYXRjaFsgNSBdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAyIF0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbIDMgXSA9IFwiIFwiICsgbWF0Y2hbIDMgXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAxIF0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblxuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbIDQgXSA9ICsoIG1hdGNoWyA0IF0gP1xuXHRcdFx0XHRcdG1hdGNoWyA1IF0gKyAoIG1hdGNoWyA2IF0gfHwgMSApIDpcblx0XHRcdFx0XHQyICogKCBtYXRjaFsgMyBdID09PSBcImV2ZW5cIiB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbIDUgXSA9ICsoICggbWF0Y2hbIDcgXSArIG1hdGNoWyA4IF0gKSB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFsgNiBdICYmIG1hdGNoWyAyIF07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByWyBcIkNISUxEXCIgXS50ZXN0KCBtYXRjaFsgMCBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gbWF0Y2hbIDQgXSB8fCBtYXRjaFsgNSBdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoIGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApICkgJiZcblxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KCBleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGggKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQoIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcdFx0XCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkgKSAmJiBjbGFzc0NhY2hlKFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdChcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHxcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fFxuXHRcdFx0XHRcdFx0XHRcdFwiXCJcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIF9hcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSBub2RlWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8ICggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblxuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaSBdID0gISggbWF0Y2hlc1sgaSBdID0gZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblxuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdCggbGFuZyB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcInhtbDpsYW5nXCIgKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSggXCJsYW5nXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKCBlbGVtID0gZWxlbS5wYXJlbnROb2RlICkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmXG5cdFx0XHRcdCggIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkgKSAmJlxuXHRcdFx0XHQhISggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCApO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkICkgfHxcblx0XHRcdFx0KCBub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQgKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1sgXCJlbXB0eVwiIF0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSApID09IG51bGwgfHxcblx0XHRcdFx0XHRhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0gKSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0gKSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSApLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgP1xuXHRcdFx0XHRhcmd1bWVudCArIGxlbmd0aCA6XG5cdFx0XHRcdGFyZ3VtZW50ID4gbGVuZ3RoID9cblx0XHRcdFx0XHRsZW5ndGggOlxuXHRcdFx0XHRcdGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1sgXCJudGhcIiBdID0gRXhwci5wc2V1ZG9zWyBcImVxXCIgXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKCBtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWyAwIF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKCB0b2tlbnMgPSBbXSApICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoICggbWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbIDAgXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSApO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKCBtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkgKSAmJiAoICFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KCBtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSApICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1sgaSBdLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8ICggZWxlbVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKCBvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSApICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuICggbmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAoIG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzWyBpIF0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbIDAgXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1sgaSBdLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyhcblx0XHRcdFx0c2VsZWN0b3IgfHwgXCIqXCIsXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsXG5cdFx0XHRcdFtdXG5cdFx0XHQpLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICggZWxlbSA9IHRlbXBbIGkgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbIGkgXSBdID0gISggbWF0Y2hlckluWyBwb3N0TWFwWyBpIF0gXSA9IGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblxuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKCBtYXRjaGVySW5bIGkgXSA9IGVsZW0gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAoIG1hdGNoZXJPdXQgPSBbXSApLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSAmJlxuXHRcdFx0XHRcdFx0KCB0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFsgaSBdICkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFsgdGVtcCBdID0gISggcmVzdWx0c1sgdGVtcCBdID0gZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMCBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbIFwiIFwiIF0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdCggY2hlY2tDb250ZXh0ID0gY29udGV4dCApLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBpIF0udHlwZSBdICkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvciggZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIgKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1sgaSBdLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zWyBpIF0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBqIF0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdHRva2Vuc1xuXHRcdFx0XHRcdFx0LnNsaWNlKCAwLCBpIC0gMSApXG5cdFx0XHRcdFx0XHQuY29uY2F0KCB7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSApXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAoIHRva2VucyA9IHRva2Vucy5zbGljZSggaiApICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kWyBcIlRBR1wiIF0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKCBkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSApLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSApICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gc2V0TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblxuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKCB1bm1hdGNoZWRbIGkgXSB8fCBzZXRNYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkWyBpIF0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblxuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFsgaSBdICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKFxuXHRcdFx0c2VsZWN0b3IsXG5cdFx0XHRtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKVxuXHRcdCk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoICggc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvciApICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICggdG9rZW4gPSB0b2tlbnNbIDAgXSApLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDEgXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFsgXCJJRFwiIF0oIHRva2VuLm1hdGNoZXNbIDAgXVxuXHRcdFx0XHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSwgY29udGV4dCApIHx8IFtdIClbIDAgXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbIFwibmVlZHNDb250ZXh0XCIgXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1sgaSBdO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICggdHlwZSA9IHRva2VuLnR5cGUgKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKCBmaW5kID0gRXhwci5maW5kWyB0eXBlIF0gKSApIHtcblxuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoIHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbIDAgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1sgMCBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHRcblx0XHRcdFx0KSApICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KCBcIlwiICkuc29ydCggc29ydE9yZGVyICkuam9pbiggXCJcIiApID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApICkgJiAxO1xufSApO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcImhyZWZcIiApID09PSBcIiNcIjtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgX25hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSApO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT0gbnVsbDtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0KCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSApICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0gKTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSApKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIGVsZW0uY29udGVudERvY3VtZW50ICE9IG51bGwgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErXG5cdFx0XHQvLyA8b2JqZWN0PiBlbGVtZW50cyB3aXRoIG5vIGBkYXRhYCBhdHRyaWJ1dGUgaGFzIGFuIG9iamVjdFxuXHRcdFx0Ly8gYGNvbnRlbnREb2N1bWVudGAgd2l0aCBhIGBudWxsYCBwcm90b3R5cGUuXG5cdFx0XHRnZXRQcm90byggZWxlbS5jb250ZW50RG9jdW1lbnQgKSApIHtcblxuXHRcdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuXHRcdC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuXHRcdC8vIGRvbid0IHN1cHBvcnQgaXQuXG5cdFx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG5cdFx0XHRlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBfaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIF9rZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggX2FsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuXHR2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdFx0fSxcblx0XHRjb21wb3NlZCA9IHsgY29tcG9zZWQ6IHRydWUgfTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBpT1MgMTAuMCAtIDEwLjIgb25seVxuXHQvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcblx0Ly8gU3VwcG9ydDogaU9TIDEwLjAtMTAuMiBvbmx5XG5cdC8vIEVhcmx5IGlPUyAxMCB2ZXJzaW9ucyBzdXBwb3J0IGBhdHRhY2hTaGFkb3dgIGJ1dCBub3QgYGdldFJvb3ROb2RlYCxcblx0Ly8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXG5cdGlmICggZG9jdW1lbnRFbGVtZW50LmdldFJvb3ROb2RlICkge1xuXHRcdGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Um9vdE5vZGUoIGNvbXBvc2VkICkgPT09IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHR9O1xuXHR9XG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0aXNBdHRhY2hlZCggZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBJRSA8PTkgcmVwbGFjZXMgPG9wdGlvbj4gdGFncyB3aXRoIHRoZWlyIGNvbnRlbnRzIHdoZW4gaW5zZXJ0ZWQgb3V0c2lkZSBvZlxuXHQvLyB0aGUgc2VsZWN0IGVsZW1lbnQuXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxvcHRpb24+PC9vcHRpb24+XCI7XG5cdHN1cHBvcnQub3B0aW9uID0gISFkaXYubGFzdENoaWxkO1xufSApKCk7XG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuaWYgKCAhc3VwcG9ydC5vcHRpb24gKSB7XG5cdHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbiA9IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXTtcbn1cblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4vLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91cywgZXhjZXB0IHdoZW4gdGhleSBhcmUgbm8tb3AuXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbi8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuLy8gKGZvY3VzIGFuZCBibHVyIGFyZSBhbHdheXMgc3luY2hyb25vdXMgaW4gb3RoZXIgc3VwcG9ydGVkIGJyb3dzZXJzLFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuZnVuY3Rpb24gZXhwZWN0U3luYyggZWxlbSwgdHlwZSApIHtcblx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFwiZm9jdXNcIiApO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIE9ubHkgYXR0YWNoIGV2ZW50cyB0byBvYmplY3RzIHRoYXQgYWNjZXB0IGRhdGFcblx0XHRpZiAoICFhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApO1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXG5cdFx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKSxcblxuXHRcdFx0aGFuZGxlcnMgPSAoXG5cdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmdldCggc3JjICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRlc3QsIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBmbGF0KCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCAmJiAhbm9kZS5ub01vZHVsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZSggXCJub25jZVwiIClcblx0XHRcdFx0XHRcdFx0XHR9LCBkb2MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgbm9kZSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBpc0F0dGFjaGVkKCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbDtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjayApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmNhbGwoIGVsZW0gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTY0XG5cdFx0Ly8gRG9uJ3QgZ2V0IHRyaWNrZWQgd2hlbiB6b29tIGFmZmVjdHMgb2Zmc2V0V2lkdGggKGdoLTQwMjkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdi5vZmZzZXRXaWR0aCAvIDMgKSA9PT0gMTI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwsIHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fSxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEJlaGF2aW9yIGluIElFIDkgaXMgbW9yZSBzdWJ0bGUgdGhhbiBpbiBuZXdlciB2ZXJzaW9ucyAmIGl0IHBhc3Nlc1xuXHRcdC8vIHNvbWUgdmVyc2lvbnMgb2YgdGhpcyB0ZXN0OyBtYWtlIHN1cmUgbm90IHRvIG1ha2UgaXQgcGFzcyB0aGVyZSFcblx0XHRyZWxpYWJsZVRyRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGFibGUsIHRyLCB0ckNoaWxkLCB0clN0eWxlO1xuXHRcdFx0aWYgKCByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidGFibGVcIiApO1xuXHRcdFx0XHR0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidHJcIiApO1xuXHRcdFx0XHR0ckNoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdFx0XHRcdHRhYmxlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHhcIjtcblx0XHRcdFx0dHIuc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIjtcblx0XHRcdFx0dHJDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjlweFwiO1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudFxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdGFibGUgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHIgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHJDaGlsZCApO1xuXG5cdFx0XHRcdHRyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggdHIgKTtcblx0XHRcdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPSBwYXJzZUludCggdHJTdHlsZS5oZWlnaHQgKSA+IDM7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCB0YWJsZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWlzQXR0YWNoZWQoIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyIGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZSxcblx0dmVuZG9yUHJvcHMgPSB7fTtcblxuLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgZmluYWwgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSB8fCB2ZW5kb3JQcm9wc1sgbmFtZSBdO1xuXG5cdGlmICggZmluYWwgKSB7XG5cdFx0cmV0dXJuIGZpbmFsO1xuXHR9XG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cdHJldHVybiB2ZW5kb3JQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9O1xuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggX2VsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblxuXHRcdC8vIElmIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyB1bmtub3duLCB0aGVuIHdlIGNhbid0IGRldGVybWluZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyXG5cdFx0Ly8gVXNlIGFuIGV4cGxpY2l0IHplcm8gdG8gYXZvaWQgTmFOIChnaC0zOTY0KVxuXHRcdCkgKSB8fCAwO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtNDMyMikuXG5cdFx0Ly8gRmFrZSBjb250ZW50LWJveCB1bnRpbCB3ZSBrbm93IGl0J3MgbmVlZGVkIHRvIGtub3cgdGhlIHRydWUgdmFsdWUuXG5cdFx0Ym94U2l6aW5nTmVlZGVkID0gIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBleHRyYSxcblx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3gsXG5cblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0b2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICk7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBVc2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciB3aGVuIGJveCBzaXppbmcgaXMgdW5yZWxpYWJsZS5cblx0Ly8gSW4gdGhvc2UgY2FzZXMsIHRoZSBjb21wdXRlZCB2YWx1ZSBjYW4gYmUgdHJ1c3RlZCB0byBiZSBib3JkZXItYm94LlxuXHRpZiAoICggIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpc0JvcmRlckJveCB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTAgLSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHQvLyBJRS9FZGdlIG1pc3JlcG9ydCBgZ2V0Q29tcHV0ZWRTdHlsZWAgb2YgdGFibGUgcm93cyB3aXRoIHdpZHRoL2hlaWdodFxuXHRcdC8vIHNldCBpbiBDU1Mgd2hpbGUgYG9mZnNldCpgIHByb3BlcnRpZXMgcmVwb3J0IGNvcnJlY3QgdmFsdWVzLlxuXHRcdC8vIEludGVyZXN0aW5nbHksIGluIHNvbWUgY2FzZXMgSUUgOSBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoaXMgaXNzdWUuXG5cdFx0IXN1cHBvcnQucmVsaWFibGVUckRpbWVuc2lvbnMoKSAmJiBub2RlTmFtZSggZWxlbSwgXCJ0clwiICkgfHxcblxuXHRcdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHRcdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0XHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkgJiZcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlICYgY29ubmVjdGVkXG5cdFx0ZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHRcdC8vIFdoZXJlIGF2YWlsYWJsZSwgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGFwcHJveGltYXRlIGJvcmRlciBib3ggZGltZW5zaW9ucy5cblx0XHQvLyBXaGVyZSBub3QgYXZhaWxhYmxlIChlLmcuLCBTVkcpLCBhc3N1bWUgdW5yZWxpYWJsZSBib3gtc2l6aW5nIGFuZCBpbnRlcnByZXQgdGhlXG5cdFx0Ly8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBvZmZzZXRQcm9wIGluIGVsZW07XG5cdFx0aWYgKCB2YWx1ZUlzQm9yZGVyQm94ICkge1xuXHRcdFx0dmFsID0gZWxlbVsgb2Zmc2V0UHJvcCBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJncmlkQXJlYVwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtbkVuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblN0YXJ0XCI6IHRydWUsXG5cdFx0XCJncmlkUm93XCI6IHRydWUsXG5cdFx0XCJncmlkUm93RW5kXCI6IHRydWUsXG5cdFx0XCJncmlkUm93U3RhcnRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcblx0XHRcdC8vIFwicHhcIiB0byBhIGZldyBoYXJkY29kZWQgdmFsdWVzLlxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIF9pLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKFxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwgT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cdFx0XHRcdClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIEhhbmRsZTogcmVndWxhciBub2RlcyAodmlhIGB0aGlzLm93bmVyRG9jdW1lbnRgKSwgd2luZG93XG5cdFx0XHRcdC8vICh2aWEgYHRoaXMuZG9jdW1lbnRgKSAmIGRvY3VtZW50ICh2aWEgYHRoaXNgKS5cblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IHsgZ3VpZDogRGF0ZS5ub3coKSB9O1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHRpZiAoIGEgPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIF9pLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZS5ndWlkKysgKSArXG5cdFx0XHRcdFx0dW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVzZSBhIG5vb3AgY29udmVydGVyIGZvciBtaXNzaW5nIHNjcmlwdFxuXHRcdFx0aWYgKCAhaXNTdWNjZXNzICYmIGpRdWVyeS5pbkFycmF5KCBcInNjcmlwdFwiLCBzLmRhdGFUeXBlcyApID4gLTEgKSB7XG5cdFx0XHRcdHMuY29udmVydGVyc1sgXCJ0ZXh0IHNjcmlwdFwiIF0gPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBfaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdHZhciBpO1xuXHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRpZiAoIGkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIiApIHtcblx0XHRcdHMuY29udGVudFR5cGUgPSBzLmhlYWRlcnNbIGkgXSB8fCBcIlwiO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMsIGRvYyApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXG5cdFx0Ly8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcblx0XHQvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuXHRcdC8vIG9mIHRoZSBkZWZhdWx0IGNvbnZlcnRlciBpcyBrbHVkZ3kgYnV0IGl0IHdvcmtzLlxuXHRcdGNvbnZlcnRlcnM6IHtcblx0XHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oKSB7fVxuXHRcdH0sXG5cdFx0ZGF0YUZpbHRlcjogZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHJlc3BvbnNlLCBvcHRpb25zLCBkb2MgKTtcblx0XHR9XG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gb3IgZm9yY2VkLWJ5LWF0dHJzIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiB8fCBzLnNjcmlwdEF0dHJzICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiIClcblx0XHRcdFx0XHQuYXR0ciggcy5zY3JpcHRBdHRycyB8fCB7fSApXG5cdFx0XHRcdFx0LnByb3AoIHsgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LCBzcmM6IHMudXJsIH0gKVxuXHRcdFx0XHRcdC5vbiggXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZS5ndWlkKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBwcm9wcy50b3AgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHByb3BzLnRvcCArPSBcInB4XCI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBwcm9wcy5sZWZ0ID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRwcm9wcy5sZWZ0ICs9IFwicHhcIjtcblx0XHRcdH1cblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIF9pLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBfaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH0sXG5cblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXG5cdFx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0XHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0XHR9O1xuXHR9ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG52YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cbmpRdWVyeS50cmltID0gZnVuY3Rpb24oIHRleHQgKSB7XG5cdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFwiXCIgOlxuXHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xufTtcblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4uL3N0cnVjdHVyZXMvTWF0cml4XCI7XHJcbmltcG9ydCB7IFJhdGlvbmFsTnVtYmVyIH0gZnJvbSBcIi4uL3N0cnVjdHVyZXMvUmF0aW9uYWxOdW1iZXJcIjtcclxuXHJcbmZ1bmN0aW9uIGltYWdlRGF0YVRvUkdCQShpbWFnZURhdGE6IEltYWdlRGF0YSk6IFtNYXRyaXgsIE1hdHJpeCwgTWF0cml4LCBNYXRyaXhdIHtcclxuXHRjb25zdCBpbWdSOiBNYXRyaXggPSBuZXcgTWF0cml4KGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XHJcblx0Y29uc3QgaW1nRzogTWF0cml4ID0gbmV3IE1hdHJpeChpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xyXG5cdGNvbnN0IGltZ0I6IE1hdHJpeCA9IG5ldyBNYXRyaXgoaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcclxuXHRjb25zdCBpbWdBOiBNYXRyaXggPSBuZXcgTWF0cml4KGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XHJcblx0bGV0IGlkeDogbnVtYmVyID0gMDtcclxuXHRmb3IgKGxldCB4OiBudW1iZXIgPSAwOyB4IDwgaW1hZ2VEYXRhLndpZHRoOyB4KysgKSB7XHJcblx0XHRpbWdSW3hdID0gW107IGltZ0dbeF0gPSBbXTsgaW1nQlt4XSA9IFtdOyBpbWdBW3hdID0gW107XHJcblx0XHRmb3IgKGxldCB5OiBudW1iZXIgPSAwOyB5IDwgaW1hZ2VEYXRhLmhlaWdodDsgeSsrKSB7XHJcblx0XHRcdGltZ1IuZWxlbWVudHNbeF1beV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoaW1hZ2VEYXRhLmRhdGFbaWR4KytdKTtcclxuXHRcdFx0aW1nRy5lbGVtZW50c1t4XVt5XSA9IG5ldyBSYXRpb25hbE51bWJlcihpbWFnZURhdGEuZGF0YVtpZHgrK10pO1xyXG5cdFx0XHRpbWdCLmVsZW1lbnRzW3hdW3ldID0gbmV3IFJhdGlvbmFsTnVtYmVyKGltYWdlRGF0YS5kYXRhW2lkeCsrXSk7XHJcblx0XHRcdGltZ0EuZWxlbWVudHNbeF1beV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoaW1hZ2VEYXRhLmRhdGFbaWR4KytdKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIFtpbWdSLCBpbWdHLCBpbWdCLCBpbWdBXTtcclxufVxyXG5mdW5jdGlvbiBpbWFnZURhdGFGcm9tUkdCQShyZ2JhOiBbTWF0cml4LCBNYXRyaXgsIE1hdHJpeCwgTWF0cml4XSk6IEltYWdlRGF0YSB7XHJcblx0Y29uc3QgaW1nUjogTWF0cml4ID0gcmdiYVswXTtcclxuXHRjb25zdCBpbWdHOiBNYXRyaXggPSByZ2JhWzFdO1xyXG5cdGNvbnN0IGltZ0I6IE1hdHJpeCA9IHJnYmFbMl07XHJcblx0Y29uc3QgaW1nQTogTWF0cml4ID0gcmdiYVszXTtcclxuXHRjb25zdCB3aWR0aDogbnVtYmVyID0gaW1nUi5tO1xyXG5cdGNvbnN0IGhlaWdodDogbnVtYmVyID0gaW1nUi5uO1xyXG5cdGNvbnN0IGltYWdlRGF0YTogSW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcclxuXHRsZXQgaWR4OiBudW1iZXIgPSAwO1xyXG5cdGZvciAobGV0IHg6IG51bWJlciA9IDA7IHggPCB3aWR0aDsgeCsrICkge1xyXG5cdFx0Zm9yIChsZXQgeTogbnVtYmVyID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcblx0XHRcdGltYWdlRGF0YS5kYXRhW2lkeCsrXSA9IGltZ1IuZWxlbWVudHNbeF1beV0udG9OdW1iZXIoKTtcclxuXHRcdFx0aW1hZ2VEYXRhLmRhdGFbaWR4KytdID0gaW1nRy5lbGVtZW50c1t4XVt5XS50b051bWJlcigpO1xyXG5cdFx0XHRpbWFnZURhdGEuZGF0YVtpZHgrK10gPSBpbWdCLmVsZW1lbnRzW3hdW3ldLnRvTnVtYmVyKCk7XHJcblx0XHRcdGltYWdlRGF0YS5kYXRhW2lkeCsrXSA9IGltZ0EuZWxlbWVudHNbeF1beV0udG9OdW1iZXIoKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGltYWdlRGF0YTtcclxufVxyXG5cclxuJChkb2N1bWVudCkucmVhZHkoKCkgPT4ge1xyXG5cdGNvbnN0IGNhbnZhczE6IEhUTUxDYW52YXNFbGVtZW50ID0gJChcIiNjYW52YXMxXCIpWzBdIGFzIEhUTUxDYW52YXNFbGVtZW50O1xyXG5cdGNvbnN0IGN0eDE6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGNhbnZhczEuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cdGNvbnN0IGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XHJcblx0aW1hZ2Uub25sb2FkID0gKCkgPT4ge1xyXG5cdFx0Y2FudmFzMS5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XHJcblx0XHRjYW52YXMxLndpZHRoID0gaW1hZ2Uud2lkdGg7XHJcblx0XHRjdHgxLmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XHJcblx0XHRjb25zdCBpbWdEYXRhMTogSW1hZ2VEYXRhID0gY3R4MS5nZXRJbWFnZURhdGEoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XHJcblx0XHRjb25zdCByZ2JhID0gaW1hZ2VEYXRhVG9SR0JBKGltZ0RhdGExKTtcclxuXHRcdC8vIGR1cGxpY2F0ZVxyXG5cdFx0Y29uc3QgaW1nRGF0YTI6IEltYWdlRGF0YSA9IGltYWdlRGF0YUZyb21SR0JBKHJnYmEpO1xyXG5cdFx0Y29uc3QgY2FudmFzMjogSFRNTENhbnZhc0VsZW1lbnQgPSAkKFwiI2NhbnZhczJcIilbMF0gYXMgSFRNTENhbnZhc0VsZW1lbnQ7XHJcblx0XHRjb25zdCBjdHgyOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjYW52YXMyLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHRcdGNhbnZhczIuaGVpZ2h0ID0gaW1nRGF0YTIuaGVpZ2h0O1xyXG5cdFx0Y2FudmFzMi53aWR0aCA9IGltZ0RhdGEyLndpZHRoO1xyXG5cdFx0Y3R4Mi5wdXRJbWFnZURhdGEoaW1nRGF0YTIsIDAsIDApO1xyXG5cdFx0Ly8gY29udm9sdXRlXHJcblx0XHRjb25zdCBjYW52YXMzOiBIVE1MQ2FudmFzRWxlbWVudCA9ICQoXCIjY2FudmFzM1wiKVswXSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcclxuXHRcdGNvbnN0IGN0eDM6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGNhbnZhczMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cdFx0Y29uc3Qga2VybmVsOiBNYXRyaXggPSBuZXcgTWF0cml4KDMsIDMpO1xyXG5cdFx0LypcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMF1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMF0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzFdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDUpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzFdWzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMl1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHQqL1xyXG5cdFx0LypcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMF1bMV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzBdWzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoOCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMl1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0Ki9cclxuXHRcdC8qXHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMF1bMF0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMF1bMV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMF1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMF0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMl1bMF0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMl1bMV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMl1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHQvLyovXHJcblx0XHQvLypcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMF1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMF0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMik7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMl1bMF0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMl1bMV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMl1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHQvLyovXHJcblx0XHQvLyBjb25zdCBuZXdSZ2JhOiBbTWF0cml4LCBNYXRyaXgsIE1hdHJpeCwgTWF0cml4XSA9IFtyZ2JhWzBdLmNvbnZvbHV0ZShrZXJuZWwpLCByZ2JhWzFdLmNvbnZvbHV0ZShrZXJuZWwpLCByZ2JhWzJdLmNvbnZvbHV0ZShrZXJuZWwpLCByZ2JhWzNdLmNvbnZvbHV0ZShrZXJuZWwpXTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCByZ2JhWzBdLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgcmdiYVswXS5uOyBqKyspIHtcclxuXHRcdFx0XHRyZ2JhWzBdLmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0XHRcdHJnYmFbMl0uZWxlbWVudHNbaV1bal0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGNvbnN0IG5ld1JnYmE6IFtNYXRyaXgsIE1hdHJpeCwgTWF0cml4LCBNYXRyaXhdID0gW3JnYmFbMF0sIHJnYmFbMV0uY29udm9sdXRlKGtlcm5lbCksIHJnYmFbMl0sIHJnYmFbM11dO1xyXG5cdFx0Y29uc3QgaW1nRGF0YTM6IEltYWdlRGF0YSA9IGltYWdlRGF0YUZyb21SR0JBKG5ld1JnYmEpO1xyXG5cdFx0Y2FudmFzMy5oZWlnaHQgPSBpbWdEYXRhMy5oZWlnaHQ7XHJcblx0XHRjYW52YXMzLndpZHRoID0gaW1nRGF0YTMud2lkdGg7XHJcblx0XHRjdHgzLnB1dEltYWdlRGF0YShpbWdEYXRhMywgMCwgMCk7XHJcblx0fTtcclxuXHRpbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxcIiArIGVuY29kZWRJbWc7XHJcblxyXG5cdC8vIE90aGVyIHdheXMgb2YgZG9pbmcgaXRcclxuXHRjb25zdCBpbWdTcmM6IHN0cmluZyA9ICQoXCIjaW1nU291cmNlXCIpLmF0dHIoXCJzcmNcIikucmVwbGFjZShcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxcIiwgXCJcIik7XHJcblx0Y29uc3QgYmluU3JjOiBzdHJpbmcgPSBhdG9iKGltZ1NyYyk7XHJcblx0Y29uc3QgaW1nID0gVWludDhBcnJheS5mcm9tKGJpblNyYywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSk7XHJcblx0Ly8gcmV2ZXJzZVxyXG5cdGxldCBiaW5EZXN0OiBzdHJpbmcgPSBcIlwiO1xyXG5cdGZvciAoY29uc3QgaSBvZiBpbWcpIHtcclxuXHRcdGJpbkRlc3QgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcclxuXHR9XHJcblx0Ly8gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBpbWcpOyAvLyB0aHJvd3cgXCJNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiXHJcblx0Y29uc3QgaW1nRGVzdCA9IGJ0b2EoYmluRGVzdCk7XHJcblx0JChcIiNpbWdEZXN0aW5hdGlvblwiKS5hdHRyKFwic3JjXCIsIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LFwiICsgaW1nRGVzdCk7XHJcblxyXG59KTtcclxuXHJcbmNvbnN0IGVuY29kZWRJbWc6IHN0cmluZyA9IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVBvQUFBRlFDQUlBQUFBWmZ2UldBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFQK2xTVVJCVkhoZWhQMW5sRzFiZHQrSG5YUDJ5YUhxVks2YjQ4dmQ3NzJPYUFEZFFEY2FxUUUwMEJFRW82VXYvdUp2OXRBSHlhWnNrN1NHTEV1eVBLaEJ5VFlwV1JpTUlpV0JKQWdTQUlsTUFJMXVvRisvMkMvZThHNnNXN2xPblJ6OC8vM25PblhyTlVCNzFUNXJ6elhYWEhQTnRPWmVlNTlRK2YvUGYvYy9GZ3E1ZkQ1ZktHUlVoWHcwOHZtWnorN0xnOVNSNVl6SnFUZjNHSi9MeldqazFEVVRXbjlnWnZtWjZjUW9seE5yRlhwVnozVE9UYW1uRU9vMW0rV25NeHFxcHNMRW9hWXFuY1lhTloycU9SR2xoMGY5dUp3MFR3MVRFUnBoTk54eUFlZVFRajNTd2sxS0FCS01FNnpSeDhJWm5DSlNiaW9KTkphQmxHbm9JZjVTWExveUF4YnpVSjN6dGtWK0lzUVVVK2dQeEV5OGFNSk5HSFZOSjhITklvSlN4UVF3MTVCcFNPMENlNnR5VW9Vd003eG1EUDZ6OTlTVVE0V0NJZ1J5Z2Z4VXNRNHE0T2V3eFpvWE4rZm9PUWFEaUNTcEpnV2d0K09zeXpTNGpUM0lNNHJTQm1TRXRVTVVMSUxGb2tCbXZHb3greDVKWTk0UFFENWh6QStPamFKUVVZMExzQzExd1BuLy91LzhmVWxqS3hHVER0Q3dEcWlBd3BFRkVUQkNOczd3Y3NIRW9paGtDb1FDRG5NemIwL1pGV21pNE9VZVJ0aEpXQWdyNkVSUnVBZk9BV1RSYUZBcDhBd0tGakR2c0xyMG1pTmRqSVJ6ZEVjUmFBSmhIRkR6a3M5bFNUb0trUnVqOUVvbmoxV1pNUG04RjhHa1JNRnRPUTRPaWJzT3IyZHp0V1ZDV3drZ0FnVklzSXRJUWtZeDQ4dzg3b0kwbXNFaXI3aDNneGJGaWlqNlUwbFk0MDlLaExzNjV3RGxoT2FFUGdBVjV2YnNKeVV3S2lkd3JIYXZ3ems5V0owbTlwcGlIS1VVVDE0RWlDeEMwYWpMS0FZQzRrb01RRVBTK1h3aTJHbXBUa29nMDBBT1BPQnhJSDJtbk9Zd3h5T0p4QlB5QStIK1AveDNmMDhuOFZNSFJWZ01SUmN2bDVCdURndXBsQi9XRkRJU3QwcGtHcUFReVE3WGFhYjVsR2ZtekZMWWhiWVdEd0d0U1l5YUN5eUpmY0p5QkFmZ1NYRVB4UktwZ3dvb3dSOG9US3BpMlhtSlFCZXF4eVhDM1RQSkhjeWl4UnNvaGJ0ZDZNaWwxMlBwbW5zUm5wckFrS1Rrei9aS2tpR1BabGJRYUdqU0VjQWQ1TWw1ZzFDbUUzNjBRbUVXVmJJOEY5ZmMxRmZYWkVwVFUwNEh0NHBhMzROUkVWblVwNHRWaTFrcDBhUWdJMDNFRHNTOEh6eDVXaDEwSVNkb0NIVHhsWEFCQjNXY1VHZmVET1VpVlVUUWdYU3RJRkdvQ1BhbGozSmE0RFJjczU0S0VSWFRRRjhvRkdsUHZDeHRXVm43TkFlWS8rSi8vL2NGYVhMaCtWT3hUd3liMkVNQTRoVWtEdmM1eE45TUwxT29FQnVhM2pDaUtkbWtzVEVxcUN6V1hHNm93dHNXMGZqb1VwWXpRS0FKSGNnWWFEaE42VHFWaU5XUTJ4MFJVSmJLMHd1YnBGTkJ2c1FQQitLSnlOOHVZZnJVVUNzWWdLTGlGUEphTDV6dFRzd2lrOGZzanpjenFWTWx1TTBGQmNGUVE1RTNoRGFXM0tRSlhMQ2lqNFNET0NyMXplUGJBS2lUaFJGZEFhcytLVEg1Q1h5Q29TRHZxYWFLV3RJK0NTVkFMOVVNRTlNZ2thVTBKU3RZU0JEd1lNcGdGVWcxblV5VU1pRTdKWml0bDB5aTVnaytTaURWalQ4RXVJWW5OSUZEMzhqaTJzellqOENuUy83di91SS85Q3d4cTRWTlZNd2U4OGFrTm5mTVlxM1RUQWt2MEFCVHBsNXJGMEVzcFlsNVJvalFOSUhYQkJBeEJpTjRHRld3U0p5U0hLZnFBQ253bzBRYjJFWSt3YWdFUVJUUFQ1M2tOS05rWWdjN295YVJ0K2JSU0laelJwa1hOUkpYVmRva3ByWjV5NHNhSis2bloyV00rRDBXeWZ5RmwxUHNlNEVXN01RUmFiNncza25ncWhBbGovMFFYVFFFR05hK2xCTEUzMU5paUlyZ0pNQzhEdUFFVmpHY2tydXhFNkYwS2doREhxZWMwQXNRejdsV2JrSUdwRm5OSTRXVnd4OHJjWEk1RVN5VUZKWEpreW5BMjUrMjN1TVVtU0xFZHltY21TakJNVHpnN3luNXYvOTMvNUVYVE9JdU81MFFha3d3Q0l4aDlib1Y0Y0xPRXJScWwrU0grV1NuUjRzR1p4aGdJM0dhQWpVOE1zMm5zNkc1dmg5UXdJQ2I3azBrSW5XLzJDQmgvS21rUVhORzlGUEN0bmhremh4ZDVWeDd4bG5yOFkyeFhzSkVtbzlSYXRzQU5MaVhUSmFHOFFsM1JwdEV1ejJCNmtraVVTSUFuUDBMb1JGRkF6VmFEVE9CeGl5cElwUUZaRHd2Z05ROXByUW84eEJQZ09tajl3T0ZhZWJsWkY1a01YeFNCekNkSmhPUUJTSUY4RkkxOXBtV09BWjhVdFFFb3lIaEUwWnpEdjAvSUlFbFBLbVJXRFFlQlFkTWhtVzVUcXJOVEpNZytKNGlndUNpaW9GL3Fwd2c4Ly9nNy8xRFRVYm1WM2xNQ1NTYVFsd20vRGlDeTZwTG5DMlRRT1FLY1ZYK1ZNU25FcTJnT2lFT1RpamtpUVB2K252R1JwTTY0SVR3elJ6bitVRGg0VVovNGhEMDZYcGlRV21CRXJFYUJMaGdhUi9SSFA1bHYrNkFKUHp0WjVuVXBKaWJJNjEyZGFvRWU2T3RqRXdRVFJXa2dWeVVjZlZLTWpQT0swV25JR09zUmFNWkt5VGFZVk1LK0hsaHlubi85KzViNXFHZmlycE9SMythY1E2b0NBajRneGdwTEVzSWx0WVJzMFpMTU1pVURkQkZmSVVSUU1NQjRUTzBHa0dJbitLcFd2Tkc4NlFFaG56UGNDSmMzb2d1bGZuZDhHTW1vazROQjdwS2NDQSs1ZUpUczN6UDFDcloxNy8yVlozc0pCbEZkR3FsQjFzQ0dBYktlMTJEK0RLeEVndU1xRTZwQnBDUXFUYkdqZFI4YkRLR21NQzFLZVpEVE9HUjgrSXVuOU9nazRxekpNUkdab0trUnM2SGZFL0J3ZTdCWkdqbG1OWUk0MTNBK1k5QW4wenQwNkFDWStkRFl4U1lreUt1NnZWQXM2TmhHWlVxd0hvYTBUUEVXVk1XOHpqTFBvOFdZempUMGtzRjc2ZEx5ZW1DM3RZWDZIUTc2aE9NeWtremdOTWx6ZVQ2Z3dWSnlLcUlHUVp3bFRxdFRvQXVZaTRpVGFBak1OR3JocXMvemY4RDhnZ1dSVEtjOUhYY28za0V0MCtxRXJIdmhUUUdPRkF1UXFvWlRsSHpoRjRGbURHei9QLzREOGp1SHBybUQvS1RWZnVuaW1ibTJST2dWeTh2VHU1TXE5R1E3dmQ4UlRqaG81V3JPYUlsZWkrcXh6UEg5SE1wS0FKdHhPaGdSb0pwWGtRcHppZjBwd2VxeEtUUW5GeVZqQlNWb3dla21zUWhaNHFZUjlFUXg2M2RUTmhhakJBYlZWVURJdE5qMVlJbDRqR3BZRTFqa1VKK1huU0xRSjF3VnNhRjJ3ZjNqNmZWQ1pjRHVBUXVFbmNpY0JIczVKMHVBb1dNcENVNGNueFFudFNuZ1ZBaEFDUkFMNTFWNlNRRDZDcG5vNXhrZDNxNW9kRmlaZjJSOWowK1J1TXBRTE1CbzVJWEtVMmlSQ2dwZWpJN2lkbUtNOHdGRG41MEdIb0xJOWRGUEFsUWIrVHlQMTAwNUdSR3lYdEtRUXBTNldTQzdPZS85alZQOEFFS0ZTSFRzTy9wSXRvOTNqMW81M2RVb3FBeWl1SFUwREtwbENoQXVXSGdOSjQwa3FBQVZCSk1VTm5ZcDdxK3B5UlI1MFdVSnhnTkNqZ050MlVDREl4cTJTaUFLTHFFTTErRXUwL0t4MVlySVNOUEN3VGc1TkZFaVBpb1NaN3k5b2poSXREWm0zbjNHNGxJNW5ReUxUd01HNkNJdThpaUpKUnQ3dm94TWdEYVJEM21ubTlkNkEwNDJKNE1jU0VaOHFlU09rUnpNanVTSVBCY1locTJoQm9pRmxhWUlCWGtpdE5qcEdIYkNITXdFWXNrcld5bTA2UXhNREE2bVRORkZyUmt3bEdmTUQzRi9JTzYvTHRLRXRNTU9MSmYrTnJYTlZDRE5Wb0htMHdMRit6a0U0bHBBaDJSV0R5TkdpRUtEUWhrVjhIMEliVHV2eUNLdVV6bFVSWTMyblBGUTVUVHhlSkpVQm5EY2VMRkk3VFhtVjlSUXNKVEpacVBBMTBGZ1JtSDJvR3hmcHhqWHRXRUpWa0JqQXR4NklBbVFPTjJUWFFPWms3R2ErdktMUEFPWW8vM1ZaNUY0SGtNNG1vUFl5cGpHVzVoYU04UFdTT1FMaGJiL09mYm1GT1lLQUp0OWc4VVIvRGozZ1JGRGNwRjZTUFF3V3plTlQrOExJMHhzWW9za0t3UStqUFMyczZKNWlVV3VLNm5xcm4rKytxQUpIWU5PRHRDY3lvK01FeG9ySnR2REVDc2kwbVNXVjNKS2hBSjBLRlkxQ2gyK2YvdUV2UlJ6REFCS29LelAwZTR3MVp0M1V3SnFlazRxS0FMV1YxT2dNQlROT0FFTnU4VEdodFBKZEZGd1BrSTJZMk5JMlluTk9nTlBDVmgwbUdCL24rVzAzNDlnUVZFc1RqQitZUU1TaHZJVUFyNWNHckFjd3Bpd0NjTG8ySldZRndqcHlrY0ZjU0YvSUpEd2FmWU1ObmpnZlFsZ0VjRkU5WFJaV0hwQ2cxVUcwT2hQUzhKRTRQbXVrY3Q4N296TFJWUElhVGhoSkNkWTREbENTMVpuVDZmS0M5QU5uR29lNjFERWt6VlNBRnFmbWJEUUFHaHBzaURUaFJwclR1K05RYVlQd2VDU2xMVTlDY3FVQkpHeGNORDJNZklLRW1HZVVtVWlhTmh3SVJYdU90V2xmaVRHQkhaNk1NWkdSUDNHT0dUcDNUTE1nc1ZoL1JQV0wwd2pTTEE5T242RUJ2TE1MSC9UaGZZSkJIL3JLSU9qWXlKSVFyUldlWGZPd1I4ekNPYWZDNHpvWWc0eFN4cWVyaXF4M1drSlFESlBYOGVrUXJpZzNZUDZIZ2lNYzJOU1lTK0tnUXhONnBNQkJpR1k2Y3VHUTJhUkZnQVpJbVd5VlI3TVFxMGFkU0ZzbXpCRVRjRmhhQjQ1bW4vQUFVeXRTajBwbUlDbWpFYktOenI5REhqcVVTeXA1RFJpVHhKdHBCVkJZaUdYN3h2b3o2aW1QQ2Z4N3BCVVVSSXV6SStPclFWMStDOHRvS2FTZnlZRFRrOE9DcXVBNzZ0WjlDZlVZdzMxOGZsUk0wMGwwdHdtemNoMFVSRzBwWXNxaHp1dG9zLzUyUno4T0l2RmZXaEkxNzNVQmhGQ1pLVEtlUW5Xd3JTazJuQ0UvT0pwL0lWckduRjRhTHUrZnNGcDh2Y2pWRmlsZytRSVkxcE5Pc0hpVjFPREp2R0d0QWZNbklDSTVsU1VnZVlnelRDZzZZQlVsdW5rMzZRcG9JRTJBT0llWStZejBnSkVyUFMrUVEwZHhLTkF4eVVSSTBqU0ZYd1RMU2xuZ0NqUE5RZ0s0S3dqUkw5bkV6cUZ4WVFGQVBVMGtSQ3VkL2pxUFJDZ0tBeGxBcnJIZzBmMjRYdWVVT3d3TFFrUEZBTTZJOWVja05pN1FWUFFWWWtwaWtSTUpXblY2SHJoQXp4NWkxNGZhQUVBdkpvbnlxUE1lYWdJaEVFbnZESWZ1R3JYdzJEK09DUExpYU1FVUduR3F4aDEzRVJ0NUMwUW9MRU5jR0FsTWVCaUxucDFjb0toTWE3TCswbVZkVEw0ZWIzd0ZFQ09SLy9aeFhuUHhFb2dURTY0WkxZanF3UEZ0QXU5bVBBdUN4QjRkeTVEM1ZZTjk0aEVoTFlTVUNYaEJDTnRqbTY2WUhNN05IdVYyMVQrNXlpVVMxdlNjTUtzaGRuSndDcm9xYmd5QWpSZ29CQUQyN2dnMUZxQ1F4V05EZ2U1M0xCWEI0UWh3T1BDSkNVRVh0YXN5ZUxseE1hek85ZXBLU0l0QVNJVjVxcVlTU21ZYVJnUkpjUDcrd0VTQUlEVVFKd0hTTHFUQklNQ29rZi9hZ2VzV2d5QS9DS0NtenEvZFBGdXF0cnpoNnF0TVN5UC9mVkw4OFIwZTlwUWNSSkxha1ZtQ2lCaDg2eXBRNzBORmN4Q2RoRlFNd3E0QlF5ZEhJZm5raStlVnptM3ZwM0ZYci8vOUU4bm00T2NlWWhLa0NNRlJDZWpjU3RzLzJtNG5NMEh5TmRJQXdBRzNDV1l5VUxrYUtTWWlHWU00OHBLUUMyc3VZV1BWZlRGS3BZd0NwNWpKQnUra1UzWlE3RUlrN01YWENCWjJGUWtGSGpIV1BvQmVlQlZDNld5cEphdkJCU05TVTJiWTU2SDdhQWpjQTJiMDZuR250aFFMcTB4UkdSZXlneGtnZUxrSnRnWGs3Z2tDWENTRENVSjRwNkdMMkozdWRvRy9aZkttNWp6OEFhTDQ1TW5RYk42d2ozK1hYbE5EV0JDNmd4anZkVXdvQkdhT3VqWVN6Nk1ITlN3eEd2b2xvTE5JWmkrQk5MdTh1djVORTh1MG56blZNQ0JzRWMrR0FSOXVRd016TVhzVTlRdUFTQnFrQjVpU2NqZ0ZmOTJEOHE2R2tYNHJlNWgxUHl0c1BpRUJ2M0MyY2VNV3B1dUpRbXdhT0hoMGc2dXYzV0FYMXdTY2F4dHVodWpHU1hlRG9ZQzFwL0VRcUNyR1BNSXRoblQrT0ptRUtVUWFPTFQ0eWw1VjVEODk0UEZDUlVseXBkc1pGV21sbzN3V0VBQStxYVRwem1CVnZadUF5SU5walFKVWtZUFVidENmdDFrWWlwbFVzVFBTN3pwaVdUVjN3T1RKeFNQM05CR3dkRjNUYnNIQmZrS3NMRjJPZzd3YzlMUHZ2NXIzeFpxdkpuR3BWMFlxeEhFYjRjd0dIazZCQTNKazJoaEZGYzB1bmZYWkxhYzlQYkdjSWczU2wvUU1UbFRPVlBTYTJTbURCOGZtMjJRRVpSZmFBSVk5dERaWms5SWhYZU9xVUVLbm42QkRoRkNFck1HTUhMS1pCWFJMcDVSZzMvRUVKQXF0VWw1V1EvT3RBWnVTMXdvc1RJNks4YWpTQ2VrL0lwbVdoQVNZclJsSm8rUDUrYVRuT08rZUtjYm1yOUViU1kxOFRmV3l4dGl0eG91cWh0bEVzNjJTQkVpL0RjdVVKQ3pwdmJTaStQQjNIQ0tFck1SQVZFcDE5ekdFT2c2WnpVUlNTT2F1UFNXUzltQXZ4ZVphUmdzc0RjclBPb3BaY0IzS3ArNWN2d1VDTXhZUmJ2em9BNDI5RHFrakVzbFRYbUpGdTd4R0M0aWo4WkxJMzJ3Q2pCT1FvKzlZT0JrTW15R1I5N1UrT3QrMXpxUDZ2UW13cnp4Z0NQSm1qQWVzWkVodGxFRk0veTAwQXdEbG5IY01yZnJ0eGhxd3FwWWNFS0JqSElSWnhWbTQvZ0FFMlZqb0NaVDRvSmlrVTVEMlVMWk1xQ2tLZTFFUWpNS2FDNVJmQ2RaZytqS01ibXpTUVFXTkVISlNQaUZpYWVHeVlPSGpGbE96U1gxOC9JcGJUNkhMUVJTNXdmQXlwanZaVGEvZTY5MEVyaEdnVS8wcHpTTjIxUjg3MHZjMkN5S0pyQ0V3V1FKazJLcGFhM1o5akFOQ2dTdEVsRVpKNERqN0dwbkc2NHg2TVRGblBvOERDOUVLeUFRbVpwaVNsV0ZQV0Z3Qmh6QmZDZHgxQWNPdkJ4VjlReEZ5VW1taGYxcXFGRHB0ZmgwYW9vUVlEK29sZHJqaGZ2bE5ybkpmQUJCR1p1dEZUY25RZ0FUeEVZbjBiUkh5UUJ5TDdKKzRwNkhWQ0drOUV4S0xHSnJnQVNEcmRieXRSVWx6a0djOFlhZUZ5c2wwUFRCV042MHRRdEVETW1Qa1pRZE1iWUJpQ3dBZWVqMUk5YkV1a0hCNm9FREdvZW5XYVRJQlhmZW1xOVROSUg0ckEydTNJZ0RYS0JXSFNHQ1JBT3ZHYUVLYTJMRzFSOHFVSWM1bDBueFJTTWpTN3hBUkJmRTU5SWRTTGJ2Smg0amoybDNPTmlIdWJtS1JKMlB0SWxXb21WVEtGRG01a3ZRUlcyRE1nRkw4d0w2OWQ1NkRFTzg2dmdSN1gwZ29FNGtsVTBnN21aeW41SzVIUWJjSFNiSUowL1VBSnBHcVI0M1B5emlGVXNWL1IvTDRFdzdoVkVKVGlKQmtCV0Q0eU00Z0J6ZzhmSzRaY1RJd0lveDZVRzF3Y3hpU05LNU95RWp4UitnZ21oVktkbWtpVlgwQjBMNWdJZGpPaDJ0ak1sVFZOQ0lqeTBFcy9FS1JkWWRsMFVKV0FNWVJyTTdPR3FHYWdSUXNhQ29hVDZWSmxyN2hJeHhONmJ4U0FqSkdBeXRtT1o4eVNqdzlaWndrdklqRFhhMUNmOEhFaVNLZDI1SUliZml6RTJ5UkV3QUtQU1FCQmlIWUFLazd1bG9qazh3ZzBWazgrYlRQRVk5QWt6Z0pwL2JZZUFsaDg1WUd5WlQ0b1pmUkNWK0UzOFZvc1NIbThLcXN6eEZOb0pUS0lGWDVwekRxbUc1SU1sUnVLdkV4NFUyKzV4aWVHbnkvZlFuOHh5R3FDY21wT1c2bE9kOHZFcDJnL0Fib1llRVdFYXE4TStENVU5ditQenBJdmFOK05zTGJ3VTZKcmtKdkV0VDgydlFZdzdMYVNKb3JqRlFNWitJTXNxcWlLK1ZIalB5d21ieUV0Rm9RVWp5bndJRU5uYUdIenVUQ20wNnBTaHpmLzBFTlVXRGhEQkk1OGhpWG81c2NqU01ENXhZSnowRytjdGo4WlkwU0FXSUtuQXd6SVFETkZ5SXBZOHhOUE5TOGpBQko3T2VTZG1PU2xRbVJKRFFleW1hL3dpU0xVS24wN2xQRitGSGlKZUozR3NibjhETjRiUFM3QmtZQlIveHdYeFhjUlVoMVRTOEJCY2h2Uk5leXFNOERCRkI4M1RyRnpVam5Ra3FUZ2M2S0xFY0NtcUNJODBQSVZYc2hIai82eHkwZ1dSMU1YakZFSUNPRmdqSkRTNEFWTDB3cUR5Z1pUQmRzS2VGdUJVVVZPSFlsSWozVGFneWpCYXdKb2NBNUVPMnp4WmpnTk1rRkFTdldSMURaa0R5d2ZtOVJpRzIxa2lDSlhDLzRLOXg1RE13Unkvb0NvbWsxckdRd2tnajQvRkZwaEhLZXh6V0RuTzZNcUJic0lQczRnM1owY2JyMWdrNEdsZ0tkb3NJYXVqSTRPUUN3S3pUeWNGdUVIUFlsT29CQjZkTUFic0VaOFNiTzNiUk84REJhaFoxMTQyMElORE1ZMFNaRU55TnBJbTdQbE1aWXhMbytrTElyT0l3VkxBczduREpTaFBGNkVJRlhYaFh4alliSTk3ZGFUODVPR3VBU0lVb2hBanA1b25oY3o0cDlCQkhDV2hqRXpRdkhndUhSR3A4eEl5aGFDb2h1OUI0RkhIUXhyQ2FxT1haand1L2NDOHA0c0lWT2tvOE4xZDNpVXE4SVExallyWm90Qk1DOGUxTUphRTJXQ1FkTVdjam5VdXVoNXR3WkxuRlFXNk5PdVF4TzZodHVkSk53cWdDQVdHdUhpNGtJRVBqVlFIeGdTT3lEU0xDMEtBRnpjQmhDWk5lbUlVQTFrVmFTSmlXbnNnYjZwWmZtcHpqMnU2eElxeHFVUlR6S01aa1JZRldnWlExRlRYU2U5cE1yVVFYNHNyaEZIWHZITk9oc0R1VFNYNzJzOTlNYlJSQ2U0WTB4TlJlY21SajREREM4YWIyR2NnQ1I1TlNyUWZkNFJsWVdHbkVSTmViRVIrQklvZ1Vjdy90c29zN0Y5MW1qZFZSQUFwcDhkSUZaRHpjbXJjOTVTSWxwREtCWDZXMHJJWmhjbU1FMkRucFJKcjFscEVNSHBPUG10TGsvMjM1T1pzd2FLQWZTd3Nnd3lvamhPUUdSaUQyR21wcUdoNU1HUFFoR3M4dFhDeExKenVBQkVYR05sMDFqZ3hZZ2pEVDJ3aFRveEtaSGFvR3I3Mm9oalp5ZGJ4Tkk4anc1ME9CZ014djl1S0tzUVJLZVJJd2NsVTVIVkI1c21zektSaVFkQUw3VG1CUml5Uld2TkVJamJ6SWN5VnBreTF1MzJFa09oQlV3T0JWY3dEa2lnNmd5Q3FJS1FVNUZpdHNGZ05KMHVIWlFJNXNDdUtOWTJyaWJXY2o0Si9VQ1E1VWxHSU9id2ZjMUJoVGpCenFlYTlCbE1kRmtuT0NwRlZoMmNUN3M4dUp3T2puRWFlbEg5WFE2QU9uT2VackszK3VLZmlPT0ZjNE9zVE9oUk1HZCtmMENwMXJJTlVGekVXSlFpZ09EM2NVQnh6dkxRS2I2Rzhvd283S0N5ZG9jT3BiRFp3cWpENWliSTl2ZmxKdmlCcFJUYkpzNW1KajZ6NVVKZWFzMUV1TnhaemJYYlpydWdnUE5tbE9DVlRQRjNFdnc3ZUc1NHZQS1RpMHFTSlRxU2xRalkrM3UwQTBYQmQwbU1GK0NEMkVqSGVCNllKckFJa2FlaGxOYVREajBBd3RjakVTUFRRaGdjZUI1U1lSdzQ2UVFGYkZ4Z2FnNDR3OFdHeDRKbWkxTnl5cjN6eFo5eHBXYUlJTXV5eml4ODFlQkE1S1lqc0IrUFFHbWxETXgrbmhrTVFPTWNyVkhZNXljdmJTZmVwcVMyQW9IbElVRTVpQlJNWTQwNThBUWVIbHRGd2hwZ0pPQURwZWR6RU5JSWVpMlh4azZlQmRBNjdNQURmZVNCSDR1WFpITmhzVm1nRlppNVRhbEpiVHNnOGkyekh4b1pKVDdaRDFQNWhKN3hMbXZlVlRmcWZUQmRrbkN3R0xZTFlxb2tzVE9rUDNkT3JHRFdTQTJMbURUYWVBZ0poOEtHYW9iVXdmUFpCNHBtWDllYWdCOHNrTnpQSXkwdzJvVGVPQ0xXZzkrYkFKbVF1eDVXMWNCd2pMb2RJZEVabHhSS2RTVG9vTGFwMUJ4QUxsb0hPRmdocG1ReGhRaVQ3aGovaHhNQVdvQ1VMQml4QVpNbThoSmpuTWszMnBaLzVLVFJ3MFJuY255cTJqL3FpUVJIQ3l4b3NML0QrY3dtTVJOU0VpQkp0cTVZbWxpQTZPVUNNUURUOUNXa0xuR0FoaXdha1FORnQrRFIrM293Q2hna011Q0REWEFNWHcwalBud3N4THRkcVFEVFZ3WHlRMnF6OENnQ1JIckREbVFaODVvZzVhSmQ2ck9VQ282cVlPdmtsQmx5aWJyR2I5NG8rY2NQek9KNGdJWkhEaVkvRVl4N0hnWHpvcHdpUVNkakFPeE03MEkxbmJ0OFJTeEUrZ1FjTmxCaUJ0SzJtOE5RcVhNUk9OMDAyZDIvOGVjQ01UMVFqWGZSNGxBZm9KVmpqZFFydERIcWQrNUNnd21NTHF4NjdZNXBFdG5XM0NUQzBHaUdGQlBVc3dKQVI2VlR1dGdRV0swb01QQ25CQmlSckFoWTBjOW5QL2N4UE1sQnBRcjRXR1JNSXIwNXo1Tm9wa091Z0Jta21EbmVvRzJsT1NxS0hoaFpkWG81U3hwVjRobUttbFNQSWRLSUlPVlhyaEYxQzBsUHl3eWlnZVVFK0JsT2ZMakJ4QVo2VFJMRThuT2RqYUZyZTFCVjFTR2pOS01GTEI1SE5qMmlxU2x1VzJMY2dMTXNnQ0V3TTJ0ZzQ4VWMzZ2EwdTFBTjJIOFZ4VHgvbTBHRzd5UGUyakRBYW9DUGlGZEU0N0tUQzNJa09jYUxCVTJsVURBa2pxY2xZUE9HSG9RcDBhTlNhRC9jWHo4TGp0Z0ExUE1uZHd0TVRHTHBrRng1SXhOSUxEU1NLQlk0L0tzZXUrcTJ3eUtRdFhTbFRDQkhVTHU0SkVNcDBGayttdEZRQ1VQZFVVWThmMTh6ak5CWGJGSkVFVzF4eHRrb3hoVGxtUC92VGhIdTZQSUJDemNRMkpqSldnOVJCUmpkU2lBaHJJbjVPckFNVGd1SWpTbEhjelZEQmM1ekhZbmV6bUl1SXc5VW1BRklKL0o4dXd1cElkSE9TN3lGV0E2bU1zM2duSlVRMU5NY0hBQWM2YWNUckEzdHgzNXdTNjZlUTBvRWZrblc0SjVGa1c1clV3VE96U25LUEVIT0c5RElhSndVcWlJZytqMVBUZ1VnV2REVGJ2ZmFmakttME9wMkhxWTVJOHlLTFZVSFN0UUNpVjFmTWJlTG9sWUxFT21PUjF0TjZUak5CZlc0YjFBeGtHRWRGWkhhbFZiTUtTS1N6dzNtZXIrSENDWjFjbVRLSTVnWFdhZ1pmMmpUQkJVYkZjMXBsQVVpQUdKekIrcVhEbkJqb21JRUxYRDJObTdhb0RrWUVuSDN4SjM3U3FzMDVFcTNCa0RvWWN4TnZHdDB4cVY5ZzBCSzFKeWZqQkxrVnk4cXZwTDJFVUpWS0NLV0s2emFBSlV4UzRpcWowNEFBNXFKenNLQUVPRTRnTlpMWmdvR0xSUW9CcUNrNml6aGtwZUQzZ0ZKaEJOb3dVSmtnemF1VFl0cHRKeWpOQUlBQWlFb0JxYUxsb2RxNVMxc0xCekl5R2hGN1NSTnltSStwZFlhQlVNUTZiQlc3ZkNOQXNoSytQa1JETTJIWXNzc0pqNE5icU16TlFrRmRZc3N1UDhRdzl5RFRkaUsySDFoQmFtcG5RaitvdElUbzFBdXpjSVNCYkEwVkRDTVpSVytlMkFhbExTb2lNMEF5U0FXQlRFNWlNSkVsd1ZUUTAwd0JWM1NQaEZGWGlJc2dUQStCWkdQNkpBa1luVDB1Q21lRU1RZWRiRHJWd1JLS3gvMjVuSGFTR3B2OXpFLzhlSENJUE8yemFYV2FLK3FQaUtmSm95ZjI3U2dRTlBCMGwrblk5WVFPb3BISjNTMjhhZXdBaExQaDFMQTBycUlJTkNMTXlRQmpUWjBLUmp2ZG5rL0VzQk5aS0FqUDZXVGFWQklsblg2Wkttd0VIRGUrU1VKY0tHcnhENWtaT0E5QitoVmtOSWx2dFJYVjhxTDZ2QmhWQkh1M3d6bll6TVBjS3drOHF5aUdxQktTTzBpSXFSMkZEQVR3REFTNnhTWUp5ZFNpVndERmRwek1sSVpEYjJ0NElHUWFTOU5qeFJDWmdhTjJseTJDRDlHTGdlb0VwOW9DSXB5T3BKbUtFWWlYRkxISDlHZU5UdmRhSkJlTUpvNk1DSmxOSkNwWkY1RXNsZEJhV3NJeXZRNE5DUkdCUldZU0Q0dXhNUmVDWVVrS0U0Z2NKbWpvQVZyd1AvMFRQeWJGZUNPSkNFNGJjMVV5b0Z1a2MrRmQwUlZQb1F0YTZoTEJ4RWlBZUdvSmc0Mll6TlNCWjJKWFNHdUVYd2lleE5WNUh0eFVITGF4aUdPa3JDQXdtdk9EcTNLNkZNaUY1aE4xMGxRdkdqNjU0M3RLbUV5RmFVSjZCTWJwdXBXeHVUVUZCRWprZE00QVJua210aE1UeFJ3bVVUREowQW8xSmhRK2xBRXVLTytpWnJqZktVK1pFQyt3eWNGQndWNnZ0QU1SR1RMRmZxUGd4WWFhRWtoZGZvQ28zc0lZRXhHUkU1c1Jlb1U0TU5ORlRCUG9BUmpHYlV5RTlUUXhTQVFtY2RLTElUVzcxR2ZHdU1pbHd6Sm9KMlpoa1pZem9rb0hpam9jV0E3M0lqVFl6ZVRVNUh1dFpFR2V4WmJFbzB4RWVNTGQrT1FBOUVoSXBEOVYwTTdDVVBNV0czeDEzY1VCSVlzcThRNGQ1aTlWaVUzK2IvMlgvemZCNklSV3dqTmxaQmxNTEpuNGkyZEtacWVwTUFIZURuN2NjU005Y1lLMU5SMktJcnVYR3BMREVtbVlWZFpWS1hDeko5VGo3YkUxRndhblcyMEsrSGtCUnJxRUNScFZNSTFsN0hKNkNFNGpUcnhjc1k3Ykx1bHhyRENHSmhNdlpCN1A2RFNtUnFFNFRZcWw4dWFaTStWU2VXbGx1WHZjcmRhcW1rWmRhOHNyTjIrOHZiSzBWTTZ5M2QzdGNTRzdlL2RPNy9nQS9RaHN1UTc3S0t5eWVEeU1hcmhWY0ZKWWVzaWNFbDlUSWptUnh3aWVxWk5zTUNkcVM1aEpqTlFBalJCYmxxaGhqRktRMXpWU25MQ1FHQkY0R0FNclkyU1JzQ2NyWlBqQ0hrcVRBK0ZlREtxMHg0VUJBeUVGSHlBUUJWWlFyMnlERWhLRkpjSTZKeDM2K1RHQWJZWUlERkVpUUJoZGRUQVV5UU5oMUIvKzE3em9qd3dSV09vaHY2SUtrOW14N2tXUXFEaDUxYnFwYmlvbWw0b0NtTWxxMHVGK0ZaM21Fd1BuLzlaLy9wL0ZlUFZoWFBUWGVOT1p4SndGVVpndVdBZ2huc0VjVEV4QWVBV2xDdGFURkJqM2hHT1NnaW5ramJqNWs1eFF4UkN1KzFPeUh6YUtlTEJDYzI2ZXg2QnN5Wmt3NElRWkNBMG1Za2JDd0tZTlFOemlPaVZGWGNmYjdRNTVsNmsvWHVKZ3QxZTVVZUVOOGRXMTlRKy84R0s3M2E3Vkdyd3BybzVodjlwbzdlN3NaTDJEUW1IYUc1SGhPOGZkYkRUKzFtLysycmtQZjZSU2J5MmZPZnZhYXk4ZDdlMUlSOXlFNUk1VkhjU2ZZSFJDYmxXV0VDSGRJTXVRc3gzdWRFMTlNWWczanpRT21xQlhnSG1SY05Lb3g5NklHSGNGek9GS0w0VTg5b2tjeFNYQmh2VUx5M0RvR29Da3NoMlJXWkIyVE1oblczUWkxdFZVTE5PTitiQW5QdUpoanNkSkVOSXpva01xQ3Z0UWgyMUIyeTIwd2V1R2Zja1RoK2lhRnhpYU9pd0JBRWY5elQzcm1ja3R4QkRzMUxSaHhSdWJhRWlFbmt2MmhSLy9VV1NBQlVXOXdkZ3QxalZVYU1SWjZEaDVoVm9ROXpFK0tIejVOQlU0TUtrTFdNSUVtVjdBZEFjY2tGVVRCUllBVGp3dEhKaG9ZcDQwVmtWQUlsSUh6aFg0V0QwVk5TUVNOREVvOVdwcDJGbE1va0xjZUQ3UkFveW40OVdOelUvOTRBKys4T0pITmpmUFRpYkRScU14NnZleS9KZzl3V1JhVmpXYmxKc0x3ODVoWTNHNU5CdTkrZFpieTV1YkZ6WTNpL3cvazhtWk0yZlhOODd1SCs2UEJocEYycEhaY1lmRExWeWdpck9zSXRsQ1BId28ySTkvdmQ5d05FeW1lVzlhL0prdmp4SU1tWkNrWU1LVzkxTVpBaklHTWxhaE53VXYxdXp2eFR5c3JSMi9ybG8yR0RTc0xNK09MT0lzbk5vSjhnaE9DSzlEZ0pjVEtxRVlTT21FNDBCcFk2TjUwajJzQ0ZqYk1KamIzbFVVOVhQU3RPSmlzUjkzTW5VQ1lhWXFpT21oUzV4Tm52RndqRnp0ZnNtditjUklSU3ViRXNPc1gvYVRQL3FqdUoxbWVCMU90UEU5S0RDUUE5TTBhTmY0b2tkRGM1RGhHR3h4dWM1Q0JpVkk0VlRGTmRFVHFhYmZlR21hMkxwWVVOb2c4WUhBazNtVWQyakRLMmFDQVJYOWhCRnVTS0hqUTBYUzhYbE1DS01KclZuQTB6Vi9jWldRYkFyaXBmVzFMM3p4UzFldlBiSFVibWZGNG5nMGt2K0cvWDUzNzlIQzZ1cDBQSnFPeDBlN0QvSlp1ZEZvVHN1bDRteDI2N3V2UFBuaEYvcTdPNVZxb2JHKzNseGRieTRzbHJMaXVEc29OaHY5M3BGa1VYNVVDTWdiOGN5SFNKRVUxR29RTkJnRXNYMFBnTzVLa281Z2VpSjM2allVWFp4VnVGVkZYclRUWllmMHIxVXhNUUg1RnBVVUJHRXpYVEp0Q3hKZTZySUJ2WXBTZU5pYXRyVzdFQUxoUEVaQTdJZ0ljV3dQS0tRWFZUUWhFU1BXQWlzN0ZDUk9HUWRQL1VrRzJKdXJneGg5WTdLWWxJS2lLblN4OVFNdnE3bkFpWm9pSUpJNktHOGRtVkNqQ0FPUFlzbnByUGhCQlJrZys4S1BmRjZRUXhFVGVTS2RyTGhzRlhOWkZJc1FSYTJFNTc4MHpWSHdtUnVPNFJiSW5OSlZpcVlEVGgya0J5TkNQbmRTQk5rVWlTeldTNGdGclY2MlR5d0FIV0ZBRVBDTUFyYzVYcVB3cTBCZlljMEtHVlRFMmFFQWhwRGlLT1ErL3FsUGYrYUhQbGR2Tk11Vmlub1ZtbG1XSDQwRzVXcTFzZGhtOXZ5a1ZDd3VMNi9teTZWUjkzallPVkxXM0xod2NURG9EbWE1amJNWGp4L2UzYnB6OC82TnQzdTcyd3VMdGZWMk8xOXNIQStPY3VNUjdyRUxWWENONERpc214MU1nT0p2dGlpeUdsOFRJcXpKMEFJVXlpS1Fhc0FrY2tjNXVTMm5tMWZWMnQvSGN4aHJCR2V4RGdKTklielZCSDlDRU5ZNHdjL3RQeS9FSkJUQTZpT2gwR0lNQ08rMEFIeVFVSFV5dGFuSXRmcnp2MFVENFUyWEI1c0dqa3c5UjBYRFVYcUNDajhhSTFINE13Y2VoUm1JN0E1V1pFekd0UEJWaTI0TzlkR1QvY1RuZndSL3V4R3J5dkhBaW9qbzUwK1djWmtieG1Sb0FpdU5FcDZsWVh5YXdOa2o2Q0JsblBCdTZPWGkrU3laWmFFaGhYUksvWjdOaW51MGl1Umdsdm1pT3NGVEVNWUlDMllBVnFrUS9RSEZWVnRFNlNFU2VCWk5icHFWaWovMzFUOTMvdHg1cms3OEFoVFhlakVwVjJ2YWpvKzZSNlZ5WlRJYVpLV0tpRHY3TzduaFFibDlSck1OUnAzK1lGU3Z0ODZldnpRWjlidURZYVBWcWxlcW0rZlB6TEtTUE54U3FxOHZidTA5WU91aHFKVEwyY2xqUUYrRkxSQnhJQzFzQ1REU2tjODhFZlFrWXo5S3g4eXMwc0J3czZpOWltczdTWGoyTm1JaEJxTHphaEZlMHdsMjVIR0lFL29hZGx4b0NCR0JZWmpaTXdGNGJacEE2ZHJDcHFhS2d3MWkraUNJbGpWeVh4YnJBTCtvNlRHaU1GMnNJVTNpcTRCRmtPU0N6RUxDSVFuZGREbkdvekJTRmV6Tmt2dStMTzFwWXFoZWFTNDNWTFIxRDgzRWNKYjk1T2MvRDNlbVlCSWd6MlNMUk5FWldlQ0lKUkVyWWQydElxd2JTa3Z6V1FJSkQ1dVZRVFI1TVo2T09FeWFtblE2NHUwcS9qVFlzd2lYYUFXakRQU21NWHphSmk0aTkvYjNGRmJNdUZLa3VHY3NNakdYd20reXVMenlVMS84eXNMQ3duUXlHZlBkaEZtcFZPd05KM0tYN0ZVc1pncXlTclV5SG8wTHhlSjBraXVWS3NWaWVmdmV6V0orcUlYVDI5OHVOUloyNzk5YVhOMm9OK3FEL3RHNFVNbVBoOVdGbGNNN3QzVkJhTFNYTmxmUDM5KzdONTJPTWhZZmQxRGVyVnAxdklna2dyMWRZVytJQ3M3eGp4TTVDMEN6alQyS3JPOTltaWg1TG1tdnpzbm9sVzFzSW1zcURrem94V01ueVF3TWNacDNFWTRoU0NJc1FhUEpTZDZ5dDJPS1FsT1FvODNrWGdVSmZneEFob0thZ3BER1NkRnJTWkxYZ2x4emVWUVUrd1dSZlJNYUZNSEhvTXQ4TUp5akRhQXFXR2x1cXhJVHdkRTBNTWwrL0hPZmM1YzBjeEV1QlJrUTR4a1ZWdk0wMEFZM2NBb2drRUxZUkI0TlNqWFA1aldHRlFJNWxnOWlydFZHZVJiTmJLd0tCUHJ6bkJ6T2hVUkc5THUyRGdIaVlOT0I5aUkyR0tNRjArbmV1UGFBa1pZUUNVMkkrMXNJZklKMGNYM3p5dldQZnZ1MU83LzhyOSs0ZDIrbjMrMGRIdlZlZXZtV2lQZDJqL2p3N1hSVXJwUTFZRFFjandiOTNHUW91RmlZRll1MTRYQlNMWmVtaFhwaGNuell5NzM1Yi8vMTR2Snk3K0JnMmo5c243dDhzUFZvNDhyMVYvN29kM3Z2dlhIeCtVL1ZXNnVQSHQwa1lxV0hKYkdvSndZaGRtMmdlQnNFUy9GdlpYa2ZBQ1JxU213clpxZG95eTc2Mk1ZNDN4UE5QSy8wcjJPQzlJNGRRRFVUcXVCcVd3Q2JoRDNCMmtCQlFvOTdpWEthbU5jR1Jtd1ZvaDNKaVdqYXVoNUdjSnVhYlhRdzBtS0JLelQwZ0RKcm1ETjZqdFhMbnFHVGZsQ0dLWE04SUdMNFV4bnUxalRwYVl5N0FSRURJUzJXSThTYmUxdEQrUC9pYi93MUxBTU5pbU1WcnVOb0dGR0d3UDVqTk9QWTVNelpwMTQ2WVFMbUF3WEtBT2dKRVRTRjVuZmFZQnk5VXNMWFAycXNvQmtRbWRXTHlNeWlsdWs5eEhENENVUlVzTUg2VGc3TVNCMlVCSkFGVU5CUTY2UTQwUzVnekRQMTJrSisrYmxTdFRhYVpjZmQ3bWc4eVEwSHBXWnBzVkxwOUJUVEN2WHg0WEd2WGNrT0R3K2V2bnFtMisxVThzTlB2SEJkOCswOTJxcE51K1cxU3cvdTNsNG9qVys4ZC9meWxjdkh3MEdyMFN3VXBrZjk4ZTc3N3k0dEw3VTJMdDE0NVp1VHp0RXNhNjI5K01uZi85MS9VaW9VZVFkV01zMFRSdklDUlpJUnV6d1g1V1ByaWs3RjhVaExSQkV2KzRrZW41SS9TTmdPWENMWVlRVy8wQm5iekUzcjNhM01FeGQvQlVBQzJHeGpGNFVyTnlsK3g2WW9nUlJFaEJWdmtXbFVTWHhZYUZ5UTJCV1pIa0h4Z1dhT21ieEdqWlZFZGdNdzNjYWloeXFFRkFVRnAzSENHUXdLTk95Q0VLWUN4ZDNzcFRWSWlSQWRVUkxzVG9ZSEtUSW1WbEFZVmd6a3N4Lzc3T2VnZEdIR3FOd3d3UEJnQ1R2SmF2WGNEQnBtWUo1QWZFK1pJelFWSU01MXJFdHVydGErWUFXZnFFd1hjRHBSR09nS0M4NHhXTkpoamdVQ0c0S29RMmtRN1FQSG1mbklhZ2lpUThseVBKMk9pNVg2NnZXUGJWeDZ2cjJ5dU5odUxyV3JtNnV0dGFWbW8xNnFseFQvdFVhNUtQcEN1YWpkUTYzZXJOVExOKy9kMisvM0QwYUZiMzdueG5KNzhkeVo5amhmdVBIcWQ2NCsrL3pEMnpkWHpweHZMSy9PeHNPOUIzY1VXcm5ScUZtcmxrcmxRYjUrZVBmV3RlLzdiTCsvMDMzMHFMeTBlbnk0YmJNcmdtUUdTNDE4aHJFQ2FWNkhyai9DSzZ4Tk1Sbm50Qllsdkpwam90ODBqdzlVazZiUnhGcm1MNDhKaTBFY051cGlWYWlMaDBRNGhJYXZBRUFzcFdoRURqV3A0SG55WVJ5bmVKMk13QVdrRmxPd3NGSVBUWWE0WVMrUXQ0SURqNmtTQ2FlWUJYSkRDV0NJaXRhblZtZ3NXQmZlUVBBZEFJVmFYQzBabFVhcEI4Z3JYMXV5RUh1bWNQK3NRTFBFNm9hOUxwMkdOVEQ2aUdsT0hHRWg0N0VqdVBuS0J1SmtiNlhZNHBCdnhCUUhTUTVzYWRlYXlMeGdodEIyazdpNEdlQjhuamdsUUN6c1B4RTR4dlV5Ry9VR1htZXVVU1NPa05leHJrT1M1cVpqN2M0M3Juem9pWS8rOEdKN3FkNG8xeXJGU3FsWXEyUlRmNDFZTksxbWRXLy9zSlRsS2tVd2V6dVArc05SOTNpbldXLzFlNTFTb1gzaHlldXYzWHFZOVk4M1ZscmE3bS9mZkxPNnNMRDc0SFpoMnBrTkJwdlhuNUdDeFdaN09Ncy9lUE5QU3JueCtsUFA3ajE2dUhidTJ1TFNrblpLQjkxSHMra0lUVFViajhhbGVUS2FVNTBFVmF3cnRjZDNsSFRpTWJuSWRIczZTWHNZdm8wdjdhWXpyUUVBb2tjR2lFeHZWVU45OFpmK1hIL0RHaGpJQVVoc0NHTnpNZGIreHRXRUZOMXFxM1lZUjR4cUpBVjZ3bDkxMEJyQjRYSkNrdHFlRE43dWlEOFQwNmJCOGdoNi9hVmozaDJYcDZCSmlLZ2c0M0lEbmJUVGlibThKTlFIN0RNV2NaUEl5VDcvMmM5aUhrZWl6MGFuOEFHS2dsTjhJY09HNnNDZVVmTkhuR0h0azV6RWlnbTBFaTJrSkZ5ZGtZMkJ1RTMwMmxsaVF2aExYdkFoTW14WmM0eWtXN1VqVjFTbWh4aFozWmdmZnVpQi9Hbk5nTkpJYldTOThSWE1WK0RHay9IQzZ0bm5mdkFMRjY0OFZTdVY2dFZxVml6MmV3UHRpVnVONmlTZmxiSlp1MUc4ZjI5YjIvVHU0ZUdqZys1UnB6TWFhNE96MzF5c2YreXAvbWMrYzNWdjU4WS8vWHYvK3Rubm45ODZHR3pVaHRyOXJLeXZIenk0ZC83YXRkeXN2SHJoVW45U2VuVHJyWEhuY08zcytmWExUK2VieXcvZWZuTlNLT21xY254OHNMQjZ2dDVvUDNyMER2NExTUkVWUDhoNjFNUjhHSk0wb3VBbStuMFlnNFlUM1o2Q0YraFZrSGJuRWI2eUlEMFloTFlzSVBjNTBMRmhNcU9OaGExdE53WXBVcUNlWnVFWFZRSXNwTWdrcVd1NEJHYXEzUmd3Qkl5ZVJ5VFRBWGhYcFVGYUtrRmxnTUd1V1MvRUxuMEFBYlBYVW4rSVFpR3ArM2xCRUhnYWlqSytHWnJLV2tjL2hjVUpjMWhScERkOStleEhmdmlISVpSVVdCcmpoOEhRRTMwWmIxZW9ZaFQ4Q1I1QUc0K1dZakc4SWtKQUQ3SEQ3QmtpV3k4TWJnN2ttNkF3RTAwbzAyaHZhQlBqY2laaEhzRm1waUpQc3ZOaEZuTVREMndkQktEVkpOblIxRmwvd1lzeDR5bDc5TWxrdExoKzRibnYrL3kxcHovV3FEZFFERksrTjkrb1pxMUtUaFJIbmU1ME9McHg4ODd0QjN1RDNraUIzaDlPQnQxZVFiZCtXZTNMbjl1c056YkhnL3J6SDNxNnZqVDQ5Vi82ZzgzTDF6dVAzcjkrWVhQMy92c0xxeXRaSWFlVmNmem9ibjQyS0JScngvM3g3VmYvNEoxdi9NYmk0c3J5eGNzeXpWdS8vNnVONXZMdS9tR3pYQzNVNjkzOSs0U3laVVVsbmh2S0hqS2hZNXAwcnBNQWRVbE81ZlhBcTZockxFTXdGdDBaNXM5RmhIOE1ZUXpVRndjc2l4UHBBWTREbjhoc0lzVE5FV0QrTXhBQklsaGhaYmJHQ0pYR09IdEdYS1VPY0s0VWR4SHZjbEtLb2FEUjhrSEVpRmp4RmJsNHVNbkdKQzRpSXVXa1N2aENmS2hhMkxTYkVWRVVuNW5QWjA2ZWhmTUp4cjJnZFNMMHM4OTlqczJNUUtJY1E4c2lOa2JJaWgyeEhTd3dJQ0hFWUFOMkVwVUliR0Z1cnFoMTJPRHdOSUVIYWhRczFRc2o5cDRoSUlNNWk4YVNnbVlVdFVEbXBZVVVTS1FKeEhndW9FUmxKbXdGcVpramxlSkNVK2xDSC9Lc243LzZrVTkvNGRyVEw5WnFMZDhEMGpzWmowcmwvUEpTczd0MzhOWjc5OTU0NS83TjIvZGZmdTN0NFhTZ3JZMTJ6ZU5SWVRnZDd4MGM2RTZ4bHMwKys1bW4vbmYvMi8vc3YvbXYvODVmK3ZlL2RuWno0Zi8xLy9qYlQzLzhCMXVGNDgzVjVtZzhIQndjSHZZRytkR3dzWEp1T2hxV2F2VjZzMUVwRmM1OCtKTy8rYy8veWVqaHJkV3psNTc4ekJkMnRyY2FLeHUzWG5rNVA1N3REeDZRWWhEN1pDY2oyZGkzV0d3TENUQ1pwTkJYUnVldXd5RXRWVWtvU1ZQYlN6VWpTZk5DOHRRcDNjV0tyUUJNeGl4NGdqaFVqeXBPOFY2TlpZa2dGTk1VL3JJMEdHTFBkYUluVE0zQ2tjR2RDckF3cEh6V0FVVW9CcnZRU1VJM0ozQjBpU0pSbXJHWlNGcm9JOHhqUVRuU0JUamtQeGo0bm1NK0RaeDlwcHV4aUJWdHNkWGQ5K2QvK0xPb2hpd1NrNGt6M2dyR2RqVG1SVnlpQkg4WkM0b294c3VJSjRkZDRValZnZGs1dEhyRjFzUGk3NFFOb3czSC9EU004RmtPMGxrU3F5bGJjZ2tBVFJXMWwwUU0xY1JzcEpCZ29rdkpaREt1dDlxWG5uM3hVNS83d3RtTFQ1Ykx0U0ZSMlpjVlNsbWhWT1JtWnphY3ZQM2RtOTk5Zisrd241K1ZLa090am54eE5pbjJ4dVArcURBZUR2ZDJkeXFGMHViR1NwYnJQL2ZVcGZOWExuM20wNSs0ZUduMXdZT3QzLzZObDg5Y2ZlTHM4bUpwZUtUdGY3OTNkUDZKWjFZMjFzYTVZcU5XbXhWclIvc1BCOE5aNzlHZGovM296eXlkdTNpMDkrRDJtMjhlM1hzL20rWDZ4VnhKUXRacXg0TTlLK3BuaUpqTzBRbkFiNHlObGUrSllmYnVSTHd1Vk1ROWl3SmRzUi9CYlM5RVU2endyR3lDV2JBT0Z2SGhhcDdkRldTS1MrNnBIQS9oSzJBZ2xvVUFmOGpTNzAxQndjdXg1eVpFQ2NrakhicGdBWEZVbmdWUklBL3VxcmgxcHBpRkpDRSs5ZWRsQURxSUF4bkZrZXZ0ZXdwaVNvTFNHTWUrcndoR3VPRVhheVBhQU1LeG1iRnhiS2dZYmd0NHpUR2N4UmdxbTBBRlNsbFIrbUJtQmdwU1dpSE51TWo4SG9uL1RHNDh3cGgzUWtTT1lTUVljNmVDc1JnaGdQM0dNTjVJQjJjK3VNMDRoNGY0eWZGTXJhUXR4R1NjTHhTWDFqYVh6MTU4OFFkKzdOa1BmNks5dk5Idmo3VDh1c2ZINVVxcFZPUnpzZDNqN3Y3Mjd0YkQ3UnZ2Mys4TVJzV3NrRld5MGFBMzdPeFA4ck5pS1N0WGFxTWg5NHFhOS83dDI3UEJVWHRsY2FFeStkaEhucngwZVYyaDlaLzhYLzdtaHo3MStheFFicGRIbTZ2MXp2N2g2c2Jxdzl1M3B2bmEvczY5ZTIrLzF0L2ZhUzZkYVRYcnpiVUwzWU9kWEdteDNHaXZuVDIzM3p2K3ppLy9veWMvL3NPZHdYU2x2YmJidlQ4WkR3aEJDUzk5MEN1RlB0R3RtZnpPcUdMZHQ3WUd2Q3JpbjBPcEtSUGFDL3dsVTRjbE1XNjRSQmFtWVJ1bkx0cjJobUlBSzVPckNYRDhRMEFRTDFvUGFxcmlNOE5STXhva3NlNCtoMnE0Mnd3SnFyaEErQXJNRVBHaTIzT29qaEpqVTlOU3FkT3NJa3dWMEJ3aUVPaHhZdXdvZHdVM01GRWpyVjV1aTVvM1dzMEI5aUI1MFpQTC8vWC8rRCsyclVqMU1qTGpVSWhJczNsc0NvbnVJa291VmJaZEZDR1ZFTlgweGp4aGdwNHB6RWVxSUl0TkpwdHFjbnJsQXNZVWlwZ1lhdFJTeGlGL2kxaDVCUVBEV0RLeCs0VGVsMmJZYVFxNEM0bHR1V2lYRzQyTmN4ZlBYcjUyNGRLMS9vQTEwKzMxQnYyK2RuK1ZLczlleHVQcGtNKzFERG9IUjdPc2NIUndNTkprdW5VZDlHZkZZclhlT0R6czd4OGQxb3ZackZMdjkzdmJoN1BwNEhpb0swSnZ1TGYzNFBrWG4xTFk1WTl1cmk0M3Z2bnQ3OVkzbmwzZFhOdCsyRGs3ZWYvNnVYWmhPams2MkxsOC9aa3NtemJYejA4bC8rajQ0SER2L28zM3psMjYydDY4c0hQdlJtdHA4Nmh6bUJVcUQrL2NMR1dsWWFtNmQvZE9ZU2wzZCt0bHRGQXNTek1aVUtIczNVeWtjWUtiZFNlVVV2dDR3ay9IeU13S0pnZDZZY2FYcDdBc3dSUEJSVU9HNDNHN296STM0NFB1Z3VQYmhsbXU2QUFvRnJUTXk0VjhxWkF2WnZteVRNK0lmTW1mZkNuTCtzVmNNWmNyYWxER2twQ2pNc2VFMzFQUzVZSFp1T25UbkRLM0duaWZkMlh3UHN0VldjOFRzbnBCK1dWNkNsbnVjVnpSSkhnOE5yQ2NkVUJ2NVZpUDFpMzZnNCtIZXFUbUFnRHRTSUVrZXNqVzdPeUUrR3QvOWErU0tlWUZkcVk4S1dxaGdYQkVLT1BNQWtZYVpqR2xsMkQzMGtIZUZ4Tlptb25uREtOV0lmSlZYT01oSm9BbVZmVEw3bVpoRHVhRkdNd3FWOFRzNnRIaXpFcXQxZld6RjY1Y3VISnRaV1g5dURjY2ozVERPWndNeDNMbVpEUXBsNHVUeVZUNzcvNWdQQm1Pam84T0M2Vnl0emNZamtiaVZ5Nlh3MGk3ZS92RmFxM1JiSXFEY21paGxwWHkyYjNkanV6VTY0NE9ENCtIbytGaXEzWnVmV2xocFhYNy9idXoyYWhVckwveDdvTVBiZFkrOXRUeVpEUjRlUHU5UzllZXpzMzZ4U3kzdGJWOS8rNzc3VXIxOGtjL1hTa1ZqdzYySzRWc1VtdTk4VzkvL2Zyem43cDM5NzM2d25xdDJicnozcnVqNDI3bDh0S2JiL3lhdzhJZlpVUkZkb1RhdmNpcS90RlVSengzcVFyM2tmY3pvdkluSExHcUxJeVJOVXdCNkNTaGw2TWNVL0lSTjBBZGZKVkpFUTljNUUwbTNtYlMydU5xNTRndjhsazRoWEpKZ1M0enh6TFF2ayt5S2RDZGxMU3l0QUFrcXQrQmtpdnNRZm5SUUFSR0ZJTXB5RFZVSWdNVHNQUGkvUklVNHE4bVZ6TFVoeHRhcFgxQkt1aEFjZVR3eUNLeE9qV2pZSVVHMWtqdFV5WEk2UDNyLy92L2cwNjZVcEpieFlXWExXUzJDdUdranlyQmlFM3hXRDhSQUczSGlGZWFHd2Q1dkJneTNIRHc5QlJHMERaRVdrK05LUDU1Q3pzTU9rMWtXcGxNazh0QTVmcFNzOVZxTGJRM3oxMWNQM08rVWlxUHhvb1Q3amxtQlBzMEsyYVQ4YVRmMHhhR3JXKy9QNUN6QmtQbDl2R0FSelRTYTlicjlTdVZTcWxTbEcrUGo3dVNZalFlMUJ2MTQxbHRNRHErdUZ5ZFplVnF1ZFE1SHJ6NzRHQTBMdFRydFVlUEhoNXU3M1VIL2FWV285MXNhSE12TVNmRHdjWGE4Ym4xUmpZZGozUDV6YlBuQnIxZXBka3FGclRDT3NmRDhmMWJOemJQWFM3WEZ4cmx5YVBkdlZtbmMrR0ZIL3duZi9mdlBIM3hjdjNNMmVQdGg5WEcwaCsrKzYveWsyT25OZWNuZGl3a2VMVWxyaUQ1blcrYWtDK0hzcnBBTFFsU0VPWUxvOHBHaW13c0taZ2RIZ3ZJMGU4TEpiN2ptMFVBQlM0SUN1NUNsaFVMQmQzRkFDdU9pM2xnWXBweEd1MnNUNGlycVZvMHBZSW1JUzRjOFh5ZkxRVW9IaUpZSFJhSTQ3QVJ4SXdtUzJoVHUrQk1QNkNUUkF4VjBFRGxmdFI3bklLalJEZ3dUNUNZbjByaVRNRjZDZnl6aW5xekgvbk1aM1JtQnQrN1dMNEVhNzhjbHB6R2R4d2Z4N29zaWtoV3lXTlZJVGt2RGswTUUzdFFmK2FxZ2ZEMXd2RU9SR2JBTzFncTN0a204SlZGOEpNN3pJbmhNZTAwcTliT1huanlzei85cFNlZmZYN2p6TGxHYzBIUmRzQmprNWwyS1NQZEZSWUtvK0h3OE9EZ2NMK2pjTzkxajZmajRZVFBLSFo2M1lOUnY1UExEYWVEcnVaUW10UXViSEI4a011UHF5VnRxTWJsYk5KZVd0VHdSL2R1dnZEY1U4V2NOam1EN3RIK3huTGozR3FyMWF4c3JpMC9jZTNpeHRsMXliZS9lMy9RUGRqZjJTclVXZzhHOVQvOG96ZUtoZDQ3My9sMmNYaDg4Y2xuRnBlWDd0OTlPSjdtU3FYNjVwVW41SVQ4dU50Y1hLdnEwckMyOHZwdi8vSVAvZFRYNzczNXplYktoVnltUGRieC91aXcxOS9oOHFoNDlqVTNkakhld3N2bzJzTzdzR2VUNmRUaVBRNFpadnI0KzAwWVNpY0hqa2JoT0ZuZklTTVNnc1NPWUp6ekN6alpIRE9UNSt5RWdqZnhPTTVOQnppRHlGdlNnYUVwRFFsdnhsNFZuaDAvTWhNdkNHa0dDajd6L21BcVFITjZhWm9aM2VGL08xNkhLbmQ3YzBWMFdOUlVCRDl1SkVvT002SGw0d1BsTWVWZit3Ly9JMWt5MmlveUVFb2lOVmd1bU1xb1ZrbmhyanBaSHR1UzNUbVRkbzB4QmJCTEdNS0RJc0dJRzdmd25ObklLN1drU1ZXc2p5WlVobExRc3NwRTZHdUxPRThybGNiYWhTc3J5NnZWVXFWUXlyV1dWOHYxaHNLamUzUllhMmdUMHRyWjJ1MGM3ZzYxdXgyUHBMZzJBYVBKU0hIUzZ4ME91cjN4UU1reGx6a2ZhZnhRdS9qSmVEUVk0TDlpMWw1Ykh3M0hrOUZJeUZLMWZPMzZzMGVIQi9mdjNSbE55ZCtWZkdGVXlBMjZRMjN1ZTdueWVKSWZ6a3JENDBHMVVkSDEvTTZ0MjBlOS9LRGJ2MzVtWWJWeWNINnBVcXcxMTVmcTY1ZXZEOGFGN2R0djdtMXRqUWFINTY0K1g5UmxxTEU0SGVsU1V4cnVQaGpNQ2dkSGc4bkJWckZjZkZBWXZQSE9yeXRTWlNUZWpjT1c1RG91bU55UThyUUlHMHMrOHJwdVQ4T29NaGZiVVBYRUJkRm14UHIydk96c0FCSlRiSzJNVEhhWEE1VGR0YjZWMFJWTVJlV1hndTdlbFc0RWFPdmliUTdaWFlURkluNWpiK1BFVk16TmxPekZVRHVaa2tTU3ZQemVoeWFRSUo0TjV5T1lBR3I3SEppWDZSTmFSQUU2azlHSnA0bXlrK0JSRVp3eUhrd0M3MkVKZHBBRUFtTE5BT0NnVXpzYXArbVppM0FucjVCVHRSc0x5ZUVxa3dtdjJwVE1yV3ppV3FMaEVpNno1Z0VoenJDdzNCV1lqV0MwU2ZPcVNIT3VxN0liVnc0YUF0TjZOQUNTVE9JVG84eHBPcXZWVzV1cjZ3dU5hcU5WeVZVcXM5ckM4c3JaYVNHYlRrZTl6cEZ5OEVEYmtjNUI1M0J2MUIrVUtoV2x1RWQzNysxdDcyZ0hMM1ZLMVhxcFdtcTFsd2ZEWWFGY3IxVXJ4WXBDdDZYd1V6eFZxOVZ5cFRMU1ZuNldHdzc3dXJ4a0dXdGNPLzNGaGZhczBsU1lIUFhIRDdkMzc3NS9UNlc3dnpjYzlIdmowYkJ6VU1wTmU4TmVzOUpjTzM5eDcrSERhMmNXbnRoc1hubnl5c3E1QzQxNnVWSmI2UEd1N0FOOFZtNnNiZWcrOVRnL0c5YWI3YjM5L2NwNDlQTHYvSXVuZitpbjd0KzZjK2JaWi8veHIvd05tNFpNanRLeXB6OGtJRFBLQzl5elVtUmowcnVmRGhUOHRROFhNTEtiTEllN01LYUV4b3k0Z1NjQmJHRFVsTTFrYzJCdDByVnhZYWNPeUhNcHdkcXMreVpXeVlaRkFXMityRzFNa1BtaUs5TW9hYVFkUEE3Rzkxbyt6TUI4WEU3c1FzY0lDT0xJWjJMSUoxcGtWUUc4UzRiNDdvcCtvcFhZOGdCanJGM3crdE1sOFNiMDArNG5oVHVqVlNRWmtXaVlyVTcrYi94SC82Rk1hSDQyVnZvRDRjaDJqd2dacEVNMjl6SWhEL21XMUJkV3BYVWNKTHlGampPU2lOb1hDMDJHZW9TMTBFNEo1SE55QzE0aWk4ZlRBdVJqb0FjSldseGF2M3IyYkxWVjE0WmxsQy8xeDRWeXRUYWI5TFZSN3gvM3hzUCswZjcrVWFjNzRlRmRkVHJSYmoxWEtWZnJyWHA3Y1VGYkVOMytqQ1VRNGNMVEhjbXFUS1VOc2JhL2N1b295N3JhVDl0WFpYbFdHb2d1bXcySFErMXJ4Nk5jVnhrL1Z4amtxdnU5Z29KOE5oMXJkZWhpSXJYcTJhUlMxVXlWcmEySDIzZnZ2dkhPcmZHRE41N2RxQmRyOWUvNzVDZEwxZGxLZTNGMTgwSzVVdEt1dVQ4Y0Zjb1Yzc3JWOHFzMEo3bjhkMzdsRjZ1YlY2dWwrcU5PcnpnYmYvdjlYejNxUEpES01wMlkyNXkycCt5TTJON0I4N2lHRTNMYXduWmNzaFhSS1lQNXVSYkpuVzh3cVRFcmdkVkJuR3EzUXQ3Mkl4aHR6TFUxZDNBcnhSUFRXbThSeXM3MGhQdU1welFwMy9OMGh4dFc3L3cxbTZKRnVRMFhDY0Nka2tFQlJKQUxReEhBekhUcWNEZ0VSbExQNy9wTUNBWm9yb3gxUDEwZ2ZveUJ4K01DekN5UGgwU3Z4OGhLajRtVkJITFo1MzdvTTFLTVh0WmhiR1I4RDJReGc5QnlZWDVXcGZNTjYyQ0t1cURaeDN1QVhoeWtlQ3pCUVAwUjNHS21TNmdvdk5pOXJwak0wWTF6WkYrZG1GSTBYS081VEdidDlYTWZmdTVENDFLcFB4d2Y5YWVsWWxsK0ttYXpoZGJxZURDZWxTcFpzVkZaV05pOGNHbnR6TG5WemZVekY4NnZicHhiYUM4M1dpMEZkbjh3N25SSGszRysyeDBOK3NOK1h6djhnVFk4Zy9FNG41VU9PMGU2bTgyMFg4MUlnYnFrYTlSZ05oc1BCNlZTVVVlbFh1SFJUVEdyVml2MVJuVTRtQjdzSFl6SDQwcXBNSmdNWjZOaHQ5L1Zua2tyU1F0c09NNi9kMjlidTV6aFlQZkJPMit2cmE0dnJpN2Z1SDNuN25kZnprclo0dnI1UC82dFh4UFBOMTk3N2Q1cjN5cTJsZ1k1cGRMc2xYLzdyNTU2OFRPVDRmRzROTm5ldlpIaVBKNHdLclpUWkVjamtyc2RnV2VoOFRyRjdDcU96cE9Bc3g4Y1l3cFMwZ2lXbmlsYWNRTk5QTVg2VVBnUzhZUUNZMDNNc0toMGtnL2REVzhtRnBXdzZtWUtjbmpjR0ZORHBJUHVORFRtd044a05Ub0pNTnF3UzNSQnowU1B4MFp6WGdTeU9BMmVHaWJCNS9UaTZYZzZvUU12M1hUYlBXOHovU3o3c1IvK0lUWG1PSWhVNlEvZDRhS203RXV4bllsMWxFUlBGU25KQ29BZUEvcGd0TDNBU1IxK2JHdjJDbnpiSGkvb0pWQUhQdUJDYm1JaUh2OXAycVcxczA5Y2YvTG91TFB6NE1Hd1AyeXRuVmxxcjJ6ZHZuVzhjNyt6djFXcTVzZUR2bWF2YXZmQ2o3Z1VCb09wZ3JuTEhlcmc2S2gzZEhUYzdRNkdvM0YvcUxnYzlvYmE2UXg3dmE0OEoyUzNQOGlLK1NrZnA1VlcvSjVHdVZ6cDlyV1pRV21oZXFOcDU3aXJPMWVsOEh5aHZIVTAyTnZ2VkxKWmM2SGE2MDlxaGF4Y3Flb0tvS1NyelZCdm9CVlNHRTZ6WjY2dEhIZjd4ZGxvKzk3OTV2S2l6THR4N21KN1pZbFBvSTU3czk3eE01LzhkT2ZSamVQZDdmTlBmUGk3Zi9Tdjg3MkR6V2Mrc2RCczdIWjI3dTI4Z1pWSjVjUVFXUVVyazF1d054Z1FnQUlpTWRyZTZhWEpzREVQeGRRcFdGaGRBK01oK1lsaGJYeWJPaUtIK0dPZEZERTViTVNkZmc3MUF3ZC9laGdXaFN1bGU5MUZGdFJDOUJTZXhnQVBQYjJpb0tBNDNqMW50Rk1FdUtFS0FjQzQ0U1VSNE1rQmN3Mkh4d2tTTXMzQ3NKakZhNEErWUtvMGUyQ3luL2pjWjQwaURobUdqZHpKSVVvbjhoVFBZV3NmYWhQNThxTjdSRzJraHFJanMySWQvL0NVYjNSQ0NtWndBVkQrWlJuUWdjNitSbWdJMThaWlkzSHhtU2VmdmZIMk8rL2R1RFBReG5yYzdUMjZzWHYvcmZ6b29ERHI1NlpkM1dOT0NtVWVIcGVyRTkyWnNuR2JkSTU3bllPOTQrUEQ4YWl2bTFVdEJ0MjZ6aWFqWWI4cm1UT2V4a2lrb2lLODMrLzNGUDM5MFhHdk41N014cU94OXY5Ty9UendHMllsYmIwYmpkYXNWT3RNaXZlM0J3L3ZQZW9QdTYxV3ExeHF0R3BhWUpOT3Q2dGIzMHBaZDNMVFJyMnVXTHQyZnVQN3JyVy8vd2MrdWJDMnVkM3BDL1BHcTIvc1A3aC80ZHAxQ2JPOGVuWmIrNjY3dDgrOThPbHFlL0Zidi9TUFgvemhuOWplMmFzdHRMTFJxTlplZWVPZDMxYnNFTlk4aUNUWTFmQ1RHdWQxWWNDeG14Y1p0eGRnY0lQdEgzRVdSNFFEckRDbjNSamhUZ2Eya2FsTnhIaFpQOGlOWVEzb3FxSGFic2Jqd0hSQzQ1QnpzWURxRnpOSTFBRnpGU0xDZzh6WUE0V3l6MEc2eDcwUVFrR2dpOGljUXhoM3VDMkFwc1ZML05sOXpFY2dvSWxWTTRIT3FwaElCZjRLSitNRFhjai81Lytudnlxa2JDelVYRE1wYWxVeExIWWxzV0J3THFtb2pKMmRkUmdqR1hneDJHcjY1QjZ5aHRDRVBFVjR4QUZRMEhGVlZYRmJhZC8yb2dCSUw4OHoxRVpWTzJnK3REaWFjZDg1Sy9JeGdISzUxcWhVNnVQeHBONXM3UjEyOS9ZUE8vdDdsZUprY2JHcVpKejV5ZlEwTjBMMFRDeTArOVZXWU15VGpjbHNNRktPbng1MXhyM2ppcTROdWhuVERxbGFMVGJxelZxalhxclZ5dlhGMnVLaXBzaXk4aVJYSEE1eld6dEgxZEpNdDdhRFlYODhtcFNMMmZGeHY5V3NIbmM2V2JGUWJkUjE3N3ZTS0QvUjFpcmIxMFpZdDVKWnJmWGFOLy9veFU5ODZ1Yjc3Nzcxelc5ODhqTS9mTzdhVTgybGxiZC8vMWZQWEgwNlgyMi8vOXEzVnA1NDd0RWYvZHJtcDc5MDU5dmZ1UFR4SC9oSC8rci9QQmp0eTdZVDJZQ29KcUltOFpFdnc5cU40d3VaaXN3UTJ4cWlDRTl3Z2NSMitFOWJRK3pySDVIUnBWVk94c3BhZlh4aldqRCtjRTZTRHdnNVAzZlhEbDJEZkxzc0hQZXZqbEFsZlRiMElzL3hscE16Rjd0VDNsNGwwdXc1KzVYRUpZRGRQNUtJVW1POWVIUjRHdEFVVDAra0lCZkJJdWFjaUIxZndxS2hQd3lodG9jbC9LazZRaW5WQnN3SENja0dJS2lDY1pSQy92LysxLzZQWXN2ZVRla1JNV1JKWlFYK2t4NXJRTVFBM0NvWmlIQVhCKzBkRmZSY0ozR0ZpMFpwV1NqSTVTeWtPRlUwU3IwQ25JZWtwemhyMWtURm9oRGUySUlkQ3M0clNZQXNDZ29EYXhJdkpIN0hRUUNiSXhZbDhrZ3F5U3U1ZUU2bk9FRU5najZlWkNmTUpEL3k0MnpSakF1NTZWRXZ0N3VUZFk2V0RvK0ZrMXpxeXBYeTQySldYRnhjckN5MkJ3UE5VbDVkWDY2MkZpcU5oWFpySVplVmRyY2Y2b3B4dExjL25vektwY0kwWDE1Y3FGL04zWG51RXk4ZTdSMDJsbGJ1M3JtN3NiNlVLMWIrN2EvOHN4Yy84ZjFybDY3cFJsaVc2ZHg2YS8zS1U3L3p6LzdCczUvNDNHZzh5QlVxMjdkZXVmVGk1KzUvOXhzclQ3ejRQL3p5ZjhEN3FqaWZXTmVCL0xLWGN6dys1bVI3YzNNa0h5VTNPeFZoWEJsTFVRN2d2S2E0dzlxeWxKekNUMVhpclloNHVkZXh6alpUOTZrRUlLTlY4NGdHcEoybDJDWEsrVFJCcGx0NGJyRXdmNUZWeHN4c2xQQ2hZaDFQcUJmMkFBeVBYdTRkSE9vcUdxSnV2SVkvQXlzZnV5M0d1REgrT0FpemVTMy96Mk1zK29DNFovQ2Z3d2dVRE9sQlp3UTBBMCtpNFBDaXluNzZSMzlFaWt0QWlOSGZDMWppV3VTSVMvSFRIM3B4MkNIdVRHY05EZFB4WkZjM1lEYWtpeCs4cE1LN2VMNTNnSE4wWVJDRzJ6TGlKWlZZWVJ6WUZVSGtQemREQUYzRndxTWdlWjdET2pLQk5PTWhkTVMzNHQ0NWtkeWc5ZW5uZUxQeGxCOEEweTZkVDE2eExIZ3dONnkxQnEyMW5YcGxNSnBVem14ZXV2TGtzeGV1UDkxYU82KzkvT0hSY1NrcmRBNTNicno5NXIwYjcreHRiMjNmdmJHM2RXODBuVHg0cUlnZnI1L2RuR2Jsby9mZlB0dDc4NFdQUGw5dk5oWTN6N3p5UjkrNmZPMWFwNnNkMStUN1B2ZGptcnF6OWY2b2UxREs1L3F6L0J1Ly9TKysvNHQvK2NhYkw1MjcrdlJFZTZ6dXNWVGN1SEJCbW4vbjdkK1p6Z1pZd0Y3WG90VUo2Vm4xNFdSbGRVRFNPOTVRaDdTMktleExvZWpuMEpEWk5HSTZyRW9hZzRMbEF6MjB0TFZ3TkI4K1p3SWNyUklCWmRBelNoSVhUVVgrWTRpSnZIM0g4Z3oyN2hWaExFK0lJdEJDeG1DWVdjQVR6cUVJY1RSSG1EZ0dHTWJGam5YajRaOE85OEhmbE1FM09JQUFwWmh4VDJLQ1RMbjhmL09mL25Wc0kybWxzV1ZqS1NBRzZWeEZhcWptbjFsRmt2R1R2VkE1SmcxRG1pbXNsV2l3b2FieTR4Wldqa1V3WGhCa2JOd3hsWWpnd05XQXQ0RElXR1luR2pDeGhSUzFhWG13QUdOYkV3eVR3SllrTGlic3VpVTZuNkJ5clBCcFFxZElRbCt4UGxKR3p5dm9oUm1wU2RDelBSdXpNVEIrYjJ2dGNIdWp0YkQwc1U5OC8rYjVpOVZ5T1Y4cTdYYTZqeDd0YjIwL21BeTBnV2t1TGpTMW4xcGViR3Z2bjVXTDIyOThZM0RyMjUvK3dvOHZMbTlzNys1VTZ3dXQ5bEt1MThsS3VWSmpaV2YzcUgrd2ZlSDY5WVBEdlVLK25tV2ozUnZmR1I4OFhQL0UxNDRlM2loTytzM2xjOS82clgvNnhNZC9USG5pVjcvOXQ3ZDIzclNpYU1tbkhhUUp4VUdoZk9YYlE5eGhHN0NTTVJkOW1CTkRnYWF5STlSMDV0RTFiVnFrVnlpOG9SVkFzekRqZlQ3LytleERrSE96b29IN0lpY2NrbnJzajF4SE9zUXB6Q05RK1VjTlhRVGtsb3hIbmJBSitsaFdQSmFRVUJKR1p3R2laRm1vaFNKS2RaeVJqVWdqQ09WNjc5RFlTa2dSK1JNbEtlbzh1YXpSeC95ZUpjTE1BVVl6Zm8zZlpGaENvdnJKMFN6N3VTLzh1TVNUUXVwV2ZJb0tTVkE3Y2pheUsreWNwd1g3Z0JicFFjVXdnenBJNEpqSDc5YkFscUphWktwNXRCNDBkR0E5RjRuS0czNUpDWW5LMGhOU3NuTWw0UklzYXlnWkMwbU14eUg1SWVmSEUyVVhIcnpMS0h6UWR6YlRUYW96dXA5eXBIeFBqbWNaNk00di9tK3RBQ08xR0JUM2sxRnVVcWtmTkJjUGQ3ZHlXM2UzZmJNNzZmZDZ1ZWxvZWFGeDZkeTU1WlhsalkzMVVxWFM3dzZMcFZLN1Vhd2Z2TFgvMXJmV1ZsdUxpNjJOaTlmUFgzbGk2ODc3bFh4K01EamN1UHBzcVpDdk5ac1AzMzJsVkdzMUZsb1BiNzNYM1gxMDRVT2Z5SStPaDhYbTR0THFaSEI4NTQxdm5YbnFZOW83bCt2dFcxdXY3aC9ldGY2U1dzNk9aelNzWktKREIwYXdqVENad29vOWpSQU1vRWtZWXIrd2FRb0ZuYkNiRENaM3k2SkJZN0lnRUFJNFFnTU16SWc0QWI2YVlIRml6NVY2VW81anowbmJXd3JMcCtLWlVwUXh0Zi9FVUlleHVFOHNnUmlpWHM5b3FoZ0JZRlpNQXcxem1JUHdmQXBjb3l5QVozUnRJQXhoZHVhWCtQamt4UVZHVnZyeVQvOUVrZDBhV3paMEoycUpSY2VqaXlPYlJjNmZlelB1YkFoWDNZMlFCSXh6Mkl1cjd0VWkxc1ZXTldFdUp0NGtPbSt3SWRRc01Sczg1L3NXN09SckROZGZQS2xhWFhOSHNwT2hxVURuSW1oRE9BZDRjeUs3RStuRXJ1S1lIZ0tGZ3g2K3c1K0NXN0d1MnQ5dTFrRFJxMk04WkRkdi8rVUhpNnNIM2Q3Zy9adUh0OTY5cVhBdjY5YTRWcFhWNnJXeTdrMWJyZHJHMnNwaVpkWTZmdWZObC82NDJhdzg5Zkh2VzFoY3FEU1h1Z2M3V2JGVXJKYVh6bHpXUG1YUUh4M3YzbCs5ZVAzMmQvN3Q4cmtuRnRmUHR0ZldPa2NIeXhlZXFiWGE3N3p5UjVzWG4ram1NdDBSbENxTlFybjhqVmYrK1hCNGlEaXNZWVNKejM3S0VFclBNb0Fhc2dJV2NEcFFCMTQwU2lmNysrU2dTeXpTZXNCaTRYNjFzYUNhdUlvK3MzRCtGTVpFNmxlWE9CS09haExaT0lOY3l3c2syWmQzS1ZWckVJU2dxWUtqLzN6UlZwc2F2aWZkbGswbnkyQlNtREFUSzVncDRCeGVwa00yVVg0aW5VSGowU0JwbVQ1MElaejBCMk1JWFFlQXdOeTk2bEx5MVMvK1pNU2tZeFBBRVE5QTIyRk5DTHRMSUYyOExlZWR1SWtpdUU5Z1BvWXhoMWtjN05sWlQwVVdCRGtibE92STN6NFFpNFdMMjRobUpMVDU4Q3RBYUJpOVVsRDNsUVFxaHVEcitocXJJTmN1aXkyQWV1UWIvMEtMMGdHeEx0NktiUDh3dFlid2pVK0Z1M2l5eXlIdVdSSmloRWR6azlGczFHek5ybHo2NG52M2RyZTNIdTV0N2UzdEh2UUd2ZDN0dlZxajJhN2tWcks5aGZ6KzRmYkRTeGN2WFB6d3h5cWxiRHlaTFNoYjUwdWp6azU1Y2ZQdzRkMzhlRENiOUxxRDZjcVpTOHVyeTdudTluN25ZUGZ1blkwclQzZjI5dzYyN2x5NC90eGcwS3RrbGM1NG9uMVd1ZHA0NWQzZjdBOFBZcVVtUDRiUElwdkprLzdGZDdsQWwzOFhjTnp3aU9DeGF4bGk0d2pRM2wxZHJCLzZlUkJKa2lWQUNlNG9HSmJZRmNnOG1DcmlVeVc0RW5uZ2ZVWTZNV1VweHVWVkhQQ2E1aUhXVkVjYTUxQ2xFYWJ5ZWU1VGNYSlNFK1JPRjdoYmJQcm5nWTdmNGdDdnFjUDd5Qnp6UXV0NU5Ddk5OQzEyb1pFVVo3Z2dCVktoVkZRZzhqbC9CYTN5c1k1eWxvRk1SNkZZQWltb0pId3BLNVdWd2NwRjlRa3ZwRkIwZ2lpV3MzSlpGTkNhWEh4NGU1SVZVSExvTTR1V2pRNXY1WGpNeFhKQ2ViYVMrTW5TSnJVTnF5Z2krU1V0eGJUak9INUtUc2lSUHdLdW9QV2h6VG9QMzBhei9DaVhIL211bEIyT3NzTFlINlROcTZVYnpKazJQT01wbnlGemRtZTFzTWRSdExQN244d0tFOTJtcnZXT2U4MXF0VGNxOVhQWnlvVUxsNjQ5OVlrWG4zamhjdVBTMG1oenFicTdzOTg5T200dHJTNnVYeHdjOTNScnUvM2dnZUp3L1ltUGJyMzk3ZExDMnVIK3djTEZEMlg1MFIvL2k3OWZYVG8zbUpZMjI4dUt2cmQrL3plcXplYXN2OVB0OVZ2dHRlSEJYUmxtMXRtdDFocjFXcHNuTWZMTGJNclRGSHhGRE1tUklpbXlkUkdnakVFUUYyUUVvbDltY1FCaG5MRldDTmR0M2ZMZ1hFV3RmNnNBZHhNNExIb3ZiRXdsZGZrZ2hTeUF5c1NEUUREWVUxYWRUTWRqZnJWaGhKVjRyR3Y3MkZhVDZWQ01sUlFtMHhFME5wejQ2eXltdWkrU3RaMTdTQ3R5azQxUEp2SzNjRkRRQlVtVVhIUWdEVENQRmh5YWhya1VVMXUxY0wybDVmdnB1QldKNGNiQmVCd1plT2J5UU8xbStUMWtkR1dkOElHUzdPZS85QVd0TTRXaHRpdXlwcGFGbnlZUmczRTRRZlBaT2RWYWxRcGlwMmVXQjFtY1JFNFVxeGxWTkwyNWljMUxYQ25TdGw2SGdwaWE0UGFCaTNUeWF2YmFuZkt6d214ZENHdFd2T09TQ3pPR3dCWTJoT2lUNnlCd2ZGc3hwM1FaU0JTWURPdGdDNjBOM2NaQ1ErRHpScjJzcGRTcVhzaTAyeEVsamlCdFZEcDdHOE9qUjR2TjdOeFM5WWMvZHYzQ2V2UHlack00SFdoMWR6cUhPL2Z1TlJzMThXdzFGeFkyTmx1TFM3UHgrUEJnZjI5N2UrM0N4ZjdERyszTjgzdDNicXhmL1ZCK3VKY2I5UnFyWitXTXM1c1hicno5VW00NFhUaHp0Zi9vL2RGd1hGOVlMTmVhajdhMnNtcnQ1djF2N3g3Y1laM0xBMTd6ckhhMUl5M0pNVTZOeXA3ZVVZUzVSTUk2bGk3UWFrRW9ia2daVXA4OEFUZnBTNkI3bExPSi8wZ28waGNpazVrak5Sd1RZOXVDQ2hJaURkaVVPdEh0QlFuVG1FMUlEaElyWXp5T2t3bWpJZUlFblFET2NSWlBaQ0puVG4rTUFrZmpYMDEwNG5FRE9NNTRwSVNUWWtrZWpCWk1yQjJXU2RjQnBvQmUrOE0vLytXZjRVMEdndGxGY1lrNWFEazZBL0JOcFJvbmhVaG1kYWcvWW40ZTY2d0hzVk9KV2gwYTZuMjgrR3FBWWgyZmdVVU9TNGpDa2tadGhacmtSbmVTZ2FTVU4wbHlFcHdzaEFvb1RJQVN4bExiV1lwbDdTU21tSVlXdzVDdmhKR2JORXA0K1Zka1lxdGRqUTNCS3VKTFF5S0NUOXBxNnE5ZGV5SGZYeDMyajR1RmFWRmJqZTdCeGJObkd2WEtiREtjRnV2RFhxZkdUd0szOHNYYThhTzc5ZVgxZTI5K3AxaHB0TmJQN0QyOHA3dURVbk94V3F0bjFYcnZjSGZsNGhQRGZxOVlXNmcybG80ZXZuUDJxWTl0dmZGN1o1NzUrR0RRcmRUcW5iMUg3YlZOVFRRZGpSNGUzYnUzL1k2dWNqS0ZyS0liRjdhVnlUS2NzQjlCS0NIbFc1c0ZQQWhuRGZBYVNBakdUa2c4c0MxR2hPTzhpRmEyaTE3QzN3R2hNaTBvRVFRL0RKK0dFU2lpVk5abEhsbEpCQll2aXVVenkrakR3V2xPK0ZJeGRjd2ZIbWN4KzVzaDlES05tdlBkS2U0VmIwNXFja0dDVHdwMzRUMEUzNmxBS3VaY204Q29CVk1rOW95aFdreUJ4dWFRL1lXdmZwSGd0bWt4R1laTG9ZMWtFZE51S3NLQkNIU2lQR0VkNno3QklSSzZpcmNzVkluWWJFM0RuUmFTQ0lPczhkQTN4RVVyaFR1NkViNEtRWnZBLzJjaVhmV3dNOWNzeHpRS1JFWVhSQzA3ZVNXUXdybFFDcHR1U1ZrdExBQ05IV21ncm12eHN5MWdQRmJFbUVjMm0rYk9ydjNjd1U1bm9pdGhsbDlvclN5MGFxdHJLMnViNjN1SGg1MmR2VW0zVTZsWGkrVjZhMm1wVUswZGJkMXBuN3MyNmgzdFA3cS9mTzdLL1J0dkRYdURsWE1YcXZWYWRYR2x1Ny9iUG5QeDIvL3E3NWVMMWZibHAvY2YzbTF1bkI4UFp3L3VQMWc5ZS9ubzNodnRqU3ZqOGFqV2JIL3J6WDl6MkxrbkdXUTR2SVJIQ1E1Y0J5UThjb01oTWpCaFZBWXdKdmFFV0lvd1FpcTVJMVhFQWN5ZEZlaFBhSVduaGlqSHpPYzBDMU9JMGlsSGZRS2pvdWlTeUVrMDVtdTBSMXNDMDZoRGtPSUpiRUtrdFNHSEdnTWlkYW93SjNycGNBRGdYMStCYVpLTUVBbHN3cHVWRUlTRVZFczgxSXNNNmpXMUdiSlVxZUZNdURzY0ZZelNuRmlWTkJyaVI2eVJrRk54RkNzQWlHTVRxNm5Wd01NWmNPeGRPSUdsSTYyVHg5SHZFckVlK3NwemtsNjFCSlJrV0UweVdRSGlHeWw1UDRoVkhrbzZzbTJDdEozVVNab1F1R2tub3kyTlRuRHdTaGhyOTZiOGpkdW94Mmt6dzhEeGlGVUVXL25MUnJSRlo5T1Yxa2Q3QnhlR3h3Yzd1L2VYMXM1cjA5SnNOcXJWVWpXYlZHdXQvZTFIbTVldmpucjl5U3lyMWNybFdrc0RLL1ZHdmJWY2FXOTBENCtXMXRhcjljcmhvL3ZhUUplYUs1MTdyeFZMbFkxckwreTgrNDIydHZqMzNqdi94QXZIbmIzQjRmYmgzdmJaSjEvY2UzUmZWNFBlNGY2dmZlc1hjNFdKZHUxeWl3emwvK0tGZHJLTWJHZDMrdkdDcldUakNaSjNiVW1obk5SSWRZN3BFLys3WUZhUmE0aDBoSXdPc29OeHhLanpPa25RM29DTGpNZzB0cjVxalJFOTFqZW5PWCtNSmdIaEFFOTRzNjl5cC9EbXBBR3FKUlFUTUpJSUM5RmNJeHZDY0xhdjR6WkRuSnlNVkl1SGQrb2k4MlhFQStjSG1ndFFqL2dydkJCT3Ric3Nza0lyM29LYzViSy85UFdmSlhnZGdUNGNyRllIb3puS0JVU2xGem5iZTIrNkNXYWppWFRITkdlL2dvY1ptOUM4cUpCZG9BR3NoeTFKeGpZMjhTM3RwTE1PN2pVRmVBRUloU0ZtYk1HNWtXSWZqZ0pqaFQzSkc3TmpIV3JJTUkwOWxHSmRLb3VNMnk3MlFEb3dveGFEcHNaVW1KaGhNdWJGODE5NmRIdi96dTFiSzV1WGFyWHFRcVBHUDFmS2pTOWNmcUxJeDA1eTVVcVovOG8xNlkvNmc0V05DOGRIZTRzYlY3NzcwaCtVdEtHcEY3Vi9QLy9rODczZWtiWTc0OTdoMGFNNzljWDEya0s3dnJRK3F5OVBqbmV5U3IxY1g5dzhmNjEvdkRzNjd2YkcwNFZtczlQdi92NXJ2NlRrb1dCVElwRThZU3pjZ0dCNHowa0JMRVUxMnVIbk9SMXhtdkhPZnNLYnpJOXhwSmFkTDZ2UllxaTlFRnlNa0RkUUgzTzRHTy9rekZaRGNPUUcwRVl3T1VUMG1RR1RtUlUrbzlqSndtaU9PT2lqd3ZVR0haY2c0Ryt1T05vSE9ZNDU1ajdGYWN3UERxN1FXQW9WODlMNkFRdnMrYzJHSWZQMTVyR3o3Szk4L1djbGdQY1lvbkpBazk4VjBUdzFkQjUzc0taQUpvaFZpZG94TFpXZ0YwQWJQcG11Q0ZHNE50aDVzVmtYTE1VWUxpVHFoZEF5TkRMTlU2eGpGMVZQZml1TG1BNzlKOXh4UzI5dXNXMEZZdGIzbDJFVDM0TWJMMWEyblE2Q1hvQlhWT3dGRmVZYXpoMnNwa1lDUXpaSWJtUDlNNFhSczd2YjIwc3JHMXNQM3I5dzZjTE5OMTgvZCtIQ0QvL3dwNy83Mm10THk0dkQ3bkd6dlhTMGRYZjEvQld0N3R2djNwak9pdjJqM2VYTjg0ZTd1N2w4dG43dDJlUHRoMW0xY2VlNzM5bTRjTFZZTE92cXQzdlFxWlpMeC92YnErZXZIVDY2VjJtdGFPK2oyOW43Nzc2OGVlWFovdjVPdnJuNGg5LytYNHBGUWtGMjhxWlNGcE9KOEFiK2N4R0dyWjh0VEVwTFBad2dsbTJsQjNjL0dnTlMxMTVIbmZSV3JiRTJ2T05ZSFJDalByRDF4eG9pc0ZFVVBoUWxWVUVGdmhVTFV0MmtCeGNaMmVzaDhDNGFJRW5VTkZZOGtwU01vNXY1ZzlJajVKdFlUT0VYQmptcE9SS1kzTjdrSURJSWQvQTRPNkFZSHNRMEJiZ2tianl0VjlFSU94cUpzci95ODE5Q0FnSVRzUlNYYnFsd2NxQkh3VllReEpvZzdnbjBFd3FXQXNqb2lPS3JNSXg1d1JmV21qVGtRMlpFZEpOQXAwbTRLNkRIczVFVE03OHo0VWN1QktpUGtXSjk3SXhPcXA2TmRaa2l3N01xNEdPakVPVWFibE9xaWNmNGtEQ1dBcUFYQ3dxdjZiWFlKSmIzZjVQQzJaVXY1b2VOb3E0aHc5N3l5dnFIbjd1K3NOQmVYVjI0ZnYzeUs3Ly9PMCsvK05IeFlLQ05UYjJ4OFA0YmY3Sis3Ym50TysrVks1VmlWdGgrOEdCcGZhTmFuTDM5amQrdXI1eXBsd3Zubm5yeDltdS91MzdsZWVYNFVtRTBQTm9yVmV2YThmY0gzYXlZdmZUUGY3RllyaTFmZmJaV2JVcWduWU9kUDM3em4rc3UzOExJQzRRejlnbjdPVnFkVFdqUWxxcEI2UUMybWFONGljd0RNQmFFVUFvaVFzQ0doZ0xyd3lRaVJIWVAyTWxRWTlVRmpuQjB6bEJ2cEExR3pjTlFYU1ppLzZWRFRVMEhINjlXUVJEUVZLZU43TUcwdmUwUUtMSGxGTThmQnhsZGhVaUllR1VlSDJyQlNMQjNKbHovTFNRTHdXRk5ueW5nRXhnR2dnaVk1aXo3eTcvd2M3WnVGQU1TUThJNWNObHFlYjh1Vm5TNUlLWUlGT3Q0Z1VGTy9IU3BWZ2NmTzRCRDZyV0dtaFBqU3l5c0NZenhRemhpRjh0NG42Mjlpb05iWVozencxMmlYM2s5endZR1N1c3ZSZG1PUTZlS1FwcG50U1RkWklYVXBUV1FGMC84eFJKaS9lakNFV1M2UTdDYllKQTd0L2JqVjg1ODh1Sm03Uk1mZjNKbHRmM1p6MzVpb1Y3cWR6dkhCN3ZYcjExYzJqZ3IyYWVUVWJGY2xtYjMzbjE5a2l2VkZ4Ykh3K0g1SjUvYnYzY2pYMmt2WDdoY0xPYkcrV3E5MGR4OTlHQmhaVjFMcXJxd1VHNnRiYjMrQjYxelQvZDNicGViUzlwZ0xDMDN1dHQzcTB0bmR2WjJTcVhxT3pkZWV2ZkJIL0p3UFVJVkE4dXZObHBZRDFmRXJoaXpHaXR3eGgxU1pHc2JIRldNZDl0SlhIcHFuVUFkZXVvR0FBanJHM0JJKy9HVm02cUpid2pZUUVnaW51bXFpM2lTUGRQS2tmOTRWNVVMaGpmdWhERFN4UVhFL1k0U3VqUlk4d3VYM3Rwa0tzZ0pVUDg1Wk4xeWVNYStVcFZxWGRpUlRpOFJTQUQxNC9WNVFWQXJ4bExGdWJRMHE0aWRRSFVpcnpGY3NKYm0vK29Ydm96RUlpSmVFWEorU2dLcm90dDZlYzJDY1k4eEhCNDZMd3lUQzB6REFFd3Z3RFVBdW5HUVIyVFFFQ3RTTmU5TmFIZE94T2UwUVZlQzkzc1dDU2t0UlNOTXZMdUV6dFlmcFRFUVprUXIrMHRzTWFUTlJQWTN4SFZEOXdBc0dGdkI4a2cwekhuMTdFOWNPL05UbHk2dTZ5YTIxV3BjZStLSjJmQm8xRDllUDdPMmNmWkNyVnJpb1dTcGRMQjFmM0YxTlQ4YlBucm41ZTVndEhyK2VyN2MxSjNMK3FVbmJyejJyVWFqUFo0Vjd2emhQMnV1bktzMktnL2YrczV4ZjdTeXVyNi84NmphWHR4NjV6djFwVFAxUm1zMHl4WGI1eWZIajdMbXhzTEsycjN2dnJKL3ZIZmo0YmUwNjBNaUczRXVQNkZNdzVha3k0OVdmTGJ3aVI1aVVXRU9rY1dHRVdlQm5wdWVncmt4RnJ4bEJnMVVwRWRraDhtOGVZRlN0UkthOGdMOHlPZ09HWnNZam01cWN0SXIvMDNLWk9Zd0x5a2FZeEN5aXNaVGUzUzRUUlh6ZWZKSVR3UURGK2x3TnhHc0VTRWR0WDBGZzFTa0liV3c2R1FhOVZ0RjRvcWFOMkRNUjVjRmhmdFhKVVJrZFlkdStpaVdjblRJVHdlOWF0aUdCdjF3bGRRaWVxRkU2VUVVRW53MEVBcVZnRUpEckIzaWtzNlJIdmw4MDAwZGI5cEZSbGQ4QXhDajAvUVdxV0RGdldqOFJoMzhaQTd6aExPNWNiQUdLQmdyWm1TczhhRy9TTUhqVml3azFNWFZUMzdxMmI5WUxzM0toZEdWSzVkeVdTazNIcmI0ZjNtdDk5OSs3WnUvK2J0bno1L05GY3Y1UW5Hd2V6OWZYMWhZWGgrUHh5dWI1eVg1d1lPN3crbUVyNXkwMjZWcW85NXNUdnNIaTFjKzFHd3VaclBoOXQwYml5c2J3LzVSYzNGdGVXVnBiK3R1YmZuc3JIZVE5UjhWR212aVdTbVdPM3ZiaDFuM3ZUdC9RRWo0b0NnNHlDNUlTSjdoalZYc3I0SmhPU2RpcWFGdUhreDRaNitHRk5RRkJBMU5qRG5tdTFlMWxkMFZVUElaa2FxejU5TWFVbE1FTWFXU3F1SWdPQWpCbDlaRXI4RzZVcWl0ZVR3cG5vYXJnSXpSRXBCZUpJSUxjY0hrYWpPRHFNd2NCM0hIU1UyRnYvaVBzUGlYQ1I2NzByd1k0N05PREVrelVDUnRlQmF4N1Z6MUVlV3NHUzRsSWpROTgxRm4vOTVmK0VvSUxvSGlqQ1Y4MWtGcVNXRVJHUVdBaWRRL1A2RGxTRnNaeHBxTVVSb0x1WnVBek8wbDZGV0xvTURjY000bUl6Ymx5c1NLZGY4WXFlTmVpWG1jRy9LSkxvWnd6eHFMZzlGTUFVTlpNWjQwQVNCbnhBQzlXbFFTUVhNeHlzdGRvekJuM0xmWktjM2ErWi8vMG4rMTBLaGNPTCt4dXR5Ni9mN3Q1Y1c2N2k4YmplYjJuZHVkVHZmS1U4OVVTcm1EdXpjbFZhbGNhaXl1OVR1ZGpVdFBTcUQzWC81bXBkRnFiNTdOVGNkM1h2Mm03cFlMcFZKajZlejk3MzV6Y2VQeWJOZzUrK3dudTN0Ymkrc1haNGZ2bDVhdkhtN2RhQzV1RkZ2THM5Rm9WbDlXc0l4NnZVUGRBUnpkdUxQMUtyWkdlQXdkc3RuU2JCZVVoOVQwVlJna1pCamJXbUlCeVBpK3FlK1hNZ0QxUWFwWCttUTFEVTZFakE3ZFo4TEZmb0VIeTh0eFEveWJtZ0tGVHA1SEFBdUtFRGRyVFdYcnc5Y0gyeVJhSWJrNWlTUHloVFNFTWs1aWZyOVlpbkhaa0Y5VUM5WWdBMHdiSkV4aXlHSmJsT0FhWXVrbFFHNTJySjFhVTZLMXU2TU9NaWNPS29UbE9zbTNUVUo4OEJpWUxnNStWb3d4bERCd3NOQWZMZFJtdCtrak9FQnBPeU9IcFZlOHBhMFhockFXM3NLeHExRlRHWjJZWm84ZUNkNnhUb0tmaktkRGhkVDhhVHQ3RXVWNFBwZ0JEWXNCL2pCbHJ6TEdjUDdnQkQrYnF6RnFjajFoZW91blc4SVFYZm5wL1ByM0xWV3o1WGFqbU9VT09xUE56YlBUZnVmaGU2OXA4NzEvNTkzMjBrS3V0OTllTzdkKzRkS05iL3hXcTcweDZ1NXAyNzExOTUzYnYvZExsNTc5MEdqM2xtYXQxUnZubjNsaC8vWGZLdVlMQzZzYnE1ZWVPdGk2ZCt1VjM5UHVLYXMxOHFYU0tHdHQzWDZudm5KUlY4M2U0YVBld1Y0cHl5YWo2V3R2dmwxYjJoejFEMlF3eklYaDV3YjBnMFZqbzh1OTZaRGtpWXpRNXZrakhoTWd0Yno0ZVFRcEs4T05uSzlMOFpSZkNkT2ZOVmVveXQwWlRpRm1kR21RalR4SlhMbk5pQzdIWStSNVF0V1kySGpnVHBDUWNXbUJDd21NZkJRdTQrcU11OWlxY3FzMW5xamdSQ04wNEJ3L2ErQy9xZ2hrUDJ1LzI5SEtidHJRNnNJdUlEMm1reFRxRUV4aE5sZkVGNU1TUXQ0amtFL05PZDY2OFEwYk1hRHMvbVcwRDBOaEwyREpuK0xCS3J0UGhhc1p4VFVoeXdnTUdJYkczbUh4NEdNYW13dHhFaXo1VXFxV3VVS085Q2tpS2E4UTkwNkdKK3NqYjJuaUUxMGFLSEhtNnJGRVlNWWNYRmRWNlZLb1NsWm4yYUFlUWM5RnpiV0dhbm5ZV0xURDVmN0xWN09GanozMzcxODh1NWFiRE41NDVYVlphOVRaN3h3ZGJWNTZzc3kvb011MVY4NTBIdDdldlA2aE1yLzZNUzFVNnFPajNmYlpxNHZyNXlhRFFhN1dQdlAwODR1cjUxNzlyWDkyOWZudmIxOTZialRvSzc0cTFWcWxXczZOZTgybGpWS2xzbmZyTllYNDVwVVBEVHY3dys1ZWErM1MzczY5U3FVMkdJM0h3MzZ4MnZpWHYvL2Y1dk1qdG9heW5GT01QL1pNS1NyVnpPK09DRzB2Qmh2WkZlOTVZRy8rMUNUbHcwQ1JhVXJNZ3l1OTdXQ01rQ2NNMkRjRWlwVE5KcFN4ekJWSEJnc28rZG9wMDRQMFBQU3IxL01wVC9xaE5VTWdnMGNNRTZrWEhBMDduaXlEQjh5RERCZ09aSDA2V0ZpY0lPbENQTHNaUjRNQkp0QTl5cndoQ2w0UndFRmdlZ1VEWFRGV0NwdXZnNFhDWnNMTXRWWmhIS3pta3lFcVN3cEErenJQN2NkOHlxYmVJYWdiTHRSZUxVRTg1K000azVKRUlmSG1pUFg2NHphVXVLUjJ4T3NRa2xWSjBJLzVlSjJ5TzIvNE81RXpWSG5GRXhEQk5DZHNnWlEwUmxvYlh0RGFGTEVYZElLUm5INk95WFVwdnRDaUZ4ZFE0b0FyMXNlZS9mTDFpNWRxbGRMOUJ3OFhWOVkzTjViR3ZjN1pTMWYzN3J6enpzdC9VcXEyU3VWaVBwc1dzdUp3a2g4ZTdaVHExWEs5ZGYvMTN4MTFqMWF1UDErdjF1VGx2YnZ2bm4vNmhULzQ1WCs0ZC9QMVNxVThtd3h2L3VHLzdCMGR0QzgrdDcvOW9GaGI3QjNzMXBjMkpzTnVhKzFNZGZuaTBlN0RsVXNmT3RqYkxwV0tHMmN1M041OWE1cnZoSHQwTzZRdzBqWmRBQTVYT0NudzFlVmduQ215L0Q0R0N3QUYvQ1RIR0xiazNHMnhtVkZuS1pBRW80ZkNuTmpVd2JlTHROMmg1bGZ3c2t6UnFubGhGZkh1dzlUK3NnRnZpRnVtZUJkUlJXZmhJeDUxMWtWVkxySC81Vm1RZ29sNEhLMWdrWS9rRjd3OHhPT0FKSHB5RSsrbHlIRTRYRzZLSnhhT0pnYXhNQWdVdUliWGlDdXVKb3BlaDVZbmlpSXFKaFlwcmlma0JFUndFcDhFcWc3dDUrRTFqMGhrU3ZESlpGNHhrSEdvVjQzMFg0RWM5L1N5TXJSa21DT09LTEFTR1F3SnUwanRPcGpZZ1M2TVVBeFJvS3VwR0lZcCt4a2lPZVNpb0tvM0xUNTRnR1B6SWEyTFRsb293OW5ZSC8rU1dUMGpXeGUwc0FLeVA2NGdCUHpwWTNuejJ0a2YrTWl6UDdPNjNOemVlbmp6elRkYnpkcnVuYmZQUFBIMGJOeGZQbjk1K2V6VmNyMDZHdlFLcFVwbjUrNXc3NTZ1L3ROQmYrbk14Y2JpeHZiTjE1VkFpb3VMV3ZqOFdQYnl4c1VQZnlRMzZaYWFpd3ZMYTJ0UFBuMy85VDhwVnR2eXpQSDIzV0orZHV2YmYzaDAxQmxwY3o4YkhlMDlVc1FNdTBjeVFiMjkrSzNYL21kL1hEUlhrbENXakxlSCtFUTBINjFUYUJKdE9tY0tZaDc0S2hhbFFJa2Z1ZU4zN29oc2h5d0x4ZC9EY2VoN2YrTTN3Q1BNeGFHb2tDM21TOFZjc1RncnFoYW1wTnZ5R2YvaXdiODNvSjBZSC83Z3MzNU9CbDVZNGxBaTJ2bVd0bnJMR2tVdnk4MGZHWUUzQWVqNDkxbFc1cytGeitUaDBvZ2xlOW9SZ2tOOU1iYi9IUVoyS0xXNlRrS09UM2ZDZ1JqakUvOWlKWXoyMVQ0Q0p1MlNlVjNqY1VjNXdFbThwY2pKL3VLZi96bWhOSWxFWXh2TjRneFpvWE9ZQ0NEZ1ZEbTBkUVZRTFRrZ0V5WmlpVE40MGNCQWNsdGloNm5qMG56UXh4ZzAwWUdHcEhQMjZ5bXBUNGNPYUczZ1NQRE1hVlptQjMvKzRvUUVLckJVQ0lPUjZabVVmaDBheWQySSs2QkRRbUZ3a0Y2Yks4Ly8rUy85cDgxNi9lRFIzYTJkZzBaamtkOUVIWTZYVmpkbWs5NDBsMDFIZy95a1gxOVlIbzhHemVVTnNSa1BCNFZTdmIxMnB0SmVHWGFQaThXc2YzVHc2SjJYbXh1WHRtNjh1bmJ4aVVwalllZnVqWWQzM3QrODlvSVduVzRjY3RQaDhwbkx4Vkt4c253MkczZno1Y2FkVjM2enRueCswRGtrUmVYTC9kendOLy9nYi9sTE1jU09wSFBJQ2xTb09UY0g2RFdnVGxJcjN3eU5KUXRONm1kd0trTExJZ0kwZ0ZIUWlSVlhOTzV3b1RSdkNyL0dvU1pSN210RnBIQTNXVkVNOTBvTGpJZjRjNE1lTGpsMTBwRDBpU211SnFHQ1Y1N2ZLR0F5eXlMalI4WVI3T1doaGl1Rm5kYUUzQ1VJbDlxOVVJcU1JUUhEd1U0UGRpSTZLWm9DQ285U3dNUmMrTi9MejAwSHR1NVYvdEl2L0xRalQ2TUpMR0pId3lKaS9LTEFpVFNab2c0WjZOTThPZ0ZRWUtKaWd0aEZSUGFOUXdPNWVNRkgxN2I1SXZaRmpRME1RYzh5aUdlTzdGekFlNDBoSGhkR1QwTWRxdENVK3hETm9ydGZOcWFON2tTQ05nTHlBZWJBcDBwdzNoTHJwZnFyWC9pL2xndmw5OTk3L2ZCNDJHdzAzM3o1ajB1ejhiVm5uczJQanJSUkdZL3owM0h2N05Wblo0Vnk1OUZkQ1NxSFBucnZ0ZlZyVC9lUGovTlpsVis4S1ZmcnpjWGUwV0Y5YVdWOGRLQlJpeXNiQ3l1cmQzN3ZmNWtXU2h2WG5qMjY5MVp2NTM1OTdkS3MzT2gydWdmYnQ5Y3VQajNObDFxTGEwZmRvK04rcnRsYXVMdjMzdHUzL28zU3RyTXlndnFIR3lPWTFPUUwxTjdiQklad2pGbzBEbk9ITzM3bGx6WVlRaEVuWXFKRXA3bUtqRkEyYlF4bktqTWhjT21sVDFNNGN1SE1CMXFaVWhjQnlVVGl0MGg4cnR0NVhhTXRCa3VJNndIenFvKzF3REk1S1k1T09TRisyc3h5RWRUdXduY0VOT2RVQXFtaVVHR3NEK2RwZXg1NlVKSUJybXFaSSt6cGRVN2pDWkdhd3F2QmJ6QjVBamdVdksvUzduWTRmOXJOTHNxM2pNS3orK0Zhb01nak90V2wwQk9neUFKUE12YUZJd2k0WG9qVmhLMFlUeFZCRXNTRU8vZnBhdExsVFJnWVQwRzQ2eGp6NUVROFdYbGNha0o0clN2clkrRmxMVGJjeUk2ZXFNTkpoRmJNRGlaWEtmUHBFczgvWVNIalVPUWhldzRpdVVmbksyZSsvK3pHcFFkM2I3M3lKOTlSYjdWY1dGbmJIQTlHdFZwbDJEbTg5LzZkVXJYVWFEVHYzM3F2V3F0VzJodTl6bTZsMWxxLzhody9CNXBsNzMvcjEvdTc5L1BGOHZhRDJ3dm5ycFN6NHZyMVovZnUzK29lZDNLVjlybFAvT2pPN1hmazh0V3JMeTVmZlBLN2YvQ3Jzb20yRU4zZHJjN2UxdHFGNjlQQjBYQXdYR28xU3RYS285MGJXVW5iakVLeHBHMUdvYUx3S3ZKdjB0aHBaTHFUTHFCTHhnK21TUytsV0E3MkhvbEFCLzlXaGtqVVJsc0UwcENmWitNL0V5anUrUG5MdkV6Qm1za3lMU3ArNU5jQnJZME5QM1FkZTZTTXI2eFIrT2FhT1pjeTlSYUt1VkpKQkFoSVJIdDI1UXc0YUFsb09rbFN5Q1NiRjR4NldUTXNxSFNQUWRIYW9rL0lpRXM4R2w3a1BwRjlBT0ZFUGt4eFJRalE0dW1FdHlnS0dLVTdOa1g1Y2E0d3lldlFUcVl3NFc1TVMxeUhyMlljMnB0bkdzdDdaYXA5VXlGdTNndXBYNTEvL3VkL3dsTkcwTE1JRklVT09iWkJEbXVpRHhZYWE1RXNreWdSbVhqajhpRjZEVUJrQ2NkVEtxME5oelhMZ0R6Tm5TVXAzL3FZRjZ1RmpCOWY5MksvemtyendUSmpGQmJ4cFlTcmlmYWkyRTAyS09pcVJNTHo1Q3dEWWVKT2k4U0NiUTF3Y3hYWFdiVlVITzB5ZWJXeTl0T2YveHVOU3FHOXVsWXFsUzVjdktUaDQwbXVVcStkUFgrK2Y3VFhPVHE4Y08zcGNYZW4wVnJRYk1WeWJmZjIyL2xLWGZ2YzZhUmZYVmp0N0cvbHg5MkZqYXVWTExmOXpyZWFaNjdWR2kzZEtlZTFBZXAxczluazhPNDdpK2V1bFJaWFI0TlJ2ZFY2K09aTEY1Nzd2dTdoOXNyNUsrKzg4MDRwUCtQT2RYRFlYRnIvMTkvNG04UFJ2c0tINkZRNElMQU80aVlBNmNBRGhZZ1ppZStnRjRDWFNiTWE0V3NXV1UxRS9zVmVWajhiY2U1aVk0M3o2TVE4RldyY0pEaVhlenJSTXNROGRUaW1IYzNDZzZTTFhvRlJBTFNRK0JLUGpJbUp4ZEtCenYwR0ZtWmVFam5NNGU4WGFGb1NsRlFGa3R0cUFIS3lZcFUwYnhmalZVWkZ1Q3RPNS9zVGo0S3pkV2RtRHhlR1FDY1cvR3lINXp3bmVGc0dRcDJtQlcwbnhzcnIvSjRjK3djQVoySWwrL0ZrN0xhS2NqYjVPT1ZteGFXL2pFaUVlOS9pRlVJdUgrZmlTZUtRWURVVDFYNm9vaVlzSXJJbmZEQjlrUE5UbDdUKzRDbitzZHdsTHBsZXpwYXdxTzVMcTlhMVFDbXAyTEFYOFpadm0zU2d2N000VGlyNWd1eFlJWXo0WmlMeEJLcGNtSDdvcWY5MXZaUWRIQnk4L2UxdnZmL1dtM3dOcTF6YnVuZTd0Ykk1NkE4azBNTDZlWEdjNXJQcGVDamVzK0Z4NTJoL2RMeGZxbFo3QndlYTQ5d3pIMzkwNy81NFBLcXVuQ3MzbHZaMzkyVEV4dnFGMldpNHVMeStmUFhGeFF0WEI0ZTd4OXNQWC91Vlh4eU5jbzIxODRmYkQ5ZXV2ZWo5MnZGTHYvbXIyc1pvVzM4OFBEallmMmYrZFdIWFpOeFFoQ3pPemFsenVUS29VNzZTcmxTVmRNN1kxbE85V0tlWVZaVHBJNHVUc05XVnE3Z3BEdVJmcjN1ellpTHhLWlVZV3hGYkVkSEw3RnhuMUNVYk1sM0JWeEtHSzlrTHFiSGxrbnN6Ym5ETFhEV2dMeWVENDV0ODBXdkdvSmNLdXFnSEZMSUw0aUVTYjlvNlhjcmxYZzBDY1R5SmxhOFZ4ODBlRVp5eXJjS2VGTTdPbGxzeWRpOXkwYmpBRDV6TnNqeFpuNStUMGNGS0k3WDdNa0tVcDBOaFJIVDZnWGRFcDVzUjVHb081N0NSMGF0ak5ocHhFemFPSTdZb3dxZWFwZzVGUEZzanZqMFVPWnVFRFExSm5hQjNDdWZ3ZFlDc3p3UEVNQUVMY2w2SVlObk9GcFRadUV0akg0aVA0MG1Ga3hrVzlZckhkVVM4VHZZdUh2RjN6QlVidFN4M2Z2UHpUMS81cUxadTNZTjk2ZkdqWC9wcXRWWS9QdGlWRUdWWnJWUjhjUHU5U21PeGQ3ejM4TzFYSmFVR2F6VSsrYkVmWEQrN1djSFZ0YzdPdlVxamZlR0ZIK3p0UGhSVnJiMzU4SS8vNWRHRG01azAxZFRWK3ZIaDl1Qm9mLy8remNXMXMwdm56dmJ1dlhibTZqUGFEbFVYVmdiRDhkV25YcGdVU3IzajQ4UGUrSzBiZjFDdUt0b1ZRQlRMaWZRNmlEWkNtakNTT2xLU0RPcWJEMGV6a01Bc0RFZDhDaXpuWTFuS1BQamV2U2lGTDVSU0FoWlRBcEhJWm1ERXREYzVXYmxZOUVyQTJ0VGVxM2dmcGIxTkdvSUFZbWc1dVFRNHhiTHd2S2tnNGVzeWdqZDRLQlJwaUJCSGVGeUpzMlJrUktDVFA1Q3FGYnVLWmc0QkNsTTJNd3AwN3pjY0RvRW5oZk1vcHVCZFNrRUJyUTBBYTBTVEZnditSZTlVRUVPckFvYW5TdmIxcjM1MnZ1WHdabDFIM0VGNmUrS21JY0pSK1Z6UnlVeGVlWFNCSTFqWm5KRHNGYTlzVkNTVWNya3c2VEFUSlhmUmU2K1NIdGNveHd1akpTUTE5SkprQUE1NnNlS1RHbEtTakJCR2s5YXlrNHF2VHp4bkUxWUtVWk8rY0VSQm1RWWlNZzNJV0Fod0d1czFtM3pxeGYvTlFuTzVrazBiNWVuNTYwOXBLUThIL1hlLys5YVZwNTdaMkZnWkQvcWxTdTNPSzMvWVhqOVRhUzdtaTVWYW82a01VVzF2SGp5NHBjdGVZMldqLytodXJiMmFsYXVUZnJlMnVLYlZNdXdlWm9YWjRzWVY1WkNkKzdkcTFWTHZ6bmNXTHo1VmE2OW50V1ovTUdvdHIrL3Q3UTRPVmZaWHpwdy8yTnRXOUJ6Mng2L2UrRWVqOFlGRVZRRG9PdVlRUVdqVkRsd3JSK0ZhNWdXdUxnVzlTUnh1U1VsYlJlTWQ3YkhETVFMMXlRWWF6bGFjZ2JhYXI0MmVaTTVDdHRNcGJCcGJjUGRwSHBrVWRtRkowOXUyUEpNWFVyMlNuSDhPa2ZEYXNxaUd2Nm1wRFBrWnZ2eUdubDRKRnRxcFdpL1ZjeVdFNUlwT21IcXNkeU5tUlRwSFZ3N2ZsME9uSGxOUTRXRkNYeUFMZ09sTVRXRDV5TDc2bFU4VDN3NWMxcFBqa3JDbVZ1WUdDQ1FFcWxsaGZ0Z3BZbitzSnhZQUg5NGlXUG50eFJqcm5icHJiWVA0YUoySWVYdWZPMXFDbnAwTGk4RkxoU3NBZ1M0TzR4ei9lU0t1V2VIKzhFMXlwaFgyV1VsZVN0ckswcFBReDRFeVBFTkVodlZOSnlLOVpLQjY3ZktMei82Q0JHdzNLOE5CVjc0dGxzdjgwN0pScmw2dnR0c0wwKzcrNGNIKzJzV3J0ZGJpNHZxbDhYaklsWFF5MFZTSDJ3OG12Y1BteXRuWmRGQ1lES2VGNnY2dGx4cXJaeXZOSmVseWNQKzkrdXE1Um51bHQvTitZL1ZDZmZYaXRGQSsycnE3c0haR053TmNqR2V6NWVYbHQxNS9hZjM4eGVGZ3RMYTVNWmlNWHJueFB4VXovL0tEWDdqUW9QSXJrU0R0ckNxMVEwVjk5QVNTYXh6dUZLQ1RiUVBBV1lPREp3WHptYTNhOGRnUkVwbEwwNmtMdExxOUJrd1ZwTUFZMXIyNlZXSzFZRWdka2poV0ZKMlErWm1Qd2cwQjRBK1pKUW5KZWNBSnBZUkVCeC91RmFYQ1ZOdHUxcm1MeVpTLzFhTklGbEtraW1JakdNVWFnQTVaZ1gxendqcGlteE1yeE15REtJWDdxWko5NWFzL29HanpycGx3ZEZpVG0xVnBEVVNXZFJhUGNIU2dLd0NJV3QxSGltd3k0bjFXM1VaRHFVTmR5cVJ3b0pleDhPYytXNWNudjkvcDk0K0VKT2k1VUxCbTJHbnB1dVQ5SEU4ZHlXcHlpUXpGM1k5aDM1QmhFVlVCWUxMQXFJNEx1dG9Bd3BDdTFNWGpDTlk5WC8vT1AvZlVmNUFiNXArNGZ1N2VlNi9mdi9GT3RkbXUxRnZEMFZUV2JqWDRVdDU0ME8xMytGOElGYjZkV3N1TmVrZDdDdFpoTWFzcXozZjNIclRXenV2S054bjJ5bzJGWWE4eksvQjFWYzFWS1d2SFdpbFhhM3VQN2xVcWpmdHZ2bFFxbDBzVmJSS0s3WE5QNkc3M2NHK3JWbS9xWnFYUmJOKzdlN05RcXU1MXR1OXUvN2EyRHhJU0hlVXQxTFJhRGgwVVF6OUp6ODhzV2wzOEZ4MEEwQVZJSzNvVWlhaDdRa1FraTY4WWFxeHdKMTBSbW01NGUyRWNBRGpiVUllTUthS3daNUtPNElJUWQ3QXlHUUJPbzh4RFdLOEZkamR1Q2VrUnVtOGtGa0Z3VzB1c3ExZ0tGd1cwczdwNnViRHpCNDFqSFE3QUdrVWU5RDVlcDhTRVNvZkNIV0lFNHJCa2RNYVNRWXJzNTc3eS9RcDF4M3JLN3RySmtMQUpVRytzSGJXeCtTYjZuZGZ6aER1aDc4VHNkd2tJWDI0eWVBVGt1SGZ1SjZCakxFSHNSTzdWUXR5cnFXWGdmWkdhWHAzb0ZuY2JhQ0xyRU9VeW50YWxMWVFHVHVRNmxKelF3QmgycEJEelIvaGdLdklUOTNXRUJEUnJ5NTgrYythejF5NXYzbmpsVDhwWjd1cUhQdEh2SGQrN2MvdldqWGQxbFZsWldxdzFHcEpsTUJoV0crMTZyVHcrM20rdG50ZUZldi9PMi9YMmFxWGU2T3crWEZoZWxiT0sxVVVGUXBHdGNlMzRZS3RTS2hmcjdYcXJmYkIxKytDOVAxNDVlNjNTYU8wK3VIbDAyRmsrZjcxY3Erdk81ODZiTDlXWDE0NjYvWGF6Y2V2VzdVYTlzZHUvdlh2NEtvSmJMMTJYckxMMzMvYVJQWWUvRU44bEFHaU1rNFpzNEEwSnJUVVQ1b0Jqb055bUJ2QTB4aEpNeEMzQjZ2R3BoMFRNUGwrQTB6ZDRtSGsxQmdkdzZsSTdIYVlSZTRKYlo2VGxMN1pGTGlpRk9uSU9EZHdSNmxrUVhHenVCcGdGSk1QNHMraUNVM3lEVmE4aVBoa280aHNZekVtaEN3eWQ1b2xNcXJPZis5SW5GWTVPNm14RmRLR1BXQ2NYUjB3VHBrU3piNG9GakZYN3JWM3dDbWgvZkY0dmtqM3h6SXQ3VXk3Z0pPOWd5RUx5eHNZRDFWUW5NM0xGMEJCbGR4NmVGaWFPYXQ0UER5dllaQmhYaFNCT3BnSFFoWXlnSjZiSjVBNGJZUnpyZU5FZXBxVWhyUHR6NS81S3M3Szgwc2cxcXNXMWMxY1BEM1lsZzVKenBjSS9jbHBzdDBxVml1OVY4bzFtdFZLcGpJWjlpWmdyMVZyTG04UEpxRnh2REkvMk5IbDFZWldINUZsUkZ5M3Q0UE9qM3VCb2IvL3VtODB6VjZ1VmFtUDVYUDlvZStuaXM5clR2LzNLTjNvSHgxbTFPVGphTHRhYVdiSFNYdC9ZZnUvMVAvNzJHMCsvOE15MzN2aC81L05qUWlEOFFjUlRPMlpvNHl3N3JCaWVEcjA1SzVZU2doOWc5eUJwS2F3aG9SMDNRUnNBSTFNMGNiY3BEQSs3V0RiTzR5d2EyeFp4YUVjVVdoNC9tOUZJQnhyN0NwRWhORU1RREx5bjBjdFNNZG9UQlE1S2UwMU5oaU9LcnQ0aXhqZXdBeWR2YWlYNFdUTTRHQ2VHenRtdzlHKzdFaVJHc3UySGlRNmdkR1lXSTFPd3E0aGNVNm9TSnZ1WkwzK01PQ2I2RlBRYTRIaDFrbFkwKzYwZnAyUSsvUXZHZTNjd1BQTW43b2xYWjNIbGFVMm96SjNDV2ljSkYra2ZudXlVK09hWUl4Mk1ldG5Ec01zZ25Wc0gzNHVFYk42eGtUSWtzZTNPdmh4ekpLWEE0VW1kMlBvUjdrNlZ0cklWTk1waG8vZzhjLzdjWHp5N1hKd09PN1hXMHEzdmZsdkpXRHVXOGJBN0dBNlBENDYwWXlsbG1XNUdKNk54cFZiVlRxUllyUTA2SFdsU3JsU0huVjNacjdtd3BGdjQvS2liMVZyVFFiZmJPUlFUTFlmWmRGUmZQcnYxM3V0WnFWaHJiMDZVK1V1OEFkOXNyNDU2eDczRG5mRjR0TFMya2E4MmxFMlU3UGVPT3JQYTlxUDlsL3lQRytWMDYwaDhVRmxGQjVJS1huZnlzcjcwRU9Mb0swcHBGbkZrYmMwa2pyZ2lPcEJrTzZ5Um1Jb2FIUGNHd3JrTkJhYjFRS2pKSGVxVThianA5QWcxaGRUSlk5VURnRkFlTXdjUlU2K1lWWlVkcEw0UXpVcFFSYVFpUFppTW1GTS80aENoOElDUWpZMEN3REhna0orSHUvQ0tGa0ZhSUdJRmdpYnJSUXhFYUNKNEdHMXBZSW9oQzhydUgxV2s4ZzFuMHJPMkpjUWZuNmVOT0NhTFQveDdFR0xrcE03VUNuUXVCY0t3QUJ5N1dqQVIyZHlPSWlvZnovSytuQ2puRmpTa0o5YWxvV0NOa2hqU2dYVE9zckY1TFp2c2d5L2tORURDT1pCczZIWEN6L2pGZmlKYXlGRWE2NnVsS1NqeWl0eE8zdEsyWjNubGkvWEt1VXRuRnZZUDltKy85aWZEM3ZHWnEwOGZQWHJZN3cyMkh0eTlmUFhxeXNiR3NIYzA2WGNMeXV2ZG8wSzVVaW5YdW5zUGQ5OTdiZlhpTmI3S2xGZmNON0p5cVhlNFcya3Q1NVRZVzJ0N2QyKzBGaFpucGFxMk5wSzV1M1ZiVzV3SGQ5NmZUQ2VWaGxiSFJtRTZXcjV3YlRnZWpiZnZka2JUY3FXcGZjNnRSNi8xUjkvdEQ3Y2xaQW1CSlR5SlZ0cmhMbFFoVFBTU21VSWZIOWdHYWx3b2hhVmFFVmRySElrWUxNU0VMMmRaa3gyRkE5MUxCZU41b1lReCtad09LVnhUZXlEV1pzbjU4R3dhaFpXZE45Um5Ta00rZU1FY0J6Z1FpUkpnc3hlaEdvbTVaeUdVZzQ4OHJxWkhSRnVLaW9zb0lYVndXbkV4Q01jVGJZU0hWNFJHMlVpQ1JFVm9zQy9RTUljWUJHbVFTSkJSQUZFdnBCVDU0cGRmZENhTzNVdUV2T0tWdUNjRXZYWHhoOXFVdjUyTXRlRTV5ZlJFc1hZa2hMdVllZFBDbkRyaUNpQ2VTR3FreVNTZkp2SGlRV2lOc293RXVrekFyWXpkeHRzUU9FZzdCcVFWSkFYc0FWbys4QUFPd0NqejNBU2NJQTBseFRFSXk1WlcxdjY5QzZ2Tjd0Rk9aMi9uM2U5OGMvUGFjNjMyVXF2ZEdzM3kvY0dndGJUY2F0UkxwZUxnY0svWVduNTQ0L1Z5cVZScHRiZ1JLR1dsZW1NODZIZDM3NWZLaFZLcEpxRTZCM3ZUL3FIMkVidnZ2ZHhjdjZqSTF5U3pmTEc1ZnY3K1M3OXgrV00vK3Nadi9OUGF5cG5HZ25iejc3WFhMeDMzTzUzZHJWR2hMcFZmZWUvWERvNy82TGgzMTRHRnF4RVc0UWtYTmlTUzJndGZSbElQWkN4YmJ6d2lsdGdGMklRYXBkSGhYR0pEQnpFamhGMk9qMjBpMGNzL3BpZVV5ZjJDbUloSXhpa09mQUxPZUlIQVpjMHNpQ0dRdXNmZklkU1Vvdk1NTUlyQ09ZMFdNMHZuMFlSWk9saHNBU1lnU2t6QzZLQlZWRGlLM1NXRVlrUmNVeXpER08xUVNCMzBPTUxnRjEzMG1vc3JoQkNJbUZMd3A3LzhZUjdVOC9DSGZVcmNVSktESTRpSmV6RlY0UEk1QktZZytvWFM3anhtaVZWQlVkdnBLVzVreWVJaElxSGdrRWNsNnJsU3pLcHJrSzRlOXBJRmsxZzhrTUhBRkJzVDU4OGRpejBWN0hhTWZlWllWNGsweVRXWWpBSUJDQ0luWDYrL3NOVDZXSzNZSzJlbFYzL25WNXJMNXo3MHFVL1BSdDI3dDI4L2V2aG8rOUhPWW51NVZxK1Zpc1d0Tys4ZjdUeVV1QnErMEY1bWd6NGVpbVZSK2J0WW1QV1BTbzEyc2R3b2xncVQvbjYxdVR3Yzh6M0RhbXVsZDN5UXowb1NlemdhVnFxMXhzYWxkMS85azhXbHBhUDkzY2xvdEhMdStzSHVWcTVjeTRyWmErLytZcGJySVdib0VzN0dmbzQyMndBOXcwdU9OQ2xKK0JHVzJnd0t3ZFhSd1Jrc0dPTDQ5SzJueklUZEdYaGlMOWhoU21hSXpRcFdDK3R5Z2dhQmpOQW9IbWZaZElJdEY1ODJReHl2TXBLUzZiejhJTkdsRFJUZU00YVZxU1lqMUdCR2djSEFHR1JrWmhmaEJRV3RsWXlCRVVrRWtGQkVrQ1NRU0ZvTEhtV1R3WklLNjhVNHNPQnROL2ZHaXo0Qi9yTHplRlp3Q21jdnJvMktIeGY2cnBSbjVQNnhGOTdVelk5eXVVSGVHRFl3dm1ITjhkOGJGZG02WVIycFM0bS9RTzVYbDNZcHVnNk04N3oxNVNhZUlvdGJKVDkrNFFOTXM2TFNoY3dtaytBREVnTnZNT29PS1dVaGJwVGlmV3dRZkVhQTl4VDlKbm5HejJ3TEYwOWpYQVRJZnJQME1CdWZGdk96ZHZzejdWYng4TER6Nk9HOXhjc3ZmT1J6UHlrK2Uvc0g0MXcyMUI0cUt4OEtIZzhuazBtNTNpeVY2NjJOUzVWV2V6anNIKzl1S1FXTXh4TXhyaTZ1MTg1K1NHRTBubzZHM2VPc3RpZ25MWis1MU5tNVA1a01KWHR1TXV6dlBjemFGKys5Ky9ycXVjdXRScmxhcTgzS3RWdHZ2NUlialRhdVBWK3IxTHZqQjZVaWwzSVhOaG8rNUJmMHMrZVEzKzZFQUNYWWkrRTVDR3duSlh2MUpacmtZOXdjWkFTRTkyKytDSmliLzJkV2NOUEp3NkNsQU1XQkhJNUs0U0tLQkVXVGc2MnhlOVZJa0tuc1RkS2tUdlI0d3dtQVQyR3JBNkVnRmdrTHdzWExEMG90SHgreHpCTm5RZENUSjVVVHRlRXdIMWc1Zy9LblRoS3RzbkxLdGlydWR3bWVIc0lGVTZEN3NwLyt5alBhZGZnSnVuQzhQY3ZERXpZdGJHbUllMjFMR0trcHFjbjl1SWlGcDRseEYweXRBS2FXYU1yeG1pZzlUR1JXVmN6S1hvWDNGSmpJZHh0OG9raEdZYUJlNnVXTkRQblUyU0FwemtocEppQzhKVExoMkhjNk1rVHBSeE1RT1JRRU96bHBYaVVrRVZSS0Z5clZIK3Z1N2F3c3QzdmQ3alBQZjZUWnJDbVVhN1g2OXM1K3VicVFsYXBMU3d1dDlySnVOeDdkK3U2VWFDdzJ0TGxwdFBMRm9yWXhXYVZXcWxSN0IxdWovdEcwVUJ4M2ovajBSRllscnplV2EwdG50OTk5ZVdGdHMxUnBJUEYwK04xdi9PSFpKNThyVm1yNXlYRDV6Slh0M2QzVzBycHkvNTJ0VjIvYy9aWHhwSXZTb2tSVWpVRElGRmhTRnA5aHRmQThrZWNMdTJDeW01QkVEdTRUa3FCUU03akF4dm1ZTW1kdWdGR3luSzFCb1MyeVdGMFlVQkFtcG9jdUNEUTQyRkJBY3puNTNnTEdGMjBzcjRaU2gzbnpjaEFBSUNkVnhBTkk0aFVxS1lGdy9CQ2hGVFdDeW44RXVvWVJQUUU1K0pnTjBZeWd3UUZzK1dLUUtNRFA5UlZ6YmhIb0wyUS85ZVduRk5icGw2QUlZb1c0Qm5IbnlqSmdvOEoyUmFNeVpYR2FOcWtBRnFzdDdrbXNIWWR2USswYUtNRWpCN05aeWhUSE91QmptQnZrRXJMNDZtaS9hYmhPTXFIR2k0YmdjQUxVU1J6VWJRZjZRSVR3clcyWUpwaVY3QUJOV2E3L1VKYWRhNVlMMTU2ODNEM3VMTFpiazhHeDlGSVdyOVRxTXo0Q25WdGNiSXBSNytpd2QzaDh2TDlUYTlSMHcxMnUxNVdmang3ZHpVcDhsS0NrUU8vdEY3VjNuK1dHM2IzcXdpcGJ1ZnlzMyt0azFZVmVaN3U1dkttWXJqYWF1WExsK09EUjB2cUZvNGUzeW90ckI3dTduZVB1VVhmdjVUZi9GdS9JSXBhWExhWWtsT2RlSTNXUVBXaXA1anFIQ2FVZ0toRVRVRWJUenJNdHhFZGRzaDJ4WUd2Wko4R1dYdFcyRVViU3hUeWFnYWFZRjhJRXhya0RLOElOczlLd1RVbVQ1bXM2VVNJUTBzb0ZacVBpdVpHQkdVRkY5QVg4ZUJLUmlUdWtKN3ZjNkxJV3BuQVI0T1FORll5SU5FYTVOa0VRUndDaVdveU9vamtoZ1FieEtRcjM2OXhXOGtBd2JrbTVPckJYOFRSTzBuQlNVNGtaYVR5YmxaUCtOb2daaDJHWWpCZ05RWHhJVlZZWHdSY1lVanpncVh6aHl6UEdNOFlzYlRBUUlvdWNyVDZ2SXZJUmJXN2ZZR0tVUXgvSUltVDgveWUwbHk3dHhTK1ArN2xhZVZxUmY4YkRiTklwVmF2RHdlU3djelRvandianlmTHkwa0F4dTdkM3RMZGZMRmZiRzJmNUlQaDAwRnhlbVJYS3ZZUGQ2YWhYVzFqVkhpZFhLQTQ3aDZYR0lwdXBrdEozUy9mbXVrcnN2dmZxYk5UTHF0VjhzVHJ0ZDViT1hkRytwcjE2N3ZEQk8rWEc4dkx5U21lOC8vcDMvM1prR1FtZTdLQTJkc0p5TXF0REo5eGo4NEczTVd3L1FERHFpaXN6aWhJeU1WQ3dLS1V4eVNZU3VTS0VzU1lraVBFY2VZTXVZZVhhNUVhMVBabklGTkErbTUrTTc0bUVGakZwQlhmTTl6dndDR1k2T3gwaERkNlNKSVFmc2dpblhnMkVObEtpcDFSbklOa2cyTG5CaDRxeEJMY1NnUm9LUXR3ZVNJRmNob0paaEw0S2laYzlnMW9uZkJBcHpqVGp4UUFGRFB0MVAyYmhrU0o3R0cvS0ZmbzZ2UGcwcDIzbG9vSDJneVMyWGs3ODVxaW03S0d0Z0wvUDYwK29zVE5qRTZPdVNhNHd6aFdtY2dYK29pdGt3VDVZR1JQR1FjTzkyRVJBUklkVTBjU3NDMjc4STdoTnpTV0JPWmhUYmRhR0xoVWFJUkhFWmJGWVdidjkzbnNycTZ0aXRiU3k5T2orKzZWeXRkbGVxamRibzJsdWNXRkIrRktwMk9zY0hSeDFabGxaakpaV2wydUw3ZUhSL25SNFZGOWNFWi9oOGI0c3pGNS9lRHlkakxUWE9kaDUxTmwvZE56aForQlhuM3l4dFhsMU91aVd0UGZMaXJQSlpOUTdIbzBHQndlSHBWcTkxejN1ZGgrT3BuM2M1Y2dRUTBVZWwvNUlERmcwdmh0OXFobTkyc2xBRTNBaWs4R2lsNjg2ellyK3JIY2hQOVZPc0VRS1pqK2FUYjFQWktCdWZBaWRPQ2p5RDFQYjVtb1NjV2xTNlBHTm1pQUQ1cDlTd29jQlJJTkd5YXlZUGpsSnRrNmhSNEtCcGZYMEZRYy9xQzhSbUVXY0RHaEdWb2dMNDhUZHhiME9UaDBXejZIa0QrdElKSUpTU0M2TVNqZXFQUXdHTHFLUmZXSXFrclZRQWdrcjE5cWo2eFp6N0Z0VmQ3UDlSbVgxSTdlRTh2N0tDbWdBYjMvcVVOeHBaYUd5dWpnVXVGeWNsWFJ4Z2dNNnJ0bjJqNzJFZlZnZUtJT3VzRmJ0VDZ2YWZtcktwVFpqbURQTUd0bWRPMUovQXR5U3FWYS9aMkNJS29tT2FMTEZGR0hWbmRYcUg5ZGl2ZnprVTdwQmJMUmE5MjY4ZS9tcEY4Tkd3NEgyTStWYXZiRy9mekFhVC9LVFViNTdwS3RCWHFTNVFyVzVwTnZ6M3VHQjdyL3JTK3VEL25IditHRFU2Kys4LzQ1dTNDWFNaRHpvUExwVnJaUjJ0dTVMa3Vsa1hHK2ZPVDdjSzFhcTBxOWFxZWQxVGFrczlnLzNTdldsZzg1OVpKUlVoSyt0aUtpc1R3RzgxNFNsNWNWd2xRM016K3VHT3Z4bWdOY0pkaEdCeE12TC9KRlY3QXJvbFVzMFJFSHZaaERJRmFKUnlHSVFacmNiSGNveHltR2tpUXN6L3VPVE1FazJQbllsRi9tUXJXUnJjcWdvL1FkU0VjSW1RTkVpVm1hSlZ3Z3N6eVNjK1dpb3ZhbGliNG9NZmg0WkllWnV4aEhndW5FazlEbXdoNmxKdXVxRUJyenl2UVh6MUpLZkhvZWVKeWNXekROWnorcUU2TEpPWHB1Wks1b0FkUkpIVFk2V0lhUVFIazJYQ2dHb0ppRUdEMUZhWHRHakloT3E2ZnJrbUN2SmNIZUMwUUNDTVpDbTBleWVFUlRVd2hrOVIra0ZZNTExd0pOZUZ3RFkwdVZ1Z2VZc3BEWWpIMjAyTDhwRzlmSjBzVjVkWEZsU1hDNjBsd3ZGNG1Tc0tDcnVIM1FxNVVLbFhLcFVxc1ZpcnJmenNMV3lVbTIwL0ptNXNSaG8zMTVyTkNhVDJmSCtsbFQyeDhJemJWb0d2VzZ1dDl0Y09Wc3BWM1lmM010UHgxbXhXR3V2N1czZnIxUWI5ZmJxZU5EdERYUEhCN3NMNitmLzVLVmZaRGtpbFZYd0pWOUE4cU5nMVhKbFVrTWRXUXA5Wi9SWTM2Unc0dFUxeE1BZWl5bklqTGpGSGt4REhBcEN4eFVVakJpS0U1TkN3S1QwQnhsQWdrOGZzS1RZMnhnYUhVNks1MVZSRjJnZmNDRDVoVmgycGZzRThsSy94cUFCN1JUVDFBRkZVWWZmbm5kUld5OE1RaUhNeFU4ckUvN01aYlNZRVpneEZUTlN1QlNvSWF6TUpSN1pGNzU4R1pnb0ZGbGtkM2ltVlNOK0Vmckl6REtBajRoRE9aM01tK2lmOFI2dnNZNUV4cHJVTHFMdHlpZ050S0JjOG5ndW84SEJoOEdjemMrUUoxWWRKY1NVVGlDRjlqNlZmZzhHbjJCb1phZHBhK21ueXZuSysrKzk5OVF6VjZybFVtNDZhVFRxeDkzZTRWR25QeGdlSEhhR3ZTN3Y5ODkwZTFsc05adlZhbkV5SEJ3ZjZwNzFRSzRTZ0Y2VlNyRmNHWFQyYzFtbHViUStHbzZyQyszalJ3OXV2ZmxTbzczYVdqdXIrTy9zM05XZVhyWjc5NVZ2Rnd1WjFzZ2tYOWc0ZC9HdDc3eFVhN2R1M2Z3MzdMaDBVWkJrODhnUWdJaWhNbGNrTmJPQ1B6cGtESmNwYVlMTzRRMHBGUTRKbGUxbVhWK3hTYks5T0Fpd0VSS2NmQ2pqazQ4NXVRbFhSbE1SU1dGdEhLK1NPczB3QUlJbW1va0d2Q0NlWGN4eGduQXhIa1lBMXd3SVowa3FQK2Z3U1B3TE40M2cwUWlDR1cwK3JIUEh1STQ1UmxOZ0t4R3B3c3ZneFFHMnFzQVJ6dWp1S0xFMVlCblc4QjBBbkhTcitwVXJrRkJnNE5IMFJaT2hwZ3hZaDVLOVR1Nk5TRVFJbW1pZ29xYi9UZzc3VmxkaU13RVI0eG50dHFRUkpBS3BRTGRSME16cDR6QW1STE94YU5tNDJEZndwb2o1TEZZeE8xTXNmdDlnME90czNYdmhvOC9rWnhQdVFVc1ZaZWl4dHJlbDZ1SCs0YkEvS1BJWjRWeXRxQTNSck5aYXJOVnFuYTI3ajk1L1U5dVZZbTJoWEs3cTFsYWQ0MkdmZUN6ckJyWGQ3K3pXbXUzRGgvZTFnOCtYS3N1YkY3VGJrY1diUzJ2NTZiQlpLdzVHVTkzSkRvYkQ5dXBhcDd0ejk5NTNiTm0wakpPa2NyV0ZSMVk3SFFCbFJVU1lZbnNET0pwaDVIWEJYZ2JpbEpweEVZQ25nOEFjcUxHSk1CQm9qeHNFL0xjeERkVDJRS2Q1cjdxZ1ZqUFoyYUYyY3BoQWVPS05IWVNGQVo5V1VRd2huWXZVTUR1aUlKTXNBc3pZVWdVeHJ5RFdpbUZYQTJVVWNaWXN2TXNKZi9CZy9JYzB1RmRubUtYaUp0SG5CaDBSNGlmQ3hDbm16V2MvODVVckRJVkY0R2dwWkZoZ3JDUFFjK1lSU1JnYjlnUWFmVjRBK00xRHpRSUZOUS9rTVJnSjR1d0RrclFRWUtJUytpWmkxMXg5RVYyczZUUUJnZTUrQ0NSZFNBQW1zaHFHZHR0WDgxTDFVMW4xMHM3OWU2dXI2K3RyQ3R5czNtaHFXM0owZktUaCszdUhFejhvOWtmYkpwV3lkdDBWZjdwejBscGVMNVZyVXg2MjFIUDg2OWlpTmpTbFdtTTRtZldPOXJXM3FWVHFoV0twMFY1YXUzanQ4TjZOdzhQOXRYTlh0TDBaVGNmTFo2NGVQTHk1ZHVGSlNUSHBIalFYbDdlM0h6eDg4RWZXUldtR2lDZVJxOWZiVnk2b2tkRjE4QVBvQW1KN2JSVzE4d2FXcWJpREZHdzE0d0N2STdtYjNhaGdoWU9ZRzhsYkk5SlBQSFVRS3dFUVNTUm1iS285UFo0V3NiaXBNazgxYWFRbWgxNk9RTWNRRHk3b2dvL0ZrUHgwd2NYejJuVU9XTDg5ZzhadzlTd2lKMkF0Z2lnWlJJdTJ4QlpUQmxLOGtmRkxGWFFwNXJoQ2dESzNpQXo0YUFLdmVSa3FCS1lYRVIwaVVGcWc3T2UrZWpYQ1J3ZTBUSTNxZ2JTa05FNXFEQThkaFdERWpUQVVTelU5RGxwZWlNZWZDTGlhSUJxa25FR2pmSnpNZ0xsZzRBTlJyYU1IdWZKVUJ2UmloQlhIV0xheThYUE5kZkI0b3Y2WllubnBhUDlvYWJsMVpuV2hYcS80VythVFZyTXRvUlRyNDlHazF6MCtPdGdkOXJ1VDBURGp5andyWllWS285VmNYbC9jdk5qYjIvRXpvSUp1cHFlejZmSGUzc1BYZjcrNXNxYXg1ZnBpdjlldFZTc3JGNStxbFlyZHp1N0M2dG5wYUNESDF4ckxvMkczVWw4Y1RjYWxhbTA4bWIzOTdtK3ptWkZnMk13eFRaSHdNaEpyMVJqRXRqbWpQcmtUdGVvMkQzZVRVblJPSEJ3Y2M5S2RVWFFSQkdIVXhEQUl6Q3BzQ2pzRmxuclpRYk1JSFJkbTZDR1lGeFJ1RUZKRDFPRDdvUk00dXpXL1VJZ21wa004OWpPKzY2Q3BnbDhna0wrWWxOdEFKQWlzcG9Cek1GY05CN3lwdUp5dnFLRDFMQ3JJUDUrTGdjazRNZGFiSENTMzRtZ1hnakVXVnJLcUJtVS8rNVhMREhBQXFWUG1oQVltak1sVTBRazJ2blhoTzFlSVhYdHFkOGNwVFlrc25FbkE1QVVUZUQ2TnRoQnBTTlRXUXJLYm9aQnpZZVpINHFVNkVKNFpKSktmMXBtQ2V1cEZ3OG9QS0Q3SzFmcGlQYmUrMnZKdnFaU2J6ZFprTmh1T1JvUEJVS0V2Q2ZkM2QvY2UzQzNWRzhyakUvNFhUVlhydVZodEZNdTEwVFIzNitVL0xGWHI1WEtweEdmZ1M3cUwxUzZsV2x1WVRFYmowZkRnNFkzeGVMU3d1amtkalk3MnR1cnRsZnhrTWhnT1JLNVkwalZCSVRJWWpkNSs1M2Y4ZlR3WlRlcno0UUhlTThCV2ZIYyt4Q1plZzhRNjhnUlFxZ0h6L0VIbXdZWHlKa2lhNnNWcTltNGdkV2kzWlF0aWxvalVjUHlKaVdoQ0NTTXdNWGxrNENuQ1lUeHZXcURCV1dGbFZYeTVuMUdNNGZvRHJaY3I3MUtDTmVlMGROMFVEU0lpcEJERWdVYmJQVll0QURaeWVOZGQ0a2cvckMwWjNIemhRalU4cms1TUFYTzBFTjRhQlRFRXNMSkJJb0E5ZFhxQW84dDQ5ck5mdlFxcFVLSjBFS3RoQm9MRkdKZklERklVeGJqMXhUWjJEQ1dDMERPVEdxMEwwM0l5RXh1UWZzUkZONHVuSHV0dFUxb2lScWdnSG53ZDlTWlJFK3JISkdERURiWTJEVGExdjBYRndRUkc1VXNmS1diVlVqNjN2SkN0ckN4VnFyVjZyVEhXTnJaUTdIU091cDNqUnFQV1hscFlYVjhUK2ZIUllVVWJtcUpXUjRWSG51V1N6RHdaOUthai9teVMxNWFkbjhjb1ZZcVZ5bGdiLzBLKzFsanM5YnA3dDIvczMzbWoybHFxTEt6bnMyem4xdHZONWJWOG9YUzBjNysrc0RTYmpMVnN5cFhLNjkvNVZlL0R3aDhDc0tCdTB5V3EzYU9YREM5N2s4N3RhV2NOL01xQjEyMUQ4TnI1WUdrZHVCQjZOeDBxMkdadUtOZGhITGNmRjVFSWk2blVwYzR3TUZqUm4zN3E5NWc0T0R0MmZRUTFjUUZ0Rk9kN0JvR2s2UzdCbGtReDdZdUlNU0pMQXNmSFlRQzl1Mkt2SWpnR0FzLzVFL0dhbGdpMnRHR05FTWFZU0JPRWpycTRhakdLNVFvSGdoZE1JZnZacjEzRjBnaEZ4SXN0cm1DY2VWQ1pkd3ludzNSV0tMQlFjT0k3SFpvYm1BSWdGWHk1dE5BMms1U2tqYTdHZUM3NU1Ld0VMeXlTYW85UWd4SFcwRWhXcm5VRUdZUXFxYWtyb1JLbnB0VjJvOXo2b2NsNHFDdlVhcnZlcUplYnJWYVE5dnE5ZTNmdWlFYnhyVENlVGNmMVdrVkxZVEljakVkZFBvWTJuWlpMWmUwbWlMZmN0TG02V2FxVk1ZdFdlMWJXZllFdURaUHBxRlNxVlJ2VmZIMXAvOEZ0M1FGWFc4dVR5ZlJvOTJHOTNhNHVyQlVtZlpHSmg2NFM5KzdkN0hlM2RNMlFIK0x0U2Z3aWNjTTNNbWc4UkhkSmdlS2J5K1I0SFZMYVZ2QTNaTlRGbnA3ZVdZYnBOR1RLZStNMnJVMkpxYWtjRU9xYzIwbkZ4b2RNeUhUbE5ZejFrTW1OaEllTVdST1ZoaVlFd29SSXBIWlBqYkZFR2JHVkpFZVM4RHNZQUUyQUN2WWdTR1BTSjYxQ0hOaElmY2NkRGhabnBXZUdFQVNFcW9lWU04R0RRUWlreUJlRUp3SWdIaHlFaEkwdG04Kys5TFhyV1JyRFREeENvVnNORXp5R0xJZDRhQjQwamk1Qm1oYXhKTGVXU3JCT3J6UWwvT1FrblRCVjhJRmV0RHBBcWFFVHhoTVRTMkkrN29nemVtcVVtZ3dITXRMKzFqaVFKTGxjb2NnVGE0bW82WXJUMG5OWnVkNW8xSnVWd3NweW0wOGR6SEtENGZEaC9RZWR6bkZkMnhLZXhtaWdrdmp4VW51eFhDMVg5RmV1akllampKODB6d2FEUVUyYm5FcXRmN2czblkyN25VNjEyUndOaCtTZE1mbEs4aHc4dkRzNjd1YXljckZhN3gxc0xheHNLUGxuNWRLazM2ODAyNU5CcDFTcFhidjJzVTR2ZDdEN0h1KzhPYXlsQko3RFQ4bER0cFVVbDBCRXN3OXBwTnF1UVVlL3JjaE9ZeDRvT3B4UVNZck84ZG83ZWVPclA4d0xCWGt4YkJhUVpyWEYxR1dQZ1JJcDFDcno1dHpJY3ovZ0tUYzFNc0VzeTBSUHRFRWE5OXdKR1RmWnZ1MUdXcnFNY1doNjlXcUkzQ3BBa1dJTURCMWZCRzY0bFZFV21CMWR4TEU5am53SUNYL2V3TFRBdW1RYXdJQXhDNnVDR2JFekJ2emExNTlFVm1jdWgxUnN6Z1Y3YnFIeEJPSnIxaERIMHdpSHlpcFlUaEpERW9qY0JOMzBKOUlrYTl3WGM1aFcwczR2Tjl5SXM2bFRYMXB5NWlUVlVSeHR3NmllUVdlYVZrQ05NQkJOSm9NbldqbWtwT2RzbkwvZVhqOVhMbWZGZkc1cHFhR082V1M4KzJqcjVzMmIrWHk1MW13b3Uwc2xLVHdaODM4RldzMW1vY2dQQ05RWFdtTituQ0ZYclZXbjQxR21qWGcrUCtyM1J0MU83M0N2TUJsbGhheTZ1TlEvN3ZEcGc5NXdZYUZlcnZQT1ZHOTM2K0RoKzdwSnFOUVhlcDJEd214WXJMZG40MzZ4MHJ4dzRhbEp2cjc5OEhWc1c5Q2NITWlKNDdDR21yaFoxa1lwZXkyRmlKVEhobEhqdHBURitTVXVLWS9SNWxzQ2RZU1pvTWRteEQ4RWRHQll3Z3NvK3NYVGZ5NUdxVkNMQ0FCTXVKbzJQb3h4NXBUNGlWWXJqVlVuYVhsdjNkNVVQbGFIbzVOVlpWYWtYaVpGQ3dMeGhBRFZIdVBOVTRjSWxEakN1UXBMU3g0em1zWnh3YnMyeklBVi9UUmJUZE93VDhHdVlVenpWQ0c3UHdFbDFvV0lEV1Z3eENzUXphZlhHT1l6SlJXMVdRaEdEdUpZY2dzVXBkRE1GN2NJUGtETnI1V0J3WFpVTUVrbFdPZ1BoMklBY0NHQVRxcURJWU94SFh3OEFtazFMNytHd3V4KzUzeVdxeTkrYWpJdGFJdlNLTTBXR2hXR1RTZEs3YnBKclpSckNuMmxld1c2VW55djI1Mk94N1ZHUXlvUFI4TlN0VG9aalpUb3RSSkZOaGowOG5sdDNiVXhHZk8vc0VlalVxV2lPMVZ0VFhhMjdoVXJqWGUrOWJ1U2JLRzkwams2YXF5Y3lXZTE4YUN6c0hxMjN6c3VGUXVqNFhnMjFaNnF0TGwrK2VDbzN6bDgzeCtYUmFsSTZnNTl2T1hIR2hLVHVNZEtYSzlpRFd1bHNyMXhTTEZaeHhpUjVwTlRJaVpPVlZIYjJ0N2RpUzltUzlrZmtPNUVBcFBrQ3RzYzJua1haeE1IUzFDT2VRenVlQlZXL0duaUswaHdoMmlTRmlhTHQzVWx2OThScysrZ0RHN2tWaTkxTmZHcGE1SGhYSFovVWhrSEM4bEZMeG1Fd2E0ZDRqcEY4WXc2T2ZTaEpLbEQ2YldVZmVXcnp5VENmRmJrOTJMRkhXbkVsTmhLZkNWQ2NFTG9qS1NDY2NJSUJ1UU1WbkVLUHBHcmoyeWtQbTVSNklnd0ZSLzh4TkRZRFNSVGl0cVNrbzBlVXlJb0JvbmgxUEFOZTZtRkdieW1aWVg1UWxXTmtMbDhOVmY5ZUZFN2tPTk9mdHB0MWFyYWxJL0hvL3QzN3pkYWk2MW1vOTF1OGZabmhTK2g2dDYwM1c1bkpjVzNwaFE3UHNLaitOYTJmdFFmRERvZDJhSlVxc2dsL1Y1ZndsZXJ6ZDU0OVBMTHI3ejN5amUzM242MXNiU1NHMDExZHp2UnpXbG51N0cwMWxvOU4reDNXdTIxWWIrcnpVei91RmZnQjNiTCs0Y0hPdzllNVRzbm5pV3VwZFlEcjVCdlpCUDFzVnYxTmtDNllFOUhFaDVRd1Fia0pWVXdrWW5VR2NhaE0vRFkwL1JZbGJ5SmhmR0xrVnBQWVhXNVRkem1zRWlBc1RqdFNlRFVTS005QlI0Z2VvUWhESTNEaENLR2tKazR5TzZhQytGRm1YbmJwTGJGUVFhYkdVb0h1dkNPYVh2Y1RQd2d5SmRlNWhlQndwS3h5VXJlL29sWVo1SEJVa2hBcnlzdW00cFRMQnVkRmtrVFpWLzkrck1lb0tEaE0zUU9OZWFEeGdWeFBZRVhLMm96RmgyOEVVSC9wQ1NHQUJiUlhIa1Q2dVZhVGVFOVROMGVEV2YxZW80d3BHL09wU2Y0UUhxZHBCWWNMQ1QyWWt0QXdpT3BxN2JWZkJEeGhWemxvSHUrd20rbXpJYkhSOVZxUVJ1UG82UEQzZTJEMWMyekNxcHlxVEFhRGJSM1lmZVRaZHJGS05QbnBoTTErTURNVkxrL3I4VE9EN255RTdHajBXUWtNY2FEM29qMFgrbnVQaW9jM0Q2OGZlUHc4S2lZbXl5c0x0Y2FpNisrOUsyYnIzeDdjWG0xUDg1UDl1OVZXczNxd3VyZTdlK0taYVd4cUpqZTNMaVl6N1czSDcyTEtiRXhLbkRnWnZrSnJIMGNzUzdaT2RBWGQxanJjQkFJTmFGUGZYQnhsN1ovRGlWeEZBNjc0eE03eXBSaDdtVHM2RTVJVUhHWkFMWUFtbHIrZ0l3R3BJNXAzRUNZc3RYVUZLeFZpNkNpQ28wa2cwTFc0K3dtSTAxR1pDTWFBNWpDVFk2cGFyVlNuS2ptVWF6TklnN3FDYldjdGhYVmpJNTdIa0hLVG1wRStpQ1k0WUFaR0JXVUFJcVlyMzcxT1RhN3RudW0rd1BtVXg5VFFpeHAvWGtNek1GdkNxZ1NRS0NTaHEyZTI5R3JBUmdvT3ZoV051eUNpMU8vTFRmVjlReEdta0pGM2RiUGJOQlY1dlI2Y0U5d1VvRXQ1bVpaNmhCUGIzeXR2RVpyZXdDU3pVeXlUbTVXTGphZXFaU0x0VksxZDdTLzBLZ1ZTNFhkN2IyRjVjMWF2YXd0Q3Q5STByWjZNS3JXZUxhb0VjTkJYMjRhS24rUGg3UFJZTVQvNXlpTWU4ZVQ4VkQzd0xxaEh4d2ZqZ2Y5d2RIMjhlRmU3LzdOaGRXVk04OTk2c0s1dFhQWG4rZVhlWExUNWVXbFVxVzkrLzUzVjFaWEZ0WXU5TzY5WG0wdURPNi9OaXZXZFdFcGxzdXk4NnB1SjJyclcvZThpWmNLY1MwbElIQ3d2S2JJQUMrY2ZTazBpUTNkY2FDTm9TNktRTm5IZU5QRGdoMm9PckE1RlBSREFzTDBZWGFsMHFBaFg4QW8yZG9uTWhHZ1lGa3pFZzNEK1NremlGV0RVU2YyOTFhRVdQUkVOajQ3ZU1PNHhvUFpaRW92d210T25KUmlCc2lDajJoUnhIeGkwK0kxQStCMDVrMmd2QjJtc3owMHdON1hvV0ZhQU1TNm1zNGFNWmR1dmJRZTJDdG1YL3ZhODBJcHhHTWxTUWd4d2xTU2c5MklwS1YydE5tNnRoU0FRMUFTcTVhTnVGK0JQcEJRQUxOWmlUdFg5aTFoT1FXOXd0NGYyNUJXS29uYXJBVG9uUGg3YXFiUWdXeW9sSFQyK2dRVFdqa0NDSFRNcEZXdVpGKzdNcXRjYlZaejlkSzBjN1RiYUZRMXR0NVlYRjVlckpaTDNlT2o3dkZ4b1ZqdWRJNnJsZkpFQVQ0WWFSYkZlbTR5MUNaR1dYL1U2dys3aDRYY1JQZXpXZzNIQjd2YXdOZXI5V3F0VWFtMVNyV2FibS8zYjcrZEh3OXZQanJvOTdxLy9rOS9lYmMzS1JRTDVlRisrOHlGNGFpL2RQNjZBcjNRV0NtV2k5czMzNm1VSnFWcVl6WWREU2F6T3pmL3hBa1FYUWhMOURJQ3k3dU55dmpQaVI4SHBqZ0ltdFJydjV1ZXltN0RHbTVpVWdHeWQvUzRtVkM0eGYyWTJTTUR0TzNWUTE0eUdEM1NQMEQ0eHN3Umk0NG5CaG1KWDZRUmZpSGc3Q3dTRUFtTnJoZ2RKWVIwR3Nack5nSVk4N1FyUGIyWTQ5KzRkT3N5THIvYjJRNEJ0T1dzUCtPRTRVQVFNekVOc0VuSmlkblh2djVSWWIzeDlhSkVTZGRrNzdrZEhJaitpUm51bVRRSnRxSnBXOHFJV05UaXBRSlMzU0tZaUJRS2IrNFpCamVGdmx1bWhBT3dNSWh2WW1SVmxnZmpUVG0yMDc1RXdTRnQyRmVqaG5iY1dBRnpLSzlyczZ2ZHNBQjVRa1laWjFmMk81TnMwajEvWm1WOWZYTnBkVzF2NzdDbEhmcGlvMWJqamFTbHhVV0owVG5xUEhxNHRiNnhjWGg0T05HdDVlR0JZbDFHSGZUN1N2K1RjVi9oT3h3TXgvM2phbXRwMU8xTGhQRlVTM1ZXcWkzdWJPOE1wcVdkdzk1a01ON2YzYTFXS2c5dWI5MSsrNjN2dnZ6Vy9kZGZ5aCs4WDE5c2JML3pVdS9vY0ZZb3Q4OC81Y2RCUzdseHQxbXZ6d3FMZTQ5dTRDSlVSbG5COW4yNFRoYkEyc0lvVXJsVVF4bmtkcUh0WkJ2alNCMXFBZ2pFK1BSTjNRZzREQStvQVhLY2FNUFI0cUJ6U2tYeXNsWVhaTWFhWHJMSTB4QjZpR3FZOEowU0p4bzFtVjBpRWVqTWlEc2l4ZUlJMVhoTlRmRlVMOS80ZzRibEhJckUyckNvOGFUQnJvL2xaRmpjWUpqSXdqd09ZSmZUWko0Q2pNTEFNd0l6Sm1iVWRTVDcrdGMrSGxpaFlwMXBKdTJpWkI0Tnh0emtBU0VkaGVaaFc2aUxRTVl4NmtLK3FPbFNtRExjNXNMTUluSG9peUNlQ3lqQzdjd3dub2NpRmxkMm5RVndGVVVOYmNyUlJBZHBHOE5aTjJvaHVaSzZTVVpSckl0UFdJZmNVSCttTjhoS2srN0dXcnRRcnV6czdZMUcrVnE5VXEzd2lFVjAycm9vbEl0WmFXVjFRNXQ0c1M1bWhjN2VUajQzcVRhYTVVcWxxenZVckpDVktzTUIvODJoV211V0dzM1phSnBsNWF6U1FJdFpzWDl3T0Q3ZVhWaHFuYi8ycExZL2x5NmVlZjZGRDExNzRTT0RYT0hlL2VPVmxZWE5heS91dnZ2dDNRZDNlZ2RicmJWenhVcGxPaG9PZTkzTjgxZDM5M3E5emlOdFBrSkJyQmNHbGdxT2NreEJoTGxMZVBVa1NFNnhNMndsdTFNVkZDUVJtWlhBdFZteFAzUlkzeGxLUVBqQ2xZcjlJUks1SXhJWU02WVVoSTgxdlYzanFXM3pjSTA2TWI0S1VSUTEzaUd3Rk5QT1JIWVRiQlRhOGlPU3hpRU9ZaWNhcEE3VjhDTVRFc3RXK2NUTFJTOGtwakFaRHd5bC9La0MrL2grajJpWTF6RmdoSEtsSjBxOWhlem52L1pKRmt1b3diUDllSTlhM1d4bXBDN1djTXpwYkgyd0c0TVJ5cklTdXFwcDJXTFlCblBwSEhKaElKdkxpODgyMUh6V0orSTFFS1JuaVNmQ2lIVkU1emFVSVpJWWVnVGdZUG5HOHhNdkEyL1o1eFlobDh5S3hlV1BsWXZWTTJzci9MSkFWbHhmYlN1cjYySWpXeWxyRDNyZHp2N3VhRGh1cjZ4VWExV3R3dEZna05kOXFnU1pUTFRJUnBOaHRWcFgxSlRLbFFtM0svd3JzbkgzaVAreVZLOGpTYkcwc0habTljS0ZSVzRHYWd1cjY1ZWYvVkI3YlhQNTdPYTdOKys5K2dlL3YzTHhUTEZRblZicWUzdDdDNVY4WnpCcUxDeVhHa3Y1WWpsZktNa1VsNTU0NGVDdzJ6dDZJRU5KSmRURWJIWU1aazI1eWxnaVNXZE1nSzBBN2Nqd0FhVENLRlpwNEp3SVphY2F6bzUra3l2S2ZWMkZJQzdQWmhoTFFIeUVNT1RFckNuVno3V0ZQNjZjeHRoeGpnZEw1R0JpbXlHTWhGSVhBZXBlNGNIZ0tkR0xVMmhuUFVTamszb1ZDV1I2UEE0SGtpek4rZDRkdERwMEVxQVJETGNZY0lJN2M1a0k1b2pOemljNGVLajRXd3VHWjcvdzFVOGxsbXpLMFowbm80cHZHZEN4R3c2dzlCUk1rUnJnNDRLYndoUU9Hc1NVaWptVHNZb1lMRExTRE55Z1J3TFpGZm1pR1JjZ0FURTJIS3dwVkhPb0pUd3lReC8yTW8yZm5Qb096NGZ3a2tUNkxnNEtGelZEcGN3MzM2cTEydWJtYXF0Unk4OG1FMjI0OS9hT0QvZW5BMzdYcmxRdUtkbU9oLzNacUs4Y3o1dExrekdQYTdKeXRkbW8xaHVGSXYrcVlqb1o1ck15OTVxb091TzNiY3FWVElQenM4YkthbU5wdFY2dFRyTFMvVnR2SCsvdlRuUGw3czcybFNldkwxKzRzcngrdm5QdnpzSGh3Yzdicis3Y2ZhOVl6WmJPWEMxWEYvSVoveENqMFY2Ly9mYTNiU0FyaS9XeEVzVytDR09yejdBdEhwMUdxcEtPTk9rR0lHb2pTYnZRSVppRE1XN2pvVEM5UUxuQnFZc1JXTlpNa09UeGdVbU5sSmhDOE5WVjJyaEozV0pUQ2pMaFZjczhpaXBoSU1iMUpNM3dySmt3VUJOR3VuWGdoY2ZuWVlvYzRFTTdEcEhDMlFoVFdndDNXQ1BvYUxxWGtBZ0JRRU5ERHdkRkZ2OExYL3NCWkJLUlFsd0Y0VFF5Q1JjVDYrS2hka3dhakJCYW1MbFk2dFhOSE1WR0krYm1jWThCRVZCOW90SUZFOWw0cUk4dFdHTk9IZzVjTTNPcVJrcWxCRVFQQllUa085ZitIeW9TbXR5bUZCTDV4bnlRUythS201RDhxSFI1cjFPb2xXYzFSV0d1MEZ4YVhPQ25ZaW82eXVXS0VubXoyVmhhMzlSMG5ZT2R5ZkhSZE5ndHNjdlJUV3pKSHlSYlZHUXJKU3JRSlVtcHBOaldwYUlob05xb0Y0c2wxb051Rm13eVBpdGZyZk52ZVdmNUJ6ZmY3aHp1N055N2QvYmF0ZkhSYnFsV3YvM21LNWRmK0ZqNzRqTmJkeDlremVWaVNYZTVqZnJpc2k0T2s4bmt4anN2SHoyNllXZGhxTENWaTZJa0lHY3lOQXpQMnRVVTZPMEdDRDJRcUlaS3RTKy9hcW9vQTRGM1AzM0ErRmhZNzFEVEVBd09WLzZ4a2h3aHk3b1ZnU1JFcFBBZ3dXVjRGcVRjSVF5VmI3SElXUkxLbDF5UU9GcFF3cmdKVCtKS3RmbDRKbXJUazJOcE1oTXlRMmZaT0V4QVNGcDFFWVpJeHNOQmM4MmJxYlowRnNGTG9KRDloYTkvR3BzSXhIU1JneVVjZlRCa0dMVXd0amdWdGZGSktyNzVlMExtbFdPTFdIL2hrd21vMFpaN3lyQ0llYkpMb1liTU5NRFduRVhFR3VCK25JdVJWNjB2QXZUU3BETVU4NFVSSDJpTmlmT3cvT0hKZUxpMlVCZCtPdFh1bzlSc0tISjE4NmxkK0ZpTHJxUWRSUzQzSFBZSGh3ZVZTcjVVclplcXJkYnlXbVIwRVV4R2c5eUUzNFRKVFNlS1VYNHl5V21xTE1yR1lxV3hVSzd5QzVMVEtaOHdWbWp4VDVESzVmN2h3YWg3c1BQd29SZzg5ZkVmS0ZRV3Z2bDd2Ly93N1ZmeTQ5NExQL0xGYi8vT2IxUUwvZnhNSVY5cExtMzArNzIxdGJQdnZ2WEhZUjBYdENBQXc3d1J4WFlHM25RbGtSS0p1MVRiY2NRMHpRaVdlVGVBVGpJTWpmU3BLOU03MEgzUWxzOWtTenhuUVd6Nm1NcjEzTTdNUTFQM2xEaUVmQlJKUjA0bk4ra1FSeGFMUFlzcnlUN0pSNW9OajFrQllUeVhXOUhMSVhIb29nRWdsRVloV3VMZ0YycFJwRW9nakUvakhCWUpFMHZVWGNMWXh0bWYvOXBuYU5NbzZGNGVTN3FEU3g0Y2NRQzlJQ1c2bG9DbjhRcVpLMCt2S05tQnBjbVkyNkd2RTk1VWFqYXhQZXNsZ1VuVkJXSEVOM21VS1JEWUdBOFVIdjd4cTNnRXRidVlaRTZqT2l1Smh2WEFkU2lmTlM2WEY1OXFWa3JyRzB1RFFhNjlzamdkOUV2WlJObDdNdXIzKzhOK3Qxc284SVBWdWVsMGROd3Bsb3IxOWlxU3h1L1Q4engrcG5pZmpjYXlRcmxTeThvMU1sbVJmMnNuSXY2TGdkYU9qbkl0VTIreG1pOVZ4dVBKc0hmVVd0dlV6VEFoc0xqU244MFdsNWRMazk1bXBUZGFXUC9PcTYrVjYrVitaOUJlWFZuWXVGRFFFcXJXZXQzdTN2YUQ2ZURJamdzalU4S2pqdGNFQUtXbWFza3FZdnRCQUxkWXhMazM1Q0IxVnU0V0tVL0tHWWJGQ1dvN2hyeUlUVlZCSk85clpyclVpZ2JzN1JaTTdSOGxkTDk4TVg5S3htVTJzcnU5Z08vaXdBLzBDbWFYWXVMZ3FCN1NWcUprR3E0TTBRdHpLMlFZU1J4NGFBcEpkRnRnVkFheWVvVFh2QmhoempyclJLSjBhRktCZDFmMkY3LytXYVV0c0JxZ3c1c1pRbE84QVJBSmczR29FTFZHY3BGbHcyMEZiRXNOMU9GUURpVk5sdkF3ajZiQ1YyM1JjSDlwY3pneHlIYXBHVkdPS1NPNDJjVkVNM1RBb01hSHVmbEZmNmJRY0xaUCtXcDUvVFA1eWJDOVdLM1hHOHVyUzVQQm9Ldzd3K21vWGkyTngrT2pveVB0MzZ2bDhuQ2syOWI4NHVwcXJiVkVCdEhXcFpDVmlPTlNxVkxKaXBWU3JTYTJmaStkaDdLYWc5WjByTTJNWWwweVpNWFNkTUx2RGFwTFc0YkpzRDhkOUJxTHkwdWI1d2JqM0hEbjdtSno0ZUp6SDlzOTdyLzdlMys0ZS92ZHJOOS8rcU1mZWZsZi9wTXpaNWR5OWJXZDdZZnlmNmxjTzlpK2hTc3dOQlZuM0pvQWpDN2xIbVA4OGw4VU1wTmJPakFFWFdDSUh6cjh3bWZNb2IyTmgwQXBzNFduc0xuVU1VcEdWdTFnbDNGTDJCeHJHKzgzc04wazBhaU9DL2lKNDNBSGJrMDBrTG1jaW51VEMzYXRsenZoajl4cTZNL3VOTEhPbHRuTjZOVUpadEJHY2FlN3FCTjVRcHBId01FNG4vMmxyMzlPaUJReHRwc041Y2xEM0dRM0NjaVNnSUVBN084VjRxWW94VUhxWVV1YUxBTnBMMkk0YTE5am1wVHBHV0s3RUt6a0FERE1SZE9Ua2xFaTFpbGNPTU44TUtFWFdGNko2QmMzbXBZblYycC92RnhiS2VjbS9kSDQ3Sm1OcFlXNjloWEZMTk8yV3pzWnpUUG9UOXBMN1ZLcDFPMGNWZXZOU3JXbTZDOFZLOG85K2xOZHJBam1zNVBqWVZlclJBckV0VWdSTDZITDVTclRGeXVLVTZWSlNUZWJUZm52Ty9iWlpOUXIxaHFGY3JOM3VKL3JIWmNXRmtlejNNTTc5ODllMm5qdXMxOTh0TnZKOHBOTEgvbStYLzJmL2tubjNqdnJHNXYzM3ZyMjJldlBQN2oxdWdackhsdlNFMGFaUjNDMEJhaUpLekNwZ0hTYnhaK3hMbEJnS0NFQWxlWmxZU2hZRlhhenA4RzBvcFplSkcrbXRiRmxYdGUydHRTMWExSitJYk1JYnhmZ0VSNlR6M3NWOXlhMlV3Z0Y5VkxiL1FibWN6QS9BUUVackJBbUVoeGFXY0lZcEpONEltM0F6QW1adE9IK1QzL21xVjdMcndJaEJRMDg3Y2xoU2s3WlgvcHpuNGVsU01YTFpnbFF2ZlBoMEFXQkxlbnhtZ003eGtURXVvbU5aNEtTUUNNRlJ5WVE4eVN1Ly9tUEFINk4wUFRTaEV3ZmFqTUJzVTRveXhOV0g0UFNpMkkybk9nNXNhamdEemNrejZvWHkrMW5MbTR1cml3dnpncWxjeHZ0VWphcmw0dmR3WmkzeDJaajVXM0UxWVFTc1Z3cWxxclZXazFaV3ZGYTFCVlkwVDNsMzFFNlNuSkszdjVjVjBXYkZuK0lZTXJrdWlLWHRIc3BjNkhEVlBFSW5FYytvOWw0ZjN1cjF4MU9adG9WRmc4ZnZEOGJkN2NlYk91bTRPSDd0K3YxUWxZdXRsZmJiMzNqMzY0c1ZLYVZacU5lT3NvMTYrWHl3ZDRkWFZYRFlyZ0F0cWtFSkhsOHB1QWlyd0ZSQjV6b09ldEFHQUhhbTh1YUFpSzJvK0JHUnNxWUdGVW1sRDdSUVU3aE9xbm94K3pZRktBSXdxQmR3QU1EOWNoWnZwQ2FRVGczSGJJSjY4Y0NwV1NVdWdoT0FVeW1JeUNSSlNRVmVBOEUwT0dPT0Nkd0RsaGpnd3l3MVpBQkt5VmxOVWpvVXpOR1hjai82ai8rVDJReHY2K3YwMVRYd1hnR205NUk5Z2ZWUVlIUUtRZ0U2L0t0TnA5OTBWcWIwMHNPUGpiZ1p3VitRd2tVQWNHUzVPMm41SlZVdVNacTFJdTBvdUxHUng0RFVqZmtPdG5pRmhsTkJYSDFoQjYxMlVqZzVPbWtVTDd3VTVjM1YxYmE5WjJqWVNYTDZoVnBOSkdPdTNzSEdsUXBGU2F6YkRUb3QxclZ4SzlRS2VRVW5NcnZRMCttWFIxUFhOQktVMmphRUZHcGZqUlU2cy9uZEtFbzVrcFY1Ym5KbEsrNzFtck5FWjlBNkU3SG84Rm85T2o5VytQK1lEYnUxUmJidXFMb3p2WFd6WGNudmNQbHRUT05sZlViMy83bTB0cEtmZVB5Ly9PLytLK1hscXRQWDcvNHNSLzdxZjJIRCtvYjY5MnRkLzM0MFBHSVRhVlJQQjlITE5uU3ByUWpkSUN3NVFPRDMwUU1QV2U1QU8rb1I3Y2lkTXU1YW9wV0NnS29Zazl6Y3ZoQmd4L204SWRoeElSYUx6ZmliS3lvR0tPV1hXcEhJRGdzZUF4dEZ0Qm9OcE5aWG8rQzB0RmpiR0FZaWRhaGl6Q0MxTU83WEZwUXNJaVlVUkdGQVR2bk1TQ2NHVWRCcUZnellUaG1OSTBxZ2pEN0szL3VKNGg2RGhZdWZhd1pLejFIZXBYRW9VSzJkcDN3VHZHeDZqVXd1dEtseDhuYlYwQUo0aTRuVmgya2JkS0hDTnpGcXB6UDRzR0JVYTRob3ppRmNOQ2pHekRsSVJLT0JpZ0VtVm5xWksxblZ6WXVyeTdWUjdQczZLaTd2RkRTZmtSOTQ5RllWemRkaDhWck1wM3lyODM1V1R4dFM4ckQ0WEEyVXpvWEl4a21wcGZmQ0JuWlFkbFl0dGNPVHdwb1NRalNybjZXbFVZVHZvOC9IazFHR3A3TFRVWURmcTdEbjBEYWZuZ3ZOeGxLblBiS2FuMTVQVit1Yk8vdDFSdUxsWlhObFRQbjM3MXpaMWFzNkpyeGtVKyt1Rml2dnZmYWE4MWFlWnpMTGp6eGthT0RCOG9LMkI0Ymh2bHhrczc0akhYdFRocmh2R2lsSm5XOE1JbmFZUm5iVlZocnFINnhGcDdDTmZKeFVYQW9KVXRobVl0KzdIeFN3dXlVNENLdWRxVUdrTC9uM0lFQkpITHl1eWYwTWlBa0VobWFXRTVIVGVvMWhnQ0ZHWjFNUXJ3R3NTbFVjeWFnd1RGQUlwZ0JPcWxUT2dtd2JvODExZFRSajFRUytkZi81LytTbFJPcnk3VmZnZUZUalVJcjN5bERhT1g1TjNBVURuUnE0UkVGenZrcWtmZ1ZLU3hxTTFGYnNnVWZSQ1JmTVZ4SUwyNHlCZHJSYlJ4YWFxK01iSWpQMnBmT0FLcHRESjlpNWFxSnl2ekFoaWFjRkdxTnF6OXphWDJoVXExTStVbU5ZYm1rZkQ4cDVNYTZjeHBNSm9Sc0x0L3I5ZXFWVXFtc1MwaldIdzdSYXpLdVZTdXcwYkJCVjM0cGw4cDh1REZYdEEyMHllRkh4bWFURVZyeHk1S0Q4WEJRckRRMHRmYjZzL0ZZUXlYS1lEVHRIbmVtbzNGLy8wR3VYSzQwRmw3OXpzdjM3dHo1azkvOE44c1hMcTJzTEx6MTVudmJ0Mjl2cnJRKyt2eVRsNTU0YXZlb0oxNk5hbTdqSTU4cERLWkxsNi9kZU9sWHBSREtZQkVtaysxa01ZeXBOSWN4T0ZTd2xRM3JUT2d6N3JEWjhSVFhYWXlLbjB3cncvTnhWVm5LN3ZSNlpwYlpKTDRPUldyM3BLcjBzcW5UWG0xdVovVzZ4VmtzY0FxaFRDcGxqdm5USWJsUWgyY1BuNG9KaFRvMGNQRVFNME4wenhsWUthU0dCYlN3WnBxRzg5N09SSUNLRlFaL0lwRmxGUkNVR2tqV2dCY29rOEU5bC84M3YvUmZKYVBBNUtUbXJPckVkdXgyYkcyTnhveVliUUtwSVhvNEpDWlNhREp3bWtrbk80R3ArYzFiY3dhV0xjQ1MycEhMT01KWU9HVUNrUkhtRmpjQXJ3dUhPK1JlQTJpaGlUeHJhZU1IbGxjdkxMWHF5dUwxc2hMd3VGb2szTldyaEtPa3JzU3NOTjhmOUJmcU5VMDlISTFHUXlKVndhL3duNGhVcnArTnN4SUp6cXMyRzQ5SENnaWxQRVU4enlWenl1amp3YWpIbTB2OHp5anV5MHNsM1NJTDN4dDBPNE5lVHdta1VxNE1lZ2VIZDkrOThlb2JiNy85dHE1cjFYcHRZWG5sMWZmdUZVZVRhck42N3N6NitXdFhSN05DczF6b2I3MmZLNVlQajNxZitObS8vT1lydjY3bFoxTmdTdUlvRE9lRUVvR0tLZFdRTzF5N29rUXJTUGpIYjNZSWc2SFdpMDlCMkU1enI1aVh6QWVSbXU3R3JuWUFmc0MwNUVnb0krRWsrNHRJSThOcmRoUUF6QUlJc3dEd0VNOUJJNWpLWjgwQ0ZZTENVcEJSRmtRUXZaNkJNa2ZNQ3lDTVRpajVRMzVXQndLUkxobHZzYnhwUUNvMWFVT3MramQrNlcvQ2l5SXVOcmNyR0dOVlI3azM0cW9aWjFTUXVJaEdjeXJzaEFPTmpTQUYxZ3loc1AyVzFESWEyd2tTc1JVSzRjTUJGdHNXcDRtSkNVRVRwU0xZNDlCUjE1QnBhYkYxK2ZPdFdxbFpxMml2VXFzVUI4TnhWWkEySXRPUkNNZDhFNi9hN3cvNGZ4dVYwbVE0R2srbnJLclpzS0tyZ0haSFZvT1A0R2dybytXdHpGMG9hcjh1ZXQyQ2xrczE3ZGhuNCtuK1VVZW40OE5lWTNGQis2Tis5N2prM1ZtNVVwNU1odDN1Y0RycE41cUxnK1A5dTMvd3I4NWNlL2JXemZlbnBkTE80VUdwM1BqZDMvaXRzNjM2NVdlZmV2M05tOVhwZUdsemRXMngxRjVaMzNxMGQ3aTd2YmgrOXRwekwzU1B0M3JENCtRa214MURoZ0Z0YnF5RDJLbGdOcDI0dW1CVEZaekIyVCtmNFNBM0creGtCd2xTTFZwVDJaMWhXcG9KR1ZGT2hhMXhRZG9PbTQ4Tkw2RVlacEROdGFQL3BCZS9pQmsxcWtoTUM2VXo3Tk0wUG1rUWtaRVFMb0xsQzFPYUZ3UlFwTEdtZ0g0K2lsa2NTakYxcW9XZkE4SlFCWFgrdC83NTMrS01KWm5Kb0tVQTFpbk01VnNnQnRIMnI3MEprQVdGVTVmb3ZSejBJZ1k5alRRM1VlU2N4NnBpS1ZGS1NnWkQ5WmdjeVhqQURZQmZqWTZtR3E0U3lJbGVKSnJtbHo1U1dycFNLZWJQclRYbFkyMHhScE5adlZyaERTUFBJdXBpbHZYNncvRmtXS3VVeWZab3hqK1dxbGJTVG1ZMEhpdlRpeU8zZlNMZTZ4dysybjcxbFZldVAvMTBZNmw1dkgzNHU3LzUyNDJXZG5ldG5ZZTNMbDU5S2l1VzlyYTN6bTR1WFh2eDJhV2xqZHgwMURuWUh4MGZEWWJEcm01YXQrL2N1M256NFR0dnZiTjkrT2l3WHlsVk5pNmV1M2JwL01xWnMyKy8vZTZWODJkdXYvbjZ4Y3ZueXd2TDkyKyswenM0cnBVTDE1OTcvdXoxWnc0R0I0UE9EbVlpOThod1dGWEtvb2JOalFkY0JJQ25TT3FFVVRVSDFRaDNVVG5LcFRUNm1VREZ4Rmh5UGdnMllWMXNUb2Q3Q1grOGxnaURRUDFwb2NEVE1SZnM2SWdRQkE3Znp3dnkvSDhaKzg5b1c1YmtQQXdzWDdYOTNzZWJlNjUzN3o3YjNlaCthRFFjQVlna0RFR0FGRUFTcEVnUUlBRWFrWlQrek5MOEdmMFlyalUvNThmTW10Rm8xaXpOaUpLV0RFVktTeVFBRWlBSWRxUDlhL084dWQ0Y2Y4NzJ1N3laNzR1czJtZWZlMTlEakpPbktqTXlNakl6TWpJeXNxcDJsWkJKQXY5bHBqUUo5TkxRT1RuckVSSlZoQXlGQUNsaHp0d0s1QWVQK0NjSWdoZHBGWWxnSUU0cHEzLzVYL3kvbUZzeUtnRUpzY3JpNzVYZWVYbFFSNzVYa2JNUURRVU4yZ0dubTNGZzJVcld6UnJJaTVrU29SNnIvZ29VZEV3UU1KSWtnVm9MbFRTUkIyazZmWFdaUDVJU0VDSUNLNUl2TWJoWC9xeG11SjI2dGRhcG9RNjRNS21tTituTklCTmVkV1piaG0xWllSekZnZDlxTkxDdGhGSkNRUTB0ZDEwUGxlU1pGc1doNjFwMGZBcHRkRHo3di83bi82ZlI1T1JYL3NNZmZlZjllOHZkbDk1NjY2djkwRzhZK241L21oVDVwZlhsbytNKzZycXd1dktUWC9yU1ozN3VaNXVkRmhaL2JOQ2lJRHp0bjZaeEdnZXpyaFk4UFRoNDc1dmZpTFQ2OXFXTEVOclM4c2E3bjN6U1hWdDk5djF2dXMxTzZFODh5MnpaeGdybVRYY2xucDNzdlBtenM4RWpQWS9RTlhFWDJjbm5SZ2R3bGthV3NxT0tSZ3BneU5TaWlwZ1VWNk1wTWRwOFJzbWVhWlpWQ2lleXBYZ1JVVGFHY1dYbFNhUE9DR3FhUWNsNVNVNnljSlRMY3lVM0Fybkw0RmFBWnFtWlJ0d2NUelZVRjJaa2dndm5LaytwQ2c4TFhGanlyQllBaXFCZDdJbWdtZUNScmhTNTRUUm5DTXhYL3VYL1c4NkNVb2N5VjlXTEl3RXhhblVWWjZNZ1U1UkNOVGpReHBiRkZLaG1LL21nbDlKbXlraDBWRkhTTGdpR1dhTFZNaStZVm1UU2RNeFM1aklxeldlTzhnc1ZuOVRwZHE3OUIxRVVyVFN0NVc0ZGFqMll4cVpSTkYxV0J6TU9tMTczYkt4SkdIclljTG0xcFdkeG5LVXArRGxRY2Y1aXhZRHJVdk5xNFdUNi9yLzkydGYvNkgvN3h2ZStVVGl0L3Nub3QvN2FMN3o3enR0ZisyRC96czNOdHo3YTY3YnFRWnJEWVkrVERNcmRybmxCR0Y1ZVh2ay8vSi8vOGRMMXkvQ0UrdjMrazBjUEh6KzQ5KzdYdm5yN0N6OTgvY0xGSnc4K3JIVzZmRmpIc0E0ZlB4M3VQam80N0QvZTczZWFubWtZTmMvYzNOaTR1TFcrMHZQeThXRDkyc3YyNnJadVJFVWFZZ2RlcnVzVktPRXpJa2RrTVNJa2xGMlpnSU9uRmx1QnlseEpsQWNaRU1VQkI1RXN6QmVBUGdsQ09SamtUcUZET1BEN21LNTBtd1JDajRKTVNsUkdSRVlLSjFURXVoZ2xXcXJnbnlvbWhTU0RFU0trWHlYMXZJK0NLUWtrcWFEVUpyYVJ6Vlh0RklTUXNRVnNBNjA3bTRGOFlVTSs2TUJYZi9mL2d6akV3NDRLVy9DVGlCUm1UQkxxOWZJU1FWcVVHYVdoVUNXQ2NSSld3THBsRDBFT0lnZEdsSnJTR1lJaUwzUU1JSTBFaUV3a0xqMmgyU2VVTFplZVNBQ3dlTjY1M3RwOE9RcVRuWlZhdzdNelRYOTJQTzQySEJoNlRiZG1VV3JxaGVlYUdQTWtTUzNiS1hKZW5jU1FZN09LcmFmbk9aYk4wVTNqWkhZMCtoLytMLy80ZXcvZmpneHJaNlhYWFhidVBkamI2NGV1NHgyUFo1YzIxbTByZVhRNDduYWFqL2FPTjNzdHc3UXU5QnJmK2ZnaEpsQkQwLyt6Lyt6L2VQbTFPeDk4OU1IdzVLaldhbXBwZG5JeVR2UU1PL1QyMGhKY3ZuLzNiLzV0a2t3UEhoOWdFd3hmcTRVZGdWNDBtOTc2U3VmR2xRc2JGM2MrL1BqWmxjMzE3VmUvNERUcTArRlRMS0pvSnpxTWZrSldGQVk3VGFrcFFaVExya2hEcmlDVWNmNkdESGp4NlVzaGkwSUxOWVpDQms4eUswbG13bzlCVGt5ZFlhaFRaOE9pbEY1eTFWSHhWeU5MSU9yY3lBcHc5SWd0bTY4S2xhZVNHRmxncU1ySy8xbnlQRkFQQVdpWlVucFFnUklnY1JVcDFSMmd5ak1QK3ZlYmYrM1BTd1M1aXBKbkpHVnA0R1ZVRUJLcFRwSXQrb2ZsVGlLOHVDbFhjZFcxZHVLWUZKT0FLVy93VWp1SmVQV2RaTHdLS3RkeDJTRGhnd1F2MHpMQ1FBSVZRVmZPYUJTZWRiSWlZbFdyOWVaRjAyM0QrWWFLbzZvd0tZNU94cTZORGF1TkZSMm0zVFlMeDRKZXdhdVJEMzhYdVdVYS9DVTEzQllzcEFETFRsUHQzVC82K2dkLytGKy8vOGxiSHowNThacjFXWnp0OThQQktFR2xyVVlkUFhseWVHeUd5V1EyNjdXWCtvUFR0YWI5WVBjRU85MVpuRFJjODNnYXZQK3R0KzY5OWMwM2YvUkhETXZiMk41YVcxc3ZuQnFXbDQyTmxYYW5BNTRYcmwwWUhvMCsvT0E5MU5xZkJrLzc0LzRBemxVcksrenQxZVgxaloybkQ1NkV3WFI0ZXRDb3RkSUN2Y21vYXRXSXlGbTZyWkljRVdJb0tVWXhZTXduTUpkSVFhaWp5QkFabEMxUEZLYVU1b2lVdVl4ejdTTktqcFM1cE5nT1NiSUkxa2ZTY2lCUWl3UzZjWE0yVllWVkF4WE1NeGlYeXMveUFQTkUyVCtRRTRjZ3NYbFJGaTRqQXFTUkZnb0hSUGpnQW5GeVFLdXJlcVNVK2JmKytsOVEvS2ltWEpLSWwwNElBeVZFcHVCR244MGhxWUFLTFd6S1FNbElxT0lncUNaQVNhTU95TUpaa2p6T3A0SDZKN0VLMGdMa01vQVNLNUFnaVJZQ3RDVEw2NWMxRzl2VW90ZXdUZE55Yk92d1pLb1hjUVBxYnZJU2pldGdlRUFIODJZa2NXendONjIwR1lacHhuRThtd1hoSlB5WC8vZi80cC8reTMveTFlOS85TXMvLzZabkpPL2NQWUxsV1dwNjJPejJHdHFUWjBkZHoxMXFlS1BBajVQazN1N1I1bkpuTko2NTBQTFRjYnZ1WVFIQlZQS3paUGZ3Sk42LzkrRHRkLy9Nbi90eEk1aTR5MnV0VnN0d3RKMExXNnNyNjNxUjdUMzlKRStUNFhDQy9UUmNtVlRQVGtiajRXRHcrUDdEQisrOUN6Wm8wMUt6NXJTV2l5eUxnc3h5S1JRS0FZdWhpRU51OFZTS0pLcFdSbUYxejZRcWcwWTdMSW1TR3NEUkpFMVpTc21Ud2tkRUZGcitoVkxsU0JUMGN4T0dBQVNIZy9uTUZtQjlWVGlEczN4a3FCeFJubm1LeVhtSmhTaHFQTWRJZ2Z4VXBNeFE3Y1FSN2NhQVNveWcyaUNaNEtmdWRTcGdPYW83TTg0d2twQjVJZElzY3dCem1RRksxb0tSQ004cUtKRDRHYlpNOFpvNkVkTGxra3dNQ1NtVURvdVlXVE5US29Oa0Nxb0lPNFdXY2ZDaStwVWsxV3BXVWF0NTZEZjhnOEFQNHlRMkhRcytVNXBtcmcxZHdXYVV0aHp1Q3hZKytQZDVubHVXTlF1aTAybjR2WC8xVDQ5MnYxRmZYbm42N09qOVQvYTNWamNiVnJRM0dDOTMzYzFPelN5TXRaWTNDV2FQRGdjcmpjYVZ6VzZqYnZRbkljei9oVzd0NldDNjJtcWVqaWYxZW0wNmk1dDFKNHdTUC9JNzdaWGYvZWUvODVuWDcvUTJWeDFxU043cHJXNXZYWHp0alMrY0hEMUtrMmpRbjQ0bjRVNjNjL3ZDeXEzTFc1dVhMaFl6ZjN1MXZiN1Z6YkxNdFRndDY2N3JqMlptamU4L1k1RGV5NENJTVFMTTVWQ0pwbHE2SVJuUzRFaWtaQUZLR29WZ05pVmZzYUpWQnljbGJXaTM0QWhsTnM2Q2s2U0FHc3hGaklDcVZBSGJVa2JQbWtGNG9XR0s4bmxlaExOeUtyZnFmQW1sd2toTVViQ3RaYUZGVXFMTTMvcnJ2NFFUMzJLRnpEUE9pbEE4ZWlnTFhBRlNxLzdOVFR2UGMzRnc4YU8wZVArbGtpR09WYWpJcU9kcTRLUjNhTHJLSUxBOHowREtnNmJJcVJyRStjdDhsVko0OFFYdGlidGo2VmE3NFdLYzZ3Ni9INTlueGNsdzVuazF6M0ZRQ1o4YjVnUHFhREE5ZVBhR3Q3ejV5RHI2dHIvbmYrZGYvUzlyR3h0UDl3Njc3YVpwWnM4T2h5aSszRzNGV2YxNEZIcWVjV0c5VzdQMUpkc2NnZk00V0ttNWI3eTBNNTRsZzFuWWEzcEhVNy90ZXBadGpHZkJTc3NkaDNIVHR2N2dqNzUxT2p6KzVGdmYvdWxmK290NlBPQmRxc2pQVHg3MDczMXpjNlZ4YVh1OTVsbVJrWitPZzdjZjdkMTdlbkx2NGU2VG8yRi9QRDA4R1BFRms3YlphamZHQjd1Tlh0Y29zRXA1V3BHcUI3ZVVWaWdWVjFaQnFTLytlV0lPalJTZ1dnMGtsNldJUkx5RTB1d3BQVmFFaUZiaktVODdtdVdJQThtamhET1E0YWd3NUF3bE9TUEE2RWpOWnpTcTlqTUtGVC9YSktyV3VVWXU1Q05MOUxBRTFWRFNVeGRaQzBGWXp2WGtUQWJ6OEszZi8yOVFnZXhxZUkxRkFValZGcUhhN2FqTkFadFNnUlFvYlFrcFNneFlNczJEN0ZZQlBNcTJTUzR6NFh5MitWRFBpWlJRc2VERkNJaStSQ2xnUytsTXpSRUFwbkl6MnZocCtMdmRwbE4zdFEwNE5JNExsWDYwMisrMVllNWgySTA4alIzSDRsTXpwcFdsV1JRR0VCRkU1NWoycytQSi8vUmYvcE83My81dlc2NzM0ZjdvUno1M0p3ekMvYVBUMldUY2NlMVJtRCtkUkhZZWFxbTIxdkZhN1dhaG1aTTR4aDY0YStsaGJqenFUMXpYT1IzNTJCc0VlV0ptbVo3bHBtM1VOWDJZNlMxYk94NU9mL296bi9rcnYvRlhONjl1bnV3OWdHdlVxam02eG11bjMvL2cva2wvY2pJSjd0MjkvKzIzM2wxcU9zT1E4amtKTWlQWFZ6M2o1c1hWZHJ2WjFMTS85K2QvdWFnNWVUcnJibC9rM2J3RkVVQUFTTXNta3NBb0IwNUVLTDRNOXlwS2lNQXVGcFJoVXVXZzYxSk9rQlN6U3NqV2swZ2VTQ3JWcUlJVkNFZUZRVlFlVWlDQ2FUWkdSZWN0THZIOEx6RXFEZ2FLQnYrb2lYRXBwMnBVVkJVc3hnbXFQVERWdk00dU1FYytCNm9LODdkLy9WZGc3bWpvU01aaTZDcWJnQ0pFQU5RVTV4WkE1bzZ5TWN6QUFzaUl6Q3VXeDdTU2xVWVZyR2EvQ2tSd3dSVHJ3ejgyc3N3QWxIR3hJbUtkaEdZT2JHREpGcUF5VUQ1M3VwR3pQZ3VtU1JoMzI0MTJnMC9xMnBZeDh2bWNsbTNUSUtLbllJVVlHNGxwWkJxdTUrVjV1ci9YLzdmL3krK05uMzdsNXFVdE9QWnJUZS9POVZVbjlyZDZ0WFFXeEdrMm5zek1QUCtSbTJ0M0xxK3V0dWtUMVYydlpoaDEyMWxiYXJjNnRQMUxOYWRSdDZkUk1Sak4xcHB1bEdTT3BoLzBaOXRieTM2UVJwbjIrUERveWYxUGJsNit2blgxb2xPcjVWNG5MOHdnamkwenZiQnpzVnYzbmp4Nk91bWZPcGlqbHRkYlhkOVk3emc2Wm9XM3Zycjg1bWR1TGErMFAzem5uZkhlczhHelJ6RDZuZFhOTEtNL1Zpb01JeHc5a1VjNXhwUWxSU2hDcE1qS09JaVVBTVh6QnBBVVk0dWo4aVlsTFdNa0RCSERVWEdBQU1taHFrZzU4dVJjRmhUR012UUExZ2VRQTBYUHVDUXFLT2xMT0orU3RGUlhKdWZBd1N0clpKNzZhUnZpYkM2QVF5dGtWU01CS2o2dkFCSHp0LzdHcjVDUGRJWW40bFVCSEJHQVVFZitNNkV5SzJCRzJSRDZNRXdDK1dKakt4QW1JRk1xWGNLY1pZbFRuUzJybFNvcjRzWEtzWEhON0Y1Z2RLSHJydXR1TFBOOTdYeVBhVkVNSjJFWXgzWGU0c2VXajVPWEQwWENpdVR5ekRxRVpSbmYrWmUvODkvOS8vNXZQLzZsVjhMeDhlSFQzUStmOVc5ZXZkUnJlVW5DYTVmRFVUQUprcVpyM0Q4WVBualNIODJTZHFQaFlhK1VGNGV6Nk5IZWFMVmQ2elZycHpOL3A5YzlIbzEwQTdPTVR5dEFDT01ndkhYMTBwTzlBN2hUY1o2L3ZMUDhMMy9uWDIxNDlZdXZmYjdUYm80bUE1Z2FPR0RUMDBrY1RodHJuUi83NlM4VTNmYkRlN3ZiRGZ1bGxkN3IxN2V1YjdaV2xwc1RQNnUxVjE5Nzg3TjlmK1lQaG5vdzFMSHQxVzE1U0JUT0JvVlNDb3ptZ0NDQ0FUQURpZXBmL0pSS2VPY1Vna2dtRjVIUFVTNGVGWkJyR1oyVGNrajVoK29FcFFoRTlSR0lndDFSYURhdFlvYUdxbWpKVVBMNUw4MWVCSkJWS0o1bGlvS29MSTdtTFJZNDE5b0ZWclR1S0s2eTRYRUlFa2NFWXZpalF5cnpHUmIvejdma3VhU1VuTmNtUmM1UmxJa0Y1R0syMEtNMFZ6TEZCditDTEtuWU1ZbWpZYUZlbnhZdHozWFNvdWcyYlpEQ2lVNnpQRTd5eWNUbkpVamJTbmhKUnJkaG5GbVVwZlVpUDNwMi9MLytQLzd4TzAvM3Z2bTllOXViRzJzOTcrSHU2Yi80NDNkM1QyRFlOYy9Sc3pSM3pieUdDU1NQL1EzOThQN1IrSEFVanFOa211YWpPQnY1WWNPdE5WcTEwOEgwbFN2cmc5RWt6a3pMTWZjSHMrVzZhL0ozSklXRjdYS1Nydlpxc1BydnZQUFJKRXlEVHo2NS9jVWY5UnFOM3NaR2IzMTVhV1B6eHRXTGx5N2Q2RFZXMHpodFJVZTdKNFA5NDlOaEhMLzd3Y0dOSzl1dWtSN3RIci8rK3N2TjdRdDVPTnQ3OG5qU0g4OW1VYk5WdHh6K1ZBV1NFRkZ6bE9aaUVUY0FlQXdxKzg0ek15UkNIQVZSWW5pUWhNTHdyRklFaFZGUU1sZHhPWjREb0o3RENyMEFDMG54NTIwMmtTOWlNUFRFbHJXcmVvRUVxVnFYWk5vZ29kWWthYXVRU0VjWUw0L2tvVlFGUjVBeW1IL24xMzhWcE1BQ2lENXJBTEtoR2NRckp3b0hCdWFYSlBNRXd3dHd6czlhb0t6NHZBaG5KS3B4RWlHY1VaY0ZTMFJjdUZPOTdScG1sTVIxZmpNVk84WjhGdkx6ZHpNL2NTeWpCdjlCYmk5anAycFpGbS8rNm5ya2gxLzUvWDl0YWYzamdYODhtYjczeVpNc1NPV2RNZm5CWlBaay8rVE81ZVZlb3o2WmhsZ05YTWRzdWJhdTVTM0hxTmZzcURCY3g2cGJSbjhjckhacTZ6MFBNdXVmakRmYkRpei9NRFdtWWVyVmFra1VyN1dkS05YOXdGK3BlY05aRkNUcHQ3NzczdGUrOSs1V3M3YlU3U3gxMnk3V0lxZHIxenVCSDMvbHk5LzJnbWRYYjEvVjE2NE9UMCtTSVAvNGNQcnV2U2NmUGpoNFdkYWNTOWV1cjF5NUdCMDlDK1BvOU9nd21BYWRYcy9tMjdveGhrb0pPQVFVQ2c4VW5SSzh4S3FnVkJuL0JDRldsQklES0JXZmEvcjhXQlZWWEtyQlU5bnp3dWVoYkV3RjgyUVpVV1hQUTBYRDQwTHBzOWo1S3NzNFFNVXdqNnRJQ2RCYkZablhidjZkdi9tcnBDcVRpTW4wcUlvb0c2dXluNXZ1Y3lDdmhkWjlLcWhzTnUxL2ovSUhnYXBsc1EySTVXWnpablF0dzBpS1BQVERLSnhOWmo2Zm4yazNXblcramgzcURpVXU4aFN1Rmx5QUxFOHdEUStQQnIvenovL1o3LzNoMTFOTnI3djYxWjdUc3ZNMGpETFR0RDM3V3JkMmNobzZSbmJ2WUxUYXFoVkpWblBNcmZWMjJ6WTNsaHQ1RU1EK04xeXpWN05HczdqajFWWmFqbVVYZStNTUJEY3ZyNFJCZ0xabFduNTdlMlV3bWMxQzNyd2RUWk5PeCt0akl0TE1mNUFNRHpOcitkSzFDK0hvU05mdDhXZ1V6MDZiN2FiVFhqL2FQL3J1MngrR2FYSnhwYjI5MXJ0emZlZC8rM2RmKytTakoxN3NYOTY2Rm1yYXljTkhXcEppL2NyeXZMTzBiRkhqeFZ6VGtuRWNJRjhWWkJqRm14Q2c2T1l5QkxJVTVGeWVSS3VJSEVRTCtNOUl5Vm1ZVnZ6bTFTekNwNkJvbUZsMmptZUVxWE9FQ3NtT1NIVGVLbFVwQUJqMnNjSncxd2hTYWVhYytJeW1wR1RMUVUyOGFvRDVkNkh1cUtGa1NwQUVjZ21WQ0FBc0FGQ0o1K0lxTWdlV1B4L1l4aGZJNW5CV0NZbFo2WXUwTHhZR0pqZXRZYmFFcUd0YWNNK2hzbU0vcXplYlRRODd5eUxoNWFBVXJnNS91c0VMN1dhV3BqTS83ZzhtSDN6M08zZnZmbng0M1AvQ3kxZXVicldTTUJ4RW1WMXoxOXExOVpiaHgxbWVKdnNEUHpQTXcwbmNiYnFiNjB1Ulp0WHI5VjdMYWpyWXRXdXJiYS9UOEk3N3A5aVFYdDlablFUUmszR1lCTW1WYm0xcnRjTUhGb3BpYTZuKzVHUnFadmtrVHBiYnRTZ3JDdFBlNk5iZi9lRFJ2WHYzYmw2NHNQUHFaNGJqMGY3QnM5eWZUSVlqMzArKzk1MzNMQ3Y3c1IvOW9hKys5WjVYSklrL1dsdGFmalFZNys0ZEdNTm5lNCtmVHNhVDhYaWFaMGswSGlkSnZMcDl1UnJ3VWtJdkRNZWlkQW1sRFZ3QXBSd0txcWhTTzRCaUo1cUFvSkNLWnFFZVJPY3BGUmNGVWNDZlJKWlpBTWt0R1p3MXRZd0FJNDJaRTVhMGlwTFlxb2p5M1JIQmFiSDlDaFRsM0xwWERLRHV2L0dYZ1pRTE10Um9aa2krcEVoVUJhTFBtaUwzcTVTdm82ai8vZUhGSXVKMWxjT2c2c0Zaam44eUdKcGhuMlRkZ2w5L3QydTJsaHRHbkJhTk9wUmQ5eng3T2d1U0pLclZYSGp3Y1JUU0M5ZU1LRXFQVDA2SEJ3OVBkM2N2M3RnNk9KNGNuWTdIa1RFSTg3cFQvK3pOaldiRDFhSWt5cEtpTUhZSDR5eExoMU8rVEcvdmVQcm9jSHhodVlIZHNHczVXVjQ0dW5icDBycGJzeWZqcU5tMHNicE1zL3hnSE0ybTRjdlhMNXhPWjIzUHpRdjlKSXh0dS9Bc0p6ZXN3U3hjOXF5amliOVVNMzcvRC80NGUvYXNzM1h0OGt1dmhMUHhKMjk5T3pqYWUvM05WMXRlUFlxeUZTdEVjMy95Q3k4UHg1TTNMcTlkdkxaWlgxclZMUVBiQXo4Q3hOZzJZd25xYmV6WVhwT0RUMWVVdG9KaDBRUUx0a3h3LzFKaGxIUnBUMlc2NEZoU0tlVmhXcUZBTFJSbmJGZ0tjZkdNY1o2alh3VEpsNGFWOFI4RUpZMkNGeWsvQmNOR2xFMW5Db3VJdEpqTnJhQ0tzVDhBTURIL0h0Uzl5bEJTcW9nK3BYa0twUTVuaEFJcS9XSllCQlFudkloSERwdTBtSE9PQlAyU2NtV2tIQkQ0N25ydEpPdkVVWnpueVhxdkdTWEZMT0lQT09RVFk5eW5wbWtHRDk2MitBSVoxQkpGU1JqRFlnNlMvYnNuZTg4MnR6ZWgrZENiYVlnTmFES2MrdWtrblBqRjhTUmNXV3EwYTNiZDRSdWJkTk9hQlB4WTJVZTd3K1dhWTNuT2JKYU5nNWlYaGlLdFpobEpWdXllaG42VUxYVWFXbEZnMzN4d1BMeTJ2WXBOODhoUDJ1M1d4STlyMkZWb3hoZytkNk14aTBMMCtOazR2UHZzOGUvK2I3OXpjMjExKzZWYnJicldiaG5EVTM4MENpYkQ0WU5uSjBzdDc5R3prZU9aZy9IVUtOelhYcjNocm0xOStNbXpuU3RYV3QyRzQ1b3JHeXR1czZlYkxscG84WGRZMUUvVE5OV1R0Q0xyU2xaS25PVzRsMENjNEZVbVRvcTRwSnNUSTRMeU1rS0xBT1psckFLa0dSUklYTEJWdktLWDNEUDl4cGxobmwzQlBGK2RYZ0FXa2paVmRPaTkwcU1LRmtveWlseno3LzNtOCtwZWJURUY5UUp3aDF4R3o0QzFxTXNCQzBGVlhESVRFRVFKenpHUjNPY0Z1Z2dnVUlNeDV3T1JwWVU5TlplaGlIbWFOeHRlR3FkWkFudWFkNXZRTHNPck9kaWE4amZEOGl0aWVEUmorTjF4Y25xd2IrVCtXKy9lVzE1dHplZ1NKSTJhRllaeHo5TzdiaEduOFNSS2s5emNXR2w3T24rWGJmTWhZVjR2T0owRzkwNG1iOTdlcnRkdGZ4WWM5bWRqZU9OcFp0bldzK09SbjRGMzd0bEd3OUl2cmplZkhRM0RER2FYejU2bmh0YnliUGp4cnV0TVp6NW00MkFVbW82OTFLdGhCdTUrL1BiYTJvMmxyWFZ2WmYzQnZVOGVIaDYxMnZXdDdlVTdYM3J6OU9DZ2JlVmhvcTF0cjV5ZStLMWF3MXJxUEh6dzlPbXovbmdDajhrOU9EenN0UnVwVXplMXpMVDRNaHhJaHVaZG5SRTROR0w2S1RKWms4c3NKVVo1S1pWa2w5S1hFaVdVMmwvUkFrRnUvS3NRNTBEbEtrWWxQNlV1RE14Z0tmNlhzMDlsY1VBbE1nOXlsYU9NZzhzOHZuajVRMVdEcmlCR0ZsQ1BzeXFCWnBSWk1GYk1RZ0VlNEx2L0pad1VHeHpuL0VqOWFTQWNTeWhSVWpjYkl4V29Pc29NNFRPSDU3UEtjMGxUSnViSmhTQzhTNEl5UWp6ZjlOQlBtbkJSMENuYjVDWDFPSU54MVpkNHRZWmZDZVlQVVIwcno3SjZyWlpyV2hLbllSd09qNC9lK3Q3N2ovYjI5cDd0TjEzVEtGSUhia0dVZk80S2J5Wmx1VDRLMDBrQ1Z2bkYxYmFtNXczUGh2ZVBTWFBFYXpYYVpCWmYzVmpwTkoxd0ZtTHBxTmRkeDlTUGh1T081ODdDY0wxYlN6TnpNZzV1WFZxMUhKczMvSFJ0czllcVFkcEZQZ21TS00wM2VrdUgvZUhtY3U5S3IvSHU0NU5KbVA3dUgveVJmN0R2NU9aZi9PM2YvTUlYUDMvNzh2clZpK3ZyNjl0T3czdnpKNzdRMjE3eE5UdkprLzdqajJ1QmYvbjY5c2lmRFhneklIcjQ1Tm5sbmJVZzFUNTQ1NzJsNVNYNXNwcVNGcVhFa3dJcUlzZjdISkpRanFlWUVwR3RTZ3U4U0kvRVF2cGNGa0Rsbmkra1lweE9FaXN6MUFuSFJlUWNPSjVzRi9IbjZpOGJ1d2pNbDBtbUVrcXJVUmxQWkRQWE1oQmg2ZnM3Zitzdmd4YWp3c2toZ2NXa3BBTGhVd0pGc2dBS0tkRnpwaDJnc2dDU1lwTEhLdjRjQ0hxeFNIa2ZHZjhxS0NpekZhalpiT3A3RXhzYlNwYmdYT1VUOW1tYzZIcG0ybkJGYk14MTJEeDQ3OWdsNWhMOElQSm53OU9qdytPam80ZFBkZytQQjFtcUxUZWRPeGQ3VnFHTnAyR1U2cUhsREgzNUpWU1VkYm9OY0JsTm8zSEkrMVdPWlIrTVo0T3h2N1hTV1Y5dHNBcE5hL1k2dlpxakplbFN4enM4bmwzZDd1UjUrdmh3dk5HQVAyVmo0L3hrdi8vYWpZMm1xV1BwUUNPUHNhSE9pOXVYMXB3aW5pWlpxK1dlQm9tclovLzAzM3p0TC8zU1g0RHo0OVNjenVhRjlzckdGdnl0blV1M1gzbmpDMjkrOGRYUC8zQ1VKMm4vb0ZmWDYvVjJ1OWN4SEh0OWMvMnJYL2xPT0JydDdlNU5wK0h5Nm5LdDdwVWlVakkvQjlEcVVtVXFyM2Z1d0VCRCtEU1I0QldvSFB5VFNXWFhud2NxVElXWFVaSUVEMmR4NWloSzJ1TXFYb1V6c3VlQ0FIUFBRSGkrQUNSSFcxV1dWRU1qUTRWZktDNDIzdnk3di9tWFMzUUZ5RkUydmlKalZKR2d3Tno4ejBHUkxVS1pzUUJzd0VJUG5nOGwrZ3lFdktLdm9Nd2pJSVZ1NGErWVJNWW9zZmdONnlKMzVCWDQ4R0tESUt1N1ZyUHVZT1ZPc3N3RUhnMkh1dWU1b1puUmVEUThPVDQ4T3B5T1JpZUQvc0hwNFBGKy84SHVJQzdzNFRUdXg0VmxZVHVZd0MzeTR4U2FlUlJsaDVQODFFOHU5RndzQm5DU1I5UHd2WHNIbHk5QjUydUY0eWE1c2IzV25rMm1HNXNySjhQaGRKWnNyeTl0WGR3K1BqellYTzEwNkFzWi9jRzAzZkNhVFhlNTRVN0N1Tjd5OGlnK0dzd1MxOXZaMk54Y1cvWk03YU9uSnoxYnYzbnpNdllIbmMwcm5VYlhhWFZzMC9JYWJhL3UxcHZ0blJzdlR3dnREMy8zNjkvLytCQjdoZjRnTEhUejhwVk5JNS82czFuLzVIanFKOHVyS3czNTRJTFNXeVdzQ2tyWkxRQ0d0SXlwWEZIRUVvVXpVUUpRL2psaGlSSllwQ3B6SlNoUWNZWTVaWmxUSWptSVB3QlVSc20ybXBMcTlEd3dseTB2YTVFaWNxTFNTeWxWajZnN0MxUmF6R3MzWWxxWnlRd0Zxb0JjNjF4QWwyVmVnREo3QVlCRG9QUEJLaVNwaWdzN0tiUUlaYWtYTXdDQzV5QXhoa2x0ZS8zSUM2TEVMQXJiTnFEeDhrcXRvdVphN2JvRjl5YkxzS1ZrdS9NY2s0TFB1aFhSK1BUd0VBby9HZmExa0JjZFhZZGZkTm9kVGZlR3dlRm9Hdmg4TDhmTFc1MGlDc01vekRRdmdXK2tGWmZYT3ZUbUxkMnpORmpwUjN1blR3Nm1iclBlNk5URHFGanR1clpoTmd4dE5JcytmbnkwMXF6L3lBL2ZlZmZlN2l6UjRLOGNUY0tkOWJiR0c2L0dXcWZ1MmM3SjJOL3RqeHVOWnFiWlcydEx4NmY5cVIvQkxmL1dIMzMxRC83MWw5ZmE3U3MzTmgxTDUrdFhuYWJ0dFUzYk1VMDdMdHovNnYvN1g5MjgwUDc0NGY3K2RKRDQ0NDgrZXJ4V2EvWTg3Y3FWSGV3OHBsSGE3bmJxOVpvSWlPT2xoQ2FuWEZtSkVpdkRpU2dTQ0pYMUJtNmVMOUlXS0pNWVFWS2ZBZE5sOUR6SVdNdS8waWpTelNuTENERmwxZzhNNTBDMWpVRXhLNzBTenNYU2pSZFFrV3JxcWxiSXlmejd2L0dYNUNFNkJTQ1VQSW1lWVZsSytRdHpVSW1TMWY4dUtFVlg5S1hmdzlTbmxrVzdTNHJuRmhQcFExbFNwWEdHdFQxSm12eEkzblRrZVI2Nm5vU1JibGsxeis0MlBkTTAvVGpHUGhVR0c5TWdDS0s4eUNOL1dzU2pZSEMwM2JPTlBJbVM3T0phcjk3d0FtaCtvVVVGNzh2Q0FGL28xWnFPWGJOMERiT0JkMnl4U0pqYnEwMkhyeGNUU2VzNi9PZFJrbDNiMldwMDI4MmFBMjdkYmlPWWhuQlJDdHY4em5mdjlsYlhIdTRmOFkwM3BqRVlKNis4ZFBIeGc2T1ZiaDBMelNSSytsR2haYmtmQnRjdVh4d2RuZkJoblR4SEUvZVBqOFBoK0hNLzlJWDIraHEwa0dzVHBHYndnNGxCRk9ZSDl3Nm0rZkxHMnEwTEY1NzJnMzZTM3owOC9YaC8vTW45M1hBNGVlbjJiY3lmVHJmcjJHcUZMNGRQaEVldGdMSUFGcVVKa0NnT1lrY1lteVBQUVVtMUFHWEdpNENza29RUnhzRlpwU3NRcWhKS21nVWdCa1U0Q3hkMHNRSkZUb1VtR1lCcUkzRmtLQldTbmhBa0xycHYvcjNmNEZZVnlUTXRxNEJ4a1kxS3F2dFlpeFNWdFM2VEFGSlhVS0lFVkp0TFVQSVdVSWd5SVlBQlFjUFFHT0NmMC9VeVJtQ2MxUHlWcGVHYnEvM3haRElaQW1FYmZBNFZ5dTBhZXFkZHR5MkQ3eExqb3o5bWxtVnczR0Zwb2x3L1BUaE9aNmR3RkxwMXEybHJMOSs0ZUhGamVSUW1FY3cvdG9UUXpydzRtWVdmdmJ5RzVRQk1NcmVHWTV4bGE1MWF3NEdGMWpFejRsekgrakZKMHYzOVlaenFzMW1pNTRsZDVKNW5aMm5lN1hXZUhwdzgzanU1c3RuTWMzMjUxOGFrbWMzU3dzeXdEWEFOcmRXdUhaMU8rdFBaY3F1ZVdaNnJ4NTNsRlQ4SXJVTEhEdmZaM3Y3N2IzMjNhN2ZxdlpYV1VpT2FESEkyTE8vdlAzN3ArbXA3ZGZ0ay8rREJzMmZoTEwrMjNMNngxdjNNblN2ak1PejdrMmRQbnh3OE8zeDQ3OUhheWxLbjF4WWZCR3NUcFFWNWxib3VFcFRvR1ZBanFzR1J6TkxhQ0tJRUpJQlJVTm52NTJFeGR6RVFPWTlMdWlyd0E4TlprVThCSXBXNkM1Uk1xV2tzeXlQcktLMCtueldIV2VkMWQwVTN6MStFY3dvbmlYTVlPUzZxK3lLVXpWQkEyakxLbnhCWG9EQXFycDVxVmRmTWZoQlBnTkF6V3hWRWI0WmFOd2pTWU9wRFhldTFPZ0FaaGw2MFdvNkYyWk5uTTk5M1hBc3JRQlRIdkdhcGFjZkhKOUhnTUEzR2NSVFloYmJjYWVWSnNyVGNTNHNDVGpiODlxekl3amkvdXRtRmN3Skh4NnA3N1dhclVXODgyenUrZnFsSDdqRVUxL0FzVzdQTUowZjlaM3NIWHF1MkI1ZGxQTDUrWmZQaWhlV3BIL1BOTmptZlgzLzUya2FkYitvcjRpVEZWckxJdFNESmxqMHJ3ODdWc3FjenVPRDYxbHJickxXM1Zydjk0YUJkOS94Q2YzcDArdTF2ZnVQMDBlUFAvNmsvNDlidDBmR2VVZVRUL1FmZi9mSjMzdjNLVitIdHYvM2VnemdMeDFuMjlzZVA4dWx3ZmFsdW0yNlVGQTlPKzN2SHArKysvNUVaNTYxbXE5MXE4TGFtS0xLeU95SzVVdTdFTGtiUFlaUU5mQjRVc3VSVkFzdVZNUUZtL2VDZ0FNcEtYVGdyZWo1ZXNmcFVVSnE0UU11bXFwMndBQjFhV2FxQVlXQ0dXUGUvZ2pOVmJWR1JwU2FlT0NkS0gwaUJsQ0lEZ09La1FMNlRodHBZSzkvMmpVSXNXQkpVVkFMQ1RBeE51VDZvZ0ZyWWY0RTUyL09BRW56Q1hpVkl3MWJxUjJFOTA2M1pjQVNYcGJlOHpCVzhLQnpIb0MvRGQrdWIwMW1jWi9EbWEreGlsb2RoRWtTUmYzeVFCSk00bUhJREc2ZEpucnVlWGErM1BucTBIMkpXUUNBNmFNMVhibXdZT1hjRmJiZ0hkZmZSWHIvakdodkxiZG4xNm5CZG5wNk1qNlloUEpCclcydjFacVBqRkE4ZW55eDNtMjYzalgxa05NTk1URHVPZGZQcTVrcXZaVnVXSDRkTFMwdjFkdXZoazcxYlcwdmpDUE12Tyt3UE1IT3dFQzFoYitvWXZaWFY0WGdTNU5wbzZuL3k0UEhnZUpDY0hHOWZ1UjdNK28vdXZ2MjlkOTY1ZGVkYWFDOTllUGZCV3FlVnpNSk90eFZpMWVEUFhZcEVMNEk0eFhUQ1F2SDQ0UGpodzkzN2R4K3RMNjBzTFhjb0xBUWMwRG1hY3BFZlJVbkZLREZ6WklraVFvTFNENVVQS0xNNGcxVEppbEtXNWs4SjNEdlQrSUlJQTBSU1ZZcWdqZ0N4emd0cHhFaXFORkNwbXdxaUxVckZrU2RiMGpPdFVZcXVXb3hzT1VpTjhzek1jNXIrN3dHcUFPMUZWYjF3UllYZ1Nta0NtRWNNemJiU1k2S1ZEUytCNUFCaFUrYW8rT0lLb0dCUjBSV3dScm5rM2cvdHd2Um1mZ0RQdDlsdDhUVXJTZUk1VmtOKzEyekpMMU5Odmd0UzdxM3krb3cyUERvZURRN2l5UkF1UCtwTllZVlp1MkU3OW9mM2QyY1J0QmNONXlkVWJjMjh1TjZvMlVhbVdiMXUxL2ZEdHgvcy90RE5UZGZTb3poYldtNS83ZDBuVTE3NjFMdnQrbzJyRnpaaG5vK1BuK3lkUGowSmJyMXk1M0J2djJrWjQzSFFxcmxYYjF4ZVdXcFB4N09UWVFCM3k0TGJZeHV6T09OdnJpeTdmekpZWGwyYmhaTTBTQnZ0enVIaEVYK2R3b3M2NXFPSEQ3N3k1VDgrdVBmb3ptZmZXRm5kM3VnMTl4NCtpYWREWjIzMTJZT243WHJOMFBKcjJBK2tFUmcyRzdXYTdWNVk3bTZ2dEdMVDRBWTR6aDg5T2ZESC9yWHJWd3hUYnJqaVh3NGk3eEtxZUNYZGNpZ2tRYUJhUzRSWlpVWUZDcThBQ1FaaXkxQXFhUWtjV1lVaFRoMUx3bk5CUWFuK2xXNHdmZ1lMU25KbTErZFFWbHROQXhBWDV0OHRmZmQvWDhpbHROb1JLM2FLR1ZXUFVTenpvc000bE5XcHI4cWZnY0txVUFGbm96SXhLSVNnT3JZSVorUlZicFhTd3N5T3pWYVNwRUVjT3FZTmZVN2lDRjVHMDdNZDEwYTdmTmp6TE1kZUUxNDEyZ0tucG4rd2UzUjA2Q2JUSkFxS05FdVNFRk9oa0R1dmovWk9Cak1mL0dFNmFyYnorR1M0dGR5K3RyMlVSUUVjN3lBSTJnM3ZENy8yd1k5OS9ucWVKcjFlODE5OSsyN0tPVzZFcytqTjEyNHNyeTFaNGRnMnpiY2U3SzJ2cmM0bTB5c3JUYTFJOW82bVJaSjYyT1FhenRIZXdZZ0xEbHJJa2NRR05FL1RlczE5dUhkZ0dFNGVCWTVUWDl2ZW1vMU91NjJtYmxweGxBejlhUDl3Zi96azBSLys3cGN2WFZvNmVIai9wUi83OGY3UjZMMlBIK1RZWmd4bmo4Zit6c1d0MnhmWHR0cDFyRTFZM1BiMysydnQ5c2FsemNjUG5rWStPcDNhVG52bjhrWDFpaklLVWNsVVpDa0paUk1saDNZVEkzdzJja0wrN3djb1JHN0NWSUtveWp4STNUZ0k3K2Vab2tiYWNtR3dHQVNFZFJtWDhTRmdDb0lDUlpTbllJaWJRVEllQUx3V0J5QVRXdmRQVS9kRlEvc2NxR0xuUU1ncUpNOVNXUDRZVWRQaFR3YVVXTFQ2bndLY0RjOHhLcHRYUktrWjJsM2JjZ2I5b1c3enByRzh4aktuVGRhMU5NK1AreE1ZZUhtV3hnckRhRHllams2UERnNzI2M29jamtiUkRBWWVOZzgraXpFTC9HZUh3LzZNRC9GQ2dxNXJZOU42YjdkdkZrYXo3cmJ0d25LOXI3LzljSnhHVnpkV20rMTJmNUo4NitNOVNsVFh3eWg1NmZMbWhRdWJkVFBWOG13OGlkWjNMdXp1SDcxeWVja3gwQXhqNzJTODJtM0cwUVNPOU43cGNEQ2F3ZWU1dkxNMkRHSi9GalliWHN0elBubTZiMWxlelU0bnc3RmxPdlYySTgwSzdDVmcvbXVlL2Q2RHA4ZVR5Y1dWelozYjE3dGJ0L3E3OTdENUhrZUo0WnE5dGJWaTR0OTl2TGZmRDBKL2RuQThEdklNQzA1YzZBY0hwNmV6Q1phTFIvYyszbHJlMk56dXllMDQrZ0lVbndoUlFNbFRkVjNHVHd5V2FPdHpvdjkwNEt5bndsSVJ6NjNpNTZERTA2aXAyQ0lJcXB3S1pmNGlueGZpWWg0Wngyck1oUUJSUlNOSUFlRG1GZkY1OXoraE15cEhjZmhCWklxck1nUWlLUlpBZDhXbitZRzZybGFKeGZBaUtCenFsYXJQVVNnVUk1b2VwdHJFNk1KeFFaM1lZK3J5M3VvSURra2FZUTh4blViVElMRmdObTJMMWowdlJxUHg4UGlnZjN3eUhRNzBaQnI1UHI4dVhCU3dmL3VuNDd1SGd5Qko1WTRpWDlRT3hVVlA3aDJOdnYvbzZQNno0WWNQRG82bnMrM2wxbktuTVlxMFROUHY3WjVHS2IrSmdBbG1hZHBycjF4dDF5MDlUelREZGVwTitDUDk0OU9YYjI1Q29SMnYxdXJXdW8xNnAxUDNoeE0vaWdyZFBobEVMMS9iTlBYaThiUFRyYldsbXEwZDlFY2QyOVhOT0l4aXE5WVpueDZIYWJHNXNsSTN0Sk5KZ0EzdmR6NzRPQndHdDI1YzJyaDZNMGhtMjIzdkMyL2N1YkM1ZFhqYXY3OS9FaWM1bjdzRWVXRTkyejEyc3FKaFpGdTlSclBYblFUSjA4Y1A4MWwwNmVwbEtyRW9DNFlNcXFuMldTSlhjUnJMNFJTRFdRcGY1b0JnMVVtQkZLU3BGZno4cU9aU3lZZGpKZHJBZURVTkZwa0FxZ0lLenpOVmlOR1NIcUJ5eGFOU3lmSmNJaFVIZ2JJdlFyOW91OHRuWm40UWtKcGt6NE1xckFDeEJSSkdwY2F6VmlwNGJyby9uMzBlbElHcDJNcTVLakN2V2lMZ3l0dW8rN01hRk5TeUxkaHlxQWwwdGVHNWNSVHBwcG5tT253WktEcXZTL0l6cS96SzJQN1RwNEUvL3VEZXc2NVQ1UEUweEZZMVNXWkI5Tkd6MDRQaGpBL2ZRSDZjSVE1WFJrYjVGYzZvMElLSTc4aCs1ZnFGVHNQaDgyTmE3dWY2WVg4RVh4LzlHMDltbjcxMXlYT3RocE1QUjZIWmFOYnJ6dUhKcVd1aWRydlg4QnpQZmUrRDNWZGV2ZWk1cGorZVpKWjc5Mmo4M2llNzIrdnJONjZ1REtaaG1tUTd2ZnFqazM2M1ZndlN6TlN6ZXJNOW00NXl3L1pEZU9FSmZQNW53MGwvTk80L2Zuamo2dlcxbGZibDY5ZVdkNjUwbHBjbjQvRnNFcmFOZUxtSlZjbG8xYXp0MVU2OVlUOGVqazhtMDNVdHYvUDZyZE5wT01WT05zcXZYTCtrYVVrcFcwcVQwMXRFV21IS1NKbXN4SzRJR0pTS3Ezd090MFRPaHJYQ1BBK0NWemtnWm1RQmM0NUJ4UUZWUzlzUVphNmlsTmNKS24rR0JJS1psNjBZSzFJQlJmT0QxVjNxcW5SZHpleXpwcWppeWtLTDR5UjZ0OGllQkdlbFpLS2U0MEF2SHgxRmx5b29yK0lyYThFbzg4bTJyTDJFODdXd21UQU1nN1FXNXpwMFBVdHl3M0thbldhV1JNMW1reTAzclRURlpxTm9ObHpYdGZ3Z1RPSmtPT2dQK2lmOXc4UDNQbjVrNllWckdYR1NmdlJzOE5IZUtYYUgyQUJBNFYyVEp4dHpTSmZYRzFqOGVKbVdaWjE2N2ZyT0JqYUZjQ1I0Z2Q5eTd6MDdZcHNLelRhMS9zbDRaNlBYYmRxbko2TmFyOWR1ZDl1Mi92NG5EeHFtZGZuS2FoUmwvZFBwZE9pdnJMV1hldGo0WmdOd2lWTW9jWDg0M2U3V01rMGJUOU1yUzk3ai9xelRxaWN6SHo1U3U5MmJUVVpaR3VkcFhxdnhJMmJZYlUvQzRIZCsvOHQzTHE2dnI2M3R2UFNaclV0WFZ6ZFd2LytkYjUrY2pLSW9PUWlTNWFYdXM2T2hydHZSZE5veHpZRWZuZzZHRGNQcTlwWmJLMnRiT3pzT25DNE9nR283eGFxc3ZjaVZLU0xrV0E1SEZjNlJsQ0FKRWpKQ2RaTVJoMDdnZUVaVm9zcEJWM2p4N0V1UVhQVzhRb1dSbUxMY2xmNGdMdHdSUFN0YWJXb0pQT05mdVBIbExoVWJPRE8vL3FzOGw3Q28xaXhCa3lVeCtIb29nQlJjSkJFTnlHUzFrUTRwRUpZcUxNSWlaazVRWXBRMHdVbmxWWmdTU3RhcXAweWVaUUZVa3E5WDVkWEYvRFJ5NkpMb0JuejBkcnVlcFhtbjFYQzlScVlaanVNRVlWQ3J3ZjExOGl5YkJsR1k1WS92UDV3TkRrOEhwL2Zoclk5NWhmeDdUMC9pTkt2emEvR1dZZXBRZW1oenU5bnMxS3l0alpWWmxNRTRlNVoyNDhMYStuSWJtL1VzUzJxZTU5YmRKd2Vuc3lqaEY4QTA3ZTd1a2FrWlRaYzN2T0xDWGxsZnhRYWdhNmR3cHJIOHRHcmVhREtOdzhDUGl2WFYxZ1RiNnlpRmlqZGNhNHBOUlpDMm9jMDFweCtrZHBIWnRVWVFKMWVXM1B2OXNPUGtWczNxajhPZDlXVk0yMm1tdTZZeENNUGp3NU5wZi96WnozK3UwKzUyMXplUGp3N2VlL2VEYVpSMWF1NGtUakU4am10QUxQVnVFN1lBYzM2dDVRYis1SlZYUDNQeDBySXVydytDQU5Vb3lCalFjZ21Vb3E1VTRSeFVob3pSODBHc25rVDR6NU53Slk2V1MrRUFaYTZBeENzRXppb3dqbElsSGgwUkJFR2RGbk1CZ2hVYXlTaHhiTCswcDZUa213aGczWkdZQnh3WTRiUmdZeG1rUERTZWNTbEdRbWFWd2lqSmhGSUJLMUNZWE93SHR4SWlPd1JGQTBtcjB2TXpCQVZLRlZjQWIxaE9STEtIbndvb1ZSU2VsZStPckJ6Nmx1ZEpua05mWVpoZHZ1SzlpR0srYmpkTlVrd0syRXZMc21FdlQ0YXpweCs4ZlRJYTlRLzRQdDd0cmplYXhYeDh4alFjM1hROXg2VlZ0enpMNkxRYm43dTVlWEZ6dVhDYmw3WldkMXJtRW54end6QzFQQXhpcis1eDhiSE1rLzRZOWFMQm1IRWZQenZjM1IrOWVYdmp1QjlzWDl3d2JjZEpBZ1BiaVZUYjN1d2tmdFR3ck43MjZvZDM5NTE2STBsaTB6RGpPRnR2d3ltYWhYRngzQisvY2V2QzN1azRLN0xkazJtM1huUGM5T2drZU9YQzZyTlJ1TG5TMitwNkh6L2U4LzFvYmFtdFplbVR3OU4wUFBuY2ozN1JjNzI3OXg5LzU1dmZYbDFkMG0xM05Cd2FXZkgwYUVTdlRPT1BQbDYrc0pyV0cwVnFmT3V0Nzl5NWVMR3oxdVBRUUx6VWVBQXZvYWt3bHpVaVAwRHVud3JsVUJJd0pVUURvUXJWT01xNkxRZWx2Z3BZSTBqRU9Fc1pWYWVxdG94TG9venpVSjdtQVV5Z1lLeE5oUkxCazFwaEFKeko1bS85K3EraHFnWFNNZzR1NmlodFBwdk5LcTVvcEhrcUN5ekxJdk9nOEZJS01FL09jeFdTalVBelJOWnNuOHBRd3FoNEVrUW9Ddk1jY09YUmVCUFVQQTV5ZEJJZURkSkZuc0YzaDFMR1VZeENudWRnSnNCd29qZllqUTJIdzBkM1B4cE93dG5ndU80YXk4dE5LQmJzczJQYlVWYlViYWRWeDJaQVgrL1VYcjI2M1dzNFNacU53d0srZDBQbk43SWRTNCtUTEkwUzA3WGpLR3UzVzhmRE1lL1l3c21nUUlyVDhleDdkNC9pb3Zqc3E3ZnNlaXVhRFdDdFIxQnN5MjE1eGVyV1V1NDBqMmZaNlhEcUdKcnR1cWVqNlhhdnFXZUphMnArRkwvOXliTTNYNzJLK1FPZWs3eFk3M1JPWnpPb3JHN3E0N0ZmYzR3Z2pBNkgwK3NiSzdsZTNIMTJFb3lINy96UlY5LzQ3R2YrNS8vcS83bmRxeVZSTXA2TSs3UFlUOUxsWG1OenVaTlpSWmhueldickpNRFcxZFhpN01IamcxZnUzTEd3ZDZkaWxGSlZvZ1pVVXFiOHkraS9GeWg2aHRLV3E2TkN6b2RkS21LQ1dxTTBwMFFoU2ZYQWJDQk9TcFVCVWkyRHVuRWc4VE1DWWMwZ1dUVEV5czdLY016VjJ6Qi8rMi8rVmFEQUFsam9RYTZlTFlQSElxb3NrM0hPdDZ4TVBDTEpMZkYvUWxCd0RrbjVTbStsaWV5aUJBVVZEZHVEVGlNWFVEV0FNbmd4Z0FVdkpNTDFlREtFN3NOUHgvS2RXRkN2WVovNmg5MWtsS3d0Tit1TzNXM1hNYlZTWG1oUEJ5ZEg0Nm4vNFA0bnJtM2MzbGdPc2l5SCsyK1lreWhhYXRhdlgxamE3TFp2WDFwdHVQWnNGaFJwUG8zUmFjdU1BdHVsUDVmbmFSaEhCWGExdHROcjFaYTdqVFRQSnJQSU5IVFRNck84bUViUndlbm9aMzdrdFU2bmUzclVienBwVkRpWjNSaEd4YU9uUTZmV1JLOU9SNk4yeTJ2VW5jSXd4c1BKcTFjM1JOekdPSXJ2Ny9XdmIvYkNPQS9DMExXZHk3MTZrR2ZZUFdSNU9qd2ROdUdyUlBsS3F6WVkrV0dlMTF6NzRmNyt4OS84NnNzNzlVYTc5dUdEdzJtUU5WeHp0ZFZJNEx6eEduOStzZFV3aS96R2FtTjFjelBLclNMeTF6WXZyNjczc0NSaEhKV2tJVTFsemhhc0wrTHlHNmd6elBOQUI0YmpWY1pWcEFTRng0RjF5T2xja0lJUzVIbGw5UmJJcW9BRU1hbkFvbnArZG9JRlpDMVErc05RMGF0Y0JpNzRHancxNUpLbmFoRnYvK2ptMy9xYi81RVVGamxMQkdOZVFPL0pDeGlzZ1VUT2d5TGp3c1R5QzNoOWtaSTFTVEJra3BXYzJSVHAzTHd6MGhCMUJCRERoaUlxTENvbWtpSVY0bXc4NGlWU0FyQlFhckI5TW9LZXdTWnFLVDhXRS9HN3B6cC9sSlJsdW1QcjNWWWRYazFlRkVtUytXR1ltYlVRQXpuY003WGswc1h0bTVkV3VuVW5TTFNqNFhSbnJiWFphY0h6cWNHTVcrWmtPTVZZekJLTU8yWlN5SlVJS3NrWHhpZDh0YXBqbzJQd1R5NHN0N0FON2k2MWIxL2VlcngzRE5jR2ZlOTY3bkxYZS9Ua2FLMWx3RFZ2TGkzRlNiNS9ORDRlVDVZNzJIRm00TGE1dXRKdzdGaFBCc2V6ejd4NjdjS2xkWDg0akdKc1RiTkprdHVlKzcyN1QyOXRMcTkwUE10MW9KMWhHTmM5NjJRUVdDYmY4R0hiTHNRd0NoUE04L1ZHczl1c2JTNjNkaTR2alllenc4RnNwV1lQb3JTSTBnZkhvNzB4TitwMVBYVWRZMjh3eGZwMTY3V1grVUVjOVFjdTFGWVJ0RkpFUXFYNUhBZVJ0cVFBejJ2MmVUaWZLeU1yWVFHQk5PcUFiaUFHY1VwdWFWN1BndXdWejJOSXlUa2dBUmdtaGJQa3Nsb2swUUJSZlNMWkcxVUs2djdYa2EzdWszSitpSTFuU2JIdXJPd3NVQWFsNHlFWVJhUGUrWEhXaWFwaTZja2NyNDRNcW1OVllHZFVVQk9qckVWV0R4SlE2a3B3MHU1SzltY0JCYVRueURpWjVoTTRFTmlsWmpuTXZBTUhCa2xEYzJ2TkxNMHM2S2JKTndxbWZEUXltQVJocHRmcjA3MEhqeDR2TGExMVhITzlWNTlvN1lQajAvSEkzOFNHa0M5YXloekhDbnc0QmRrc3llSkNzL2xNU2w2ekhleGk0eUF5SEF1ZXVlZEFBaGsvT1dsWXI3LzJtcGZPSGg4TXdwUXYwTHYzNU9EbHl4dmYrK0QrMWJYTzZjbHBiMzNicTNIenNIczBoTloybTk3aFlBSUJKbWxzRzhidmZPTzlvWi9mMkY3RkRIU01BdTRYWmt5elVZZGo5djBIKzdjMjE1b05VSmx3Zmp5ek9KbjY2Q29mdEhSc3o5RDZmcnpkYlR3NkhLQlFyMTI3ZmZQVkt5OWZ3eVprZVdNMVRiWEJaRHBOTWM5amlNeWZCVGN2ckt6dGJQekJIMzlubzlWWjM5bW1UUGtaTGdnWCtRUVpCSkZ0aFJIZDRKQUFJKzYreXBvSDRzdXp5bG9rNE9Db1BBd1VScmJjQjVaeEtoVi90MzdlWXBiNlErTkxyYUEraUE0d3FZNVZVR3BUUmxTTjdBaUxVRE5MdmFMcTZPWnYvc1p2S0Z1dTZudXV5aXFJSUZTdWJxbTNZN1B2S3JEZGlqc0NPNlNDVkQ5WFhNcFBCZFhvaWthSldKcW9DcGFka2JJbFhsV2tpaTkwRlNJbG1acCt6Tk4wZTMrU3lmZTdlQ2ZaZFJ6VHRvY1QzNjNYTWJIek5ITnNEUnZRTE11Q0tJVDdPNTRHMjgzaTJWRS9UQXM5bWZXV2x4NVBOR1R0SForZytFYXZqUzJ2WmVpWVBOaUIra2srOVdPWDMrekpzQW5HbkVuanhEVHRUQ3Vzd2dpQ3lJV3g5UnFGWVVlRFk3NkRZQmJ5YTVWRjhjSGR2WWQ3eDkxV1EwL0NlcXZYVys3QmFjSSs0ZnZ2ZmJMaUZ2eGhoanpMMW5LZDQ5UEJ2ZjNqUC83Ky9mY2U5dzNOZk9QT3p1YnFVczNRZTkyR3BXVlBCdE8yNldEbDBVd0w3bE9RWnFOcG1FVjVyK20wNEk1cmNMZXlzUjlmMkZnN09Cei8zdGUrZjNvUy9zd3YvY3JybjNzbFRmemhhTlMwdGJXR0MwNXJLMHVUMFN5Wmp1eE80OUh1b1pXa216c1hJT201Z2FkU2lyTHlRak1IU0RJRVZCeDVBSFVaR2dYS3VDcEYxQm1vZ2h3NGpwUWFPQmxaYW95S0svVkFLUnBjTmZwUWNlYkt1Q3NNeVRnbE9FOUt0NEkxbG15Vm02NENXOEU5c1NvbDhZb1NCYzNmL0p1L3dUeWxySXBhRkt1TTh4RVloTEp1Q1djWU5mK290V2VCZUttcG9tZE5xa3RWVUhnaGxsVkYra2tNS2xRekI2RnFrbkJRcldkMXFpZUtodHhJQ1Zac3FLNTdWbjdxdzU4eG9pZ0U3NGJqV3E2WDhZa1d6Y1VlTkluaGpMaU8rTzdjME9xRDRhU2YyTzNsMWJVTGw0bzRjTHFiUjJQZmMydEh4MGVIbyttRnRnYy9CZFUwUE0vM0F4Z2hLQWxmYjVHbmRjOEJudE1nMTd4VzA3WDVNbFJvZTZyYnBsMVBnMUduMXpvZXpKRG85RHFub3pGbTRNUGQweXZyN2NKMDFsWlg0SDk3TmZjNzMvLzQrdFpLa1VUaGVQcm02MWV6YWY4MHlOQVJ6N1dPeC82VDAvRmdIUC9ZYTVkdTM3anc0ZE9qbG1PM1hjdXVZZTl0TGJXc21tM3hiZlJhL3RIdThaMmRGZFBHWXBDZWpFS3ZWbk1OYlc4Y0JycXhmM0x5d2ZmZitXdC85YTkyR3RiMitzcm1lcmRsYWpYWDdaK09qNklvbXFWYks5M0xGMWMrM2pzMTRueGo1d0lWbmVySllVQnNycmUwd1pRL296SVc1VmdqeGhJU0wwdEpmREZVdmdETENwTTVKY2RPOUFIbUZVbVFNUWxGcDlrRnZuS1ZsZjNsYWtDTUtDNHhpZ01WSFZuUUlyb3VrcXNtUXlZVFF6alFqcE9QVUpxLzhSdC82MHkzMkI2bGJWV28yaWRCZFp0eGlFQldJZ2JXWFdhVnVaL0dnVXFwTEgxSklQU1Y2cXZBUGhCNVBsRFBWVjJJbHhGVmZENi9RWUJsQjhTNlk1ckRvcDdBZE1jd3JwcGpPNTduRGNjanZtckpOT0lvckhrMlJETGhyVVgrYW1rMEdzNlM0bk92M0RqdWo5czdOMmVEa2UwNUowZW5RUndlRFdZN25acHFWRENMME9HQm54aW1YaVNoQTZ0djZVRVVRd3pOVmdlNExFMHMyNExyWCtzdXhURTJtUDUwUEwxOSt4ckNrNmVIbUZ0QmtwOU1velRONzl5NjZ0VmI4SUhlK3Q3N1RjL2VXc2FFVEZlWE83VzZQWnJsbUZRT2RvWlpGaVpwZitaLzY0Tm40NEhmYVZwLzhOYjlXNWMyNzF6ZGlwTFVxV0cxeXBxdGVzczJsaG9XOXRETnVqc2JCYmxsT1k0YkJNSHgwQ2NteXVCaUhYNTAvOC8vdGY5b2FlZEM3UHQ3VHg1NVd2N1cwLzdFVDVJOFhXdVlxOTNPZm44OENlSzEza3F6MDRMR0UwU3plVkFqUlYzRTZFRENqTXdIQ0JtVXZDajBEd3lpQTVXYnlnSEt4WW9yRGdpZ1VYaE5nOWRRbGlxSlZTaHJVZlRDcDlKc2hRZC9ZTXBKVXE0QWlBaUJxTGhFMEJmbW1yL3htMzliZEVnNkptVVdBLzE0QnVSV05Jd2dDOFJWT0lkaEtXa1oyZ3BOUVUzaUhUR3o1Q21FaXRWelFmSGhVVllWTUJFT3dvMXNKYmRDc2k2RkJ6dUpjQkthUmo3T3ZHbVV4ZjQwQ0daT3ZRRnZaRHFiWWxQYXNOWG5Kdk9hNThCdkgwMm1HWCtTQ2ozTTRjcytlN2IzMHAxWGp3NFBZUGRkcDM2dy95eks4cVArZUwzbHdXbkpzZ1NxYytLbmpsc3JvaG4ydk5nR1pCRjJoNlpYYi9CSnNoUnVzVDZleFc2ampaa1VEckU4UkMvZHZOWnNkcnlHT3pqdHcvdWZodkhSeWZpenQzYnFudGNmRGI3eDNROHdIcDk1YWN2VXpNbG9jdUh5Sm5hV3J1ZlpOcDE3U3pkYzEybzFuUDNoMUI4SFcwdk85Kzd1WGRsY3YzeHBHWE00bk0wTUd4dHJZOGtwL09tazFXcWVEa2R3aytCNFlRN1RSdXE2YSttbncybm9Ed2E3UnovelM3KzZjWEhITnBKbmUwZnczVHV1KzlMbEM2Ky85dEtsYXh0amZ4cFo3ZFdOamQ1U0Z6b2lnOGlSRTIzajZPZHlGSFZYK2tkUmkvQ0pVYlpUMlQ0VlB3dENqS0JHVmd5NUdpL2hMRWNFVG9EbnJvaW9ncFdCZno2d2RlV2dTeWoxb1Zvb0lGVCtJNDZXbHdRVnNmbnJmK3UzU3BWQ0hmd2V5TG1BSVZSOSt3RkJaUW1OZEtrTXhNR0dDcDVYc1pCUUhWYmNGa294TW85TFVLcXY4Q1ZEeFp4NE5CVjRPaS9JeFpRbzZaa3JXYWpUeUpOc21CcHhHSUdBbzg0WHlhU3dxN1p0dHVyOG9FZVBaa3pqSTdIOGkxQWNibld1YVhkdTMvem93dy9yclU1N2FlbmpEejR3Q201UEQwZCtEVlVaV3QzU1RzT01oZ3JXM1FFemZwc3lSOW8wSFF1Vkp2Q3o0SVEwZXN2TmRtdnYvZ1BYY2JzcksyNmpzZFNxWGFvWnp3YmpKR1V0ZVppdU5LM0h1MGQzbngxR1lYcm40bW9IN1lsanI5YWNSR25Oc1RGUGJFNWN6VEhzQzJ1OUR2YW5sblY1clYzSDl2VGsrUGg0M0sxN0xleFFzUXFOK0dxbmkxdTk4Y25vMXBWbHgzSU94ak1MUXkzUERobHgwbTY2VUtaRzNlcWEyck4zdi9Gdi85bS95R2F6TDc1eGJSajQvZjFqQjVOakdtbUZ2Ylc2c2JhOTAyeDMrRG9IYW95b2tkSklBem9ndXpYbGxpZzlVWmFlQWxmQ0x4VTlGOWRYWGZZb2thSkZNdjFBVU9xMDRDVXVSNHdaMVZIRmYwQlFCV216WlQ4OVYxOEpWSWtLV2VKWnF0UzM4c2kxQ3JQMjEzL3o3eEFsN2F0MFR0WEJPR2RDRmFoZXBWWlJlNVgrVmRvbWMzRk9LVWFpOVB1bEVTQmlLVldMb2hjWGhjSmhLQVUwRDZSbjVQbGFHTW9zSXRrVFZaYjFFUU9PbGxuTUlzMlBVOGd2akZNUW9YL1lOWVpKM0t6YnJYb05lZ25OOC9sTDdBeVpVUnIzSHo5ZTMxaUZBL0Q0OFpQbGkxZnE5ZnJKNGRGb2NIUnB2YWRqWTJ2by9XbWttOVp1M3pkczE5VXpPUFg4d1VkV1JHRlVhemJSaWp5alBkNDduZFNiclNRdDdIU0lxV1kzUE0xd0c1NmJUNGZZMmU0UGZaY3ZLOWJ2dkhUcGREQjUrT3dBZWd5cmYzV3pZMXFtNzBlV1Y4UGVlam9ObTgwYTNLVTBpdXZZL2JaYTJHbkVZWExqMHJwWjVNMjZGd2JSSDMvNHRFRC9za2l6ekxwbHI2NTNIS2ZSck9rUDlvWnc3NWRidFdtU2oyZis5bEpyOTNTYyt2RW5INzMvOU5sVHJFWTExM250bGN2Zi8vakphQmI5dTQ4ZmYvL0RKL0ZvdU5Fd0hqOTZ2TEY1MlcyMW9BblZoc3JFMW81SEtpSnN2Q2lKNkFiaWtMbFkzN25KbHduQVhGaHJLcHc2MGtXaGRvbFRRVlpDVEhwazBSaEpyc0p3TkRFNVVaQ0RxWEl4eWhLdmNvRmhBMWhxTVFoL3BaUmNLTGpCQTcyaUJJWkhWYW41Ti83MjN5VUwxUk1WK1pTQTRtZTFVa2VGVjlrbG1YRGlsd05QeFdORTZlSThTTk1YZytMQStjcGNLYnNZempXR1FwY3BJTldWdVNWYkJOVWtnT29JU0Uwb2FHakF2NGF6RWhXNWc1aGg4cTZRcm5tdU81eE9veWdaK3lFZmV5eUtNQXBIcDZkcnE5MjdIM3lvbWRiR3hadWVWek9jNXJ2ZitjWkswOEhLc05weDY2NHp3ZnlBNjIzd01URWJwcGNmWjgyRE1MYTltbFZlcFNoT2htRm1HTkY0c05seHg3UEVkTDFtdXd2UEp4a2RhN2tHbDlrMHpEZHU3V0RLdFJ2TysvZDNNVTBlN1BXL2VHZWJUeHByU1pRYUpsOGxXWGlXRFpQSDU1RFRPSnFOVGs0R24rd09WcHFONjFmV3d5RGZ2ckNFbWZySms2TTNYN3NSajRlcksrM04xYzZ6dzBHdDN0NWFkcDRlRDFjYWRYaFp5MjB2RHVEcUo5Z1puMHlpY0RidE5ad0xGOWE5Um1OeU9sN3Z0Yjd3OHFWblUvL2gvbURTSDJ6MDZpZjlnNlhsZGErOUpGcElpdzdySVZwT05WWGpXQTZmaXF1azZJRENLMzFROFhKb1N0TUh2SXlhRkpSQUl3WGlTa2ZuZ1NBOGhZTlM4UkpmMGxUTVZTc1FCSWxZMlJqR1dTOFVZazRrZFNFT2RmLzdTS2dnZEdXUXg5TG9BZ3AzbWVYc0NaQmtWTktRSFMvdmNPb1FneGxQOVZXTGwyZ3pJbWYwS3FCNnhaWnh1b2FxejdEM0lsYTBsQlVwQWxVanlLUWk2UktiS2dRb3hlc3haeE1BMVZHMlVDa2dEZ04wd2E0M21ubWFKMmtzNzc2RmdtcHcxNDlISTNneWVaYng4b044Z25MaWh4c3QrM3ZmL09ibTVXc3JHeGROeHdHL2h4OTlFTXhHOFBjYnBvWEsweXkzZGFNZnBSNC96OFJ2OTJGUEdjU0o3VmllNTJBTnNFMHpUSEkveVExLzBLMTV4OWdBWmxsbmFSVzVRZjg0U1RJVTMxeHQzTDUrTmRld1lKaUQ4YXcvbkdGTE92VVRiQjQwN0hZTkt3cmpSZ3ViQWY2NGJ6ejFXNDZ4MFhMNDY5cEMrOTc5bzlXRysrb3JWNklnVERPNFgrbmR4OGRmZXVQcVlEQXlOV056YS9uQnM5TXV6TE5wWVFZN2p0bnVkSHB1QWUrdGFXdW5VK3gzNjdNc096b2QxZDM2MUovVTgyUm52ZjF6UC9lalRyMXROcjJUNGNDTzRzbmdwT1cwYW1zYkZEaWZlVllHV3pSR1FqbHFHQ09PeUJtK0RDOGdZZlhCQVR0QXVabXppSkZCSko5ei9LVTZ5UlZkQWtiS1ltVFAxTDBLcEZRUlZrd2FhUUJ4YUNMeG9tWlVJY3daVXNJTy9rZC8rKytEcmdwVVVCVkFLaE5MSlZtWm1qR3F2TENqMXJKWjFEWnlSMUEwcUk4VlMyQi9wQWdDMlpDUHhPa1VVbFBwOHhBcGVHbVRVTEtVZEtma293aGtNaWoraWkzTHFyaU1BYWNsNmpCTU00cnlTYzVyaUdtYStVbmtCd0cyZ00xNjAzWnFydTRnQ1crQkt5RGtaSnBCVW14NThiLzc4bGN2M1g3bDVkZGZubzFuY0dMOXFmL283c2N1bndhbXl5alBJK2hCbE9xTzQ2SFZjSThNRTg0MzdDaGZmU1RmWlllSDBQZURscG5EZ1psTWczRVFYYngrZzI5c0haMWk5d2xydmJQU3NlSEJXUHl5VXBIbER3OVA0ZjQvUEJ6dHJMWmRuVitzbjRhaDU5Vmg3QjNiUEI1TzFydk45WTRiQk5IcWNtTnZNTjA3bmd3SC92cGFkM2MwTGVLY2R3dFMvYlU3bDQ1UCtyYVdyMjEwb2lodGRUdWpLRnhDV3JPN25VWVVwNU13YWJrdS9QaWU1MTIvdExHeHVkeGRXWHUyZTdBLzhFOU9aaGMyMWw5LzlmYlZyYldObm5ua1QvNzFILzY3bm1hdVhMMmhoaDVkVnJZSndxWGtWUUJHZFBIRklLcWlKb2tLTEN0TGhPaVNHaWtadFhLc1N3V2JCNVcxR0hrUlNjTjNyajNTR0NBbHlYcHBDcWtxMGdhYzhjOFN1dm5YZnVzZlVNOHdBN0JQUlJsZ1g5aXdLblZYUVhVZVhLcHVNSmVkS1lNcUlwR3ljV1ZBMzNMWWI2Z0p5M0xDY2JtVUJvbGRSeUFmRWV3NWJtV2pXYnRpTGtnMTk2UkphbVlEeVVrc0JaRU5sK0JrbkVDdmVIMDh5OElZRUdKN1Z4VFpVcThGMVEzREVETWg1VjBwZU1iQnNwTis3V3ZmdW56ajVwVXIxOUlrRE1Ld2Y3Qi9mSFJrNWpIc2J0TzJZWVp6VkpnWG1lazZXdVppSHZBcFEvREk0Y3BqcGNqVGxGY2J4NEdkSnhZNmFlbVRKTi9ZdVppR2dlSER5K0dqT3pDeE5CVVdEaHAycGZmMmp1TTRSUXZlZjNpMDNuSzZEWGU1NDA0RGJvVXhHWTRIc3lMTFhybTEwVDhaYjZ4MXN5QXFpbVFheDFoem5qMDdiZkZ1YTY2amczbHg2Y29HUmplT2s0NWp0VHZZYkhjZ2hYb05UcnQrWVhQSk5JeVRJSDcvMFpGakdLOWUyN1JiN1lQVDA5SHg0ZHBLOThKVzkvTS9kUHZ4N3VIUnlmaXIzL3JvN1E5Mys1UHBzL3VmdkhybG9yTzJBNTYwYUNKa05TSkt2TW9VVWxrbFNZeW9vSXdDajZxVXdxaXlaQ0xGbGVxclVaWUFSNUFUUUFaTmxMQmlLOWFRV1Fqa1FCS0pLMWJDdkt4SWlpaEtwS1Z0WnlvdWJlQStFaGp6MTZqdXFveTBUOFhQMUZyRlZTTVlxUG1LbUlGYWVOWlY4aTBqQ0tvVVVFREtQSmFJNGl3UkVwZDhwSWphb1ZjYjRuTlpqRHcvcWNCQStLaFdnUXpUQm1mbW9qclk3TVBoTkl3VEErcUFVRUJQc3hqK1FwSHpOVWw1RHJPWDhEVkthWnpFc040NERVOFBOZGZkWE50ZTIxajYrSjBQSWJWNnUvUDAvZ2NwbkduYlNtUmZXN05Objk1Und0Y3NtWHFhRjJHU3VLNExYY2R5RmFlRkJUZm1wSTltTmVzMXkvRWFyUTR2MWMvNjBQK1RpZC95YkxkT3p3ZU5nWVdQa3J3Lzl0RUxhUHlEdzlIZThlekdoWlZtMHhzTUpoNS9WKzZaV3I2OTJwMk9wcjIxcFNRSVBFNWYvWldyVzV0cmJWdExqVnB0T0o0ZEhSNXQ5WnBldS8zQi9ZUENkb05adE5TdVFhOVdXdzNZa0FzWE5tM1B2WFZsOCtXWEwvL2VOOTQ3T2gzN2ZuajEwcmJqbWpYWFd1cDJtcloxZVdzWmZzN3gwZkhCT0JpT3AxY3ZYM0VhM3NYYnIySDFnRlJwbUpTY3F5QVltaGhvNUR6M0xNaGtXQmdzRUlnbkxFR051OUl1RlJhbkRWaWRoUVdNNkQzcU90TzBlUzd5WlBUUGdxaTQwaEJKQ29iN0Npemt2L1piLzZoc0NqVlNHaVRLZEE2cDdLNHFLVFZKcFBUVXkxSVN5a2tpalpPV3FKNkRRRlVza1pLR3g3TGJJZzdrbDNnU2s3TVNwYUluazdQQXVjUjJ5alVFOUlSVFN3eUQrSWhFd3RXWStjSHBlRVpYUk10UWQyN29zT2FZVGRpN3dSU0RMa2hUN0VUaGJFUkpEUFBickR1enNiK3kybDNwOVE2T1RnTS92SHpudGJzZjM4MG1nNlpyWXlXSzRFSHIvRXJDYUJiWGJCME9ObG9jK3FGbDhWRVcrQjhoekx0bUhBeUczYnJiOUd6TmRBM1hzdzFUbXc2S0hBNTBXUGVzUnFNRzZmbCsxR3pVNGpCYlhhNFBoalBITm1acGRqaWFZVDk2Y2FYdFdrYkt6MzFqMDFBc05iMFFHK0lhNzk2R3MyQVc1OU1wSDQ1ODg4MlhlcDJ1UHhyMEo1RnRlYlB4eExUdG85TnBtaFNZVko2ZXJXMHVvVmxXcmI2NXZXbHB4dVd0emRtNHY5cnAzYnEwdWJPOTNLa1ZacjBaQkttcFo2MTJzNkduTnkrdnQxYWF4M3VuY1ZMODJWLzVHMVpuU1dtdEdzMXlGTlNJU3h5OWdQNnAzT2YwV3czOVBIRDU1VUh4VVFOSGJlRmdNVjRhUkZDQ2o2aVdCQ2tyNm9jczBRMkZYN3haV2JZRUthRWtNVnVvS0N0dTFEb3ByWnQvK2JmL29XZ3pBekQ0RjFXcnJqVW9KQUY4QmNQRm9neXFzaHhWb3doelN6VmxmVEFNNHVEeFVqOXRQTHVuR2tUVnBISXZ5a1hxRlV4WmZDRlhXWDNHRlYwVmhBbGxnU0RpRnA3c3NHeDVkYU5XcnovZU84aHo3QXNOK05zd3lYQ2I0UXRrZVFKMkViOThZRVJ4a3NDaGdlRlBrbEMzaDRkSERjL2VXTzFxYnNjUC9lWFY5Y2w0Y3ZMMEk1QllNTkxTNjQ3bjdXRjNXUERqbFh5WUpza3lhQi85OFFMNzRNRWttR1ZGenpHYU5kZFBNN3ZSdGh3ckc1NmtlbkV5bWpZOXUrbTUyQTJnTWExYURldlBoZVhheXRvU2ZIcDQyRkVRRGYzd2gyNXVrRk1VMXgwem1veXhic0NuZVBqSms5dXYzT2ozaDNDekxtd3MzWHQyZUcxN3czQzhLOWZXeHlmOS9jTmh1MWxiWCtsMDJ2V25CeWVRQmk5bHVpNG0ydjBIQjE2dFpidjJkRHgyNHRuV2F0TXpVeU1LbXFzYlFSalhHeTdYR2RkNzlQU2swZTBZczdqbEZoR3NRbHBjdnZWR3hqY25sNCtPbFVFSlhNWVJNaFJNaWNmNHFsQlpibEtxY2NkWUFFbVZZQkVoS011U3Z3clFDaGxFMFRRVkpGZnBBQlczdWtVS2R1WG9NNUMrTE1oL2hJVTJTSEZlOGdaR05OUDh5Ny8xbndxRnNGQkVFc29OQjI4cG81aFMzTklQVVFUZ3BFb3BwMFVDa0dValNDTkNVVFNzRmFGMFZLUmhiRUZwTGFpMWlpM3JVb0ZseVJObEtOaHFIYWdxUWdEZ0NMeElSRlJmV0pFdEsrSnJVRzNYZTdwN1lOdU83YnFaUEFITlBXamd4M0M1c3pUWDhpaUJGeE1WZE8rSlM2SW9HaDE5L3ZXWHZ2dldPNWR2M01CK0Q3cTI5K0NUTEFvYkxwWWcxR25BdUdCRkdJWkp4N05zdnRvZ240VUpGaE8wZ0Y2VFpYZDczWk9UMDNiZGdYK2Y4cU9VZWpJOFFTK21BWC9XM2FqeHBYbll2cnEyY3p3TmE1YldhOVVSb2lSN2VqSWFCWEhUc1picVZwU21qcWxoYlRnOEdhK3Z0YVorc0xxMkhJZnh3V0gvK3JVTDhNTU9qd2RIQi8yVjFiV2FsWnQ1MGVsMExOZndiSHVsVy85NGY3QjNPbjIwTzNCTnA5dHJuL2I3a0lTZWhMZXViNjl0YlIyUHc2ZFA5d1pqdmpCek1FdS84KzQ5ek5qcnQ2NnRibTUrOHZEWjl0cjZLN2V2RGlkOWJMU1hMdDJnWFN0bEx1SXRWWmFCQ2dSRTZhaW8wV0VRQmFqR1hSRURqemlYWHd5UVdIUVpMNlcrWlVHMXdrdFFOVlltVW1pRVRBWmE2ZHRjSHhEQVI5cFczaHpnSUdWU0JPUWtvT1V0T1VEZC94Rm5TRGt6cEgwcWo3TkJla2M0eTUwSGtPRWdpbnNHN0wrcTR5eW9wT0NGSnhPY0pNU0x5TWlvWlBocEVTbW9tbFMxcW95WFVnYU5za0JRODFKa3VnbjNCUkxwTkJ0K1ZJekdVM2dHdG0zeFZtc0JKMXNMVTdqaTJIbnk1NXNwSUVzMCt0TzU0ZFgxS1B5UjEyLzh0Ly85UC8zOEYzOGs5NkVvV3BUbGh3L3VvWGQxV0dXUXBhbHIyM21leDFuZXNPSEg4S1B2V1pMVlBCZG13YW5WdDlaV0h1d2VkVHgrZ1RYVWJMWTFHS0o5VVp3Ny9EaXJBeGZDbHNkdWh0T2doaWF6NlhyRHRlNC9PVUwwNmY3d3BlM3VkQWJQQnc2Mm9kdmVvNzNCK3crUGd5anIxcTA0aWpQZHVuSmhLUXI0dGZqamd3UEx0QzVjWEswM2F0UGg5T3ExN2VPVHdXYXZoYmFaZklEWndQOXl0OUhEZk9vMFQwNTQ0V2k1WGZ2c0s1ZXdlNmwzdXE3RFp6bTFLR3cxM09PaDN6OGFqREx0ajc3eXZjL2N1bnl3KzJUdDRtMmp4bytqbEQ2TUdwUjVVQ05ZcnIwTGVya1lsQTV3dUhHc0pzWkNMbnF1VkZ5TnVKQXhjbGFSMURJZjY0b2g3SW9pb0NFV0lDWEtVVDJvMzRpZitRWHpCY3I4MWQvK1Q4NjRDQ01WeUVBZFZKdXErVVNTc2ozU0R0RTJoTVY0R1VyS013NHFLRW9HSkhna2pTUlppQTFGQXlRaVJnVnBLbkVWeW5aTEtKdXE1b3hReWl6QzVsUjBuWmVKV2ZZQUFQLzBTVVJCVk9ha0tMeDYvYWcvVHBNWUdnL09VRzNZWnhoZVdPVTBqYkYrV2JaaldBNE1NeTAzZndtVlhlbnAvOFAvK005LytrLy9iUC9KM2M5OTd1V1RrK0ZvTWsxbkE5T0VVMlJCZHRneVlpMEkwdHppNzFTTk5NK2g4YWFwZTBiUld1NWdLQ1lqMzdZMHp6RDhnaS94MElLeDYxcEJsUEQ2b2p4emp6bzl4emtaaGcwbmh5a2FqV2VPb1UrU3pKK0ZRWllPWitscVhVL2l6TEdnN1hXMzV2M1BYM24vazBkSFgzcGw1K0pXODJUZzM3NTkwY2pTL2lpNGNXM3o4Y085UEloMkxsOW90bEIvV3E4M1ZsYVdQSmVYUnVFU2JheWpQV25UODc3Mm5VOU85dlozVnB0RkZDNnRMQyt0cmNjRkZxM01kcTNOMVo2aEpaUCtjWlFWcjk2NWZ2SEc1WC95My8vT1NxOVRjNzMyemsxdWpkQUZVUjJSY1RsOGNBVTVJdVhZTVlqWlJoTEg1d0tMbGZZYm1sZnBFc2RiU29GbnJxNGNBamlDS3BmNEVpVTBMRWtkZ0pWVU0wUk5FajRYQ1NJT1BkV2ExWldUWVdFTkFRR081cStLZGFkdUtlMEJYZ1dCQ2lsTmtVQksxRjdsRWhib3k3Z0VZVm5SQ0NpcVJReUJ3bEpJYWFJS0lxT1M2d0pQOXBsemhFZjJuWUY5VVpUU05oSUpCK0pBNmJuTzRYRWZHTGpaZkNneWlUQjJOSnJRYkRqeHVvVnRiYmU5NGxwT1hpVGl1K25POU9BclgvL3U3WmRlYnJkcWJiZElkVTkzT3ZmZiszNnQ3bUpONEtzYmJYM3FKOWhmVG1keDNiVXhoallmckE4YjhGelFpSVNQNjFoWjVycjJLT2F6eDBVd2hkYWpVbDZCMUkwR0hDT3NEa1Z4UEkwNk5xL0FEc2JCYkJadHJIVGd6OERIT3BqTW5oNWpqNEU5UU5Ic2RvTTQvY2I3anhOTjN6M3lQL1BTaGZlZTlDOXZyVGcxKzNodnNMbTlnaDNmOFdoVXEyR3IwbGhhYm4vdzBlUHZmdThCSFAzTlpTY09vaUFJWW1pSG9UMisvemdJL0NRdDd0N2ZPendhSFo1T1Buci9RUnlsbTJ1ZDVkWGx5V2gyWVcxcGRYdnQ3ZmNmYmErdTFKZVh2dmZXZTFxV1hubjlDN250UUNwaWQyRlpTZ2RhU2ZqNUlPTW91U29pZzFKaVZPQ1FJS0xHc254R0N4RWk2VHlyNmFFZTgxYVdXNWs1TWM5bHFIZ2ljTFRJVGFvbW5scXVhS29xcEZKRmhnRHIvbytJcjREdXJaQ1h4YWhQeW40cU5DTFVLWlNrK1JTZVFHQmlTZnVBTENlR1VKMlh4YWVGa2tVWnlocUlsam1xOE1vU3FNRDJzTjBVaEFMRllaRkFSVXE4VEhoWTA4bkVoNktibHU1NkRUOE1lUEZmTitETk41b2RqbCtldzNMekFrS1JhSEJPVHZmM251MTN1KzJvZjlSMjBzUnNSSG54OWp2dk8wWUdGNFRQaGFVRlBCenNEUzV2cjhOeEw0cTgxVzRWZGkxTlEwdkw2NFlSMTd2K1pOejJyR2xTZUsxR09oNUI0V3hiNTVkRWJIN0F3N0RnYnBtblE3OWJOMHpMSFBBSFU4WFdjcmZQOTFrbW9NTDJZdUJIbDVZYTdWN3o0Zjd4Ujd0akNCa2EvME92djR6dHhOZS85Y25uWHJzMG5Zd2g1dlp5ejlPTktQSkhvNGx0YWttYytMUGc0NC92N1QzcmR4cjFxeGRYZHk1djExejcycldOTEpnY0hZMWZmK082WmVadlA5eWJ4RnFyMVZ4ZFg5dmJQUXd6STBxMVJEZC81NCsrOWNkZi8vN2g3djV5dytwMnU2UGhjT1BtNnltR1dGU0JGbFFzMFhOQlNmdkZNTmV6akNReXBxVXRsMUtpSytYNGl2NlVRU3c5STF3SHFGM3l4eUR6alZrTHpOazJLWDZtY3FBUnluSnlVaXNrWXY3S2IvMURLQTI3SVExVXgrZUJ6SkVsT2laeFZNM29JcW5nRitGODZneUVTNWtyczJJZXBKTUlrc25XcS9Zc1ZLTWV4cVlTczFja0x2bklVY0c1ZWtXK2pWYmpxRCtBdHhySGllZTZqVnBqT2gxbmVZb05uTzAxZE9DVFZJWUFSU0VvdmNFM1pRekh4NmR4SEd6MDdNN0tXcTNSbm80RzczMThiNlhUZ3ErRWpXbVdScjEyRFR0Z0VQdFJDcDk5WTIzREgvWXhoYnhPRDZvL0dRL3FlaDRhV2h3WGFUU3hlQ2tEemVjNkFQMEdZTmhuY1c3bmlXTTVRWmhHYWI2Q3JZWm5iaTR0elRMK29CYnphaGFrTzB1MVFITWZIUTZ5b3NBZTRjZmV1TjdyTnIvKy9vTmtGcjkrWnpPMm5aTkJ2clhWNGpmQ1RkMGZ6ZGJYbDlzOXJCOVd2ejkwUEM4Sjg0dVhOckFYZjNCL2Q5d2YzYnB6Y2ZmQms0MkwyN3JtVFdZQkwrd24wV2d3TlBqamRxdElzKzJkelEvdVBqNGRUTkl3K0tHWHJ5U20xbDNlMWx0ZFVTQUkra3dwbGFERm9ESXV3NkZtQXBjQ3BkeG5nUlJTVnVKbFVCT0FqSVNiTUpRakV6TDZDZ3ZOWUh5aElKL2NSQzJpME9Yb0szb1ZGamxVR0tvT2RzR2k2NkpHN0krb1BvUDhsTHVNS3hwT3RUa2p0RSsyQWdWMndRWHZLWmE1QkVXa2xxRVhBeXFWcFVERkNhTGlnRG0rN01PTGdaVlNYc3JSSXozTUJnSzI1QXhxUWt0cjJTb0toUkdjYjF5N3pDS0dIVVFSL0ppbDVSWGJhYlNYTjZGNmNMNHhFSEZLSTgwWDc3bGVYRis1ODRVZlM1cTlRRGRTcTNiODRLTjRlTGhWMDlmcVRxZlYzTmpjcUhuZSt0SlNFQlZKbFBweFhIZXN3ckF3WXhMRG1QRURJR2FlSlY2OUdSZEZqUitYaERPaWdUOWF6KzB3Skl6VkJEdUhITlhwVVpvV2Nyc1pUSklraGJzTW4vbjFtMWNhalZxOTV1VzJGYVNha1dhOVpoMnRCL0ZwZndvUmZQYlZhLy9pclFjZjc0Wng2djZycjc1dHUvWHBlSGJ0K2tVK25XRFptOXNiM1pYV25ac1hWcFlidzhuczhjRW8wSzMrRkYyQjYrVDk4STk5d2F0MTlnK09HdGluekVZUDd6MW9ldzY4L0tPajA5T1RrOW5USjcvd00xOHdYWHNZRjAvdlBiaDJjYnYvOEFPT2tCb1hLbWlweC9UcHF4RlU4VkpQU2cxUlF6WWZhSlFpRzBValJwYytOMzkySkZxRWdBaGtxRERxMGdxRHlsb2NYeWdia01JZktvZjJBRWtkZ0RLZ29BckFrSkt0U2lVT3pnam1meWpXblpwVXR1LzVRQU1wazBHQmRCVjR0S0djMDZMYkNDUkgrNUF0ZGM5bi9MbEFjZ0hLcFVvaS9pSW9BdEtjVlg0T3l1YTlBSlFQVG9xbmFxUzh5emRPc3VuVWorTElNYzJhVjROYWVGNDlTb0k0Z2Y5dFRhTUE3ZzBNUENEVnNLelg3VWIzMGZ2dnhGcjl5ZnZmUHpnK2VmLzdiM2Viem9QOTAxNnJ2Ynk2ZEhSNEdrWXhIM2JudzVxd3JabmpOdklrRFlKWnUxNkRwY3pUTEp4TmtEdU5ZU0pwVUR4NDdoZ2NGNXRZZnE0ZE8xRS95S3c4YVRYY0hJNUVtbUt4Z1ZqcnpWcTcwK24wV281bVhMdTQ3bVFwZkorRC9tekN4eGp5blpYdVNxL2RxSHZ2UFQ2OHVybTh2dDc3L3IzZHdlSHd4clhWUi9mM1gzcnQxdEd6ZzNzZlB4MXB6c09uZzVldmJVUHZ2VWI5di90ZnYzd3dDSXdFdm53SWd3NzlXZXRnWDV0c0xDMWZ2Ykw1OFNjUGpTaHUxcTFtcDl1cXUwdU8wZHRhZmZUd0lJMmlHMXZMWnJmWHVIQUx1a0tCcTBHWjZ5S0NxUDQ1akFTSXZvcVhJMVVPcUV3YkdhWnlhT0NvbDV6THVjT3hnMDZyVXFXR01FQTJKQU1venVpR3hGVlZ3cUVLQkRYM0VGZEphWW41RjBYZEZaUjVFaFFOTWVRbklDaXlxNDU4TUpwWVJTSEZWQkVCa2xXQmFpY0Uwa24rcTVWRXRWc2k3SjVNK3JLZkJHN3NwQzdocVNLTVZ4SEdGU3hnRk05NUVHZVJMRHZ0N3NIaHNmeWlPakpoMUcwWDQyN28vQklUQ0R6YmlvQ0gvODV2anRraTd0eW9OZjNkaDd1N2oyZCs5UGhvNEhxVzIrbyszanZhWE9yWnVqNmUrQU0vVms4Q3d4M0MwbEd2MStHeU56eCtXVDR0aWpDT2pUejFYSE9NZmExUjJPS3dtcmFqV3lZYW5tYjVORXpoejN1MkhXc1pyQkRXRjhmRmV1TnFscjI2MUZscU9PMVdJL1luMkd1Ty9maGt5bCtYMUZ6ejhvVmx4N0lmSDQ5N2RXZHp0WmNaTnJhdEh6NDVlZXVqdlVhbnZiM2laa0hrTzg3Ly9QdmZYZXIyWHJxMTQzcjJNYTlORlVtbStVRmkxanJYcjE1QXd4SmQrN2QvL0wzSHU4ZFluVnNONzhyTzF0TmhjdVhTaFNTYXZuWjFjNXdsQndlVGNEcStmZXUydWZVU3VnZmhjbHp3ejlGVU1RQ3ZmaWhKcTFBTnhKa3pveHdiTVQyZ0VHT2tSblplQnVYVndFUGpvYWFrcVBCcW1rbE5RTkNwa2FRaXFXWUZxMThNUXNleStKK3pBdmR5aVZGaERuUExPcDlTRE9BN3A1R21JMWZxazdBQVphVWxwY1FYU0hJdHoyaGd3TGtxaXlCVnNKMkxZUUhLdXFRQmRIVXFtcHl1OUtlc0R5cVhFWUFzYXJwVmJPOXNPVjQ5UzRzeHZ5V1pobEVBb2w2N2c0MHIvT2x1bzFNNE50OWZZUEFaWXR0eGFvMmxrOU45YkI0MVBjRnVkUlRsNit1cmZwTGRlL3pNOFhqZmF1b0hmUHdTVEdwZUdJYW03Y0paaVdKc1dEV0hFNnFHN1NCTWZzOHo4cXp3K1V2VUlnbmhrbVM2eFllS00zZzRCZDlLNEdvNmJENi9EbXRhMHlESThpd05ZbzIzVTdNMGpMTTQ2ZFQ1Y0J1S3YzUHYyUXpiN2lCd0hSdU9DbVNZaHVIdGF4ZmYvTnpMc2E3Lzg5LzdacFJaVjY1dDhoYXZsbi8zL3Y1WHZyLzM3dDJUVlZlL3VlRmR2OUFaanNaZitlTnYvcFAvNWw5KytXc2ZwSDd5QzMvbVI5NTQ0OXJEazluYjl3OHd4dzRIdzY5KzdaMU1kOEpwOEJkKzZuTm0zZXlQb29QNzk2Z0lGTDRvRWdMaTlCWGwyWXovUFVCSjVlNldvSVpQUU9GVndBZ2laQVdEaWxQZkZJMGFSNmlSNkZRNTdxSVBURmVZTWtpcE13NFNZUkI2ODVmL3pqK1NLWGcyRnhuSVJ6cW5MSEhKUytYS1RFWFhHWmM1dzMrWnVDUm1TVmJEWmdBamdtRzBJaFo2Y2hBVWMxbEcxVVVTRUpORVVUT0dPR3VjbHllbFlpK25nbSs1VVhRNDBqaXdUdFdPQ3MyZnQ3QjVXcXZWQ01JNDlFUDJuSmZZc1VSRHdjeG0zU09CWVh0T0RidEVDZ2U4VEt2ZTZ0V2I5ZWJLOXYxUFBvWWJ0TkpwMUd6bi90NStFR2UwMXFZeGd3SFBVc2Znb3pGeGtqaU5KaXk5bnNhdTUvQ3RsQVgyQXBiWFhpNVNUSytZVzFRTWRsRlluc09IdmZSaUZzVHdLUGhsZXAxTkRBdTkxZTVNL2JEZWFLQ2pVUmpCYmc2T1RrSXNQMXErUC9EUkxEOU91bDZ0aVAzOXdTeE44OHRiUzgrT0I1dTlua2ttMnNucCtEc2ZQczNDeUhXOWQrN3RXMFhScWpzWHI5OTg4TkZIUyszMlVzdnNkTHZvTjJ6cmRPYWZuSTd1N28zdTc0NG1zOW5KWkhaNjNFOE04OXNmUGpMamVIQjZkSGxyUzdPMVR4NGV3amZiZnVuMXRONkJTS21wSWxzNWNyVlNJNkZHa0NxaEl2UTBaQWhrakVwZzdoeXA2RGs2YWpqVldDbU1US2NxV1VVRVNUenBKUi8vaW40UldHMmxPQXBJaGhMZ2dMSCtaWFZYVlVBeXprR0ZPYytWN1M0SnFiZ0xtZXBtZ1VvaFVrb0htT2Y0Q3A2Z0xqa3BHbFZYdVg4bmZzNjVKRDdEeUpvbmdZckpHUDR3TFZVMU1qMDRTMGxLWXNvV3pKRXNHdlg2N3U0Qkg3NHlZRDF6R0U3TGh0N3FqdTN3aVVjdGgwYkN1TU1XRklZRGMreDFMN1RXZHI3LzVYL2Q5bHpMTWg0ZDlBdk54TzVuT0FzNkRTK0s0bG5FbjRTYTJBL3hvVjlzQnhyeGRJUlpBVjhGVFFBM3E5VmV1M2pOUHpxRWtxRXBKdWNubGhwKzZHdzBEZEF1MjlSdC9wWWlqM09yMmFyQlpZR3ZCV3NmaFVHYVo3UGhDTXRDTUtQdkVZQnBuaC8wUjVjM3VudkhnNmVIZzlkdlh0ZzluZllhTHJ5ZzFaVk91K0ZONHpnSzR3dXI3ZmNlSHRZYjdzczNkejc0NUdIUGRlNSs4dkhGbll2cmE2M2xYdnZlOGJoYnExL1pYaklNYlJ4bFM3MHU5aGhYVitFNjFiYTJWcjkvLytsa1BEMCtPUDdabi9uU3ZhZTdreUMvOVpuUHA1MVYwVGFLdEpUci9Dd0R4TUNZUXNpUUNaSWxWRnhsQ29FaUJsb2g1NHdrc3dTRmd5OUFaU3YxbjhCWDZhdUNWU2xwRnppU2hpcW5HQzZHQ3NyZGdTcXZRTVhubU1Wa0dhcjZWRE5SZ1FTdU82b0ZjcldFL29Qd1p5aDMxaGhVQmxrdVVFVE5CNVpnbzJUcnpmYUFpV3pBdWNYbXJrcHNCbzRNb3JscWVRTGdLSXBkdWxXSTBCbW5rMWtSQ0EydGpxd2s0Ty9XM0hhM2pSNWtHUi9Id1Jaekd2aHhEc1pZLzNYMHdhMDFMZGN6TFpoc3ZuWU1UWU5ydkxLNnp0dENhVHFlK1d1OVR0MjFQLy9HSy9Cc002a201SU9WYWNPeWdzbWtWVytFU1I3RmZLZ1k4eU1yc3NIeGNiM2RkVDBYTzgwZzRhTTVTUnJ6RTZtWVRJWVdZY2NROGpFMUxQbHBFdFhjR3E5U1FvQnhpdXBCaUoydHhaNWxGNWZyTmJtRzZVZlpWOTdmdTc4LzNEOGRIaCtQSU41bmgvMGtTbXpOdkhKaDdmWGJWOForMnE0NzJCQ0g4blRrOVVzYnkwdk5uWjJWZi9xdnYzRjBQTVgyb2RsYithUDNudTRQd2l1YlM1KzV2cjYxM0h6bDVaZXNUcWZyZVpzdCs1ZmV2UDJqWDN3RFU2ZS9mL0NuZi9SeldSR1BCNmdGY29aeEVpaEhqWU1EVWF0QlY2Q1N4RlJFejBGRnoyeTVTd04yY3N1TjJpb0Job1lxalNGWmNGY0VGRWFLRTVSeEl5TlpOL2pZaU9BQnBVNnFZbXh2eVFHbWxBVXdha28vcEQ0Q0V4VmVCWVdmdTFselROa0lWVEZBNG9BU3N4aFVoM0NvaE1LR01qQk8xWjl6bmdlMis2eWZaVVdLWGgxVnJrcFdOY3dEeGtneHdSSFdONFducXhYWGIxOVArTTRON0F5MVpyT05YTGpnWWNKdm9DS09mOHR5TXJya09vd3NiREU4NVoxWFAyKzZGbC9jb3VYdzdyR3gwNUxnYzdldlpDWWNFK2NVVzFHNDJ6bHNid3p0dFdxMUlJNDllU2dOcmc1YytlbDQwbHJkeUUzYjU0WEx5QStwNFVtZTExMHJoZmVEQ2N6bjE5QVBUbDNNQTNnWC9JRkpGTUhic1EydDd0bG9xMnZxbjdtMnNkVDBsaHJ1WURyRERnRDY5K0R4dmo4YmYvSmtielNab0M0VTdyWWJKMU0veVpOYXpUdzZIV0wvY1dHOU00bVRWNjlmdUx6WitaMnZ2ZnMvL2NGM0h6N2NHNFRSNzM3Ly9qLzdvL2QxZmdQY1dPdlc3cng2NS8yOTQ0N1h3RFJlYVRadnYzUjVQSmx1YnF6ZHViNDltZm1VNFZ5ZUw0QWFCY3A4RGd2SmNvd1VqWUFvU0psUVVUbXlDdUZmcGxCVTBVanQ4OElNaXp4VlVHVUFKUmtLVXozT0JmUFAwM2RIVERqQ0daTTV3eXFsZ25QQTNUUUNZbkpVMDZPYWFveXdWSm1oaWd1SGlxRUVaa0xCVldFeDRkd01TTzAwdjhTcExBTFRaeWtDM1FFU0NpKzEzMEFCbUFoV01nZWhBVzFaSCtNb1V0WUtYNFR2d3JQN3g2ZXdsVUEyNi9VZ2hKYnlnOXJNTm93NERhSG5wT1pDbE1kcDFsalowTUp4ZnpqeGc4Q3lyQ1FNV3JaK2FiMW5HY1greVNoTTBtNnI1dEJwS3FEVHJ1Y2xzeW5VMTRZaDVhKzN6RGpYbHRmVy9kUDlXY1NYVHNaeGJwdHNCamJ0VWNaeHNlVUtLUFlCelZZelNBclU2RGxXanR3ME5kSUl3ellhUjY1alhWcHJyVFJyM2JwN09nbXd3V1ZQK2NKaDY5N2pvNnViUzZnT0xjQ1MrTmI3RDM3azl2YnUwZkJ4ZjdyYWFXOHV0NW8xcjlma0MxUXp6VzQybTQxR0RaT3FYWFB2N1Ivdjd4MDhmSEpZSk9tTnE5dWVaMlBuME5EVEIwOFBzRmZ2TG5VKy9PQnVwMWxiL2R5ZjFsbzkxRmRLdVpUcm1YUTVxT2lIaXA4TDFWQUxvQ01xZWNZS0pPcE01U214MEFjVklaQ1VBLzRjZ0RkS3FpUHlpVkYxS1MxU0lOVXRjak4vOGJmLzRVSytnQkRORzZHU2tsYTRzNWFvenBUWU9UeVhYcUFwR3kxNnFPdzZjcVd0aWlYRm85bzdEeVJZU0lvSVZYRVdRRnp4SjFNcFhoSUlEUW5FNmhOd0pJckV5RzIxV3o3c1k4SzNwOXEyN2RacU1LZzZWQWZlaTZiRHMrRHFDajhiU3EvcENWeDhYZTlzWE5qOThKM1paSndrY2J0VzR4ZE1iV1BRSDZSNURrNTFoOSswcVRubWVCWTJ1NzNSNllsakdVM1BvK09wNjRFZnJsKzgxTjk5WXJtMjNlaldtcDF3TXZKTUF4c0ltaGk0UktaaDZ3WldEOHVyQnpIMkZEUllLSm9udVpiRU91eDlrSGkyMlcwM1czV1hyeHhPczRFZncvK2Z4dm5lNlJpejhFS3ZpWTVaam1VNnp1OS80LzB2WEYzeG8yajN4Tjg5SEd5dExxOXZyWDduZzJkWHRydHB3STlRYnF5dndPVzd1TFpzdXJibWh6YzNtcFB4Y0sxUnk4UEF0ckNMc1Y2L3NUbnk0MWFqZVcvMzBJb1RvN25xN2x5ZmF4SkVxb1JhcGtXNnBkS2RCeEJ5bEZXT1NKNVEwYUh2UEo3VDBCS1FvVXl3U2lpRnJhb1ZtSE5id0JHUW5JY0tFRldETDM3dXA4MUtVYVBua0t4ZnhXRlpVWlpKK2xsVnhjSVVjWWhEdURKSW15RUpBZ2tVelR4SUtiSFo2dTZEMURJUGNzT3NySDJobEFJaHdKR3RVTXVaeWtYdFZISHBGRmxXeEd3VmhjZ2RRcWJwTisvY2tQZEg2MUZlMkJZOEZGZmVPMVBRcGNGbWdIZnUwQzZBYWRDQ0dscXRmdm1sT3h2ckcxcVdqYUZnWS9qOHN5Z0lQVk52MWR6K0dPYVdqOUNuU1JKT1E5T3A1WEJUV0ZJZWlJeUNKQWgwcCtZWlpoakcxMS85RERSNzZrZlRNTVFLdzkrTzhBSmNobG1tYTloSHNOUFk2OFIrQ0U4cDVyMWVpZ2V6SXBYZkdSWnh0dEdxYmJhOTdVNjlnVzBFbkh2Yit2NkRnNFBERTB4Z3JER0daZStmenVEcmQ1dk93Si85L3BlLy9ULytzei84SDM3dmE0TmhmT3RhcjlkdVFSSzNMbSt0TExjK2QyMXI0QWZEV2ZTbE4yNFZXYkN6dmJaVUx4NGRuWWF4OGFVdjNIU2MzTERjU2F3MWtpR2FBR0VxMlVMUWRNQTRLS1Y4T2JxVlpTbHB5amc2Z3owN2hJa0Jva05SRG9RRXVYd0RCS0R5a0dVY2NhQUhKUFJWNEdpck9BU2hBbmVMMWZnQ0ZNOFhnVmFmamduajVpLytIVDRpcHVwY0pGYnNHYWwwaGttSmtTL1BUTEVDTWNDSUNnRXAwRzVWQkZBU2swd2hDTUNvQUZBU205ZWkwRkQwTXVNTXpsaElRUlpRSEJRd0xrWFV0RkdIRWxSYzZGVjdTR3pvUzh0THg0ZkhjSkxoUzBOcm9EWitHc1A1eURLK014V2VEb3FnYjNBcVFJNXpZMjFyYVgzaitPNEhXQW9hbmcyUEcvTTBTOU5PM1R1WmhQV2FpNlhLYzYyajRRdytTUlpIZkJZUzFoa2JzWXcvalhVYjlYUTJHazluVzVldUQvdEh2aDlnV1JqNUVhOXA4bFdyR2x3YTIzTEhRWVRKaDFKcG5EaHVMWTREUG1MSnkzN2EwbEluaVRLdzA3SmtyZFhJOUdKemJYMk1EVUdXRGFmWWZ1UWJTdzA0U0I4OFBHaTc1azYzTmdyVGsxbDZhNk56TUJpQitmRmd1ckhVZW5nMHlwSjhmV1ZKejVNbFIxK3VXYWVqQ2VidjlaMzE0WGhtbWNiTkc5di81cHZ2Zi83em4vZHExczdGelpQWVh1bTFqY3V2OG02Y0V0MlpaSkVVZXdhcExrcTdBdW91RU9lR2NxR3NLaVVNaEcwSkhDTDhDNDU1Q2p1UG8wZ1Z4QlJXU1FWRUttNUF6WXNpUlVyenovLzJmMElYa01YT0JhRXVJL1RMeUU0dUVhb3NNZnc0eVJRbmpsZjlLc2RERldRdU1CSVFCNUtUVk1na2kxMEZsa1hJdkJTTk11Y3NMVkNlQkpDdGtsV1J4VXpFbVNSYlJja1dLQ1FDZjRna1ZISmtjVWJvdXVnRzdLNmZSTEFXME5RTWVwa25jREpTZUJUeU95cFkzQlRTQTNuT3g5UnI3YVc3My8zR2REYUJDKzVxQlJ5TFdSaDFHODR3eUxCYmhiOVJkeXpvMy9yNnhrbS9qMXkycDlEU3JJQ1QwMXRaQzRhbmNOZ05yNEVOd0d3MHhFNDBSbU55RGR0UWpJR0Y5dkJpamhFbnZNeVE4N2ZtM0Z2SG9ZL3UyS2JScXRjdzl4Smdvc1IwckNqSmVwMXVaN2szQzhJNFRZOUg0eGJXanlSNWNES0dIQzkyTE0yckRZSzQ0MW9YTjdwWVBtcXU5Yjk4Njk3N0QvWmZ2N1F5R0U1ZXViSm1hWEhEYzljNzliMlRjYTlkMzlsWm1RVHgzdkY0UE1zY3I3ZTZzN1c4dnZtOWQ5NGRINTZzM3ZwczV0WWhOQ1hIYWl4NFphYVVxUUJVclJTeTBsYkVvUUNpSWlWYXlGV1JVcUdwRjBJcGNSRVlNOEM1WWs1VFQ5S1NOYUhTbjFLUjVzMVFQSDhRUU4xNTNSMmtLS0NhVWYwTGlPNkpzZ3RhblZYdWM5WElzUUxPSC93TFQ0S2lQR3Z0K1RObDlEeUhCYWhLbmVNbTlQTWdTTXdyeGt1ZU9Ba0c0aEFVT3lGQlpxRFFBTjF1dHdhRG9XZlpmc1I3bVk1bFkzZUlQa0hWWVRJMXVOZW1BU09PZ3FacGNTblY5WTBiTjJIWGozWjMrYkFCWmdBMm5ScGZUd0NYd09Pejd6Q3YvRlZVTUp2VmJhUG1lYnk4b0puRDZhVGViSWZqb2V2QWZkSjZxNnZqdzcyczBPSUVDN09HZlc2V1pyYmpRQ2xUVGJPZE9scmdtbWJDdHo5bGFUakQwb01tOFNsS3VDcjhCcmY2WWpLV2c5cjYrc3IyY2djYVA1bWh6bkNqV3pzZSthTnBkSFc5dnQ1Yit1UmcyQjhHUDNKem85ZTBkMVo3VDhmeHlUaTR1YlYwYWFNNUhNNVdWeHJvUkdGaUsrd2ZuSXlidGM3ZHcyRXl4a0tSQmtIdytaLzhlYlBSeEd6NXl0ZS92dHhzdVpkZmhzZ29RNnF2a21CNUxnZWhFaXloRkxzQ0dRQ292Wng0S0FzSVNDSHFPQlBsYVE3bHFLbTRIQ3ZWSjZpNVZTWEJTQkJLRTBRenk1bURUQ0dpYzh3QUl2YUJsYW84VmFBNktXSWNKU21UdFl3ekFxdVBVZWFSRWI0OWhyNEkyQzcyR0tDS2daVzBtQ2srVENaWDB4RkF5dFZBY1ZiMDBuUXFHYk9rb0tpdmFvd3dud2NpcTJhb09MMDhHaCsxS09tTDcvem03VUEwWGpqbjEyL2ZpSXE4VWF2UDRqak1FZ2RPUEx4Q0E5WVZaYzJrTVBpQWpjbDNrL0haU1MyM2wxYTJYdjNNOXVVclU4MStOSmhCb3crbWdXZnBsa0dqNjBlSjY1ckRmci9XYWdaQmxNUUpETG5wR0hYUHVYLy9YZ3pmUE0ybm8yR3owME5uK1I0Tm80aVNWTE5jK1A2VElCcjd2bWNaSm4vMGpSVW1DVU0vaWFNOHpVQ1laRmtzdnlGSHMrQzZqbUpzRmxKZTBvU2wxODNMVzZzdDEreFB3OU54Q0lhRGlmOWtmK3JQeG9PcC8raDBOUFNUbFhhOTd1Z1hsOXZnLzlHamcyN0xpNVBvMjI4L204WEo4VFRlRzBXTmVqUEIxdGl3dm4zMzJVdlh0OWU2M2lmZitNUGUwdXBYdi9tdEw3NzUyWU5QM29PL2hkRXJ4NEpTUnhTQ0xvZWU5d2ZocW5NSUJDMmhCQW9laXpkcDFBaXFVSTZVWEwwdmlYbGxuQnhrZktRV1Fua0NuUEdzWUk1UnFxdThmN0tsZG1GeExxL0hxeHJOWDZRelExSXBCNXFLdFlxd1YrV3BYSTFLaklBMGFKNVNJRHBhVFNtbTBYcWdGSGNWR0FmWjNEbFRIRXFqSy95VkRRWk82TXQ4WnFvMmxIQVdKNU96TE5aWUJmeURMZm9McWFvS3pvQUNCWUZwTkZ1dHc3MERiQ3JETE1lMkQ4WmVSbEtIYjJQd0pnOFptUmFHVzAvbEVSMTBxdFhySFh6MGtXUHdEY2Mxazcra2JqZmR3M0dJcmFOakdmQzhMZHZKMGhqYlg2ZzdDc0NCVDlKME9QVTkwNER0YkM0dEYxZzFFcFRMK1c2OWhtczREbis2YWpzUk5zdDhqTmZFYk1Ya1FiUGpZTVpiVHRpem9tRkppcGI0Y1JyNnZDU2FHb2JqMVREQVVSRDBYTjBQay8waERyd2tYN09NYnMxKys5a3d4ZVkzMHkvM25DTFAvVVI3Y2p3S292VGxTK3NieTgxaEdEM2VIWThDekhhNzNhcjNtcldMbTJzZjdnOTczRHhreXcwcm5renNadTBydi8vVmphMjE1Yy8rQkxSSGhvK0N4UWxESXhaS2hrbVVRUlJVeGxYa1QwT2phRGc2TkRLTFVCYVVzaXFuVWdtV2toekp4WW1sRWFubzUvaHFkczFCa0RpcHN4eXhJRllqWDZxN3drdWJWTVZ6TFJiVlVhMHQxWWlrbkpxSUFndGVVbTYrK3hXMUkzZE9NdVlTS1FWSnpHd0JWVjRGZHFSc3dweGFXQXE5S3NKdVNhT1JGbGtnZzZCS0ZRYnE0UVVNeHBFdG1WQlpSU05ub2xUNU9ZaVVpWE5jTE9qbTZjbXBLejlXaXZYY2dFMkg5MEkvQkQ0MVZnYlllMVJCVTViQjdEdHd0czI5dDc5VHBBbTYzNnpiY0tNZFhVdXhzbUczYWxpdVplU0dIVWNCM3dDUE9yQ2NjRTNScHhFZnNPSFRZSVZWYTdXRFlSLzhVUlp0V1Z2cVpDYWYySWF5eGdsTk9OYVhKRTBhemRaNE9FREQ0TmFZbG9OK3dMU0Q2Mmd5dzFhWXZ6NjBQUkR6OHFpWmRHb09kcks4V3E5ckxkZnByYS9jM2VNcmJ2cWoyZTN0SGphNEdKSjcyS3BtdksxMWRiMjUxbXQ3bmQ1d01tdlh2WTZyWXcxREwzb3JuWHNQOTZGYlhZOVRkWDE5OWU3RCt5M1RYZjZobjBvTjN1R3R0Rk1HUWhRTHlYSThtVUIyR1pDSElNT2g4cEJrZ1JJdnBWUUc4TFJKb2hka1JRejVLM3AxK0JSUXBDK0EwazhFeVM1cG9JM21uMVBxWHRXdEl1aFF5VWRxWVd2bExFZWlTS1BDUE1YdXFZNHBQdnlIMEJXSEY2R2FiODhEaTFVQUNvUVN3d0lNS3JVQW5JUmtCc0ZJMWRKSjFXU0pWb0N0SjVzSFdpaWZ5b01BU0VpMjdVNW5QSjFHdnUvWWZBbHZsTVo4S2xKV1EzWkhwK0pqU3JBRVJKOUFNKzN1Mm1vOEdzUyszMnQ1UlJaaldZaFNiVG9ONnE3VDdYakh3eG1XaTdnd2U3RGNyTWVNK05NT1BZaUNYcU1XcEhsM2VRWHV1MjFhMDRoZlpGMWI2cEpLMDJPKytJYS9CWUYxaHd2bE9ONXNPdGF6Sk14UVA1L0U0QU9icG5FNm5CcDhseFNmdTRRWHhwdTZ3YVR0ZWVoeG1pUzJaYTgwYTF2cnkzdkhRejY1Z0I1bVdkT2lZWHJTbjhWcGR0SWYzN3l3MW5RMHQ5N3drK3p1MDZPYXFmUGFrcWF0ZFRwdW8vbmV4L2V4YTJtNitzYkdsbU1XSDczLzBjcy8rWE8rWFM4bENqbkxtY2xLUVJYOHladkY4M0NtK2lMa2tyZUNjM3pLRVY0TXlrZGx3UmVEQW1vTEM1S1JqSnR1L3NKdi82ZU1rd1BPbGYybWMwdFNHRFFPZ1NnRWMzaVFrMkI0NmFJSzRzL2pEODZaY0VDTWJLbGJaM3g0S0lFZUcra1ZONENxK3ZsQVJpcElNMlFHVlpneWxBQ2VwQkhtUkN0aG9TSkpBZVppa2xLb1gvSVJZK3VnNGZuYTZzcDRPcHROcHE3am9CaHZRUnA2RmtlODlpNnV2MjQ3WUk0VWlrRFI3UFp5dmRXS0RoK1BScE9kemVXMzd4K2FyaHZHU2JOZXMrRnE4LzYzcmxtV1YrU3U1eVNZSTRXR2JTY1dCMVBQMDF4cjk1Wm5vNzZCS29vOFRMSk92V2FKQzVFa0tVd29QQnAwMW9GMTVTUDU4U3pLNDV5dk5xaDdIbG9BcVhJNm9mR0drZkVyYXluSWRMbUtDbFpZQXJCcHRreXQ0WUdUY1R6MjBjOCtkdEwxWnN2TVR2MXNFcWZZK3ZxejdPcG1TOU90YVpKOStQaHc5Mmk4M0t5MTZ1WnNOTzcydWxOL3V0K2ZMamM4UFVzYlMwdlJkTktwMTlPdFd6SytWRFJ4VVNoRGdCb21TWmVqVUFYS1hGSEplSlN3cU1vcUJrd1pFUmFNQ0RNd1FaSldSaEx6VUZhbGlweWhrVHBMS0piQ1VFWlo5SnVBQWl4VEFlaWd2d2hDVEpEU0RORFJFdGdUOEtzQzlQMk1CZGlXbXhKMkExQ1JaWHdLaXdITkI1eHh3MW9HQzRvS1dPTkNxREJWV201WVNKQUtFVGxidVVwS0JaaXh0T0tNS3BwelVDVzVnRW9kQUlqMHpzdDNMTWZFN3Mrd3VPc3lUYWZaYXFmOEtiYUIzU3FmWllMRUxNdkFibFJlMWRTOS90TDFIL3NQdGk1czNOOGJRdTBHNDZsVHE4MkN4SS81Q2o3dUJDeG43QWZzT0grVVJIR2dtQTg3bjZaUkZKdU5OakxnTW1EQ3pjSUlRc0dLNG9qWDdwbDZFa1ZoR0tWSnJOdHVidGNtbVlFSk04UFdsZnZWRkZ1SURIeFRURU5PUmN0eDBCSHNFTEFWY1J4ZXc0SElRai9zMXB3YXRoT1lGWnJ4MW9QRFFWalUrT2w4TGM2MFIvM3gzakFKWitPRWQ1aTFmaEI5K2NPbmt4bVlaZUY0d0lja2RUMDNhNGVIQjlnNFkyMHBUdS9XcVJQYzExQ2VWQUNLamVFNThaNEJjMFhDUXJaQVZ3M29PVkFZcFNGcXdoQWpoZFFRbjRXU21KelJIYTY5QzBGdFdGRWJLQldnMGRDWnVUT3oyQlR3S1k5aW95VlZBY3FUbE5vcXpaRkFRakh5SlcxMVFzV1NRRkE4ejRETmxNNndxS0lSbmhoeUZaaVdHYW1BQkp5ZGdwY0FHZ3FmdFNLTGxDd3VwVlJCaGpJdTFRaE4xUTdtS3FCWXlFSFI2MnNyeTIvLzhWZWF2WldZc3dsT3NvM2RhZ1FhZU92UWVONys1RnlTdTVmSUw2eTFpNlA5by83ZWt3UUtyZk5WWVdFYzFXd1lWeU5MODk3SzB1Q2szMmsxK1BuNUdGdkdBbnZRV1JCYmVtRTdUYmZaQ01aRDhKUVg3Mlc5ZGd0anhYVWcxVnhhY0gwYVJwNXQra0dvMlM0OG5vWU9NNjY1bHAzay9Fd3lSaEQ2YmRXYUZqcHBXa2tVdXR4MUdIbktONlRCemZFczNnNjJMRjduZ1NlVkZQbkJPSmhHZkJRT1RiVk51OHVQbXFXSEkvL2gwUVRyU1Zybys4ZWpyYVVHYW9UajlQQndNdk9qZXFzNU91MFBFOTJDRzNiN0M1SFRwRVpCWkNJZkFBNUtLMkFMWk9BVWxrZjZDU0pka1RCQnRyWXFvU0s4dmdOU1lRQXFVYUpLQVlDUmVjV1ZSQW94QTFrcUFwU3N6QktSUUx3Y0ZiRXd4cG10a2lxME05OTlBWVNvQk5wSTBDbFFOcEpzNWlpaFhpekF1Uzh3NzZFQVNjbzZCWEF1dVNra3drS3Vxb0VtSEJIRlhXVXBTdFVwNmkrdmJ4RmRkVnY2ZVo0VFFSWDdGQ0RsUWp2UkpHako5cFVySDM3bjIrM2VHalNBdXpxTlQ4YWpCb3d2ZG9la2t6clJNc2pSc0IwK1RMeDdGNHQrdStGTy9CQ0cwemEwR3ArbzFHTTBFaVI2NGJudU5BeGhlbU0rQzVEeTI1VHcxemUyUnFmSHNMWnhrZ1ZKMm9JTHdzOHFHZGloV3J6U2o2MUR4Z2NqbzRTdkFMUk1KNC9CellDZWFnYWFGQ1NKWTVtcHptdEgwSEk5ejh3c1JrZmwwb3dXQkRFOGxvWm4xN0ZjR0hrUVpaYnR4QW1RSnYwa1hXOTR6bXF2UGZHalo0UFo2U1FFQjNoYXRtSE9ac0VnU0dxV2VmOXdnT2xUcnpVL2VucUlGc0tFcHJyclhYdXA3TDRhcE9xSUF5UEs5TXBJVUxJcUticXZwRndTeTFISWNKUlJVMEVtQ1dJa2s3aVFDalhqNVpsd0hvMHFWRVRoK1ZmbXFBZ0JNVm8rcFhZQ05Qa2NXRXFEQVZtd1pmTTgyUjB3am9OcWkycXJBa1FVYVpXN0NPUkovMGhxQktoYVJCRHFyeFJFQlRLaHBibktMVkdaSkJQdU9LQXkvTW42eng4SklZaGtHVXJLS2l4Q3lYUUI1bmhTU21lYjdjNW5QditGdlhlL0EyOGFPcHVtbVEzM1F0aERWMDIrY05HUXV6Nlc2ZGFnZnEydG5jaHViTzVzODhzWmZIN1ltSVR4bEY5YTFZTHh0Tm51VHFZek9FaFFYL2d0YVpxYWpnVURtNld4SHdSdW8wT1ZSYlY1TVJ4UDBSQjUraHVheDQwcHNtaW9kUzBLK2JtL1dMZjhLQmJYSTYvVjRLRmdrT1JGOVZuT1QrTG5lWkNtRUN1d21EeFIrUXRhdnFtNGJoaFgxM3N2WDF3RHZhWHBEdHJPejlDaWMxeEV0bnJOWnNOdDFPdHdDY2FZRUZuUm55WGZ1bitTcEhBV2srbmd5SzNWdi83ZWc1TnBZaDUrNElhUmtwV0lueHFCSXdLV0V5b3BRNWtzQSs5dk1JTGhsaU5sVFhPTE1WWEhTcWtBYXF6QmcxVklSRVlHdW1KSVlGcnBVc1dUdVdMN3E3Z2NsYzVTcUhLY3gxazlsVTdhQ1JVVUxTUlFmVlNzOHFXVW1SVXloV1ozbjRNeVl3R0FJbFpOaHFyZ0dRaSs3TVVQQU1XWjdSRXh6ZWxWUzFRdVpwR0VQd2xVUzhxZ0NpMUFsV0FuNGIxdTNyaHg0ZnExdlErK0Ivc09kOEMxM2FibHBITDlEb1VqL0d1bWJUb20vWHVqdHJiZXZIcHJhdFluUVFKZGgwcEZmRXVNQnNWeFRWaC9jenpqcFpJOFRtZDhFUUNjSWl0S3N5anlRN2oxZG0za3g2NXR3b2ZwendLWS9BSkczZEJEdURjYVgwOWcyVlJxNHFBQXpWNXVlMkVjODFkL1dySFVhcUloYVpvbTBQV0VGM05pM3F0S01GV2crMWlRWmlFeVU3UUZudFZTdTg1WFB0VzhKdCtJd0o2MlhEc0pRejdRazZXT2x0KzZlcUhlcU91T0Z5VFpSc3ZUdUc1Z0c1MEZjZFN4NVhkcThJNGFWdlQySC9DanZTSXNFU0sxRldrR1lENXRLRlVtTjJaenZhNkdnQ0RaaTNDR1VXT3R5blBUUUJXWFJiWGtJMGdCNmtVSm9pVFZRRmRCUWVuTUNNK3FEb25JdEpWcVFLU3FmVUZmd1JySGlwY2tLc0NrVWRXVUxSRGRBb0hRVkdlZUdGY3J5UmtuZ1pLaXlnWXdLbmhaSWxTVS9aYXNNMUFaQ2w2TUtCQitKWTZka25aVXdBd1kyTTJyTjdyTFN3OC8rVkEzSE5PcmU3YU5oVDdqYTB5MG11MGtVRDU2eGpSQmNhRTFtcTA4U1daSEI5QmlYcElSZmxiQjN5Sk5wNEhUcU9kSkJGMnZlWjQ0R3RETHpBS0ZZVFE2bmVFeDczREIyWUNHZCtvMWRCZG1Gelplbmw2UTV2SCtNQmNUMTdHend1QldOUXhkeTNBOGUrYkR0SU9OMWZENGdGb1JSMWh0TUNreG5kQU5UTVdXNTZGelhCMmhKSWJWOTRPVnV0MjBiWTkzdzhBN3g1VE5NZzA2M2FvM08rMW16YkhzSWtYVjhMNTBiTWV6R0l0RGdXV3JYcHVPZ3k5ODdwWDA1UEg2alpkblprMXVoRE9Jd0FpY2tpVU9RY21BMkhNaWh1MkhQa0JKT2VRS2o3TU1xQ0k3SHhTdktpNEhVU1VXSUtJY1NLVTZpazd5MVlUZ3ZCWkRRVGIwTHBTcFJwSjFMWURDc0NFbE44NURRSmt0OEZ4eURtV1ZBb3VseU9YVEF2VURjTDROd0JPQXBHbVg1WVVrRlg0Qm1MRUlDelJ6SnVWaGdmK2ZBTUtCQ3JkODRlS2YvdVZmdVhuN0pzeXdENXVwR1RWdVFUVnNSbTJNTnN3aUdNS1gxZ3QzOCtLRlAvWHpiL3lWMzZ5MTZ0amJ3ZEdHV2tlNW5tUTUxQW1UWWpqMkxjZEppZ3d1dUF3Ukw1K1BCME5zaFhXemhrYkxxcTcxaDJOVDR5U0JEeERGS1loaGZFR2FHMW9VUjRnNGpsV1lEcmF1eDVQd3VEK040RTRVL0J4RHdJdjNhQkd2ZFVKbTJPQnlqZ2pvY0xsQkpGL0x3WGp5SnlFNkw0YU9aN3pHeWltRVBXcVdIWjRPc2NOZWJyZThsbndKT1FoZnVYeHhhYlhuV2ZyVW42N1Z2S2Y3KzBHUUhnNUh0K3BHejZNTlZFTkdjYW1JeE04QjVDUHFTRkFVYUFxb1JOTzVZZ05kamhwdFB4bFVsbHNtREEwNWJibUtsM2hTc0NBRC9qaDNGQ2lHNTRIRTRLdVdma3dTY1FtazhLSkRvS29BTHgxaVU3a1FWWlY3SHNBRTRTeFAwWituVlRTY1lDb3RRODQ1QjZqRXhPV2FORlZBTG9PQU9wV1NrWDdKb3haengrb2NxUDNyR1ZBcVplVDhXYlVLUEJCVVhBVUNhQkI0UFg1NzQ4NmRXM0JGK0Ywa3VZTmpXeFkzYmxuT1gwUHg2eUFhdHArYTdYUnV2Yjc2MG1kYmpSYjRSWEJFMEZSc0h3MDlpVUkvVHFHSmNJMFFVRURIZktESGt3eUhmYnRXZ3d2RDd4SVgrZWxraGhVRC9PSEJZQ1VCSDhmaFY4VXdGdGl4c2l3ZmV1QW5ydUFSUVRnV25BUytXeStZUXQrVGhML2Q1bFU1N0dLTEpDMzhPQnY0VVFqZkpzc21ZWWpKNmRYY0lJeVc0YXRvdkpDZllKVkpNdyt6eURRRy9FWTlYNCtNNmVYWk9xeis4Y2xSczg1WHkzY2JkaDVPMFpKKzVFYTFsYnVQZGh2OE1pWkhzWkI3WGVKeFYzS1QzeUtmaytSOFlvZzZVOXFJNFNpalQwMGpGWkdpZFBOWkpEbGxRb0lBejdEYXdwUHFRUmFpbXhMbTlRS3JCcEI3Qis1SUdhb2YyeW80NDFueVI3dm5rNEh6Q1BFRktFblB3NmRqWDRDS0JRL28xaHdXaTFOTE1YcUNWUGp5K0NLY05aeTVrSUc2OHFvQVowWjVLa0hGeTF4S2UxNjZCSlVoRWtjVGlrNnY4OFpuWDE5YldRbWpHT3FDdlpGcE80WnRwOXhIbW81dHcrZ2FPUjhWZnZXWGZ3MjIzM0Vjcjk2WWh0RU1pcGFrTll0dkhvakQySVN4aDBqNUduZ3ZwWDNYRHA0OVRUVTloQ0huaDgwNE9NTXBGcElVZWdtMVN4TnhyZFViV3pYZUxvWHpqZjByM2FwY3QvbE5jTXdNYzZsWm04S3RpVlBzTXRFMStEYXc5VlI4ZVA5NUVjVmdrS044elhMYWplWTQ0Z2FoV2JQUk9VeENQMHBwNDAxOVBCdUZQci9zZ0xveTNXcTQ1bVF5VG9Oa0dCYnd1MkROVjNyTjNkMERiZVhxZzBmM2R5ZXhraHZyb3dpcGRsU1ZTcENMbW9QMUJmRnpvTXkyQUZMOC93RkFsYXZDSXFpVTZNN2M3SjhEMGk4cWxrQTUvemhET00xWU1jMjVzR0ZjRGJpaVVkTnRnVkphaTdPeXRkem15bWI1VThNQ25FMUI0bFUzY0NEREtpNW5wQ3N5MmV5ZldYMEp0Q2hNRWlCc1JCWUtLalNwQURpVHVjSlV3R0ZTY2xRZ2F3VVdSbGtiaFpaWWRrd0NyN3RmdVh6aHdvV0xRWkRNWU9TcFRkeEQ4aW12QXRhV2owdkNJTGU2Sys3eTZ1MC8vWXRmK05XL2xtcUZuNlZqYkMzaHFUdldPS0lCUnU5aFpqQkVLY3VqWC9uUnlURWY2RVVmTkNEemlSL01ncWptT3BiallzTktlODZ2U3VXMmFmcFRYOXdQS0xrOWhSSkQ4aVl2d21SSjFtdlhSOU1aTnA1UWV2N1kwQVFyYkxuUmZsN1VaL2Z6b2xhcmRkb3RQMEV5cjlsWUpQSnB4S2RvMEFOTUl2Zy80Nm1meFRGeVFzd2xtSGV0Z091Q1BibHVHWFhQMnVvMVBuejNyZDdhQlg4eVJGT1ZERVc2ak14bFR2VlJNZUJsck5VU29BWlhtYUZ6WXlWbktsV2wweHl6ODZCR1hObHZ4YnprTE5OTUtKQ21YaW9tS3BmYVVrYkt1bWd6QUJ4dWppNEJFeEg1S3M2T01CRDRPQ1VZQ2FCVXlRQkFPakhEQ0NyK2cwREtVSnZLTmdrU0lCRTFuUmI0bm84dndMeFpjN2xLbzBSVkZVclVuOXdvZTBGUm1hcldmMm9iaVFSV3dsbHVHY01KWmh6TXRyYzN0bmUyd2pEd2d5QUt3eUxucmk2SkVwKy9XY0xtVko5azZVLzhvLy84OXMvK3hSdGYrck8xOWhMY0NUOU5wMUhFRVRFTXV0VmdsL0srS0h5aWtET0ZseVFuc01ieW9nNjBjY2luemFIS2hlMXlZMHFmbmc4YXdNb1hmSjhyM0J2WHF0WGR1TkNER0lPbFl4cU1wdE8xVG1PMTE4SWtoSXVDMHJMWTVJNmh6MmJjeThMSkNVVExJUlJFb0FVdzNqWExuSVJ3L28xWm5HRHhhRmhHZnpUR0RJU2JGR3FhSDhTZVo0TUFWbXpzeDlBbGZpd2hDVFRiVFJvZExReTRlSXBBbFh4NEVzQ2d6Y2ROeVZxY0dlb3NiYndvcU1pYWFsU3FnWXhNV2VZOExOQ3dvTENoQnBmWkFvdmNGa0hJV1JsTENnWXpqNDBUL1M4bnpyd0lJdElOckZLMGIvQjc1cTVQU1ZHQk1KSGxTNllvTUtydWVWQ3dXSXhGR05nYXRyZEVsL0V5dVJBSER3bHFoUlNldk1aYUJsV1BFQW9zUkV1Z1BDb3N5L0ova1FweGxVVEdwNVFHbGd4Z0U3TExPOUQ1RFhnZWZDb3I0Uk9SZGxIQWU0ajRXKzhVSXNKdUZEcmt0bHZkYm8rN1RCWTFZTC9oYnNPZnliSGxMWGh0Rnp0V2VCeW9ERU1IU2NTSktJT214ZkJKNGdRb0dOekN0SFB4UE1sV3B1NWtQSFVzRis3S1Vyc1IwVlJTczAzTG1FeW1uYWE5MFd1R1NRWUZ4eHlBSmNNMkFNM2tiUW4rb2lwTG93aitqeDhuSVcvdlluYUJSQi80UHArU1NOTjJ6Wm54WXo2b0tUVXNPMG56dW10VFJRMXp5TmV4cG1hUjc2eXZRdDY5bDk1TWtnalRsMDR6bTB5SlFVU01MWUFTT1ArbFk5V3l6QVIyUE56MDhEdE5KcDErVE9nU2lLRWdDS1FYRGFHNnlnQlRBb2lJcWpFQVJHcWxQcU04VVJXVTR5Z21uUzJjS3pEbHBtTG5BVWoxRU93OFFINXoyNjlBOFZSUVloQXdRMFNoR1ZmWWlwS2V3VmxsWi9rOFZTMzhRVUFTb1ZHVFJHRXFwT0FobERsSDRqOGRoS1FhS0FIVjJwTExpeUFaUWdJL05MOTEvZXJMdDIraEg2N3JZZFBtV3A1bHdYMTNhUy9Tek1GRXlMSlpHSGEyTHQ3OHpPZDB3NEt6RFB2c1FJZTQvZFJzMjBiMS9MeWRZU1gwZ0hRUDJ3Q0tXVTErdXU5OE1WT1dZOVBLenlXZ1V0NzJoeU5qVFAyWlpWdTFHbllITGwrVm5SZXViYlU4ZHpMelhjMXFOMnBRL2pnem9OWnc2b1VqbGg5cUNrUStDUU9NTTR3ODl0WFVadkN4TEg4V2d3NzdXdmd3QWJiaW5JRTVOQnNiVyt5RHUzVVgyM0NvUExRQUt0bXMxK3JMcS9iU1J1YlUyTkx6RWxQeFJZeUM4NE1CQVlqdXpqV1RQbW1KWWRrS1h4WVNkaXIrSEZzQWRQMVAwRVlaNEhPQUNVUjJJbVdTb3JCY0ZLVTl4eEc5Wkp3T0NCeEZiams0TWRBa1ZVUkFwc1M4R3VtTTBNK3JWNVJsTjg0SUNZSXNHNFdjT1U5eUthTmxmTTZOUi83ZURUNnQwSXR0RUVJQ011Y0ZBZk5TNTBENmlDQjVhR3dWWjBxT1VpY1hmbG92dHB3ODBVMDZmQkF4c29wdXAzMWhjelBnTDVFTTZEcGZPU2JHS2s3U01JaTFKTXJqOE5WZitSdlhmdVlYWWVhTlZnc0N3V1lVM2pUOGQreEVlZlZlN3NzaUFVc014MFBVSGRXeURtdzdremlGNitMWUxuYXBJSlhIZFdqSVpqNzJEZkNKRE04eDNYck5EN0gzNVJ1Rk1TcXpJRVJEK2JzUTZJM2hySzF2OGpFZUErYUZCY0VXMjR3Y25veHB3bmZDQW1McWVkM1JNVFhCbng0UDM5eGtubUtxWVZab0JoOFRLdktXYTlsNmpxMDRwaHNjTGx2TDJqVWIycS9aZkhKQmdScFpEb1VrRlRBdVF6eUg1M0xuU2NxYnd3RFZnN1E1RmtDaXhhWENpT1ZtM21MNUJXRGZYZ0JGaXlvNW5BQUlGWHhnTFJoSEdWRmlvV0UxQ0NDZE41Q05rVEpvaUxUdEhMMEM0YW95U3p4amFyNGlvU1FpK3NRWWs0citIREJkRWFrOEVnbEk2amtnWGkxclFsTFN6TXZPWVRGWDhTL2pDcVNScW9VS251Y2dDUnhLaWZQSXJ3Y1hzS0o4aFhRWVFYM1pFam8zSHZReVRhR3NTUkRBay9HMkxtM2Vldm1ILzlLdnAyNEQ5dHgxSFV3UTdFSjVOWjRlQlowS1U5NVc2WWNSTjYrUWJWNUVTVGFhelRCQTh2SnRCd29wNnM2WGdxQllFQVNDOWx6YndmcVM4WXRvZEFhT2hpUGJNSmRhRFp2UFY0WkxuZVdWOVMzTnhOcWlKWHljdUlpVGVCYjRjSE5HZmt3SEJodGRVMGU5VkFPZEh4aDA0TTNEWjQreDhDVHdLekN2WU5wdFUzYzhQcGtNZzFja3llYndFU3NRUTZEZ25DS2pHZ0djeWxnRlpmWUxRQ1U1RXo3SXlySnF0cFNKaW1hdTNDVlRBWVdoSGdnWktZVU1XY3BTcVRnQWpjWXhxNVNiVnJtS0V4UjNWUUsyYm82WFJyRWs0b3I1SEtPUUNsOWljQkFIUmhYblZCRWlwR1VHbGNwS01oNVpUQkpNczRCQWVZR2s2alpabldYTzRjeWJWMm5Gb1d5aEFFWElsQUpValphcC9CS1F6OElrVTFEU255RWtpUjNkNGNUM3ZJWS85ZjNaTE9Hck9qSTlUYUxKaEErNzgvcDZIa3pIOFhSODdVLy9jckd5OC9xdi9NMFF6Z25hTDdZYzZ3Q3ZQRUwwNVZJSUF3Ni9KWWFCUTcvalBCL1RuWW5nYjd0ZXpZZjZTOVBSRzlNMlR3ZDlTcERYZFV6TmNtY3hyeVJpemt4bkVTeC9vOW1BandPSGZoYk9hdTMyOHNZbU5zcThCMHlya0dGdWduZ1NwL0Nrb1BINDR5WllNNElreHhSd0hYTVNZUDlOM2pOZUZPSlg4Rkd0NTdxVEVKNC9wbkh5N0lPM1htdno1MWhLRkpERlhDNEtLR0hSRkFRVkZ4RktaQUVXRTBKTU1WUnJ0VngyNDBLcXNETFVNazdQd2ZOV1g5VUtDY3BacWxZWjBrNmw3Z29CRUgwb1lhN1pBSkpXWjFWQmhUbURSWXppZ0JQZGRLWUZPOGN2eEJVb0RNaklRUXBDQzg5SW1IT09Yb0VxdEFqU3pVL2p2QURWUWlCY3FVTEVxYlZLVGFTeURFOXEwcWllY1F5WUlvS0Znanc3enFOSC9uRHN6MGFUTWV3aDlGdCtScDFNVGs2blI0YytIQklZeXVFWXN5RFhESHR0NThKUC9rSUtGYzJMR2Z4c3g0SnBoNUI1L3hWMmswK241TEN2OE9QUkp0UkxLMHVkeHJDYmhXVkRLZVdKSGVvbWl2TzJybTE3WGcyZVNXeFk4TGloeEpabGpzWXpyQU9kVGh2bTNwOU8wQ1JNQktmVjVyUEgyQ1JrT1JZbHJCZ2orRUR5b25BNCttZ1JwZ01kTFd4RitMN1Z5SEd3OStZSE1yR1R4aVNHSkdxdUcrY1pERHpzL3QzMzMzRm53KzBtMVl3U1ZLSVNrUzZDRWxXWm1JUENDaXpHbGVEcHhpbnpMRWpGVUtJQ0lGcW9RK0VVdmJMckFOcURNdEFnemtsbGRGbkUvUG5mK29kSWdCaXlseUlsek90QlJLbStPcWg1cTlSRWdTQXEraElQelVDTUtpdU5QeGZLSHFsbW5RZEpDOWtaLzRwR05VSmdzWjNuYklhS2dwQ1Jzd3pRa0NsYnZWaVVJTFJDcmRKeU9pdklmK1pUTkdVUVhycldIMCtPcDlOUkVJVEpiTnp2eDNBd2RDT0w0eUxMbzlrMDU1dWFBcGpPUEk3Z3kvTUI5RGowVnJiVytCVTd5NDlodUhKdUdQbkdnUndiQUxaTEJnWnFDdG5CMWJCMEhYcFpjL2xxanppRDU1RWs4TVN4YVFRTlZGUFhZSEd4dGVBdnRVMHJpeUpzTkdkUkREUFJyR0VXMUVhak1XeDVyZGxDZTJ0ZTQrRDRHQXNPZW90amhQa1dSTjJhMDNRTk1BWnplRkdOdWgxRk1RaE9wLzdXNmxLY3dCM0w0S2xiT3I4N2k4YnF0bDJrTWVzcU1ydDc0ZWFOVzdzeVRhWFZBQmx4TWVKSVFGdzhFWGp4aDRHeUo2V3lsWlJuSmRHS0E0OGtrMXdFVU03SlFFUThVK2M0bkFPaFVZdEJWWCtwZ1V4UVJRdno1LzcyUDJDbTRpUncxbFRWR2ttZlE3SHNHVUs2VTBZSjBtQXBSNUJhSlBidkI1d0pGWCtSSDVLTXkySW5LYzZGeGZyT1FOV0RMYU1xTGFrU1ZOYUxCWjlMczZUNll6Z0RWUndnSEdqNUhoOGVuWVFoM1BIcGJCam42ZWh3MzgwTWZ6cm1iUnJIdm5EbGlqK2ErcU4raHUxaEZKcTZHVWV4Z1QyeDViUXYzbHk1ODhieXpWY0dUeC9tSVZ3R1B2eUw3YXY4ZUlqZnZjRUpocHgzcllxaVhuZjVuSmRsajBjaitQcHdXWGdaVXpmOE9GcFpYYUYza3FVQkhPMG93azQ1NFRWTGlxeFJxOEVUQXI4b3lUdmRKYXdLV0NqNDRyNGtkaXhyRXZBMnE2MGIzWWFkOFBWbTJUUk1WN3NOM3AvU05MajEzVTR6b3JvWDJLUjZOdFlFOUxKb3R0dHhNRVBIVWJ2cHRZeWJiOHo0bE84Y3hGaFc5bXRCek1vNlNGcW1CdDI1ZVc2bDZRSVNaZk1seGZUQ1BLaU9CQkRNYVJZWkNFMmxQd1JGcFdnWXgzYms1Ly8yUDBDRHF1SUM1NVRpTE01V29qSENTWHdkM3VkRXRtS3RRQlVGQnFkRmZBWENvb0tTb1VSNVlEdFlsSWFnakJQUEZhcWtWZm1rSmI0OFZXbUFpa281a1NrT0ZaVTZuUWRXY3laZUFtdm1tVk5tRVZSS1dzTkM4SDArMlgzcVo0VWYrNTVqSmxFMjJOK3Rad1g4aStYVmxlMHJWOVkydGtBS2s3K3l0SEs2dnhlSFBseHdNMC9semg5TWZ3QzN1SHYxVnVQNlM2blgxR3NOWjJtNWlFT1Q1aHNyQWkvSmd6REVITURVY1J6NEd6RVVVMjd2VTZmcGhtdTI3Vml3Ly9DQzBpeVd5NDEwZERRRGl0N3JOT0Y0d0ZxblJWR3J0MkR0c1luMkxJTy93RFcxTU1uREdCWTk2Ylc4RkpEelo2eEwzVmFPcVlQOUJoWVdQc1RNeTQrbXJqbG1FZkwycmI2MnVqSVlEQ0JYcTFaNy9PanB6Ly9abitybmJxTFRlS09wbEkwby9BdUF3VlRxaGx6c3B4WHlIRlJEaWtPcFRJdU1WRzVGY3dibkZWMnNlRm1Wd2pPaUNpS3dMSGpUZHdmRnVaTElCbDZRWllDekl4aDRjYVhuUzBXWHRZYlpVbGs1ejVHbElpOENxNlR2T1hlZUpTeWtLdjV6WnA4Q0lvK3lDaFZUNVFsSUNRZVZ1NWlKTXhpWDZBVmdsalJBcFVvTVk2b1FBU2VHQ3RRMEhNK21xVmJBOEhrMkw1em5ocFVHL2xMTnFua09kS2JWNlVIdnJ0Nis5Vk8vK0V1dHBkVnV1K09aNXVtVGU5RjBHQVZUTFo1NVdWeE0rdEYwM0x0OG8zSG5oOXFmK3dsajgzTFc2MlV1SmtVZDIxTEx0dGt1WFo4R1FjUWZNNldtd3pkcUFJbmE0Zi9ZbGowYWptSStBb0N4d0s3WHBwdVQ4UnE4SHllajZjeTBiRXdCeDlUOHlSUStmYlBlMUMyUDIySGRyUFA1TXkzTXN2NHM1a01mU0pqNi91RVF0aS9QK0dxK3dXZ0NWeDVKVEF6NlhIeVRSOUowbldGbXlsVjUvZU5QN2plRys5ZURoKzAwd0JwMDN1S1ZjbFBBcE5JMER1OFpBS0ZtQVdDdXgwZ2pnMm5HeWx6QVBGWVdGaWhSQWpTN0xLbXVuaTlBUlVWNmlkT1pxU3BnbXBOVmFpeWRMbmFHZjNPZ2ZWTE1BVkpLNkZoTVNnb2VjV1UzcTNhaFFTU1cyNStxZzdLN0VIb1drUW80UFVzK3FsUUpraUFWYWlYRlFtditCSkFlS29Zb1hWcnQ4ekJISVZkc0poeFFWUm5pWlU5VkFDL3hrU2hOczlDT3hxUDdSNE9vMEdLb21tRU05L2VpazhQLzRHZC83cVVmZW5OcGJRMHpvZFhwdUxVYVRETm1IOXdiZnBhczBFZjk0M1Eyd2ZhZG4yV0tacWJuR1V2TGVwSE5wc004bWliVHZtbDR0MTk1cmRab0JLTUJoMVRYNFBuejAyaU9EZHVPZlREMmxXZ0t6RGcyb0hDdlhSdWVQWjh4aGlpaFRFa2NXekRlL0hKWjJtdkRxRHZZUDJERDdOYnJVUDJ4NzNOSXNIand0U0tZTzN6QXVPWllmTzRneXdkVE5GTDk5cnlZQnZGS3F4SENvVW16cHNPWEI2YWF0dG5yUFBWVE8wL3JudnZSMDZQUDNiNjJ1ZHJ1WnJ6bmxlZ3VGcXVGa1QwVExFREZCU215WFFDVkpvRXFXZzM3dkhpWmhpUzRwcXJFSERBV1FERUlCeDdKUS80VUxKWkFjZVJDM2Y5alNUSElnZHJHa3hBUnhhTlNNMTdjcmFwUm9MSUpVaWN6U0ZJQ1kvaEhRQk9rakNxSVk4bEI2Q1VmUVFyS1lYNGlsRzBCaGtoT0pDWUpha3I5Q1ZCbFNzdWZNd2tFNFZVU2tWa0pmQlpDSWp4S2pOM25RV1NxNi9jT0R5TURUbTJpZm9keCt1U1RkREw2VXovK0UrM2xOYS9SZ0w1Q0NYZ3hXOU1keiswdXIrdytlYnk2ZVdFMkhIbTJhMkFER3dWNmx0aWJXMXFyRFM5Y0s1SndRaTkvcGQ1cXQ5dllYd2JURVR6K25PYWNMWEF3YlRRK1BzeVA4NkU0M1VpWVpNT1BZdHZsdHdKcGhKSDBmZGh0Nk80c2lqcU51dXM2RSt4SjQ5aXJOVEUzTEhuSFpjRVhOc0g5MWtNK0ZxbE4rYXVyQWxsK2ttR25hMWk2WStoRFA4WVdHU3NpMXFoV3paSW5tZlcxVG11UTZ5ZW5vM2JOZkhZeWFtQkJxZFhianI1cUoxMytZTndNREJTaHJKNkRQM0dBQ0VKd3J1aThpSXA4MnRqUkdwUlJFSlRSYzBnQUI2czg0NTlaNXMvL0xWaDM4SlBSSkZJZDhhL1NBaHorTWtwaU1YNVNCT3hKUnJRRWxqNEhOSWRBVjBIK2hYUmVTbEFFbk9lYXJNNU1ZcUpJUzFWekZWTG1MNmM4MDRJVzA4dklIR1NDbnVHa1kyVlRBZXlFZEpvVVFzYXJqSklQa1FtTzlDcVhaNm1GTFBWaU9KaytIRTJ3UFkwTkY4YlFINDdDL3FtVHpkWjZ5K3NYcmxBaTRxT2loTVdYK2xwV3ZkWllXb1ovMGo4NHlxTVFya1c5Vm9leU5WOTYzWFIwcjZhblVUQWJIQlYrc3V5Nk5wOEtObHJkcGNsd2lBMG9tTkdLWTYvcTJIeW1OMGxNMm1DMkJtMlpCWUhub0l3TnF4L0Jhdk5hQ3Q4NHlRY0lUTDFaOTdETGhLNWk0WExsczA1aHhLZHh6Q0wxSEhtcFBDK0thdGdiOEFLOGhsVWlUZEtjVnl6aDZzVFlOdkFoaExySDM2bUF4MnFuY2VESEo2Y0RkQTVyZzZkcCs1UGcyZE1EZnpycEh6NnJyMTlQVEp1UEdhQmRsVkpRcENJSEpzcUJLa0ZoU3FnTXM4UVpnVnNpRWorajRtaFI5dlFJWk45WUFyMEdWc2t5S0RWbm9vQmxxRC9ncjBhVjZ2NzM1L21pQUlpalRvV1JlSlVyU0RWOXBLaml6WFlRcDRqWUpzbFJCS0JUVkdmVFRsRUQ1TVRTRlZSUlpwUWNGRlFzNUVSUU1WVlhCY2lHaGk4Z0pEcFBJMHNrK1NsUXRmRThDQ3RVcFBLVVdEQitNS1BmdW50L3doYzd4cWxteElVMTNOMC9mdmQ5TTlPWGx6bzNYbm9GdENCVm5xQ0tvK3BHcytrMTI3VldTek9zMlhqYzdQWE0zcEsydFdYWGJHamUrT1F3aEQ4ekNWWmNONDBpRFZaVjE3dExxMWdsMENrK3JZVlp4UWRmZEQ4TW9ZV3c1WVp1eHJJTGd1bHBONW9wRmd3b1paWjVlakZLY3EvV2dBZkYxeG80OW5RV1FIY3MyNFU3UGcxRFBvR2NwZktndk9GWmZJeHNzOXZ4WENma04reE5UQ2hzYnpFL3NHN0F0OEhVVys1Mlp1Q0FpZ3g3R0tiWXpHSlJZeHV3c2ZaYWsxazBtUGl1YnQ1YWJlelVNc2duMHAyVWo2U2RsNmthdStlR0M3Q0lLWUY0WUVWekpGY29GUjM5ZmVZUnc2VlRrQUExT21XeUtNeXlLSGVZYWdid0lFK2lRZDNGbVpFQzZyUUlWWHVZaTMra2dPR1VramdYUlI0NXRxeWhLcXpzTHVmYmVYWW9XREtwbXFzbytjKzRaTW5FSmtlZUZ4d25KU0FGVWdvb3NSOUNxK2dYdUlFZUJWaW1tZ1RnV2tYUGdCaVorZnc3RDJKRnlrWWhncm9ncjhkSC9YZmV2WnViOWVHVEtacnE4dGRFb2Q1WXRxMzYzck1ua1daaDZ4ZkV5Y1FQcGpNZm5rU1JabWFSWWVPSTBGdGZYYjkwZVduN2dsYXJGV3RyZXQyck56M2tmTzlmL1d1djI3UDlxT3RZOENDU01PU2o2dkF4Ykt2YjdYWmE3YzdTa21GWm84azRDR05lanpldHVNajQrQkw5bWFoZWIwQ3ZNU1ZnbnJVMHlYUnNSNjNBOXozYmJEYnFNejd3cUdFSDdOaE9rTVpZSXVDOW14U3NqcGpMcDMyMGJyZkZXd1Q4VFRvVVd3VEJUMzZucG1uN2FRcWJqM0V6M1E1MkRHZ2Q1Z20ySW1Fd2EvVjZ3OUZvTXZWUCtwTW5EeC9wL3VocXg5bXNtNWlnTWNmT3dFZ3EyY241bkM0d0xSZ1ZBWFdsSzJjanpnRXRJL095UEtzOWxVb0RxT1pFY3lCNWtsUkpMMVJrWHBHYlAwL2Z2Y3c5czhGU3VvekluOHBRT0JYSGNhNCtpcTFFQ1hQdWMwQ05sWDZYR0NaZUlHUC84RTg4WXFxZVQ0RnkyZ0NrSnp3Sk0xNGxZQjlVMmJKeDgwYVNCREhSK2hMeEFpeG1NWVlTOHhiTCtmUjBPSnZPK0xFeHJhRWJGcnlGYURqTHNGbHI5bXJMVzBlVDRON1RaKys4LyswSEI0K2Vqc2QzSHcrKy9jZmYvZGJ2L1l2WDdseDNtKzAwREUzSGFIUjdxOXNYZDZmRFJzZHR0dXJZR2s0R3A2bFJiOFdKZzMxckdtdUcyVnJaNkc1Zmhrc0NyWVgyUS95VzViYWJyVmFyaVNtTlRTdVVOTlg1VEM5MmsraFF1OVdBWngvRHg4NTRNUkllT3k5VlptbW4yZFFOWXpiMW5Wb2RQaEpvZ2loS2FmOG9JdDU0NG5xVjExd1hHOXVtNTBDUHg3TUE3aFFXRFN3VzY3MFdGZ1c0WlBKU1luNmR6WEVkZUY1MXJBWlJjT1hHamRQQktSd3FoUDVnL1BESndlSGVic2RNZTdaV3Q3d0FucDRhR0pFY1IwRkFKUldvQ0VZTVpKVjZxQklLNW9SeklPMDVFbzRuUm9qZFlmRUZCUWFvSlBFcXphM3FiLzREWWlxTkVXQmNxUTRWUkRHVFhOVmNBbzBkNGhnc2xZbFRtWVdFZkxRZGhRVkRUeE5KeGtzK3hNL0RHU3pZZXdicW1XcVZ1S29zcHVxUWZLRWtHcDZ5b0Fnb2k0QnRIRXNLanJRc3hUODFOWVNRc0NoNnhFa3B6Vk5KSGlWZW5Vc3VVV0UrUFRqSXNmSzMyMkVXd0tscDZKcWpXMFdtRzZhYmQxcHh2WlY3OVZsL0hNMW1SVkw0dzJDYWE5Lzk2cmVLOGJQZis2Ly95MGZmZSt1Tm4venAvbVF5emNhdlhOMSs4OXBsWDgrUFI4Tlo3RjFhVzMzbGl6KzFkZnUxYXovMHBlVXJOM1plZnVPbEwvNzRTei95cDVhdTNoeE1aNnVYYjl6NjBrOTBOM2U4N2pLZmh4OFBqUUt1Vkdib3htVG1OMnYxb3NoZzNTRXF3OFRta240NFJyRGRiRUJCSitPSmFVT1RMZmpsbUNIY0E2U3B4OWZWbTZESENHTE90T3FZRDNyRE5hWmh6TEdVVjI0c05ScFl2aUFNejdGSFliemNicUZRSEFhT2ljMXA4aGYvNnQ5ODcrNTdXY2dsWTVaRVFSQWVud3llUGR0cnRyb05MZHhwWXRkcnhMb2xGMjFFaDZnVDVhQ1ZvRlJWTGVoVUdDWCtPVEFOK25rUi90eFVKUlUzUnNpUWc2MFNrb3RpWXZKS21NZVFaZjdjMy83N2MzNW8xbUllb0hKOStDZVJlV0dtMFEvb211cUJWTWpNYWdMZ29DYU1LblptSlNWWENDcFE2c1hLejJoVVhTVlpXWVdrMkVocGpoQUlBdjlDVUhGR0M5Z0lnTkpqRlNlUkRLUktsVkJXTGZIelVGRXFuaVNCcy82MWorLzc0N0dlMnJHWmRUcXVrVUo3c0JYMCtDbSs5VVpTMDVNazFxUEV5T3paMEo3NHV0NnM1ZTFXYUxmZisvbzNJeTJiaE1WR3J4M1dyVmZ1WEx5MXNlSTRicVBtdmIrN2UzeVEvSmt2ZlpHdXp1WldlM2wxZVgyajBldkNKRHVOK3NyV2haZC8rRWN2di9MRzVzM2JsMTc3ekowZi92RTNmKzRYNzMvMFlYLy9LWnhVbU9va1RtaFFET2k1bldzRlREZ01SeHhES1MzNDg2MTZMVWxTR09CYW81bkJGMGxUaU5FMFRZUExBUGNZa0JTS29QMDZOOG1tNTdsaEdQQzdQWGsrOGNQbFJwM1BLV3Y2WU9aM21pMjQ4MUVVTmt3NFhmbG4zdnl4eTYrOTlQNWIzOEZzU2JCMWlCTnNBS0lnM24zeTlQakpBLy93V2NQVzdmWlNZamdZTDZxeWpDSlhabFpLa1paakpCbUxocm5TTmtvZWNlcUZ6QVgrYy9pWkxjemt5QWhIWEVYTEdTVmp4LzhGZ0s3Q3V2L0hDMmdaVjlZQ0N5a1htY3N4RjNZcUxsbkVzYncwRVdtY1ZSdlY5R1A2akt0RW1LMGFLbGRSNXBrRXlaUHorUUQrT0ttT0VSU1Y1T0hBTFBRQU1iTGw1cEFwMGpBdUJGVUJnUko1dm1xQ29sTlNueE9ka1NtWjZJbW1mMzN2Y0twbExjZXVkMXIxbGgyTS9RbFUyUFQwT3Ivb2xkaDUwUGZOTk04dE45SnJSZDExMStxem1XKzVqVGdKK05iSExIYVhWdC8rL3RzLzl3cy9zYmJVME9FYVc0WmhhWjJWalU4K3Z2dloyeTlwT3Q5QkNiSExqVDMrUTlncWlVMEJMTEVnNmJPLzloTS81YlNXcHZEbGc4aXcrU3dBZEZVZWJvRXhOYkFmVFdKK3RROWVqV1hxWHIwMm1Vd2k3REl4SDNqWE5wdjRQbHlqSWszZ3EwQlpVVFpPWXROeHNBZjFQTThQSTJ4WElRbXFlN3NKNXg3U0FCa1dqZ1p2MEJaRkdtUFhkdVh5NVovN2xWLzcxbmUvTVRydXcvUEJ1b0ZwRXlZSi9LWHBMSW9LdTdPOHZsejR5N2FXeXEwd2NCUTFRUjk0OFlkU2xZRDlBbkFpOWhJRGFjdVJlTW5pRUFCUUNyTkZqUWpwcEJTQkNFWlprQ1ZSWWo2LzVzQUJObitPRnlJcDF4SlpxaEN5U0F0c3hZcFFFa2tXb2VLSVE1V0ZKcFRSa3FjUWx3VndraTR0dEtQTUJhblNzS29sT0NLbUpzZ1pvQ0NKcFJDVlFNcEtxc3pFUDBzcUdnUmhWdW11VElkNTR4ZEFJVlVKU2NzQmRRTUtMY24xeC8zSmV5ZW5wM0dnNTJuVGFVTnRKdU13c0EzTnJ1bE9EWll0SEFYeE9NdXNadEh1OFBKM3pYYVhuQ1FZRzBiTjVBZjFUTXpCT1BNYks5N3ExVXR2dkhwMWM2M2JzSnl4bGlkNllkVTdlWlN1TkpkNFBWRDFSSnJOSm9nNFpPaVlWdU12Ui8zQ25aYy8vMmQrNFFzLzkrZS85RXUvK3VQLzRhL3RQN2czUHQ0SEhyck83QnkrUFY5RGlaN0JzNTlPL1R6TG9JdVc0NFErMzFDR29PZVo0MkJEeWVlTmVaVkg0ME5wb0sveENiTUpUUDBzU3Jwd2g5QjRuZGYrUjVPd3Q5eUIveHJNSnFhaDl6cTluL2lGWDJ5MEdsLzc4aDl4cDhCbkVQZ1lRaHFuUVJ6Mys0TkhINzQ3MlhzNE8zZzhQWGhRanlad2ovUm10MUw2TTJEUDBGYWlTdFhoWFJLNURhbnNGd0JkTG5WTlVWUm42aldpeUZBY1JUMllLYldjQithWlB5dTNtYVE2VUlLR000UW5KV1FaYjFWU2RzUWtBZ0JKUEMvTW5BSExjM1RPQWRJS1JaN2laNnZXc1N3N1JXQmFVWkJJTUtDc01pVlhrZkNzZEYzbENVNzUvTUFJVllrVkRvandBTUNBaVkxU3pLU1BURXBjVWFpYUt4YnlmaUt0R01ieG85SHMvdkZrTjRuQ3pDL3lyR00zZEQwZERtZGowOVRjV2dyOUNLTHgwM0dhMVhTM1hqaHVBVjhDVHF0cnhNR3MxblJkcXo2Tkp2ekVwTi8zT3NzYmE3Mi9BdE8rdlo0N2RtaGtwbG1meFB3S3pWcXJQUjJGdkd3dHdsb1FZemwvMVNpb3hnSFVlS0tGTU1ud1AwelB2ZjNGSDczLzlqdWo0d000S2lUZ2I0dWh5WHJBVjNyQTArRm1EQzdIekE5aXVQaDVFVVp4cTFuVFlLc05QWWxUZWltOElWV0RpMC9OeHZRb0NqL0p3S3Z1T1ZCQUlFL0hNN2p2OEhtbXZtOFdtcXRuZi9Hdi80YmJhTHovOGJ0SHp3NTRCNStQNy9QcFQvaE1VWnI0WVhJNEdFK0dvOUhoM3VoZ3Y3RisyVjdia3VFanNFTXljZ293UWtyK0NNaVFQaU5XQ3FKVUdvblBRV1V1anFrVUo5Y3lTNUdWUlJsZzNaVzZxK3FyNFNhSVRvaEpWQ0kvVTQveVFLUUNGVkhITXdZVktBeU9jcEVKVkJnOEhva3R5eEJEUVRDUVhJMng1QUVRVVR5cXM2SlpFQmI3U2FRS0JHU1dLTXlIT1NlQWxEMkhVRVZBakZib1JaUnBENDVHYno4OE9DankzVUVRSk9IUm9BOGJyU1V3Zm5YNHh1TmhkRktZbW1sN1diVHM1cVBFMXJvclZndG0zc1pHVWF1N21tSGtTV0ozbW81dDJDN1ZQMC95WUFodndycDJmZWVOTjI1aGExWjMzRkNIZFk5V0RXZVlwdFkwRG1meWdacUZsc21ZcVhBR1ZVTDFDY2RTQ25CVVh2MkpuNjYxZW9kN1R6VytpUU5tRmdZZU1zYzVhN2dlZis3TkgxemxlcFlCYnhqRm5SdFgvU1RLVTk2bWpYbVZSbjExVGU0SDh4VUdmR0dsSDhVcjNRNXNPZFJnNklmTk9qb0ZIOG5IRGhZNzRML3lhMy9KYVhiRExQejZsNy9NdHl2eEY3bFp5cXVaL0tFV0lNMzBXUmpEeTFxLzlzck9ULzRpdjZqRzlzcndRdVE0U3VNVktKdzZxMlZPTUFKSW9KQWNGWlFkbDZRaUs2Y0VkVmhsY0VBWlVWb2d1ZUxNbExJVDdWQU1LaWdWQnRseUpxYlNTZ1lpNWduV2lpTzlxektIQUhxbWhJOWtNT0NmdDhHckJ1T01JQkdrU2M1Y1JTd01pQ29ERHZ3ZEw1dkJGUEtVcHk0Z1VhQm8xVmtXaDlLODR5QU5ZVVhpSzFLWEVEZ3lCVlM4R0NYeGdSL3R6OElIdytuSk9JQWp3cStNUmRGeE5FbnJiajN4SW11RmovU2VKc2RIb1pjWDF1bWh0NzNSait1YTErSFBwdHZPekkvc2JyTzI3R0NzYld6UCtKU1ZQUXNTR05iME5Na0djVDJMcnV4MG50N2ZmZjNtcFdGY3JGcldtZ3ZEQ1MvQURHZHA1TWRWTnhiZ3JHL2xZTXN3UzAvRW5aTjhCdjZieHZiTmwzN296L3k1bDc3NEU3ZmUvTkhsN1N0MzMvMk96ZXVWT1F3ODlFOSt0OHJpRUFySVI0UGh6L3pVVDN6OHlYMXNhdE1FcnJtR1RXM2RyU0dDRGV1SXJ5UFdwbUhjOW1xZVo1dVdHY05wUy9OT0Mxc1JlT2dCZGdGLzZxZC8ybXo4LytuNkQyaFprdlE4REt5cXpFcWZXZDdldXQ0OC8vcDF2M1pqZWdZekdBZUFBQUdRQUNtQW9JR2hTSW9BU09GUTBPcnNTcVNXaTkxenRFZEhsQ2l1eUNXWFN3TUtBMkpGZ3NUQVQ0L3RucDcycjU5LzE5OWIzcnUwbFZtMTN4OVo5M1VQamhTM2JsVmtaR1JrbU8vLy8rL1BqSXpVMXRlM3YvYjFQN1NHVTlRTjFVRFB3bnJBYkZEbklocU4wUDJIWUhicCtWZWlpb3p6MHJ3ZjFoaU1CbjR4VkJRUHpUMWk5STFmcEJNZXdoYUdnWERJQWgyUGRsRG01ZDRQdjhNWWZpOHlQODJEd1AzQXovM2kwdzBFMHJ0UEQ2RHEwRUV4SWkyb1JGakFSN0wvNzBaWlBueVdLWVF3Nm1LMloxbjMwT0ZBbEhaUmhFNjZ6QjhldkV4bnFRUnRDbUVaMUJuc3MveWhXTGlYWldaUitseWtzOENFaTd4QS9FRHhSTHJqV1gzaURqeTNCNE5yK25YVGJrK3M2ZFRuRnZTZU1Ea2h5MWx0eEY1cE5KN0crZEVpTFpNek9wNTY4V2dzWDlibGZGcmMyQktOZENLZHpCZVR4VW9xbDFiM0x1VXVYMHF2NXFTVmtuNWp2YkN5bGI5eVk3VzRsVXVrRWlmdkhJaTI5ZGtmdWY3cDYrczNydTlWKzcxY05oK3hyZTU0a3RLTWtjZlBScWJuK2grMjRHbGdiUTlISVd4Um1PWHBNRDA5WXBtSFpnTkVaU09STEpZMmJqMjdjZlhXdmRlL3hjL3BLVzlhME1JbkFTR2ZCM25aWmZ1TllnRUp3K0VFS3AxSWlFOGk0ZnN6aVkvNzBaaERieWVtQnpzVldRQjZjUlNjMTJUQ0FOTXpKemlFSytaenVkVjFSWmF0d0xuem5iY0loYXgyME0yb0VHbDZGbEN3NXpoT3B5Ynh2RGRvendhOW1ETVZGWDFPQ3h1ekZsREw2Y00ybDZvTTMxUVc3V1F4Q3RSR2pDWHRZbmsrR2o2NnljcjZFL3NwUlAvQmR4N0hBQVBxQWZRZ25RZ1NpUjBoUW1tVE5pN3VYMUlsMkRkdFlqdjhwUURYZ2hrZytuczZQT3p3N3prcmRqemRKam00MkFnajJNdGtuWExSRHdKSjJqSUpnZTJsYmZwamx5ellMcXJrTWcrMEJRa1lLaEhtcFg5S1owc1hVRHVqL0R3dWlwb29TUkVaZmhvWGM0S0lFOHltUUxzN20vcisxSW5Pb3ZQQk9ETHUrazdmY1pyREgvckMzdlBQRlZ2ZS9MRHVsTEs2WWZBOExkRWFnV1ZHNmNBWGo0ckZGdlFHWWJDQ0tFaHQ5SlNlRW9yUzdmdFl4T3dPdWYzamw2NXRKVE5HL2VCd0paMTZ6NHB1cFBXeUJKVTdtOHk4OFVLc3ZudFgxUE1CQ21PQk91WmlSUENGanFCVWFncmlZYXRZRWh2U3NMZXB0ZUZHdUo5MjRoTWIxczcvMlgvNWkwNjNFZkhuOUZvUmVxY05LVTRRR09UWnlLVXY3NnkvODJEZmQyWXV2WTZiRUtDcENsUTQ2bjVjYll6cGJUbkJWaWxMWHV4aVVSOU10bFpYMGFoZXE0Rm12dkt4bC83MFgvM3JNWjRYTmVrdi9kbWZoSWlnaDlFR3FIYm1ET09iaGlqT1JVVmVsR1FoWVdncmhheVlTdWNxRzRWTHo0cTVvcnE2QTNraU04RHUwTk5Bc3JwUlUraVBiU05RaEhYRlJVQ1VHaG1tVU94UGhyRG4ySkVNdkd5TCs5SXYvRTJHRHJhSnMxQWluVGNzZ21nRnZ0RStrcm13S3luZnhTZk1FLzZFOGtUMVlsRUNIZHZIam1IbGhTbkxrN0E5VkNEdElzTENvdXlmeG9tMncvT0dPOWdtZGpOS3Nzd1Zmc0xxTHovWWpjSnBOajVyYmRqNzZFeDhRM25HWmFsUXl1UktlaklsR1lZb0srSkM0bFU5cnV2UTFNbEVMbDBvWkNyNWRMbVl5dVNTVWpJQlZydVhpVDV6ZmRVWGVNZmhkaXRLUnVGVUh2MjNrSVFZSDQwS3FDQzdqaENPekR6R1hwOFVpUWhCSkI1RVZ1S1JUVDV5UlJPdmJKWXphbHlQenVNcGZSS05uWGJHTzhXRXlORnFxU0RCNDhuOC9xLy9rOHpXNVVoY0NKdUJxb2RkRlA1U3lrV2drMUVIaHZ2RFFISDg0N00weHgvWlVuVGo5dWQvNlBEK2ZidlhCREdIcGhVNGVoY0Rkc09EOVYzWDBHVmRWZHVESWIxa00vRHA0ZFFGeUV3Y0VrenJmOURqVHI0ZXB4azBhT3JFY1JSRlVXWEp0aXlCaTNxdXRiNjVNM0hNZERKN1dqdXJuWnl6eDcyaENwaUNEL3VmbGdpZncwVUFGekp0MTVwTVZENCtOVWNuRCsvMER4L0dGU05SV0tGV0VTaEoyQWdxYkJCcGszM1RnS01waU5FbWF5MzkwTzlIZXlaTXA1Sm9KK3NoMXN5TFhQaU9jbC82MmIvSmlxUHRDL0NGZTJralBEMUNlQmh0czNUU1dxemdaWXp4U0phRFFvaGlsalZLVjhKb0I5dGc1WVJub1JUYVFYVUt0L0JOTGFaODRSY0tabVVTSmFjb09lOHNOZlRpcWNINExQR05INFN3ZVd3UDlUV3BYbkRTZVN5cUpSVWdlS05pUk9MelNKeHpGakdmWGRXZkE2M3NyRXcvUnFHeElyTUE1RlN6ckdRMFVJUHh5N2UyT1YzUUZWNVRPSmx5VWQzb0Flb0lUVnYzMkJsNWxJRHQ2TUswNXZIb1lqMGFLZkRSRkIvTmNSRUZFS2ZySWlTbHFFek5pM1RHM3RWQ2tpYW00OFNndEpPUkd2Ry85dVhmZkhEM3p1V1hYd25oaW5QZ2gxb2RmcUZCWVFleGdIalk1MkZnYWNzRFNQTFpEUlBTSHl5ZHFpZUl6MzcyQzRQaHFMWC9LQmJqWnJNQVBJUWNDeENZeUZ5SVJMeklvajJDa0M3b1B1Z01pRjBJQWszQ2NjRGw2UnBMNEMvbXVrU3ZPblBwOVFweGxWYXA5MFJVZis1SHZVRk1rdDk2NjQxbXJkYXNOWW1zRTk2aFgyZzhjSFo4QXZ6UzY5eEkyWHN6ZW96UXNxeTFaejUxNDdNL21xNnMrdGFFazJSb2Q1YVgvc01tMGNaRklLVkxQY3dTNlJ0V24zSlJLeGtxV2JzcHNPeVVFeUVVSWJyMGliMHNuWEYzMWxkaGRuWWN4VVBzWFJ4STRjTVlRaGhuTmNLNXcwcXdRRDloUVRSbFlsbml4YzZMQ0gySE5XQWpSNE9IakF4NDNHTGhkRHFUWm4xWVBhWW5HL2c0Y1FhZ25HYTBSV2FqZmpBWlY1L2M4d2JkdTEvOTNkcjk5eEpKVFpDMU9CZXI2Q3JHei9KOWdIc1I0ekNZY1VYVWszb3FvVlJXVXVXOHBtalFXSFJ0V2NTSlFkS2pVZHZEK05IS2NqRjRlZXdPcFRjYXZ2dWJ2eld2ZFpSSmYwK1ZkekxxZ2c5Z0UzSXhENExoc2d0enMyQmhBaUR6cURkZnhDTzA0QmEvV09qUlJTb1dLWW1MRWg4ek9BQW9aa2NXcytqQ1dVUTdrWGw3TWEvUFlrZG1kRGgxOWxLcUpQQ2R5U2lDbHJYYWYrOW5mcWIzOFA1czVrb3hidlAySjZCeTJXaXlicUllQ2tlWXdUaE1RL2d3aG4zTG9VVHZzQUVpcUNNSDYvamxEN2E1R0hmdFk1OXNkMXExSjQrZ3FBbkhxRFpITHgveFBOL0JQeUM1aUhvQlhaeGhVdzNRaTlUcGprdVBEY0kxMWVCbGtzVFM4bU9xZ3NyU2xkWkZFUHo1TDM3TWtHTjMzbnY3MFlNRDdJckc2R0Z6SUo3K0NCZk16S0lTQUFOZHFhUVhhRnFPczdWN3ZiUlplZkRPcTRkdmZkUHBEMlU5SVJrcFZPWWpUYU5BTFFsakRLTFVMeGNaTUY3NFJzbVVCLzhzVGhzc0VxYlFIcVlDTHpiQjNWOS94SDdwNExBb1ZrdnFLVHFZM1dwbWtzZDI0MGgyS0NRRzRhT1A1a0ora2Nia2Faa3pMQWZ4aTNPRmhTNEQ2b1FhNDV1ak1xTUwrUHI5bGpNY05BNGVuNy8zZG04SVp5NGI4SHcybitkbE5aazBvQzBjZDNIbm02OG1rN285dGVCN3FiSXNLY0pQL1pXZks1Y3JVWkZMYUtxcXBhWlJZUUNiSy9EQURkaW1CSEF6SEFSQU0zMm9XaUNoOWlKbVV1dW8wekFnTUI5SXRCYlJyb3V4OTN1MTFpMkZKcDg0MkMvS3JpU3ZLMlFGWEdnemV3NnhTR2tZOElnVGljU0JKT29qS0RPb2NFckJLZHhGZEJwRU9wQ0tJREtscDBJWDBkazhHWWxVMUVoQzVRUnU3aTY0b2Irb3hQeHYvSS8vOHdmZit0Yk1ubWlHbmk5V09oRWx1N1hUYXpjKzgrTi9nVmE3SnAwZWRpUHJhTmFydEgwQmZWSW5MRUxKTExhMHNUUytTLzIrL0NZSEk5cXRuZjNMLytaWE9vZUh1aFMzWEpjTGw0aW5heUt4T09JY3ZiRFM4UU5aRkN6VDFNUjRYQlI2VTNOaXVZNDdLeVIxUTFVQjFzSEUzRnhkRWVQOHBOY0M2MTVkeVVGc1AzUDdzdTE1Zi96ZHgwZU5IdGcrdWhycUhCSUVnNGFLaEhWRHhTbFFYYUpRRTV2RlhDcWZVNDFrbEJmaVJpcTdzWFB0QjM0aUlvblVCQWFlaTdaU3dEZTI2Vy81b2UwUXhLdzNXSzZ3cFN3VDlwSlNKMUs3N0lFd2NGLzYrWEFTQWNFWTZRekhkRGlkalVWWktSOGVFRzVTcFNuRzRqaVVGUmx1c2p3c3hnTExkUkZZQWFnZll3VDBBVVM4NFFCSyt1SFhmLy8rcTc5NzlON2JvOXE1N1RtNnBnWEJUT0RqZ1d1YjNiYmQ2L0RPY0hwNjZJM0duVjdQOVZ6UG02RU0wTUtmL3VrL0MrZlJzaHhlMFZSTkZYbWlEcjdJR1NKNmtXYTMwczFEbkF0NkplU1RZQ3RnTWlBNWk2aE5WeEFwLzJ5eEdQdHpsTnYzNXNkTjYvRTd4MnRYTDQxVll4aFJ4MUhaV2NTN0M2NGRMRnpMTDhwQ1ZvNkRuMWpFQVNJejRDTWFtUzRXdzBpa05WOTAvVVhMWDNUOHlOQ1BUSHpJR0kyNEdISFZXR1RWaUNla21CbUxDVkgyeEwrejhBOFBmdk1mL0EvVDhVZzN0QVZZZytOKzVYLzdyYmYrNkN1UDMzaE5WN1dONjdlUUN4L1diZUZnVUdDYlRHbFJVMmdjRUpzdkI1bVNMdklzdjhNSW1jWm9WRTJrQnQzbXVGa2I5QWZRRlQ1Z2lSNEFyMEpPSmtTUWFabUh2cCtwaWtMdnp2Rm5FT01aNlhxQWNLNUtJcjdIbGswUFNrbVNQNS9GWU83aTBqdkhuVy9mT1pnTWg1OTc2Y2FWU241aVc2T3B3K2Fmb2NOUk0vVENCWndJaHpnbjdZQmpZRTlINXJDUDRqbFJXN3Z4dkpFcjBuVXhVb0JMV2FXS1hZU1B0SkFWaHkzVUdCdlVDK0dIemtVNWFPZFNGWHg0UEF2Y0Y5bU1TSGI5ZzA3Q01MOHNtYVhoQ3luMG9hNWRScGNGc1F6WW9xU0xCTnBMaFh5WWt6NHNsYjZJZXkrVG9HOWliLzMydjMzLzkvNXQ5OG5kU2FjZCtITjZjUXFjSmZDWldaREpwT0hKUVdXelJROFgwNm1aRkdPRFRudXRrQjI2TkhFakxzVC95cy8reFc5Ky9UdGYvdlYvODN0LzhBY2J6ejdYSG80K09LM1dMV2ZzemdZak93S25qQzZlTDRKb05LQTN6dEhFVjFURGowSnhMcDlCZ0NTTVBFS243Yyt0cWZYZVd3ZDN2M08wbVZSTGw4cVFKMUVrbk15NUNEK2ZyVWY5cTZvb2NKd05pRWNpazBYRWpVWjY4K2pBWDdUZEJVb0F0K0VpbkIzRWhnNWhCNTRvTVYzSFNRdDhVWmZUSWtBWmpmaWVkVlovNTdkKys0MWYvNWRmLy9LdlozVWxrOVJocGdMZnUzbjd4VWRQbmxoVEUzemcwZHZmdmY3aXkzcXVnQ3FHYW03WmFmaEJsSFZrMkttVWdjV3c1Mm1lNWFndnZ4a2NNTUxzbUZ4bDgvN3JYd1VBUjVPeFFHOFhqb0tvOExUQVpaZ0ZCeStFT0MyWFI0K0V4Q1hMZzdxbjlTdDlQOUJrbXV3RndvTjhocTY1bmdNVi90eXRaeUtwTk5UTmVYZjY5cVBqem5EMCtaZHYzdHBkQTVWckRpYXNDaFFJRkdIdFdBempRSlBiL0NDVEs2NWRmUzVaV1Q5Njh1NDd2LytiYnF0ZXJHeEZKU0pPVkptTHRud29MZ2gwQ1pEVU5pcERSYkpBclNQRkZSNUVnZURHU2tHZ1pKYVorK0xQQXU1c0IzWGMwOERRU1hscEErbnN3NDVrT1pjRnNDaDJoVm5Ed0FUeklrTW9aT3hEcWlQY3hXZ01Ocy9ldS9QZ3E3OU5LT1RvTlJqVEtSd1ljRythb1FyMUFlMk9uTWY3aDRlSEI1b29nbUJiaTFpcFZJaHlRbTgwQm5GQjV0UFRZOXMwUVNVZjMzOTQ4dWplVi83TmIzemwzL3liUC82TlgvL3F2LzVYci82cmYvRzEzL3EzOTc3OTdiZ3N4eE5KTmgwTDZqM3FNZitTank2ZzRBSFFBQlI4Umx3Y1psMFRKTnRkSEgvbm5ULzk1MThKUklrcVQyK2xYaGlPZFZ1UHBhVzRFNDJhaTNsM0Vlc3VJbERob3lEbTBFdmQ2ZjROeEFBdEd2alJHVDBPdDVENXVlZlBaTmRkNTRXVUttdENqSjh2VHQ5NDY3ZiszdC8vWC85dnYvYk83LzlPUVk3V3EvVnlLVCsyaURmTHFuSHA2dVZYdi9yMXlZUW1xOHo5MmJBL2VQRkxQMEpPSG5xQmpXekloY1BoQ0FQdFFYaTZIZVlMRStrMzNLQlBHSkFvcTFxdlV4K2VIc1lGQVJvRWZJYnVIOEZVTW9XSHd6RTBvTjRpWFlpaENmUkpJMms2Rms0TUhSem5ZRENKL2ppMm04OWtUTmVOQnJOUFB2L01qLy9OLzhKVFVndlhCTTF2RGN3UGp1cU5SdXYycFkxbmRsWmQxNW5hYUIrMERUSGZEMnZLZE9vc2lJd25vKzdaNGRuREQ2eDJ5eDFOMnFkSDVtQzRjdWs2SjBsUEVVNDFleHFvUS9DaEtMNm92WWhRVG9yUmdPR1h0WnkrbjhZcDBBWnBkL3FsRWhnMDJWNXNNVUVKTjFtRXVvdFV3SVVMUzRsTGtTQ2hJcDI5VEdlSFVtQjVrQjNib2VxZ1JSNVlLZkNjL1A3d2ovN0YveElMU0ZHRFpJT2V6SU81NjNyUTVkQTNva2lycU1DcDJuLzhoQXY4ZUR4ZWE3UjVRYlM4aFdsWmtpeHF1aDc0UVQ2cE5acGQwN1FLaFJ3WDVhenhkTmp2MFQwVjAzUW0wMkdqVVh2MHBIMzMvbGYrMlQ5LzcydXZEbHB0Yno2RGhZYTlqRHBUd04yTjBzdm4wR29vT1JkZDc4Ky85dHNQZDVQeEt4L2ZrZm1vRnB0SDNka1ZlYkZuY0hPT0d3U0x0aCtNeUVlSjBSdmFxZGtMMkErTzZGUE1EdWFPQ3gwWWtjVUZkamltTFR2ZXBhUlcwU0ZtM015MHYvVXYvdVUzLzhrL0txZVNXeHNiaGlMcHVxWnJ5c3oxbmh5Y05acXRtMXNyZ3BGNi9idnZ3c0dEMC9EWm4veExQL3FMZjRjWEJOYWwxTEUwb213UTJPWXlzRTE4RVR0azJ5eVZaYVErdi9qUUtDeDNVREg1OVowUDN2aUdERVlCSzByTHVRYUNJTUFsQlIwblZ4SDBpK0VNaEEydG16aXVKRW9MZGhHZEhGWlpRbzZCYVZVS0JXOHhuM3Z1WnJuNDJZOWZqUlV1YjMzcWg0MWNMdXFZdnVQV2grWjcrOVZhcS9QYzd2cHpsN2FneHdZbVNCOVZCbVZUVTFoQVIrRmNObnpoZ0M0S0tZcW1aTXN2L09CUGF2bGNGTDR5SDJla2pTcFBiY1EzL2dtb0JEdXdidHBraWVFK0RDVHJwR1U2aGJCL3dnL1R1OXdYZnU2WGtNVGl0Qi8vWVlWUVpBam1aV2I4TDRzSmY1Q0YvVndjUmJ0WmJ6Nk5QeFVaZ2daTFl0QW5hdFk1ZVBMTjMvaFg0OWE1UjY4eDRuSTVXRVBUOTN5VXAycmc0Q3BJWStCNXpkTmpMYUdYU2psUjBlRUpaZk5aVVlnbFU4bG12UUZWVWNqak9DTjhHVFJBYkJncVJyQmNMdWJ6ZVp4TlZlVk1LdjJKVDczeStjOS9mekdUVUJZenUxWjc5VjkvdWZyVzIzLzRMLy9WSC81Ly8rVzliMzZyZTNMcTlqdjJlRFNiVE9PQmQvZU5KOVgzSHZ5cEg3dStray9BRUdTaTh4Mk4xNFhvSkJJZExJS3VDeDhnUW5XTXhObjZjM1JMa0l2Tlo0Qi9zSkRvS2g0Z01xZDM1bmwrT1I2N25JQlppWm0yZC9mVnIzLzUvL3JmV3NlUGg4TkpKcGV0VnF2SlZGcVFaZE9lRGNmbWxjdmIwSm9QSGgyODhlYmIwSVdmK3V6blZGMWIyYnZpejkxTXZoamphZlhxY0JoQ2lybnNkOWJKYklEWWgyMVRFZ0gvYVNwOXdwMFVXQWI4eXJJeWo4WDJYL3VhSUNyQlBBS3Z3ZlZtaWlqWm5rdnprZms0RXdReUp0RHdDcTNNRVpDYTRtSzI2eEU5WkpNQzBvWUJOZ0w5a2xTa25CUms4eXRXYXJXd2QzWG5oVmVTeGZMY3RlY3pyenUxNzUwMGErM08xZlhpODFjdndhL3RqTWFvTStFQURYbXF2ZWxxaisvTlhGWFJrcmw4N2V6KythTzcvVWJkTU5JaUxSVCtQWUY2Z2NDNFBEeUVGWDZRRkdJNGJHL1lNOHNUc0RoWUtXejdVcnV6MVBCSTVDV1lMamVvbkxBUGw1OVF0N09pd3hOUTFxY1oySEhzaTNMUldkbE95c0w1L3ZtZHQ4L3V2MzErNTczWC92MXZSTndwZUlBa0NZb3FkYnA5VVpTZ0JpVkZDbC9yQlM4bnFZcUtJaS9pM0tYTFZ3VkpnTWxQSkxTVXRJalBIVkUyemhzZFFSUjZnL0hVdEdSVmNSd0gzdFZrT2kwV1NpQTU1Vkl4bWFLSDNUekhESHdIR3RoekhWa1dWVTMvMkVzdmQwNVBwTWg4LzkzMzkxLzcxdGtiYjV4ODR4dC85TC84dzIvL2kvK1BjL2NOOS95RFAvYzNma0dNaVJXSmwrT2NINDFZa1VWN05oKzYxTzZ4RzNVanZFc1hXckJKdDhDaDJkMVpCRFpIRnpsM2FHK0lFVzFxYmVoS1VvWmt4OFpudGYveGIvM3lCNy8zSHhRNEVMUVNLbmg1VkJRQXF1aG9PSzZzVnZLRjdNU2NGb3FGK3c4ZlR5Ym05dGI2bGQzS2FySDQxamRlL2FNdi8rdUhiNzFtR0lsc2VaV3VsTEkrWmFORVlZbHFqQlQ5c0lFSWQxNXNocm5Eckd6c2wyS0FBVVNrc0xMNTlqZCtqNk5GTjZCRzZab2h2SDlvRFdESW5kR3FHL0Iyb0ZDZzllRlFnYWNaOEtBQVN1RGJjUVNlQi9SbjNvd1Q0dFowdXZDYzdWTHh5cVgxanNmUEpKVVh4Y0xXcGIyWFBwWGQySnJiNXN3MmgxTjN2OW84YVRUWGNwa1hMdS9CbnhtWkpta0xndEtIQ2hudXdXQXk2cmVhQ294S2xPdlh6dndna3E5c2NQUUdFV1JreldOY0pZeWlGYXpWTWZ6UThXZ1pTUUhMRURhZU1ySEFMb2F5UEJIdVMrU3Fza0FIWHh3WlJpaE95YUVjVXZKRmNVOER5L3ZoTnV0KzJrWjZxTlRoRVhMejZQRmJieno1MnUrTWp1NzJUcDZNR21mdytGQU16OGRzMndrQ3VFRys0OWl5b2hDVHBKZldSbExaVE1KUWVwMmVxS2tBN21RNlNxZVN3SEVRNFdWSjdBK0dXaUxUN2ZYaDFVRU4rVE1QVEZkUndPODVrS0o0WEpSbGFUd2FRWEF5bVJ3WGo3V2JUZENrMFdpS1hXZG54N0ZvVEpTVjZ6ZHU3Tzd1ZWE2dmdCb3BjaUZEVHVOZitDcy9kMlZqUTg5b2NLVkdRYVRuTDdvZ21FUm5GOWJJbWp5dThaT3BZdzdtMHhFL0hNQ3RwcGRPc3RuQzQvYndCY2U4Sk5NclVqbFZuRXp0MS8rM2YvOFBmK2tYT1hkYUxoV3F0VWFoV0lUeFRpUU1ESmxqTzFDai9YWUxkQ0NiU1Rud0FCYVJTaTZOVTgwaG5kYmt4UmVlZi91OTk0ZWQ5cDF2ZnUzdXQ3K21hV3B4YzRjTjUwVlhMMysvNTJlNWx3M0hjZ2ZDVWtIUk9DMFRhSGxUQVZMMHpoLy9SMG1VY1dyWVJnd1ZYWDVCMThSaUdBNTZRVEt0R2tJWFNYQUFSa3NUaFBWY2F1ak9vTm9WUWJCQTNCY0xLUjdIa0swWGM5V3ovYnlxZUhxWkpnNmdpTGlZWGR1OC9QSFBGRFl2dWZiWW1VNGN4enR1OVU0Qituem1wV2R1QUIzOThSakFRb1F3ekFLcUJrc3lISTJUUmlwWktQdUJjL0w0enVyNkhyd3Z3aFBzelpJK1VFNldRaTFDUGRrdmF6ZUxmRFFnSWJ5SVJYdng4OTkvZTUrbDBiSDQreWlVV1dBaXcvN3BoNFNTaWRjeUl6c1h4VVBCWTJla2tsbHhQcjJIYU5wcHZQKzFyNDVQNzgxY0o1ZkxUTWQyczlWSVo5TUp3emc1UGdHcnk2VFQ3SEpFVkZIVmRDbzFHQXd4R0k1akFYNktMSHN1M2VVb2xjcjFXczIwclhRMkM0MEMxRTRtMDE1L2FOck83dlltVk9kNGFubXV2YnBXV2N4cCtXYlRCQUhoaDZOaExwdE9aUkxUc2Ftb0N1eEdORHF6N1ZrcWxYMzg1SEJ0dFRTWmpQaFl2TkZxZ2toWEt1cy85Sk4vNGRvejE3cXdxMWw5R0VSSDRCT1RjZWU4OWY0M3Z0WDQ0RTd6d2QxUmIrQ2FFK2cyYWlESDY4bFVZV05qNC9KZThlYnRsS3ovdGMrOU5JM0d6NmJqcjM3bEs5LzhkLy9PNmZjcWxjSjBNczNtMG9zSVY2KzFVdW4wYk1iZVFTbUxZR3Q4bkhmWnlpKzd1NXZqaWRudmRCOCszaS9sVWl1VmNvUVgvdVB2L0FIZEMwSjc0QjZJMHFVWFh2Nnp2L2hmS0xrQ0JvKzZtZzA3ckRNYnhYQnJHWkN3bEFzMlRzc2tCQm83bHB0OUI1NzdMLzd1M3g3c1AvUUNpSitOVGFoMk9LbEFOdXdzUEhSOFN6d3Rrd05XUXlZM0ZvSC9lbm10L01GcHJUMDJlUjUreFFLMkdNNnJJZkV2N0s3bXlzWENGMy9CTGEzUm5ScWNrckVOMkRqdys1T0hkOTcreW04ZHZ2ZW1OUjc3Z1M5eTBVdHJxNVh5eXFQVHM1TnFqYTZ5MFNFVTJFSGtQVWlDSUNzeVNsbTlkUE5ILzhhdjZxdHJjNmdDMkJ5V04yUXlGSmk0SUJDVlo1QmM3Z29SeVpxK1JIQ1kvTjkvKzRCK3c3REVLZTMrRTRIMThUSkNPY2hDa3F5Rk4zUFpoNldRVW9lNm1OZnVmM0QvbTc4UHg1R255VWRXUHFWSDQyaUFYanMvblpqbXRhdFhEdllQWFJyT0tJeTRyaXRRRS9sc3ZqZnNKeE5KSUg1dGJXWC80QWh3ejJiU3RYcjkwdVZkeDNMQVd4UlplZnZkZDE5NTVjV3owMDYzMDE1ZFc1M1BaNVB4YUhWdEF3S2dhV0ExbnVPNnc4RndNckhnUkdaU0NYQlRWVmE5bVo5TWFLSXE2cG8ySEpoc2NYVCs0WVBINUlMTmc2dlhiLzdpci94cWNiVThjTHhtek8xSHhRZHYzZm4yYjM3NTNyZStObWcyQTllaWkzSjhmTFZTZ2NKRDBTODhmL3U5OXo4WURDRVJQbndNZE1HZi83RWZ1WFRyMXNQVDAyLzgvaDlXc3FsNVpLRkJKMnYweHZkQmZ5akJnb2hLdno4c0ZmUGRiaGRpNlhxd1FqeGNGM05zU2R3OERoRlFOZE94VTdJQVUyQ2swNy83aDEvem1ETUQ2YUxMMUpISTNnc3YvdFZmKzU4RHlCck4vd25IbHRKRHBVT0JLVCtrMDZRbytxRUJEOEY5Z1k5d2kzNUFBcG9uUi8va2IvOWxsUmVnTlZ6YkF0YXhLNEMxblFlb0xqY1BRT2poVFhMczBWWmdIYndkbXVYN2J1emNhd3dlVjVzQ0Z3OFd0T1lNNVBiRjdUVVl1V2QvOENlRW5WdSttdkpsOVFKMUJKZ1kySVEvYjU4ZHZmbjcvKzdoYTE4Yjl6citiQmJuWXV1bEl2amNjYTErMXU2UWJmbXdublFkaW90R0JaNUxwdFBadGUwdi9lVy9VYmh5M1VjREYzUlRqNXJHV28rR0lDWEVMTjFZK2tpZ0RsaEdXV0NIZ016OE1nNEtVNmd6NkhnV1lWVU5QOVNMeU0vNmtHV2hUU0w0OU1zT0l2eEhyRTdyOFJ1dmpzNFBIbjNyMVpQdmZrMmNXelBISEkwR2x5L3RDSUhYSDQ1aUhHZE9Kb20wQWEzUTdmUWR4MDJtZE1kMlVkT3R6VlhUbklMSkFLL1FaNXRiR3cvdlB3SWRuMDRuMld3Vzh0NXN0ZU9DNkRPS0tmQUNPRXc2bWVwMDJrWkNMK1lMTmhRVStKQnR4NkdQNGp6R2JEUWNnU2VVUy9sbXZUa2VReFpNV1JIYnJTNHFEQUVyRm90OGhIdnR0ZGVoSUtGdS85b3Yvdkx1cFkzbWFISml1dDk4OVp2LzhKZi85dS8vby8vcCtNN2IxbWkwbUpObFR5WU5WVll5NmVSa09sbGJXMDluMHI0THEwNDNZT2hPRXNiQTkzN25kMzczK09IRG05Y3VvOExSS0M5SmltbTUyOXRySjhmbmdSOFVTemt3dTM1L2tNdm5ScU14RE4zNWVSM3lER2tiRDZlSFI4Y3dLcVZjQmpvTXBZSy91UzY5UkFrK1NRaFpmUFhxTlZFU05tL2NCb0pZNStORG5KNkY4S0pYT0RiTG4rVXZKZEFmMjB0eGZFSWNHTW1NTS9QTzc3NERUa2hpejZRS2RBYjBCaFlTSEowOWl6Y0hMdWxaRGRnWkVwTFlhWGUwVjhoa2s0bEdmeFNuVnlUNE5raFlGSjQ2NXd5N3dhU2xseTlGWklVUmF6b1J3eWFkSDZ6MDB2TWZmK1pUWDlReTJXRzM2VnBtYnpTdU5WdUdwbTJ2cmtQclc3YTlyQnp4THdJZEtrWHJuam5UNnNQN3BjcG1JbDlBSWlNVHJFUjgwWWN5MHpWbW9tMS9NcEQ4SUI5OTBRWmMxVitpeHRQUjdFeXNjOUZvR0E0aVZwVEV5bVJsaDRFMWhNR2RIUU1waENObU5sdi82Ty84OVh1dnY5cXZIcVprV3VqQjg3eCt0NnZwS2x3NmJ6N1hER01NdXNiRmZNL2hITGZXYkFNUlVJN281S2s1QVduWE5RVmFaZ1NFeGZoR3JRNVBGR2N4UWRodEcvYWZnaWdDdDRvazlkcHRzQ0RZMFhhbmd3cUFsNStkbmVWeStjRmduTTNsWnV6cUNYU3JvZ2dZcHJnb1lwUk15NEZHQWNxQkdFakZ3Y0doYVE1enVZS3FhcHFoL3NSUC9wbFdxL0YzLzg5LzcrdGYrWjMvOFAvK3g0TkduZWxRNmc0TXNLSW8yVnkrVkN5WFYwcFFoT21VY2ZucVpkZnh5cXZyVU5XNnFxVFRtWEs1SE16OGZENUx6MEV3bVd0MWV0ZXY3RDU1ZkZCZXFVQy9HWm84R0F5Z3d5bG9NZ1J5TXA0bTB5bXdIVUdXNEpsQUhxQUNKRldSWktWWmIxbU8vZHp0VzVETXpjMXR5SHdtazAybjAvZmZmdU9sejM0Qi9UMTNwaGdlanVnWndad05DWXZBR3RCV0dLY29EUlVDYlQzOW9ROENtcmV5ZWVuQmUyOHVwbE9QS1hYU2xGRDdCRzVhaFdaQlNwMTNhRVZVVm1pTWZCaU1ZSE04U2N2U2RxWFVIQTNJQU0zcGdtdyttKzcwdXFQdWNQdjdmc1N0UDRrYldUWTdrS3dRVGdSSkF1N3hIVmZrOVNzM2IzLzJoL0k3ZTY1clQ0YmdwT05XdDYxSzBrcXBCRk5NNjV5eDZ1RkEvUHJ6T2MyVk55Y3oyMHBrc2thMmdFUVV5TnFISEtIV3BSaEQ2a2QrUHhMSVAyQjFnSGIvMnhkdU8ybUlzR0hJRVpaQm4vRENEMUlwMDdJZStBTEtaNlBoOFB6WTZUWHZ2UHBIRDc3KysrNjRnOEh5SExvZ0N4UTZOcXo4QWdONUFFcGF5a0t6Z3FoSWtweEo1WThPam1LQU05UTB4Nk0vZEYySFVwY1ZsVjc2WnRxRlFuWThuQ1NTaGlnQzRYUzVBSklqaXVLVVdMc0E4Mm9ZMm1BMFNTUlNydU5vbWc3b0hCeWRJQVAyb3BCS09RZkxXMnUwNlg3TkhEUllTRUpiNm9acG1oQU10QlY4bE9iOXdXTVR4TU9qbzFjKzliRm5ybC81ci8vclgvdmd2WGZkUVFjMkFzYWJneEhuZUJsQmtWZFgxdEtwWExhUTdmZUdoWHdhWWluSWZMM1JhTFo3UVJESlo5SXI1WklvY1VKa2tVcW5KaERFOGRpZHdkOG93ZDVzYjIvRnVXaENsNCtPenl6YmhaMnhiUXMxUlFNVm1DcDY2VkowZGFVTWZjL0hvckttczVmUU96aTM1NEZPdTRWaVBwWFFVNm5NeldkdXhnV3VYQ2kwbmp4NDU0OStaN2gvNy95RHQwMTZWS0pWZlhoM2JrM2pDejh5YzdtNEdLTjFrREJTSVNSQ1RjaFVGdzNpUndPU29vSW9sdmF1UDNqcnRZVm5BOTRBTHRMUmIwQW1zYnhGeEFNVkZDV20rYWtvR0Y2ZkZpbUlEVTFUakVaMjF5djlzU2tMZkVxQmN5UU5KaE5ZQTJ2VW1qYmFSaXJCNnhtQ0hza1FkR3c0RjRZcWhZU1lFQyt1YjkvNjFCY3V2ZnhwbU5kQnV6NFpqVUJsUVo4S3VUeDZEd0ZBRHFzTXNmR2g1RTF6M090bDhtVWpRNElVTmliVTJzc1k0WkkxbXNuRDB4QW1oeWZudnZCemZ3dGIxQ0hMeWxCdEtCZWtuS1Vnc0VMb0VId2pRQ2o0SUhyd25XOS85OTkvdWYzdzd0bTl0KzErUStZRFVaQVNMQ0FIK1RCeFRwWkJlWGxWNE1HVlBkOFhsYmdpS3IwZXBMbWhKOUtUNlJpZ0EyMkZOb1R1VGtBYWtnblFEbDRBSU9PSUEzUVlEOGcyZURBUUQwVVArTUVOamZGc2FoYlZrZFo5SnZJUTR3d2cydERCTU5meTRsb2hmWFRlQVlabWZnQ0pPait2UWtPMzJqM2QwRDF3ZTR0ZTI5NGJqSHI5Z1dVN3Q1KzdHdGpPbC8vdGIyZlNpU3U3MjZvaTUzSlpJQmpjT3BQTHJhMXRSZm00b29od0hselBCZm5HMk1OZGxpVnhiWDFqT3JFKytlbFBmL0RCSFRqWis0Y251ZUlLRitWaDlWRTF1bWNaNDFVVnFJaWlDYndnVm12MUJJQXZTNUJwVVphSFUydk9jNHFxbTdidHplYlpYQmJlOVAzN0QwQ2J5OFY4RkY3dmVYM1FHK3pzYkZVMnRzNU9Eak5KQStQQnh5S1Q0UUJXc1ZPdithUHUyWjIzZzI2dGVmaW8rZURPMFp2ZjdENjVKeXBxRE9EdHR1Umtsc1l0SEVFYTR2QVhYNkg2b3RIRlI0Y09NbEtIYjM2VEFFbHFuU2dOM1FFaW5BTHdVY3QxMFljOEtkcUFwdmpIZWZqUU9KeTlLODI1dEFiRWo0alNlQzVzR2pJZTM3OW5KSXh4NjR6WDAySXl4VnhyRk1uY2F6bzl3U3RnWjhmNGFhbk01ZWMvZHV2N3ZxVGxpb05PY3p6b2pTZGplcGw5SWpHYmVVVG9XWlZ4akFNOU1KM1VqeC9xdXBGZFdXZTFaQzNCZm9aWWlDT2RpYUlmQ2V6bzVUL0IvZWNKN3F3eWRDUU9aQVhRb1lpUUthSmk2UWYvakwwdHVFWDBqLy81UDl0LzQ2dUFjU0tSbkF4SDBMOHI1WUxqMHB1MkFITllhNTZMZ1pwREU0RDlLWnE4czdXZVZ1S2xuSkZNWktIZkRnOFB3V0xjbWJleHNRWTU1cmlvNDg1VXNHTkZSY2ZOZzBBUTQ2N3JpN0k0ODMzUUNYQjZVQmt5bWdKMEtGRzZ5WGpDQzd5c1NLaGtvOW1FcENpcURFM3Z1QTRVZjdzQnQzQkNGNjZpOU5nbEZCYk1oS0hydzM1M3BWaW9WMnYrZkRFRjk1N1BSVUY4ZkhEY0FIa3dMUWdZTEhoL01BQ1VxWHRpY2JvV3dNV2o5SEpza0NLaDNxaVhWZ3FwdEQ2ZGpQV0VibG5tNWF1WHhzUEIvcE1ES0hLZ1kyOTNENXhBRXVOd1RtQ1hVYVhwMUo3Q0ZOc3VqRms2bGJhbTFwV2RqZmZlZm44ZWphVXptY2xvREVzRmNBVStzV1JEVjg1T3FnbERoOW1Ec0ZYckxjTXdpc1gwMmNuSnFOMU9wUkpnTHpEMjhCY3N5MEdCMW1TY3llWWd2TzFteTVwTVlOK0t1ZlRqTjc3MStMV3ZQWHp0MWMyYno0bGFpdHBCNDRpZW9GODI3bXg4NlVPQmkwYUthMXNIVCs0N25SWnFBYlZPWTgwdTlaUHpTc0NJZ2VMamRCTFBXL1FPSEF4SGpCWXppRVpSbC9GMHNsMnAxSVpEbjk0T1NBZ0JHZXYxZTQvdTM3LzlxUitFL1VScHNCY29oZWw0Qml2OEwxRktiQnZwdktLc1gzM205dmYvY0hIdjJuVFlHN1NhY09TZ0FXRmJmWnBEaFFyUjFWN29kd0VESVdqWlloa0N3UnFGWFZSMDJCcjhFT2VpVXpEa0VvTFpHWmVTUVhObWZqbk1IMmFuSE5RakYrR2luTEMzMERWOEpQYnQzL2hmTy92dmcvTnVicTBmUEg0eUQyZ1JaOXV5d0U3QVB1Qys0WlNTTE5ITFJZbVpFK0dETVVwSVVWSFY0V2NPdXgxblJsZTdSVjdBRUk2SFk1Z0FkSFNNRjRmRG9hYkpOR1dkUFRzem53Y2d4OWxzanRuU0NQS2c4T0ZvakpvRDkrZ0w4Q1dFMFhoS1ppVE9hNGFHVGkrV1ZxRXRjV292bUNVVEJ2UTZITm5LYXRteUxURDdMcmppeUd4MXV6RkJTR2hhTnBPQk9QWDdmYkFtOGhhaVlFb0pLQytvV3hBRGNHNllJQ2lTbFZJZVhHTFlIMk9RY1M0MEVQMHdDMmIxODhhRFIvdUZYQTRLcVZETUFPaXZ2L1lheUZVK244Znc0TlNLcEtTek9TQUJ2cklvU2FQUkJMeGMxOVVoNkhnNkRhbUc0Y3BrVXBBcW1JV0RCNDlnREdmelJiM1JxcXl2ekdZQjNVOFFvVTFua2lETmVYcWxCeWdHeW13Mk8rdlpWREdmclZmcjBBanBUQlpPQmV4U1BCWnB0OXEwVEpMamp0dXRWRkw3enIvN2paWHlTbHpWdytjbkdFTFlhRE9OeUlhV0hOL1ZTemZmL2ZydlJrQ2hpTk1BRUpRVGdkUTdzL3hvRGxoZzJqQXMyMlJha05nc1V0M0FuMWptVG5GbE9EVnBmZUVBcmkwM21waUJIMVVrcnJGL041Y3FjS3Eyb0JmOTBSbnBiSVFxWUo4S0NWR0piWFJ5TE03blZ6ZWUvY3dQYkR6enZPZmF2VWJWczIxQUhrWWVTR0NzZ3B0YUUzZlU5aTJyVU5rVU5BMEhRMXFvREZZNkF6ZFZuaVZjdEpGaG1OcE5VOFIrN3BjcEhXZ09wWUR5aEpuQ1FpaUZha1ZuSTdnLyt2cTN2L2IvKzZlN2wvWmNKK2kybXNOQk94cWpOWGVnV2dCR3VydUpubDBzeUsrVVJEUWZSQVdKb05UdG9abEtKS2ZEUVZLS3BmT3JkKzdkWDFrcHpqMWYxRlNvZVFnTThPbzRWcjVRUERnNGtrUWhtd0hibVdLa29YZFJHbWc2TmxkV2dGcW4xK25RbFVSRjczWjdqbW5OQXAvdVU0N0dRQ3hrdzBqcXJqTkxKQXpYY1ZFSGRCYk5peGVwTW1BN2dCY0FQUnBOWWJpdlhkNmxOVWRuWGlhZDRtSkUyT0ZNeDBVSm1oWjJkRHd4b2VhbkkwaWdCb2hicGxtcGxBRlEyQlpEMDF3UHBTWGhvOSs1Y3hjc2FuVzFqQTVTRlJVT0tOaS9rY29ta2hrb2JGV0hWS01IZkhzNjFRM1Z0bHd1dHJoNmRYTXdtS0R6SWJRenowNm1FbWp5NmtvTy9DcGJLcmVxMWRYVkNrMVljR2Z3SGxPNkROL2RBWW4yNTJnRmpOKzRQencrT29iSzlLT1J6ZTBOVFpVTGhaeTBDR2FMeUdqUWg2WGdoWGdzeGxuRFh2WGVPNXhyOWc4Zm1wMVdjWDE5QVptQzFncUhGQUVhaGRDQjN3WDZoVGVTQjI5OUc1d2RvQ0VXQVZDUTgwTjBubERCbGdoV2pBUzBqR3RiWG1RQmdRK1lPb2YyN282R3E3bWM2M3NUbVBUNWdxNnd6YnpxL3NQKytZa3dkN1BydXhGWkpXQ3hNK012eE5xeUhpeitGTE00YWFwUXV2N3h6MTU2NFJPelJkQ3RuOEdKSVorTlpBL2FocHVBUVE3YUVkZk5sTmZpdW9IalFzbEJVUXp4RkVlTTBxbHN4TU1VK3VhKzhMTy9SQ2U5a0Flay9ZbkErb1h5a3VHeHZILzE5LzhyTGhZa0V4a2YxTTBlWWJ4bFRmRXNEOVNpMVdxbDBwblJhSkRMNXRCTnFxb0FsSUNDcXFxK0M2VUFzKzYxdTJON2p1SGprNm1zWTd1eXJwQ3ZzQ0JHR0hMM1REclRiclZjeTdweDR6cmdDK2NTQkQxc0VBd3NkQTk2QktxN1VDZzBteTJvWkhDUGhBNyttVVRWRmNBVEZMbGFTNlpCSEZKUVoxQzYvVzQvblUyRFRlcXFDbE1Bc3VRSE0zQjlOQXJlQlVnWFRVV2pOMjFFTkhiVkJNM0taUFB0VGgvOXF5dVNwcWxvQzF4R01DMWE3WFpxZ2xiaUc5S1JUS1hZYlBWRXB3T21rVHc3UFlkUCtlYWJiKzNzN2p5OC95Q2JTVlZXOHRYemhxeG9Cd2VQWWMxUVE3aXFWNjVkaHBBWFMzbW9ybmE3VXl4bUljbTI3ZmI3STdqRm1WeUtUTGlxUXE5WFZncW9OaFM1bmtpQkxrTmNDOW5NWURoRXF6dmRQaERRNnJSMFdmS0N5TGpWNGVheEtRaUFvaFd6V2NmM0QvWVByMXphSFE1R3hYSjVNaDc1MCtHOXIvL3grZDEzWjZOZXZwaVB3QUtqd2JRQUUwTWJ3MEpsWS9mczdHamFxTUl3SWhXS0JnMUhKOUR3aEhJUmdVVVVWRTFUUkNHQUhnOENVWllrOGlRcFIzczR5U1dTOUxDZng1N1Fqa1JnM1YzSFU2RWd2Rmx1N3daU0NIc2h4T2ljeTVPSGdVN0J6b0ZBK2hhMFBwMjk4dUlyVjEvK1RDd2VIelNxSE93RmV4c2g4cHFtQ1JXU0xtK2xLNnZoczBkTWJGRWNGVW5iVkRKYVJkOWhvZUY1dUMvK2xWK21UR0ZDbVBaaG9JdzRDbTBsQXMzRi92Q2YvZE54NDhEeW5Id3UzMnZYNksxQklpajFITG9CNXdQV2dTSkF6bkZ0ZE5OZzBFZkZNWGJRQzZabFI2SjhmekNhUjNqVGh0UHAybzRYUkRtaTV1eVJMWEJ1bkc1R1YrS1RBQk0wTFZveEdBelJaWmxzaG8vRlIrTWhUUGwwWWdJS2RIRWdGbTAyNnFnZUNEK1VHUlIvTnBzT0ozQWZINTF3SEMrS2NWQVVjTWVaNThMUmhHTUFYZ1FKcEpmYjBTdnllRWhHUWtmZGZEakhvRTd3Z3pWZEJZZ2gybUQxZE9OOERrOFNIdWRVVlJUUUtQYThHMVFxSjB2eW8wY1BhVDVQSkNiUzNTR3hzbHJwOXdZZ1RpaE4xZlROelJXSUg4ZEhZYlZRRThpL3Fxa1l6VUYvNURwMnZ6c0FLR0g1VTJranlndUh4K2ZEOFRTVkxhREM3dFRxZGZ1S29RRFo2SGg2RWJFM2d3M3dYQmQxU01KN3MyM1lidkNXK2N6UEpCT3dQNldWY293RG5yeWhiVGU3ZzkzZFRYdm1nREVpZnpxWEJjMlRRS0VrcWRPQkpqSWNkR0x0K0szZi9lM0JrM3VuNzM5MysrYXpMcGp4ZU1RcEdvMXlOTFo3NDRXM3Z2Mkh2bWxCbWNQZXpoaTNnYjRsSEJFU0luQ3JJSTJsZktiVzZhcFFScDRGalFibWljNkJIaHBadGlJcklMRG9RTXJQTHUycjZSU3NWUG42cyt6UkRZWW8vSk44VVJTL3dEMEQ1SWNCaVVpaHhIbEVOUkk3ejcxODdSUGZMK3ZHdE44RlJKQWZ4R293SHVyeDJOcWw2ekVGMkVOZ2trT0lKLzFNYmdvRE9wMkdxaysvK09lK1NLNHFTUnFGc0E3ZkUzQVVta3VYWStWWS9ELytvLzhoR3ZOMEpjRkhaclJjUnhSd0Y2QUdnQVVBRkpUVXB4bU9QT2dqY0t5cE9yeFZRQmFuQmhDUkNmd0dCTmx4UENPaFpITlpJQzlYS0dKRXdhMUJHSkFCakxQZGJldTZQcDJhZCsvZU5SSkplSit1QjJHbWE0anJtK3RRb3JBaEFzMnJvWUIyd0pXUlpTbkxlTER2KzhBeENod054eGd0S0NjY0NKWkYweGxvL0NBWDNPbEo5ZnlzYnNpQ2dyb0lITmgvU2xkMFdZQVREZGRWMFhVSUczckRjeDBqa1lENTN0dlpndHRFbDAzZ0ZzK2pZQlR3VnFIRDBEV3crTDF1RjNXQUJENTY4UGphMWF1Y0FBT0M3b0NyQWlENTA5RTB4dkgxZXJWWUtraVNBZ0VENTV0TXpGUTZtYzZrb2M3QmRHT1J4YnZ2dmc5Q1VpNW13VWNFTGpycTlFaUpxcHBuMloxR0IrZnROZHV1NndLT3FxRU11b04ydXd1UXpmMkE3bElGL25nd3lHU1NyZTVBVmlVQlRmVWdIUjZrTkYvSU5ScHRkSGlqMGN5eDJ4RUVoc1ZDNU9QRFFTK2xpRWZ2ZlhmLzlWZlAzdnFXcmltSmxVMzRCWFJKcExEMjREdGZoYk5GNHg0RGptYzAvZ1FNd2dqNkhQMnBDVnc2b1VGenYzSnRjNy9XbmtXaWNWcnEza2MrOW40UmpFOGM1QXR3Z3QzeVJrTkp6NVoyZHNWRWtxWWZzVklJNXVTK0lsRFpPQmRLWmhzaEZrTlZqV3dNOTRzSWpPejY5V2R2ZnVwTCtZMXQyNTc2OWdTU2QzYjRLQzNKNWV2UGgrSVJsc3dPcHZCMGhqRDloSVVEN2w5ZzNKMFFUN3ZwZExUNVlhQUUyRHdZaU5OM1Buank1cXV5YkdCSStIZ1VXaEo2VHBKSmthQTg1TFBNS1FDRmV2dnNwZ1VNM1dnMDh1Q1dCb0Z0d1ozbHA2WkpLODN5c0lseVpXMFZuWnNyNU05T1RtR2tVQUl5b0tOOCtDVFJDTFFtL0hKUWRxUVJDekx0ZERvZEYrbnFKSWc3REdtNzFURXRNNTFPd2kwampUS2ZRZXNRQ0dCcWREMWdyeUFsZmk5SlorZm5yaHU0cm0vYmpqVzFWTHJJUlM0T1BBb1E0bHcrVWN3bTlZUXhzWnp4eEJaa2FUUWNnVDZCdWt6SHcyUkNRemtjdXk1RVUxOFdvR0V4QURxZlQ4Y2lzVnExTnAxT3dEemVlZk1kWFRjNmJXQ0xyNUx2U0xkRk5WVjUrUGhnMmg4MkcrQXphamFUQU96b0Z0aGlrVWltdURpdkcvQTkyZ2VQbnZDeUFnKzFXTWlaTUZMdFBnd20xSE92UDJpYzF2ajVIT2dGZEhndjBCT2E1L3VOZWdOR0V0b1g1Y05aMUhUbCtLeHFXV1krblR3N09nTndIWCttYUdxeFhEay9xMkdVZVVFY0RZY2dZTkRCUUNUNGI3NllVd3h0MU8rRHFzbVJ5TTVtNGQ0M3Zwb3A1QWZ0aGovdXJsWldRU3VyOSs0d3cwdmNIUUUyTTBRRFVpRExFVDYra1UyZjl3ZDVUZG5PRzRQUlpBTE95WEVpdlZON01iRnByQVZSZ3VCRFlrakRjckhIYjMvcnhzdmZEODdLVUFnWTArVVRCbElHT0h6akYvOGhWT2tZU2dZbWtVZ2ZRajY0VkR5L3RuWGprNS9idnZXeXBHcHoxNmtmUDltOStYdzhTUmVnUW9INU1JUlZwck9FcGRJcHVDLzgvQzhUME5tKzVjaytER0VkNklIT2VEVDIycGUvYkpzZFNZZ2J1b1FSeGFpSUVoa3lYYWYza2tkZ1V5RUV0QVpWSUNrcVhZN1VGT2lZWWltWHlhWFJUVkRZNEJLeFdBUjlBUTNuV1BialI0K2d0RURRQVVxZ2lvL0hrWjhlSm9oRWdGUXlHZlE2YUsvVElRUXNnc2hvMkRzNU9zSlpwNWF6dnJhR2xxQllaRWFmZ3ZEWXRnMEF3U21FZWdaQzRGekNFR3U2UWZlOGlCZkNEa2ZBb0hMRkhGenEwV2hZWGxzWlQ2ZVpkSkpOU2xrOE9hcmxDL1FlNnVGZ0FHNld6bWJBVy9EWDdYUkFka2VEd1h4T0doM2tQcGZQd20zdDk0Y0lHTlR0elozRzZhbVMwTGQzZG0zSEJYTTdQajFIenBkZWZPSCsrM2R2UFhkcmJXMWxhdEhzaG5hN2ZlUDZGV0Q5NVBSTTA5bjdZVUJhSUV3OFZQVWN4WFpyalFERUQrNStKZzJYSUpPZ1ozQ3orV3dFUXNiOGpMZ2lSLzFGSXBXQ21talZtMUV1S3NZNHNBaEYxUUxIaXdxaWtUU2lYSndld1FWU0Z4RklMOXEyc2xKQ1IwR1hZQ2pydFRwc0VhaWtRNWZKZVpRNUdvOU4wMmtkUG43NDJ0Zk4xdm5STzkveDJzMjkzUzBNQWVnZktTK21nUWdLRE81QVA5QW94dU95Skh4d2RINXJvM1JsQmIyVk9HMzI3SmtQcHlqT3hXd29KTHBjQWNURGNRVlR0WnpwTkpISzVMYjJZRERwSHVSVHBGR3BGLzlQQTlQV29aYkdGL3ZRQnZJdzRZbXFxZXptTXk5Y2YrWHoyOWR2UzNveXFxamZlL3hGY2N0RUl2UFl3TEhjbDM2V3VIdTRkUkhDR05wSDBnV2JBeU1sUktKLzhNLy9jY0tRNW9FRFgrWHM3RXlVNlRJaWREQ2pidURWQVhRejFCUG9CMXd1d0gwMjg1S0djWEN3Zit1NTI4MTZFN0FHYTRhQUFVYXVBNGZRQWFPbHE0ZTZPaHlPZ0licFpJTEJSZ2JvRlJRSGlvSysxbFJvNGdWS2h2MTk4dVNKWWVpaXFHQ3dvTCtUaG00a2s4QXg2TDVsMmNsazByYmd3blB3ZEluZTVHZ3lGb1RJU09qUXFiSWlybTJ1NTNJWm5vOFZpeWxvNjlIVVFYV2E3WDZNRjJSZEx4UUx2Y0VBY3JXNnVtcEJ6WTRuSklFMGF6MEdrL0xvNFJQVHRLSGc2NDJhcGdGUzNLTUhUM1ozZHpMcE5FUVZUQXdjdnQybTFYY1hrWUNQODcwZU9kRGR3U0JZQkZDbHFFTmdlNVBoVUJLaFR4Y1BIejRHNW9oMFFXYjZQWHdaaGdiZnVkbG83ejV6TTVHbHF4L3dUQmNPd1VhTXg2cTFCbHlGODFvZFhWTXNsM3Fqb2E3cDVVcGxOQjJMaW1pQkhXVnplZ0lwWldjMlE0VWxXWFJkRytNSHlSOVB4cEQyc0g5OGRHOGtLcE1hc2pMcEJCRGM2Z3ptRWJZRWNUNExhWnE1M3JEWGd5dHNXVlBBdEZRczcrN3RwTlBaYnJjSGxLTkFRbjBzQm0wQ0oyYWpVR2lQeGgxNDJIejAya1p4YTZQU25waVRpUVZRUVUvTWFMNU5vS2lnaUE2RUQ5Wi8vKzY3VjI2K0pLVXpqTW93UFVvM3MwaWpFOHdJY1F4M1R3TTJMejRzTjlnemd6NlpHdnhHWXdJUG04c3A5TUsyRDhHN0RPR1J5L0padlluUWN6L3c4Nzk4Z2ZTbmgxQ0U4a1lYR0FPb2RvemgvYSs5MmpsOEZ6U20yV3IwZWoyTUtMUlJLcDJDVG9VU3BkblJpd1hpOEl2SXZzc1NyRE1VU0RhZlVTVEZTQmdnMDZBU3dLZGxXbXp1YUFUYUJVTm9HQWEwS1U1bzIxWXVsNFVPd3JuQmVzRno0a0pja2FTRGc0Tk1KZ0VCQXowcTV3dWd5NUFXbEZPckV3TEFaNHJGSWt6RVlEQUNWNEcrbkRrMnlqUXRNRy90NE9BSW1oT2REamFsNnBvRFZlbEFVcHgrYi96dXUvZWhMMUZObUtOZ0J1ZlBIZzlIbkFBQm0ydTZGc3k4MDlPelVya0lCeGQ5QzlDazB5bnlZcjNnN0x3S0d3Mk5kMzV5c3JLMm1rd2xmTitHL1BUNlhjZjJRZVdiemJZc0tlMUdNMThxWlVENTgzazBNS0dEaDh4UW1lMjlTMmVQRC91amdXVmJoaGpmS0JVYVorZlB2WFJib3pYbFpIY3hmK0hsRjA1T1R1Rk02d3B3RGtVNGg5bGNRRUZZZGk2Vk9XODFpK1g4WURTR05uRTllOUR0MTJwMVZVK2hyMEJ5Qm9OQnI5L0RXZktGREV5anFzaHdpK0ZLdzNvbzhIUlRXcjgzQkNmRUxzZTJrcWtVUUlCaHdsNUFDVXJvOVBSODJPdWo1dytPamdiOUFYVEU3ZWR2d2NCbXMxbFpsU0dWNUo3SkJtZ2IraEFxQ1o1UElaVThxTGR6aW14NzlrcFcrOXluUDkzcHR6ckRNUVlVNnAvbUF2aWVhcVJtUHIwckN0cXpmWFowL2VYUHdLQVJ2SjRxMlBDSDhNeGd0L3lpRUVyQzA4MkxFT3BoaXVCUUJ0WmxvRFJHZ0ZocHkrUENaQXBvNWcvOHdpK1RDTEJFUkM3aTVKN1NKckFlaWR6OXd6OTYrM2YvTlF3c2RIeTMxMy8rdVZ1cW9XZXkyZkZnNU0vbXdEcWNNSE02QlNXZ1dhTHNSaWErMjNSMUhEN2x2TjN1d0hiN2dROGJpaTREd1Uwa2pibS9RQVRrdnQxb1FXeUFKd0M2V0N6MStuM1VCSktEa2lFRG1Vd0dRNExCZ09MdkRQb2I2K3N3d0tDOGFHUWhsNE1vUXZaQVRDM0xoZXpDdzlNMEZVTUZsZ1hYRUpBdHI1UTltbUVXdHkzYm5OcW1hZUdNNEV2VVlUQkh2QWdUVkt0VndiSWtXVGs1T0lhNmdjMXBWS3ZQUFBNTVRCRGNYMVRHYzJjUWhoczNiaHp2N3l2UXc2b0tBYTZVeXlocU9KbE9SbkNMaVQrUW4yY2t5dVd5TzNNbXB1WFp6dXBxQlZ5b3VMTGllYlkvanlSU1NlaXpYS1Y4Zm5SeWRIdzZISXdrZ1o1MEJwMG45N0hmejVYTGdLS2tLRnBDYXp4NmVOWm9MVGlvOW5ZcWFjaXFjbHl0UG5mcnBxS3J4OGRuNE83cFpBcStVQUk5bDBrNXJydXp0ZUdQSjBQYmc2dXd2Ym5hYXNOL1RZTW1vbW12dnZvMTFBcmFEZlRTTWgyTU94K05pa0lVdkE2T0xDcVA0VGcrUHMybWsrQ0VwK2ZuQXNldHJhemlGSENzWDN2OXUzQWU5blozTURTNnFrRUZYTHA4Q2IwSy9kMGJqbGFTaWI1dGRZYVROQzE1d3NtaThPS3R5eWs0TU4waDNTV21lV1kwTVVoVmsvUmFrVVhVbVF4YzE5cTY4U0s3VVBrVWhoU1dZQTBEaTVJTkNMRkxVUVpNOXFGMDRKT2hsRkxvUUhiVGlrWFFURllVUXovN0FPU1VEYkZGbFB2aW4vdHBUcFJpRUcvYVI0WUN2L2pHSm4xSG9zZmZmZlA5UC9oTlE0VWZ3c1BvNyt6dW1TWTlMYUVvS3RBRGY5THppQ2pQRjNOME9xQ3ZxTEpBNndqTW9RQTY3UzQwSzVnOXVENXdFbzlIeWYyVVJKZzJtRTVrb2JsUTBPV1NCQTNkNi9aTXl3SzA0ZkpDZzFxMkRkb05nV0UzWmFHUUhMQjI2Qlh3cFh3dUs0bWk0NUtPZ1QwQnVVUjl3S3BIbzZtc1NwQ3JWQ3B0bWxNdXl0bTJtVXdZT0FYTmFKZ0ZVSDRxNkd6RWwzanVZUDhnWDh5SWNYaWxzdS9UcTAraGhFRFB3ak1LOUIwUU5XcDNZWTVRYTFnbnNnK3VNeGpDaFUwMDI2Mk5uYTFTc1hSK2VpN0tFcmdxUkJvOGVHcE8wWFBOVm5kamN4TjJ6N0lzVkppVzkzY2QrTEtPYmZmYTdiVmk2Y3JWeTN5VUx2ajNSOVBLU3ZHZDkrNEVzZWphYXVXUGZ2OFA3OTI1MXppdlJ5VnBPRFpuamcvM0xwUFFlYlRGY1hmM052WVBqKzdkZjJ5TmFZNGtTRWlTdlJ6UHMwMUQ1R2lXamhBZmprZkZRaDdVU3dCemt1UjJ0M3Y0NUdDbFhJUUZBSDJDdWtHN1lPVlMwcUpSYTNZRzAwSXhQL05jbEFZWnhyR2JteFcwdDk1b2ZPeGpMMEZmTkJvdGpPL2h3V0U2UmNGeXpPKysrUmJrNGVyMWEwWXlkVjZ0SmxXMU5UWmgzVHRvaUNGbHlwVmcybm4rOWpNbjFicFBMNm9qYkRxdURSVUJCUU0yQzN0MC9ZVlhPTGd1cEpoSk5UTXNQdjFHSUdpU1dtYzdXYlpsWUJDbmdHS1g2U0g0S2NLK0tiQVlBM3I0WWY4VThNc1Z4Ym5ubU5uVlRicWJBMTVFMnBrSURNbkliUGJrVzk5NDlNM2Z5YVJWUUEydXBFbHZIYmZoOU5CTWh2a0NmQkVhR3FVRW5nZTZ6VzVNY3ZSYUlPQStGdHZlMllHamlTNkhjb0tmQ0RWL2ZsYkRnTFhiZlhUY0RCQ1llZlNVUGwyeVZIR1Vua2lvNFBIOVhqNmZSOWZqakZESnFEa2d4bkh4YkRZVHpBTGJkdW51S3g4RDRZRnJuRXFtZkpwYU1BZVlnSGRVQ1h3bW1jN01ncmxsMnZSOGhhcW1NbW5YODFFZ3pBTFVmenFoUVBmTzVuNDZtNGFOVmpWNHQrUXNBSXVhU3JPMFFXYlN1Y3lNWnFUUlRMTHRuUzFSVm1sWmpXaVVYblZFU3pYeE9GMi9Od0NMNVFRUmpKbVB4dDUrNjExVlN6VHJEYUFxbVVpMUcrMUlGRmczd2FRZ0c3YnRpV0ljaU5HaEpCTEdRcFFoTzhmSGgwZTFwcEtBUWNnTHNiaXNHeEhQSzJlU1VMZnJBUDVheVRmdFVtVkZVWEJvZkRKMWFOVlNrTWw2MDVzRlY2NWNxWlNMYy9UQ2pEQ3pRR1Mrd09Cd0hBOTlqMkZGWDBLRGRKdXREOTYvaDY3ZjIxaXJOOXVqMGJoVUx0bldGQ1JXTXRMc2llc1kyZ0xkSlNrUytEM0l4L0hCVWJHVUI5dkdxYnU5YnF2WldhbXN0T0RpOUh2Mzd0M1hOZVhsajczOHdRY2ZDTEVvS0g0cUNYZmE2SXlHemM1SUVRVjY5NWpBdzFMQ0NjZ2FSdDZRRzZQSkhNNEJ6YTV4d2RlZ2xQMlpPMjdWc3l2clVpcjlVV2d5SFVzUlNtVFl4SjZuUUVlZzdXVXlSWmlLWnhINnBSamo3OUQ2b1ZDUU5XQloyRTBqa2gvYXkxMjd2TnZhZjF4L2ZLZis1UDdEYjMvVkdqUVc4SkttNHlldmYrdnJ2LzVQcTQvZTh4MzN5WlBIcWdvdm4xWUdSQlZ3TkRpWmE4L21jeDlFQTdReW9QdkdOQnRPRXNRbkI0Y3JLMlhRZDl1eW9Famc0c0JxaXhRa3VIVEpaRnBWTmJDRlJNb0FwR0FmUU1FTHhlSjROT24xdXNQaEVDUTdMc0JWY3NBTlFLYzRQdDV0ZDlBU1FBZmY0T1YwWVJsdVhMQ1FGQmxDT1hOOUtOUzE5VFhBUHB0TlR5WVlUUlA5QzMwUGpRNzlDaHBRS21aZEYrMGdjZy9qazYrVVRBeXlPNk5KTERSTEIwSXJGb29aeU9Rc0V1MTF1cmwwQWxqSjVITG9QWkM2czdQelVpRVBQWTNhUXJwZ1JrQ3hZQk1BYnRqM2d5Y1AwMWxzNml1YjYwVFBCbVBiQkROT3JxeVVhdWZWMWZVS3RXNDhoTVFtVXhuVlVDZFRpNjZIbU5OS01VL1BPR2xLZE9hbGtvcWFoQVBRVCtVeWtrNnVjRHFwaVlya0JCQy9oRE8xMHJsc3A5TVZGZ3RGa0ZmVzFtRDlPcDIySUN1bVk2bGlQQ2x5K2ZXMU1SeHN5NFRyWHowNnJWWnJ4OGNuTUtPcFhHRjdlNmV5dFRXWlRKTEpGTHdkQ0lNUUYxcU5acmxjZ3UxRlM0SHlnNGY3MW1RRU1wT0QwNXBQb3l1NE9EZWFUT3YxZXVEUGhxTXhGRWNjV09hNTg3UFRtemV1UDd6M1lPNUJhWGhwbk0vUW1yMWVOUEFuanIrYUZMT2x0V0dubHFIMUNLeVAzNzcrOExUcXpnSlprRncyWlJLeU9lelVCL1hHbFk5L1A1cytBMHdpQUtPRVRZSmttSUJBR3VZamdiYVhlZkM5VEF1RmhIM0NIQ3lSNVZnRzhpcnhFMG9PdDVKTWp3YURsQ2JhM1Y2dldtMGY3NTkvOEg3OTNudnRvOGRKSFQwcGdGM0FKVDQ1UHFmSHFHZkJvTjh2RkxKeERsNmRING5PZFZXZldnNlpLbFlnVUs3S0NtQUVtZzZvb1lOY3lMWGo5UWM5OG1pNUtDL0FLSU9ZV0hBUVc2MDI0QVFpMkdnMjZVYTM3NmVUU2JBZ1EwK2docFBKS0dGbzhGWlZXZTkwdTRhaHgvbTRibWl1WStmelJTRk8xeG1CZTVnYXFNOWNxUkRuaGZGNERBR0RCUWYzaFp6Qkp3TkdPNTNPWkV3RWc2NVU2alJtam1YWDZtMGNDM21vckpjaDNYUnh5VEtQUUJRT2pzYWowWlZyVnlSWkFLZENlM3ZRNHBGWXBWS0Nib01QQ2huZTN0MEM4a0RtSXNGODk5TFdaR2pDZjRYQm1kRzk1TVg1U1IxR0EyN2NzTjBCZXpaU0NVbVEzbnYzenVwcTBmVTgyQVAwZGl3R0pUY2I5L3U2QVIrR0Zqbkk1MUl3ZFBBUSt0MHh2Q1A0TjhWaWJnSnUzaC9Dc0lxR3VvaUMrM0txSkhrWXVTaDVVSlgxRGMrMkdtZTErU0txeUhxejNYNzN2VHNZQzBVRXRhUjVDRkUveUNTUzhIMUJuOGJUU2ZYOFBKTkt3bnMwSkxIZmFSWkxaZFFIS3N6M2ZFbVNlLzNCWkR4MGJSdEFuOUNGZEhNMk1WZFdpc3pBTG1EVFlFRGgyTURaV0FUelpxTlpNTkRyZWdRdWRTRVA5ZVFIaTJhbkp3dnhuQ3Bqd09IWGVaUEJiTUh4Yy8vUC9aay85ZWFqQTJ0aVF3ZEI5MEhzRjdTcVBuLzV1WTl6ZE5tTktBVjlFejZmWXBUZ0czNkkxb1RKK0E2bmx5MDNubjZJMjdCRUZqN0M4c050OXIwTTNHYXhnRjVVMFBGR0VrdzZrVWhoa01BSjBHSFExeUxNdnhCWEV4cThMcHFZQ2g5ZjFZeEVvdFZvbnh3REdXTXVMa0M4QVY5b0NHU0Yxb2RaQkVzbTJZQnZ5dlFyVlA3QjRRRkdyVlpyM0x0N0g2eWpXbTFBVHhUekJUL3d3T1c3N1Q3b01pZ2pxQVhVcWVmVFpHQmQxOUQxMEx0UVNDcTk1R1FPaTlSc3RvdkZBaTFmRkYwWVJnTGVKMFJyT0pwMHV4M1BBUlNuMFB5Z05PUFJFQU1KdE1BSmpndjBBREVzYnlhZEhZOUhwVXJKY1VCVVBMZ0tPM1NWTFFsWmV2ZWQ5MkNqams3UHRyZTI0Q2tpUS9XOFlSZ0t2RFNNRFZwRVUrZG42QlZZSzFwWEVXZGh2VGYzWENlVlNGeTdlYzB4Unllblo4bWtBZVc5c3JKeWZueU03RndjMWdQTXpyNzkzTE5CUkVCM2dBcEJrQUo2SlVhVXJwLzRNNXhvTmwrMGVnTlZsNkgxbFJoM2NsWTlPRHg2NVpWUFQwZGplT0ZBdG1PYW1XSStvV20wT0tsdGcxd3hoOFM3Zi85Uk9ac0NwVFFTNnY3K0lTcUgwYmwrNndib0g2UlJUMnFGUXU3bzVHUnNXalRaTXhLaFZ3a0lvajFocjk2YnoxdTE2bkE4U1NYVGg0Y0hEbnhZMjRZQWc5ZzhlYnd2eDJMVlZodmM4UFRzUEd1a3hwTUpiRm9reG5VSGc5WDFGZGplVnJjbmNMeVcwRzFRVXMrRDhZRXpFNDl4RTlzc0c1S2VLZ3k3OVlTZWJQWUhhanp5d21jKzlkV3Z2VUYzTWFJWVJhS2M4TVVFeVNoZnVUWW5OQkxjNlhlcHZiLzNnNjlsSkV3QnVDbkN0RGh0L2g4RUNBRFVRaWdKSDJiam5ybDZ2YmkyZHZ6b1VFdHJjSXlncERIR2tGY1VaK2dxY2svTk1SdzFuby9LQWdkVng0dHhtdVU1RHpMNVhEcWRJVURnbUVVTVVyR2dwWGlBQUpvTDNlLzE4S096QUpMdE9rNnhVRWhDZWZ1Ulpxc1pZZ2pLeWJZdGVIZWVEM2JPMDdYbldNeWdsWHhWbkFDOUtDdktZREQyUEllZWhxT2Jnb0Z1cU5EYThCUm9QbmhjbW5rK2ZFckhNV2Z1Yk5DRHhxWEpWU0tvb3pjRDhZRDRUVTBiK1FFU3lDU3R5ZWM0NC9HazFlam1nQjVEUjZjTitvTmNOdHM0UFlOWmgyQWtrZ1pJY0w1WXBJc3Q4NEF1Mi9sekVDMVZVM1JOUlg2NDV0RFFvQUVRdkdyMURQMlN6aVJRdldydHJOZWJ3bDVkdnJReDkvMTJwMXRaMjREVktwVUxyV1p6UEJtTSt6MklIUS9jQ1h5dFZzMWxNakJmNk1uajArcDZaV1hxdUhURmRCRlRaQUYwNHJ4YXYzZnZYcTgvU3FkMHVNSzFWc2UwSGJDTWs5TnFaVzB0blRQT1RzL0J0MFZKUGpnKzZRMzZ6aFJxM2QzZDNpbXRyc1RndjJyeFJEYlhiWGZWWkxJL25FTEl5VnBPcDV1N20wTUFWeEVYM09MK3ZjZVpRaDRna3RCbmhqRnF0alJKUk0vUFBTK2JTc2RocnpXdFB4aDVybmYxK2g0dnlYQmJ5VGp6SEhyanVSczNVUnJnQ3d2NTZQQ3dYcThGY0lKNW5sMUhqeFZWb1Ruc1E1ZEYvYW1SeWpWYm5kdFhONS8wQnZXekpqb0swQVBxWVZoeXBmV1Z5OWVqZ2tUUUJEQVpmQW1oTU1UcytpTW9mNWlJYjBJNFJRaXloSFNrTEJVNnk4QWk0VVhMY0NQa0xtRUsyNmFBR1BmeXh6K2hnRFNBaEdvR1BPZGV0M044ZW9UUlRhWFM0TGNnR09CMndEU1VBYnBwTXJVaDRuT2ZDREc0TlVCL2RucVd6YVhSYkQrWVFYOURHYU5jU1JTQWJIUU5NQWsvQ1gyQVhZaHpITkJNRi9MUWNSaHBlRC9JQWxkU1ZmVFJFQ1NpVDdlaWdnQmtPazR2STQzMmUvMXVkekNkVHJ1OWRqYVRoc0xHZVNSSmdaYUZ1WnhBNTR6SEVEQ1lnc2x3VWw2dHdPbUVLdlZwWFMvZ0tvNnpRTzNSU3F0aUhCMEVhUUdJcDVQcHpzNG1iQWliRTBtVEltM1gzZHJaU2lZVG9OSGdTS0RGYUJ5b0xWaCsrRkVWRmJ3ZEZBdytNcXdXdWdVYU9wTk5ueHlkUTZYdDd1M09JK0MzQVVyR3NhUFJOREtQYmU1dWo4Ymp3UGQ3bmZZQWd0anRBa3VGWWhtOXdYSHpSTUt3YlZOWFZDaVY0V2k0dDdzem5acUJiV21HV20xM0pwYjFwVS9kbnZRbkVZRUhtVlprQ1pqekxKZm5RUTE4MEo3eGNJTEJUcVFTdlhvOXJXc3dhcy9ldW9XaFZSSzZJUEtPT1g3dytHQnJiOC9RRldncnlEL01Xc1J4NDdJQzZpaEtZbTg0UXZkQ2tvZmpLVVpCTjNSMFRXVHVKMG1lNFRLTGNsSWZEQ2VlYThYbWkxeXArUG9iNy9TN3ZZU0NjcElRTFl5ME9aMmdKaWlxMW1nSzhUZzgrbjYvbjg1a3djY0VqbXQwZTJ0cFdPZDBOREExV1hRV2ZLOTIvdU0vK2VOZi9zb2ZSUHdZS0FPNkJWQm9WNCtQN3I1ei9jWFBSRVdlY01tQUdzS1RyZ25TNWhLemxJN0FnRXYvWWFBa2x2bzBpWTdFSnhRTmxqMjhraG1XUUY4UjdzWGJMeDQ4Zkx6ZzVuRDZGQ0Z5MXVpUFJrTnphcDZjbllJdXp4Y0FYd0trQlZJN0dKb0JMZlpCS25acmF4MjZFbFlNSkFoMGtCYURwU2Y4SjBBRFlBdVdURGVlZ25sY2dDVEgvTGwvZG5LV1NobVc3YUNQaW9VY3BBaHVLem9JdkFnd29xbFRrcEJNcFFBc2RxbDcvdWpSUHRRelZEam9UU2FkQXRHSDNLVXlxWk9UY3hnS2VKa1FFa0FrbVVqU05VcDZnd3JkcElUTGFOc2Vkazh0azE3Y0c0dUNxNkFWVUpsZ0k0NEZQOExmM3Q0WURBY1FURmloMDVPVGJDNTFkSENDL2kyVml2QzE3OXk1Q3l6Q0xBQlBvOUVFWFlYaWtGS3ZOeUhlNTlWR0xBcE5SeStuenVZU3BWSnVQRGF6dVN5d0RuRUFRUUR4MExVMERCUVVwMk5aYUh5M0NYbllnVUVZanNkOG5GZFVXb2xvT0J5TG90b2ZEQ0NTdXFKVXEvVkJ2d3Mzamk2WXlGcTMxWVh2UEowNlVVbktaS0UxeUNCM08zM1kvTkZnbU5HMFZyMEp4UUh0RWN4ODFBWU1tNHZPenh2TkI0LzJvZG9QanFEdlRRL0svdklsYUJrSUorU3dVRm5EMlJudm1NbXllbngwL09qeEU2Z01SZFBhN1dhalZzc1lPZ1JQVHlTZ3pzQzF3RFltcHQzdTlpNWZ1N3hXS2FRU3FUam9FTVorRVJrTVI0c2dvTmRuejRJa3JRUHN3VFNoaWpSUEFSd0F0WXBFVncybDJ1ckNJczd0Y1RaZk9tOTBDcHAwOWZidGI3NzJ4dWJ1YzRFZ2drM0NOTVVXOGIwWFBoR0htZjBlVEY2RUM2UWlNQWlIQ3Z4cEhzYlJHZDZacG1ld3AwUHd2d1Q3OHZ1cFdNQkp2M2J0bWpXZUNMS2MwS1ZpS2pXY0FpMDI3S29zeUdmblp4QkVhQ2xEVDlMN0hTS2doZ29PUWtjRDBEZ2NLaCtOL001M3Z1TUh2cTRaOUtDTnJBeUhRM015UlkvQjZhZExFRjA0WG5SdER0ME42cS9xRXZDS2RMb3RKd3JBR1RoRFBwZUFJU2MzUVJTSHd6Nkx3M2RRWUJDZ3ZJRVBXWkhZN1Q5NlZocWVKVDF4c0lqQVVJd24wMWdrQm5LZmdHNVdaWkI0S045Wk1OTmx5Ykt0Zkw3QXcxeUFIMWZQVUJSUU94cVBUTk5FdldIOFlSeHcxR1JreVpLR05yT3JLeExNUWdyK25PZURaNEdHcWFvQ2cxNnFGRE9aYkwzZVZuV3Rzcm95R2svZzVXWXlLZlRNMnRyYTZmRTVTS21rcUhGSldsdGZWVlU5bUhzU1JqMElIMi96NEYxdzVCUVpRQjZHSnAzSnhTTGtTd0JxcUVtbW1Idm56bDJJQ0Z3OUFZWXJHcXMxVzBxQ250TmRxYXlva2hDTGNFWXljMzVlWGNRVzVYUitPQmlpekRONCtkNGM5THJhYW1VTUl5cUt1M3Q3TUZiTldtTmtPcFZ5Q1hRZW8rTzZzOGx3TUxWc0hKNHdERW1WYXJXNkNOVWlTZmw4cWRQcnRCcU5UcXMxN1BadVhycGtCelQvakpiRWthWEJjQXpOMVlGMWJiZGN1c3djUEhseWtCUUYyNXZabmdmb3kySWM1REFxaU0zUmtBRXBDdlZuSkpJd0lCaTI4M1lucThTVG1lSlpvNTdUNG5LcWNINXc4UDJmL2pnZmp6MDhPUDVQL3M1L2QzaDhmOXJyUWxNOXZ2UEdsUmMrdzhsQ1NEd3dzSVRZa0ttd3BBdkFzeER1WGdZQ0FidEFFaDRhcHJCL2hHVkttTXJTMkJlM3M3MkRabS90N0p5Zk5qUTRxZk5ZdjkrMVRBditEM2lGUC9OcGVpRHhsamt0YzBoUFV2UGdGYlBBejJSeWNBNmhweFZSQWZsR0Q0QitZRnhCdlRKcFE1VkZIT0w3QWIyRE9RNWZFWFNDQ0ViVWQ4M3gyQUpwZDBDUWFMR29PZVEweG9NaVMySzgzZTZXeXl0Z2h6VHZGTks3bUlPdW1PWUU2RUM1ZEVGVEVuVkRBNEVHK0NHVENTTUJSaVJKRW1vMm05R2xHR2cxU1l6bEN6bFFaSTZuWnhSQW1HM1RZMk9NSkFHc0YvSUd0M2c4SE4rNDhZeHRXcnVYZGdlRFlZeVAySTZkU2ljOHowWjdLNVdTRUpkQTdlSnhzYnhhZ20xSjZIcjF2RllwNTREQy9VZjdwWElKcmhoVU9GaFJ1OU1EbFpxT3pFR3ZUek4vYUtaVXROY2JtbkNab1N3TW1BdVJhaUlJNVVKbWM2c0NyQ2NTS1NOcDlOdXQybW45L3NQSHNBOHZQUDhjMnRYcjlqYzJWcUdpUE1kcmR6cnBYQnBGblJ5ZVZOdmRkQ290eW1LVWk2YUVDRnhWV01Tald2WG1wVDA1a1dnM21tZG5aK051LytyZXJxNG5yanh6cmRmdkoxTnAyREc0UXNmSHAwQUV4RGdJWmpocmxJdnRIeHlNQmozMFE3ZmRnWG9HRG5nK0J0YlhIazNhWFZwR2JYMTlaUjZObHN0bGZ4NDA2dTFlcXd0a0FmV1FHYWlxamJWS3Nid1JLUHB3UElSUkpSZWVadFFRdGtCREFMSTRIeXNsMWVOR042WWxZcTZsNlZLbk4vWnQ4ek5mK0d3NlBvc0tpZWQrL09lcVp3ZmpaczJkakxpWXVIYjlGZzVqc01YUGd0MGpaVmhkZ3BjRnhPa1VMTTlGV0NwdFNvU280RUNXOHVIRm1UQWdza3pocnUxZE9qODlpM0J6dUZ5ZTdjbm84VTRQSHRoc0hnQ0Z4VklSSkJXTVpUQVlRSnVDeG9yMGZveW9xc21Bc01kZWVBSU9BSU5RS0JRYzIwbWxVOVBwV0ZiaThIWkFJa0JJTUVKUTFQQ3FTTGZSOHJqMDhEYW9kaXFkcG12cTNSNE1aRHd1cVJxSlJ4eEJFR3F3cllYY2JPWnJ1Z1kvRW0ySDh3QURrczVrM24zbmZaQlJlcFVLclEwTGpXS0NHS0RISjFNVG9BZFZXQ3dDdWpmQVp0aWpSWkFya0NpY2doZWdRVVR3VHZnUTRJOFFsWHcraDIrTVBRdzhCdnRnLzJBeW50S2Rwa1VFYkJoVXZsWnY2Z21qMittUkRmZm5zQ0ZRalN1VkNtcjExcHZmWFYxZlI1TnIxWG91bHh6MlI2Qms3UlprdFloNndxVjQ4N3R2OFpGNUxxbjFobE1JVHphYmc0Q2hEN041dXAyK2lJQ0RpSzFXOCswMzNsSU1yVnFyYjI2c2xWZEtHSkZHdmRWdXQrSFd4eVZCMDVSQnUyTzc4elJNZzZhREs2RDNrNkJuMGNuVW1vOG0xaXdTczJhellpNG54TG1rcGljemFTZ1NDSjZvMEp4SEtLYnB4UFpjQjlpNWN2VUtPdXJHelJ2Mzc5K0RDOWhydFNWQnhJblFhY1E4T1I1dExKWUxsWEk1bDZGbjU5OTc3MjRtbHdWN2hLSUJPd0xTd1BJRkkxZTY5dUxwL3VOVWZ2MUxmKzFYcjN6bUI1VlU3dVQrMnhHeTVEUmRGSVlVQlFvWS9saWszdTJqVmpmM2RyL3k1Z2NiT214bXB0WHJsM0s1N1oxZDFlOU9renM3TDMybWVuNHdhVlhuM3V6cUs1K2ZjelM1ZFludjBPMmtMY0k0UzZJcE41UVNTdFZId2pJSGhvMmhIajkvSWdzMm1BeFE0SjUvOXRta2tYQXNEODdxeEpvSzlNVEtmSFYzbzVETHpVRkpiUXNZZ2lxVkpkbGYwRVFBMEQrY0FLQ0hRd0dOWlRzT0hDeElRclBSS3BhTElEOU1td083SHMwQVN5VGh2MmNMcVN1WHQrdTFObXJzMDR0YW9uTmdONXVGOWNCNVU2a0VIeGZvUHJOQ0YreWhGTWszWkkvaHdhalY0STJsMDJDVE5DZG5FYVNTNlN3cU5wL0xpZ1kyQWk5d0FiODB4c0U5QUJXR1pDWU10ZE5zZ1FwQm5ZOUhBOWlUUlRBZmpJYmdIdjFPWDVERVlZL1daMHVrVXRDNFI0ZUg4QVhKRlovUjlCaFVZRElhTjVwdFJkRWdZNmdlUkF2cUNyNzE2ZEh4L3Y1QnJkWlFkYlhUNlk1cFRkWWtwRUxnRjVLdW9KbmowYlJReWg4Zm5VRzhZV0cyZDNmaWdnUmxyNlhTaXFvYlNWcU5IbTJSUklXUFM1NC9BNnhyb0xTMUJoK2w1VzRxYStWRUt2M3d3YVA1UE9MNTBYWi9JT3NHck0zbTVobzBpenVlbXFOUmpPZDgyNW5aZG9iMys3T1lsc25EVTRRZHppZU42WGpxQmdIODBHS2xIT040OUJnMHJtVzdsZFV5VGQ1ODlCQW90S3hwcTlXU0ZsR285alFzVmIyQjRVTkFKOVBTUmJQQUJhS2prWHdaVXB3WGVQNjk5OTRmRElmbjFScG8xNC8vdFYvZHV2WHhIL3VWLzh1dEwvN1E1WTkvN21NLzlwOXdtWlNvYVpWTDEyWXg3dmp1V3hHYTZFRnJvUVpCQVBFRzNjVG1wVkx1NGRFcGV0Z2NUOVpMeVdSaDQvRGd5WldiTjBSK2JnOTZzOHoyMXEyUDFXdW41dy9ldmZiQ1orTEo1Sng0TnpRN0VJSVBReXBwN0RBV2ZnUElTNlpET2gyQm5td0tjYjc4VUpiL25RRHRUb0hiMnR3cXJsVXMxNUhqL0R0dnZ5ZUs5SXFTc2Vud0lnZXJ5dk5pczlHUUpCazRBMjNRTlhhWHA1QUI5MVZWdGQ4YkFKbmdHemdMeGhzYU54YUpnbUhQSXo1UVB2Y1gwNmtMZkFPWHJYWUw2Z1NrRTdRQjZNcG1zL0JyZ3dWZG80RDdDQW1UcFVpOTNrbGxERGhxRmx0MGdVeG5NcG5OWkJ4NlFOU0NLNG1tQjNRdGhZaHZwOVViajhjUVFvN2VIek4vK09qeDFMVHAydkJpTG9nZzduYXhoRk9NeDhOUk9tT0U5N0hCK0UzTHp1UXlneEU5WW9zZXlHWnlaNmRWOUk4TzcxdUQwWUIybHhTMEZoNENyVGtCQjdHTGowNFhaOFM5M1YzSEJ0Zzg3TXJuc3RpYnp1aXhSU0NKNHVXcmwwWkRvckN5S2dONVVDSzI3VjY2dkh0NGVKUk9aMEgzdSsxMnE5bGVXMS92OVh2Z05vUEJCTlFpbDgwb2lnVG4rK3ExbmVGZ2ZPLytneGF0SXFiRHBZRmRsVVVPbW5ZeWRSWUJlek1lelFUbVRWZ3JjNGd1bVBIS2JEN0hXY3J3bDlQSlZyOWZ4eGxhblpWU3NkWHNRRkFoejU3bjJMYWxKL1IrcjNmMFpKOHVudmwrdDlHd1hhY3o2TU40UXV4REVJUiswWGd5YVlBVW5WYlh5Z1ZWVTg0YnJXNnZCMy8wTXoveVU1LzhtWjlmdVhZeklzU2g4aFRnRWg0WEhVY3cyOWk3bmwvZDI3LzNwbStaU0VJNjdCaUNDbkkvZ1U4b2JCWUtmL1RlbzZ1bEZFMnNpdkt4bVZQWTJqV0Nuc2NadHBMZXV2WFMrZkZqMy9ZcTEyNStGT2hoQUhLWDdCeUJmVEVzZndqb3A3Tm9LQ0JHNGtKUmZIMEU5N1NEeENZYTRaUTQzeHYwSWpQZkhJNjJOMWFOWkRvQVpOQXgvc0kwN1h3eDMybDJJQVAwS0VBc0NoUk94eVl3QnhWT2ozaHlTS0dMR0NnN1RieWZUa1hUM0JNNmROWVlBeDlid1BpNnpneVNNSjJZTGkxTTVNWEJQa0V3NXJUdU03ZzRxQTdzTy94WXVJWmc5R0JIOEFneC9NQXVMYkVVajhYNXVLS3A4SGRSWTRnWmJKN3J1aEJ5cUNSVmxaS0dldi9lQXppb0VueGJVUzRVYzVDTmdON1piMkU3bVRUUWRsWFJiUWVNSlE2M0xKdlBhSXFSeTZ5QTVpT1BwcWtnK2k0Y1NsSFFEYjFSYTRDQTdlN3RBb1dPNjJxcWZQWDZGZGZ4d1pQT3o4KzNMMStaak0xMEt2bnc0U1BJSGhDWkxhVHRxZFZ1dGlFUCsvdW5NOWM3T1RtQmNvVmxFMFY1WjN1NzBXcGlseld4c3RuMGNEU0VJTWx3NXlVSnJ2T2Q5OTZqZVp0Nm90Y2JqSHRES05wU3FReXdvS3FhTEFKejE2N3ZKcFA2azhmSForZW5POXViSHIxRU0rQTR3UWxpaHFLY25KeDVNQmx6SHp3YlRPYko0YkVneXJDeGU1ZjJMTWUrZi9kZU9wSEIyU2JERVJ6aW1lZWF0ZzJxNW5qT2NHS0MzY0pDRWhEWW5jNVFZV0w0QUh0c29sdmdMZy82SSt5R212aTV2L3YvWENnS1VBR2VzS0FwS0FTcThBdnhHTWNWTjdmVEsrc1AzL2o2WWdZRkh3VjBnQk9VaHNHOWxFL2ZQejR0NWpPUFQ1dHJLYWxRS3A5VXErVjhRVklVd1c0UHBjcGNFUFp1ZllLTFN6cFlLMHFGZTA5RjAyZDVrakJRTWlXd3MxTnRMNUtKNXJQNlhCd1F4a0tzVXdZS0xBZjlRSVVVUjRQaDFJRmJuWmdNNGFORDl3MUJiNEpJWk5DZndBZk5wTk94V0FUOUNzRERCSU5yUWpQUzVVaE5uMDRuVUlyTTE0eTVqb2NPQWRiUllMcG5GeUFPOTRYdUQxbWtkeFhVRWYwS3B6NHVpb1BoQ05XQkNNRmIwaEk2SCtOTWN3Z0ZnNXpJaGs0M2pLUmwwd3VhWGNmQ3FXRUttcldHTlRYSk5ZeEdadTVNTTdSRVFoNE9oK3NiNjQ3anE2cWNSOGlCM29PbGNEaGRNSStrVXFsT3B3OVNZU1NVUkRKMWRuSyt0Ym0ydnJFNTdROC84Y25QREVaOXFEdm9JZE0wallRZWk4YU9IeDJEQUtNYUVFb29hV0FkTkwzZjdheHZiNkxuTXVuc2UrKyt0MDR6a0JlRC90QklwSUtBM3VObFcxT28vTDJybHc3Mno0Z21HUVprVDRmRUFpNnhPWGg1TXBsa1QzVVZqby9QQUFKRDE4blptSmh3azlCUkhCeVhhTXkwcHBldjdFSHh6eng0aEU0Qi9wSktVMStncWlmZXJOWm9KMUpKQTU1QXAxZGNYWUcwcDVMSncrTXpHQmt3VHloZ2dMN2FhTUlYeXVXeU1BRGxTcGs4SDAyWitTN3RuQy9BaStESFE4cEdrd202SGNNa0E0elExclNDRlQxY1Q2Q2ZMekJZaHFKQnQ5RWo2Qnd2eG9YblB2SDl6LzNJVC9va0VNUXNtRnlFZW5ZSkxXQUk2Y1hLWmt4U1QrNThCMElFT0tJMFVWYkFlOUh3UkVJcmF0cTNIaHh2cFBXbzd4alpsVTZ6dHI1OW1WOVlRTlZJekVXRnVBNC9paFhKZ0h6eCtXZ0lFWHNSR0pvWmpwZmZJZWpEbzlnL0U1RGxJZkJjbDNrajNKV2RyVUt1c0g5NENuOERvS2tVQy9sc1hvNkw3b0plM2pEei9Ja0paMHVpNnpPcVBCd01WVmwyYUczUmdqZWJpWUlRbzBmRnFGQlJGS3ZuMVVReWdTNFJKSmpqMkF3bWd0YkpRSFBpbHVPZy94UlpBckZHMTh1aUFwTU5RRThuc0FEUlpJSmVWUURLZ2pyUnhIRjZrU0VQUlQ2UFJleXBEWnFFL29OT2pIRXhqYTRYelNlMnhjY1dkUDNkQzZEVGp3N1BZRzB3MG9IdmhSZEpWVTBmRFVkUEh1OUQ1V01VNGY0Q2tYUTlKeTQ4dXZ0QUZ1UE5YaE9BYURRYWxkVUtLQWU2eTdYZG4vb0xQOVh0OW5rcEJneWhLK0I0d2VIRCtLR3FJUGVnY0EvdTNhZTdzQm05WGdPMnBIYTNuVTVxZ0ZGQ1M1aVcyeHRPZkRDR09ZaGNESTQ0N0VhMzAyNjF1bkUrWWlSaHEvVHh5RlEwdWQxdXBwSUptQTVTcW1EcWpwUE8wSUo3ZEVsa3NhRFg4Q2xTTnBkeFI2UHhZRnd1RkdlMkNUOGRuQ3JtenM0YURTanZ3S2QzKzZxcUJzVmtHSHE1a0h2bjNvTmlvVndxNVByajBYaGl3cmhCZVEzNnZXNjdHNGxGaCtNSmZERG9lSkFUYUJEbzg2MjF0VTYvQnhYcjB4Q1JLU2Q4c0d2bjYrdVZhMWYyTW9rVVljQ2ZZV2h2ZnZvekM1NmVxQXl4UXprcHNnekVyaG1Td0dyY3VWOTdlQmRhRFhESGNLUDhnN1BxczdzYkI5VjJQcVc5ZTFEYks5SmRSajBQRGR0WldkLzF1azhDdFdUR0NFSmhtY0FvblliQXVZd2hrZlpkcEZPbUVMcVVkUWxqNk51TEhUU1JOMHhqWC9RT3piQmtTb1N4RW5uQm52dUdxcGJMSmNqSTJ0b0t1Q2s5dWtZdjVZRWZFL1djZVZ5SXduOEJjWVRTQm1oOGFBNFZNSk9IZmVCL29CS2hod2g0T0JXQUZZL0g2WDNSOUtnMW9yUXVBSGt3UHFreGRLaGptdVdWRXRDUXorVkJqRGMydDZZalUwdHFsL1l1MWV2bnNtSjRucTBiaEhlWURzYUNETkRpZHJzdGFxb0gxdWw2dFNZUjRjZ2lnSXVaU01ETjVjRjVpc1dpSVBHMkJZTWcwOHhCVWVpMWU5RE9XMXNiblY0UDdBSVMyMmswaVFCWUxsb2hheGhORGxMUjcvVHl4UUlYNVVEMER3NzNCMk42WmtkUjZSb09XZ0tKTGE4VVJKSGpZOUZPc3c1UCt0N2RCOTFPZisvcTFWd3VLVXZLY05oUEdJbXJ0MjVzWFhzR09rU0lBK3J3QythU0pLWXlhVEEzYkJjTDJjbkl2SGYvL3NiV3VtUFJndDN3T2pLcDFIZ3lmZmpvWVNhYlBUazloUW91RkV0bzZlcHFlVElhK2piTkc0UHhjUVAzeWpOWGk3bWtEL1VUalp6VTY5bGNDcFczaG5hNzE0ZG93UnNCeTZ5M08yQUJRTmgwU2t2WDgwUU9ORzg4aFZQQkpyRkdENS9zQTRRV1BYNCtUUmtKVUhQNEE3VFlNZ3RMTkxERjNXR2w2ZUgwU0d6NzhrNDJhZkRSK1hmLytCdTNmK2hIbnhMOUVIc2ZCaHdaWGk2SlJuWnV2T0M0VnZYeEI5QVh3QU1jL2Y1b2lpSFRFNXJCYzArYXZZVWZWRkl5R1B6TVh3QkNocTRFZytaWVg1K2hsTEEwcGpzL2NpVVJuMUNkTGdQT3ROeGl2OHN0ZkllYlQ3TXlsTFBuTlpZSllRYnUrNy92RS8zdWNHMTk1ZmpzZEhOOUF3aWJUQ2Z3N2hjMGNMSFp6STFIb3IxMks4b3RSSUh1WnZPaUFBa2Q5UG9nK0o0M2c5SjFYUnRxRzZBSGhZQjNBbTdxdVRPQUZaWkJwRXMwYy9DUUtTMVN3R1V6YVVXVmRFTkdkNXlkVjNINllqRVAxdytNcUpqUHczQ0Rwa05sSzVJQ0ZnRkxDTVkvWU5NR0o2UHBZTkNIZFcyMSt2TTVMVHdwU3lMVUtna2JUVW1naS91V09RR1ZoeFhDbU9YeW1VSXBoNDRHTC9KblhyMEpieHRsODNvaW1jbW1VZGZxZVF2TnBLbnQyUnhUVUpGT3AwVXpmRTB6VnloNEpxd1JtZ0FlRllueFVaUU1CQTBIZEVIZG1rNnUzM3ptL096TTk4bEZ3U2RYb09kZjMzajk3WTJ0RmZnRk5Ia1F2bXloL09ZYmI3aTJuYzdsUUlLaEc5cXR6dTdlTmxnSHZBcW84M2ZlZVI5Y0MxNDFUUVdkQmJlZXZRSEhCNUtqU0VJcWt3TFF4N2J6aFIvKy9NbmpvM3doRllzRWkxZ1U2YWVudGVwNXphZUhDK2FCNnpVNzBCY2JVREhuMWVvblAvVXA1RGs5T1lIN0RzVXY4TFNVaUtiSnBZVEt3YUZhd09nNVY2OWNnVWR4L2ZwVjhNbHV0d2VPRGpHRE1nSVFJT1NRUUhxMGtkd3JuNHZIRWtsak1ZK2VucDFkZitaMitmbVBMUWsrd1ljZ1IvZ0tmd2xXREZQZ1A3SG96czBYVUx2VEIrLzdiTzRKVU5IdURUZkw1Y1pnbE5QbGQ0OWJ4WVFxUmdNdG1SMzIrNFhTaWpzOEJhQkdVcElwZUlJcmt4MEdVNnBYaUdOVy92SWJnZVNMMHRuSlExZ1QyUXFyUVlGMmhSeUdiZEJYaUg5T0UrSkpWWU5YQ2tpdGI0T1l4cm00a0N2bWpWUUNXaHlGeVR5L21NMXBBZlZDcHRjZHhnVW9iem9jalFQT3d2dWphQnBVSnRBUHhPTW8xNlZiRDVJa280dmdYaG1hZk9QR3JXcTFCbGpqT0xDSTBYaDZjbklLRCtIZTNYdWFJYjk0Ky9iamgvczRjRGdhZTM0QVEwL3ZMT2Q5ZkkxR0ZvWVR1RVEzOEp5TURHQTM2V3lxWE1vQjFyYnJRN1RRWk1nYTNRbVdhVzVaS2d2ZWI1THdLWEtNbm9ya0dUbFJVV0ZWaVJ2d1BXaU5FQ2VYeitxNmdVSWVQMzZVeldZZ0o1RGJlcTBPWlpuT1pmV0UwV3EyVWFWbXZhbnJhcWxjUnZQV043ZThtZGZwOWRHVktCNDJiV3RudmRub0xPWXo5SnVoY0o1dnA1SVpYWU92a0VnbEV2MWUvOUdqeDY5ODZoWE5TSnlmbmROVUlzT3d6V2t5QlE5QlVIVWRiTkMyWEl3TGpBOXEyMmhBU1VmNmd4SDhnWHF6QjlrbzVET3FKcG93Vzk1c1ozdXIzV2pEWlNxVWlwUHhGQWpGV0hCY3JOZnJ4amdKcEFSVXUxYXZyWmJMTkFIYm0rVUxlVW1SM1dCdVRpZVNuc1JSVUJCbHVHSzVWTVQzc3BrTXZiWjZhbUtNWUJBMGhSYTFBOVBIMEdKQWtWNG9aREhDSzJzVmFQcXRsNzl2UnFQTy9zUGhYOFl2d2dYVW9seU1Wc0xRRWtmMzNnWlBZOU1PSW9CSE1nMmhqVXhzNTk1NWU3dVVBVU9seHlkaThXeXhNT3NkemhLYlRrd2tUSVlQYXk4cENTR2FjUHRobE00UUppeFRXUWpoVFhLQ0h3Z0oyWnZRUGp3TjRiNEk5N2xYUHQxcGQwdWxJb1E2bmMzU3JaL0J3SFRvOWYrT1k5TXQrdEVFUkxEWDZRdXk0S0x6d0ZSc0oxZ3NGR0NYblR0a2J4Z0F1dWNYalUyaElITzV1Q0NDKzZKSk5IbHF2dmprNXo0VmRXY2prMHh0d0s2VUQ3ckQwa3FwM3g1b2h2cmNyVnNySzJ0MEg0cmp6T2tZOU02Zm80L29OYlkwY1cxQlQzS0FxOUJ6UFFLczZ5S2hHNzB1VVJTWWNsQU9LRjFCcG1kSGVyMFJyY2tveW9QZUFQcSswK3VndXpIR2NCYWhZdU1pTHl2cTZjazVlc1pJcHozSEJVdUdMZ01SaDJ4VXE5WDFqUTNiOGEvZnZJN2VJdXMwbThPazVQSjVjSUJHcmJHNXZRTDNZakFhSTZWZWI1SVdwRFVvNDNTL1RaUWVQM2gwOWNhMVRxUGQ2WXhielRwTmJnR0g2UTlxMWZyWW5MNzg4WS8xZXowd1B5aVIvYVBUMWRVVjlOdkIvZ21JVDQ2dHlhcnJpVTZudDdXOUFiV2F6dEJDOGx2YjI0UEJaRFpmZEhxVE9UMVV5YmM3dlFaa1Q5VkJSWWFqS1Fadk1wMUMzOUQwamtVVXJJOUhDK05jdjllQkl3UzdDbzBIb3hUaDZEM0puWFpiRmdYUUk4OXlIai9lUHo4NlV4T0ozV3VYSGo1NEdBSUhhaDVtR2Jna1pMQmxuRk9RMmhSTmxWRUwyL2xyejRiYW5VR2NBZWZEUUZzaG1KYVNBQWZnOHMzeTd2WDk5OTZZT1RZWGpWbmVySnpQRFUxTGsvZ2UzVkwzUm9QK3psclo4U1BGOG9vMWJtaUwrVmlyQkZRSVZZZWRnaFZJWCtEZnBPd1pZS0hId3hOZG5QS0M3Tk9IOWkvallRZ3pMbzlrZ2R2ZVdpK3RyeXFhbGsybFFVVmdnUlNORmx3UG5CbGRvNEkyaTNoMEsxV1NnVFZBRFVyNjB0VkxmWHFDazA5RFExajBSQ2s2SFJvVU1rbXJOSXBpTXFuQXRaSmwwYUhIb21uWnNLOS85ZXQ1WWhkMFIwZFdOVmoyMWZVMStKU0ZjaEhFN3ZyTm00QlVqSXZBQTV2UkV0bHpqbHRvaGdFY0hJQjB6dW1PSmhlajUwZnBjU0Y2TWlnQ3hVT1hVRndYS2tyWE5UaGJHK3RiNStmTlVqbURWblZhM1dxMVhpem1oTGc0R2sxQkhtQlZKMk5yRVFuR3d4SG8rQ0tnMThvSkFwZlE0ZkJOVzgzVzl1NDJSaFFXWWI0SVZsYno3UVpkZnRVMXRWR3ZvZVdsY2dXYWxlZWpFSGdvclVxbHJHc1N5QURPV0trVUlWU290NlFsU3BXMXltcko4eUtOUnIxVGI2aDhYQlZFMkRTMm1CODlYTGUvZjVSTkp1RC9vRkd5QXFOcVZqRHFyZ3Nqa0Vqb0hsdEozVGJOUXJuQ3NlbXZZSlE0dXQ4ZFdOTnBycGpjM05xWVd2WmdNQ3JrYVoxSGs2M01nVzU4L29VWFRHdWlTa0t6WHVOcG5lNFpCQlg5UHgwTmRGb1NncFlwMVRXRmo4VkthK1ZVS25uOTJSdWVQM3Z0MjYvUHZNV3RseitkS2xRVVBWTmEzLzFUUC84MzEzZHZRbTRmdlArT0pzdXdCSW0xNjgvK21iL2c4VXM4aFdwM0NYdTZkN09FRkV2RUJsUmZtQkFwcm03bzJmemgyOTljME5TaEtBaFN1VmhjMEd4Q3Z6dWlLL1JaSWJKV3FRU0xhTG15TmpoNVY4dHNqdU1HbTBKOGNTTDhVTUVVUXZhQ2Z6ckhNc0xJeWtYR2o4U1dIQWFCSlYvRVdhVzV2SkdGZzMvbG1SdTI3Y0lVcVlZMjZ2WmxWWXpMYW0vUWgwVWU5U2NKQTB4QWdINFNZdlMwLzkwUDdzWjRUcEJFcUU0aXhMb0IxZ0VGTE1zMDR4UWVmaXpHd3pnb0JKMm9wdW1TSWtMMXdyeUNJQUw5SUpHTmFtTjdkd2R5TXBsTXFxZW53OUVJcHJuZDdnejZQWC9tVE1aanNIWTRPbWNuNTRCRnZkYndNS296TUlzWjZEVTBLNXhSd0hjOEhxRkFuQkFHSjFmSVE1TGcrc0FpTmV1dHphM1YwWERTYW5WM2R0WXhBZ21OZS9UdzZNcVZIVEMxYnFjSFJ4a01HTFlGYm9CSTFtWmV5QmJoTmJMSjNBTkpFbHIxRm5RdGZEeHdEUFFYT0JKNks1MHlQTWQ3OE9nSm5GcTQ5WnFoNTlJNkhGNFFQajBoNWZLbGgvZWVpREFmbXBCSTB2UGRnaUMvOS83N25LU3NyQlczZHRlQjkyNjdCejZEVG9iMjRLTFIvWU9qQ0ZwWGhTa1lKT211RUYwN0FvZERrNmVUNmN5elcyMElHT2RhVm5rRi9BUU9ydWw2Q3pBTmEycmoyOUJWV0Jnd1BkZjJJQnV1WllNYldWTXJYOHhaazhrcm4vN1VuUS91cnhXSzQwNHZpTXpIcG9uZVBxdWVMNExaZERLNjkvNmoyMS84czVtMXZTLys1TS84MkgvK2YzcnVCMzcwRXovKzU1LzV3ZzhsVnJmWGJ0MWV2WG5yL002N3FwSC94RS85OWMzdisxekFYZ2RDQXh1aWpINElSVXU4ZlNRd1dJVzRJcHRmWE4vcHRHcWo2Z2xhQkZXU1N5ZWhUYlg0WW1nNkE0dWVKOWtxYUlKcUNLSkNzeis2SjBGNjI0bWhmMUEwUWZjakVBKy93Z2pVTzl1N1RLSXYxSWlTV0FaRUwzQitBZlJsbkhaem4vdjBLN3FSZ3NhQ2FSNE5ScnhJaitxaE56bEJoQndOeCtORWdnanhQSWhBS3JaMk5va2YrOEhVZGNBYU1mekpjUG9ybkI3MmZEdjBIR3dpaUFUQU92T0FRN3BHRDZVQ3BPS29HQmVGRHJNdCs4Yk5HekFDY0NLaHYybUFmWDh3Nk5GSzZqNU5vSC8rK2VjUER3NVJvU0NnYVkrUDk0K0I4M1E2NDFnMlhON056UzBvOWIyOVBjL3pEY09BbEtFbzJPNXVwd1B5RFk0dVNNS1RoL3NPM0lOcUxaTlBRMHJBYTdPNUFzMnNsTlhwY0FUdUVlZjRxTy9IQlI0a0J3ejdpNS8vNHN5YWx5cmxTcTd5K25mZWdLTktOMzJEQmNRcG55K0FsY0dVOVFkRHdOR2NtanRiYTVsYzVqLzgrOS9ORnpLcUlnZXpXYnM5UVBsZzM1bDhidWFBL2k2NEJZaTkzK2tORXluOTl1MGJrY2k4V20yeG16WXhNS3RDTVF2eU1CcE4ySDNyMk9IUjZTSXl0MXk3a001TUJrTkJsV0ZtVTJrRHZRN2ZtdWVGbmIzTEcydVYybm5WOGZ5a0lsWFdLN0M2YTZ2bGhLR2ZuSjZpODRHdkNTMXRPZDlZS1dQazg5bXN0d2pnYU5ITnFjZzhaZWljRVBjc1V4SUVEREdNdzhkLzVDKy85QmQvZHZPRmx4TWIyeTdkckFyQU9HY1lZOWdnREZtVWUrYjdmK0QyRC94cElWdGc1Q0gwUi9HSFgrSVZ0SEh4ODcyQjBvRThnaGF4Nk5qYTVXY2V2Zk8xeU5TQ3JZSml4Nmt5eVJRcWJNL21mZE8xSm5ZcHA0SkFsc3VWWHYxSldsYUhXcG10M3ZTaGhsNmVpbTB1TFFmYlpOVmhKMktiUkdwQ2F4T21zTEFFK3RMSHBueGNwVnlTRE0zelBSNkduNHYxK3dPWEZuMk44aUxORVkvSHVGR3ZCOTBhaVhPYXFrUWxjY0hGa3BsMHU5M09aTktTTEVQQkUxT2ttNk1ZZWlVdXhuR3k0WEFvMHZLREM2aXhlcjIydFpvY2pjekoxSkhwUmNIeFFyR2swaE9Od0JEZG9vT1UwM1V4eDRyVDlkY0lKSDFCUytkQ1RCWWcwQ2hjNE9Qd1VQT0ZITmlGS3N2Zy9kQWNjQ2hCWjhGaHdMOHoyU3lRQVRvMG5VN244MWtzd2h1NkRrSU42alFlalhYbzRXVGFEMmJRclAzK0VHNTBMcDhwVnlvemNMQllkTFd5QlFaWFdTOWF0dnZCblR1Ly9DdS81RXptblY1TFV6VkpwQ2RUNmY2QVpTVU5VSFFlWUVYODZvMnJvS2ZkVHYvSi9tRXluWVppanZQeDlZM0t3NGVQVzYxT29WZzRPVDdlUHppdXJLOHJzanFmUnpaMzFsSDV3eWNuNlRRdENBTzdOUnFQMXRiV21zMTJvWmduY3hEblZVV0x4dmpMbDdiaFVkeTUrMERYOVV3bVJScUxMc2prMzM3bnpjMzF6ZXJ4R2Z5cmplMGRTRGZFSEVVRmkvbmRCMCtncHhDUWlIRmRXYTNjdVh2LzVyTTM0V2RydWlyRW80NXI3NStjOGFLeVVpbWZIeC9ORnRHUC85Z3Z2UEtYZmc3Z0ppK1NzUStDQTAyeXdIRGdRMm8xeXNWOWhodGdCSnVVZ2FMMElTd3hHQ0VuVUxuVXdRUTMvSkNmeURKVDNiRmZWTlJNWmZmSmQvNklBeU9GT25SZFRVc2tOQVgrRFBxL081a0lSQ0NsSk9obUttRTJIaXFablVsY0k4MU54WVZhbktJQTh2TE15d2o5aDF5SzFaTFZnUWtKOHJQZEZPaFFGbWNGVUVidTQ3ZWZGK0pTSEJ4M1lnbzhuRGtGMmtrM0V0RDNvcXBnYk5vZ3dTdVZKMCtlcks2djNQM2d3ZFF5b2V4aGpOZFdLNFArZ0Z6UGdGWkI4andYeFJLWlFjZjVjR1hwVnF0bFdxcWlEc1pqeDFuUVJXaDZ2a2xVTkhHK2lQUUc1bkE4VUJRdFFqUGE0OUNqa0M0Z0Uyb2VCYUlhRWlUSDkrNC9ldkxKVDc4c0NVb2tpRUF4WlV1RmJxOExaeXZ3L2JXMTFWaVVtNW9XdXdIMEtKL1BRc3pBb0d4ckFnTUR2a3BMZE1kb3dpUFVNNndMNkZhYzV5RVYvVjQzeHNkc3h3WWhYdDBBNDYrKys5WjcwVGdIa3JDeHVWNHVscTdzUFBQZzBiMWdNZE1OSFZvYTlnUE96SlhyVzlPcEhmSG5KbHU2S0tFbkRvNU9nSlR4YU9yUDNJU1J1SFBuSGpxaFZDejZybnU0ZjZBbGsxZXVYWlpVY1RFUFlDa0Q5aXdpWEIzZlgzaWVrOG5RMGdiVDhRUTFnMlhsQlE0MWg0T3J5c3FnTi96azkzM2FTQ3FGbFZVZWpMOC9lSGoza1JBalgzRjdaMmYvK0dqWTdjMU14d3ZjeC9jZWVSQjBJSElSM2RwY25aZ2dRU2FrNk5hdEsrM09NTTdGQWE5aGI3Uyt2WTBjOW1UWUhreCsrRC85cjU3N2laK2tGUnd2d01Dd1RtZ2dvRERjNGk5VWlBaE1ITUtzREVYMHU0UVViVkVDU3cvamJJdmk0VkZzTTF1b3pCYnorcVAzMlJZdE5iZTF0dFlkRHNqbUxpSWdyak15Ty9GQ3JtQk5oNkxWOC9KWC9DaXQ1a0xaTDBxbXNsaTUrQW90RE9Ka2VhSjBJMm1aNFNLRUdlbkR6RktZRnY1d3o3OXdHMlFERkJDNEFRTGk0Q0dhQ3ZwTHhFUFhIdDU3a0V5b3hkVktZTTBzenlGclRKTmhBMFZUb0YzSnFVUi9nUHg0SGhodDRNMFVWUkhwT2RjWUVNYWF6TkhVMEFVdmdwV3lGK25QWjhIcjMzbXREL1hQM2pCaGFOcmhnd2NBSC94WGtIdW9LTWMyWlJsMWdMeGhzRHg0dm5DQzR3SzN0VnI4NE42amcvMkRScjBCeDZHWXk5Kzc5OUJJYXVCT2NJV1RDWDA4b3N2YnRtMkN1TXRTWE5GVlBnWWg0bEVOMzV1REJjRm5vT3V0RTNNeU5qMC9xS3l1RGdiams2UGpkQ2E1dXJaNmVYZjdwMy9xcC8vaC8vU1AvN05mL0t1Zi90d24zL3oyK3hPekEzMEVpNUZOSnpFMmFFeTczdG03ZW5VeG45Vk9XNVdOOWZyWk9kVHFkQXAzb2p1ZWp1QUdRRDJuYzhVbkg5ejE1OUhWalkxNUpPaDNPM0EyN3Q2NUgrSDRiTDdjYlhWZzJlN2R2Zi81SC9naStCTHdqcjEwSjNaT2J6cVl6V1liNnl2QklvYXp0QnFkNnVFeFhPZmVjTXhGT1QyUkNBSlBFeGF2ZmVlZFoyODlreThWbmh3Y0I3WXJhZEFta3doZFY1R2FqWFovTUlacjJPc04wVzk3bDNidTNiMjNzckVHRy9Yd3dRUFR0RDd4Z3ovejRrLy9EUHhXd3NFU0NBU05VTDhUakpaUmhCQXg5RVd4aThDeVU0UnA3NlV1aDRpQXQ0UmtHaDlHZDFnMndpWEoxZHJ1MWRiNTRiaHhEcG1kQlFGbFhnUm9sRGNMUEg4T2hiSXd4N2wwdXJ4YTZkWWVaN1RzU0NzeGE4SHFFd1oyWHZwbEpaTWFKOXhUQ2tzTWYranNWQzlXcXpCT05ZWEpZai9ZNEM1ZHZzeHprWlA5SjNRSDFQVVhYTVMySERpQW5tUEN3YytBTWJQRkhQM1piRzFyKzYyMzNrNG1EUXhNN2J3ZVFBbEhJc1BCR0F5WXJrS3FjaTZmaGRqQWZ6S25VNTllRFFoM1NvT3hKaGR6YXZMeE9MaXZJc210UmcvMkY3WlYxZlJPbzkxcnRTYjlmcjNWeU9YeVlQUEpaQUo4K3ZEZ2FIMTdhendjQjNPdjN4c2xrM295a1hRbjlQWVcyM0Z1UG5NZHJtQ1RIcFducS90d2Yrdm41NFdWQXVnSzZyYTV2VFlkVzNTM3k1dWgyY0FRZk9oR3M0Rm1vMmRUcVNUYWxTdmtRS1hhclRhOUNrK1JrUFBvNkFnSGZ2REJnODkrLzZmUm9uZmZmNmRXcTZIQ3NEenV6RDA4UElHTktCVXprUmdINk1zOFo1cU9UTmY5NkdIY2Nya01TSzF2YmNCWW9hcHdXVUFld084TlhScDBoL1ZxY3pBMGFSQWlDMUMxeWxxbDN4M2R1Zk5CSXFuRGh0KzVjOThQZkZtU2RWV0YrcWllbmovMzNFMDliV0I0M25qdE84ZlY2clBQUFJmbHVGVEtnSWs2Zm53QStwNHQ1alJaZnZzN2IrOXViM2Y3L2RGNEFzVmZ6QmVnVFh4Nm5pQ0dYZy9tL3NuSnFXMmlIOFRIanc5KzRHZCtxWHo5WTYvOHhiODhvMFZSeVFqUFE5NkN3SkR5RkRwUHczSVBRdzBoaVlVbHpWZ0tCYjRvQWFoRVhqSUxZVGF5RFVqSE5qRWRaSURTV2J2eTNORzlOK2FXU2ZPeHpRa0dVUkpnNUdudThTSllRRE5GQTN0OWZZdXUzSFdPcGZKVk02Nnc4NFFudWdqTXNFRFMySWsvREdFTnFRcElaVUpDcHlXQVU0eit3bU9nZlY5NDRmYWcwMWMwSGNvbWxVZ2M3aC9KbWd3Rm1Fbm5wNmFaU1dyVHdTQzNXbzVHb0QrRWs3UHpWRHJaN1E3QW9Xa1dJYUVCc0d1TnhtUExuQUpKOUdRZFBiUUxoazF5TGRGeWVUUHF0MFVFZGdQZ2FEVGJWMjllS3hieWp1ZG9Pa2gxQnFEZlhDM2N2UHhjczlzRnZzSHBYZHVubFZzRVZKeURVc2FCRnJTeWJSbEpBeW1iVzl1ajRZUTlyeVFWQ2xuSUd4OEhZd21HZ3o3TmNKU2t6bURVcURlUGowK0pQTmowQW94c0lZdWVCeTZoN2dYMlRsTjBOMFFPOGduWEU1UUhJQjZQeC8veFAzNUZvTVVsNWYvN3IvMTM5ckFqcVFhVWF6NmZobDg0TVIwMnVkd0dLYUpxRUUrelk3SEllTkNmeDJMQTYwc3Z2dkRnNFdOb0x6anNyVTUzd2FZWVFhY0lBcit4c1hsMGNMeDNhUXRrNmRLVkhmako4TXplZWZQZFpEcVZ6ZVVhOVRwMHltUTZMWlVMcVBCb2FuZmFMVjNSOWorNGkyNGIyMjcxOU5RYzlTdXJLeXNyV1JoRTZCMDA5c3FOSzNNUDd1Z2NQbzVEeXk2WWxtUHQ3RzdYYXcwdXp2ZjZQU2dndW9BekF5ZU4vTUt2L2I5dS9QQ1BydHg0SmxnKzQwOGpqd2dES0RDQWYxS1hCSndRSU96ek5JVDVvUmt2dEdxb1Y2UHdLUm1vMldFRUxrcGtDamxNUTJEbHNJK29LTVd0YTlYN2I4NWRGNGZCOElLTTZldzlzcUEwcnUrWFUvcjI5blorYmF2ZDcyUVdscGZhZE9tMUxuUXNzTW9pck1Ud2x5cnhZV0NtSVB4ak1aWWovQkMzcGtxRk9hTGM1ZDBkTUhSb0JTaG1JMlVrRXVsT3UrUGFkaTZmbXJ2VWo3QTlybVdmSHAwTFV1VCt2ZjFzSmhWWjBJdjE0TlNLY1FHYUFqVEdkdUNCYWRETlFEUlVJODJzRHVBS3pXcU51dWM2UUgrbjNWN2ZBTldtOTZSV3o4L3poVHlrQWZrVlNRQ2hINDZuaGJVeTJCUjROc2dQV0d5NzNUdXZWUzlkdXFTb2VyZlRXVit2UUJMbUhOUUJ2WDZZNTNsVWJEZ2VwWlAwaWdHTUJ6MzRNK2pEWWlocUFrUjh0VktDczBWdm9sUnBFUUZVaFNkV3cwM0dreWliRVFUV1BwNU1RTmc4ZHdZM1lYMXQ1L2o0bkY2R01mZmJuVGI2MTdJbVdzS29WSXFLcXRhcnRjRndqSjVFdDZIVW1lMWV2bllGblhmL3dVUFlvbm13MEZRZFNoWmFmM3VqMHFxM0VWbmYyZXAxaHNWQ0Zsd0lqTVZ6NklvaHg4Zmc5RDk4OEFqaWRmUFdNekE3alVZemtVaWNucDd3Z3JSU3pISU1OSVZzQWVCNDlPRGhhR0t0VmlxNVZESVdWM3hyd2t1OHFPdWI4QzFXUzJmVldtV2wyS3QzNFAraEo5MlpEemNwbGFSTHBib0tERmtZOEdJK0o2blovL0pmL3dkamE1czVVNHNRb0lRSkFpNkREckhiRHpIeWZ4QytaejlpUy9kMEdaQkVnQ09OenJROEV5WEt3SVNERGtFaWRoalpRcTY4TmpoNU1IY3NsRUxxTmdvbEtLRHljRCtDbVo5UGFaWDF5dHJWMi92di9WRk96MHkwbFRuQmxmR21zQ0FXMkVtL0oxRGFoeldrbE5EVVVCTCtTVnJEcndpM3Q3ZUhZUkRGT0R3NVJHaEdOUytXU3ZsK20xYnpxYmU3RC9jUENrbk5NWjBJejIxVzFnaGs5RTQ4dTFnb3ppMjMxZStra2ltTjNwYVlkV2daQWhnSk01R2t0OTdoRE8rLytYYTczYkpzQzZmTzVYTlFlT2dxejNadjNYNjIyKzVxbWdwMmdRcEJvVFliOWRGb1NKY1U0L1RFZThKSXNjdlNRYnREZDAvQm9jRTY3bnh3MzBnWUtFclJsY3JLeXNON2orS0tHSmxINjdXcUVCY09qMDdvUlh5dWxjdm5ZVEVNSS9IR2Q5Nk1CRUd6MFlRVExNcmdXam1nT1p0S29aNk9aOU1OeTNZUFJDVXlqMVZyMVh5NUVIak82ZkVwcFBUMDlCUW5zaDJyZFhadXBPamVMUWhES3BuSTU1TEQ0WFQzOHU1MFBHNjNPakFJWFppK1FnblVZR3Q3ZFhPallvOG5oV0ltbTh0LzhNRUhBSDFjRXVyblZUREg4a3BsN3M5MnJ1NjVsaFhuQlBUUDNidDMwYWhpdWFpSTBzSCtNWlFEZkFtY3FOdnRycXl2d0ZmQjBJQXNHaWtkdk92eGt5ZTI2eVdTMllTaDZpbVMvMW5nQ3JJNjduVEdjQzJTeWVaZ0FBUkRteno3ek0yZDdWV29UTThYcm4veUIzL2lWLzl1UEkvcWtVckF5Tk0zRFQ5VGx3d1hJVGdZV3Rndisza2FLSjFTQ0hCUHMzeVlpOFZEQVdKcWZabENwUlBjNkF1Q0hRSU4yUUg2UkdHMXRMVTNicDhFMW9TTHhWM2l5UXFjYlMrWXc2TVFveEZSaUcxdGJNajV5dWpSdDdUTXVpVWxhVG9BQ2x6Vzl1blBoNEdxeUQ1MFpvcXdVNU5xb3NxRXRhT2RMSEEzcmw2RHZnVFI3bmY3MXBoZTZBVWVOZXgxYmw2N3RQQWpqdXMyT3AxTUtyRmFMSTFINDVFMTdmYjZmSnhIR1RBSTJXUmlNalZkVUh6ZDZEUmJjWm5XRHdoOGY5QWZ3RldpVlhNdDE1cVlNQVcyVFRORFVIR3c5MFF5Q1JwUXlHYzc3YTZxMCtwMjhDZ0JRYlNjdllZMUlvb0N6RFQ0ZDM4OExPWHl5WFNXNHlJZzZNZUhKLzFlMS9OY3NLYVRrM05BQkczYTJGaUZmYzhWOHVnK1NCM1BjUURUb0RkR0N5VkJ5QmdhTFBXY1JLTGU3clJ1M3J3QjZnTHBhclhwRFZCd0xlSXhEcElCRlp3dzZOZzRyVWpzZGZ0RDJ6UmI5ZVo0YlBZSGc3VzFGWE04eldWcDBYUzR1WVZpYmt4TGQ0REkwZnNmV2MzcGx2T3cxOHRsYy8xNmV6Z2FuVlJyc0VpR3BMWHFyVUtsdkhOcGJ6RHNIRDdlTDViSzREZW81OW5aR1N4Z0twWCs1amUvbGM3a1RNc0VTcDQ4ZnBKSUpHRzRJRTZxVG12dnBIVDlnL2Z2Z25SQjNzNU96aUNtT0RXTWJiUFdLcTZ2d1prZmp1SFEwQXVCL01VY0luTDk1c2ZhcHJENzB1ZC83di94RDY1ODluTzhSZ3Z0WXF5WGVHZi9oQUNHQnZvUWVCZ2NhQmZoSXd3TUtvenlVbUNBWThJU0hoVCtncTRpT2N4SmtRczVZditzTklvUjJwSE1EcWJENUV4aDlkSnRxM215Y0tjMFQ4bnowcnFPK2tmbkM5ZHo1RWdrbGM4VjE2K09SazF0ZU9hbGRseGVDZzlGV0o3bVQ0U3diZmlsczdINjRKZWRQS3hPV0JVU2VYZ1JOMjdjR0UvcGhjdHdzOHlKQ1d5QWtBQjVrVVZ3Zmw2SHNuSDkyZUY1VGRhVVJxUFY3dmJHcGttbzRqbFJsQkdING16V20vbGlWcWVuY3ZxQUlLZzJGSnR0MjVsYzZ2WUxMM2JPbXhFdTB1djM2U2JJeG9adUpPakdrQkNIb28zRmVMQVQ5dGcxVVIvRUpVM2xJMUhJRlZTVkF3UndzV3doVXloa0RnOFBGRmxwdFZxREFSR25Xclc2dmJNSnc1MHZGb0FEbm84REVHRGptVXdxblU2NXRubjkraDQwWEVLVFVybU12MWlrMDhudDdhMTZ2VFVlOVRPNWRJU0w1WEtGMnVrcFZHYXVrSVhzZ1QxalVFK09EdUZLcHpJcGNCNjR2T0JkbDNiM1RxdTFSRUtGaXRVTU9jclJteGJaak5FWTNlVmxzNUhoS3BmS09iUUNyazVoZFNVV2wrcTEyc3A2cFQ4WTNYN3g1dXJXUnF2UkdRMzdEdlE2eUJNSFRiR0Ezd0FUZDNaV1hTbURkRVhEeCtweUZETEQ0YUNReTBGaXA1WUxOcExPSmg0OGVMQmFXWW1Ed01XNFdxTmRQYStCaTBuMDh0Zkl3ZkhwNXM1R2IwQ0xUOEZDcis2OStLVy85U3UzZi93bktzL2Nna2NLaW9BUlhtS0JrTUFnZ0pTTEcvV2tEU2xwK1dFWmdPendRNGVFaWNzditxVVNFTUxpQU9NTE9XQmJKRU00a2hXejVDQXNKLzFRRVFBYzIxN0VkV1B0eXZNcVBTM2hnK3RDdlNxeVNrOTVSbU1LSDdVbncwakV2L1h5Ri9ZLytHTWp3azNUbTNRWUsvZ2kwUFl5aWhncm42b1Jub2pXNVdNSitLWlRMczhlN3VNdVg3NE1tRUxWZ1ljSXNqaVpUTUdsNkFaTnM3Ti9lS1RLYW04OGlYRFI4MnFONWdid1hDcVJSR3ZBV0lncGVyU3krMGE1Y25CMEJOZVRYbTRLdjd2WEE2TXA1dk8wMkNjZjNiNjAyKy9RK3dWd1R0aDdqbGFMOWp1OVRyNVFoRkJ4VWNFMkhhREhzcWJ4ZUJ4TUNHU0dGK0pzVnFEVEd3NnNxWGw0ZEFBb2QxcU5mQzRES2c5YmxFMm40ZERDVUxqZVRGUGtVWC9BQ2J4SHR6RG9lVDlWa1NWYTdtYk04d0pzRVdvTmx4cCtna2tMOUkxOWYyWm85SUE1U1VZNkNjNEFOK09sbDU5LzgrdHZyS3l0bngyZm9pM3dPUE8wdEV3ZUIxYXJWVWppMmNsNXQ5dUhaekdkMmxEbndUd0NMeGFFQjkycHl5TE9vdENMd1Rnb2xLbHRKWFgxalRmZXdua1hBVGsvNkM2NEc2MTJIekxaYWpaYzlLL3ZRNCswbXUyZDNRMWFaY1NEYWc2MmQ3ZlB6MnF3bklWaWdlYmhPaDd5TkZzZEFFY1dKUnNHeUhIaDZlcXFjbm9HUDByVUUzcTFXZ2RRTk0xWUxaZC84ai8vKzEvOHBWOEN6d05KbzZ2RFN6QWdRbEc0empUZ2JPQVplcGpsWjBvWFd4ZnBsQ01NVHhQcEU0b01tdnFSWXArR3NBU214Si91Sm1TeEtPMUJaQTRQbVFrRGd5VTdSRmJUTzlkVzlwN05KRk8rTTVWMUE5SXhud2RUZTZyR29uQ3o0cUpVMmIxZWYrOFB0Y3lPbzZUcGVGWTcxSkYrTHM2TGdHK3lNbUh6aU02RWFaU1JuUlc3UHBSS2JtTnJLNTB3UURTZ1l1a0JQUFpza1RteE1wa01mTXAwTmczZmNXdHpYWkdVZHJmdkFEU1dSWXY4UmVaUVF0RGlJd0FvTXF1VUs2cEc0Rk0wSlp2TmNUR2FmQklYK1dReVpUdXpGMTU2d1JwUFlJaFZUVVZwQWg5L2RQOUJPcDh6a3VsME51WFJTcnowQkJ6TitjV1I4VGlBQy9jeGs4M1NyRjI2WGhZWkRRZVpiRVpTNk5Ha3k1ZDNkQVZzcEpYTVpNNVB6aGQ4Vk9lRjRhQVBMWTV5NEk2eFMrd1dzQWoxZkg1ZWhTU2pZS2lTT1Z5aWVhVFJicHVUQ2JRNFVBdExDb0VFZ1hJOWUvdlNKajJlTFV1bDBvb0FaMWprd2JMZ1RVSitWaXRyRWg4ZmpNWWNGNU5wZlM4NGdsRXdKU09aUVA1V3RRYjhEa2IwTHFlRUxsdTlYcVBWYS9jSEs2dVZjcm1ZeWVWUFRtdndkMEdjdXEzdXJkdlBvZE9iSjlYRHd4UEl6ZmJ1VHJjejJOblpvamxCcmlkSzlNRGI1dTdteWVFWkxCTGtFR3BsWmFVb2lCS3FPckVjWUtLU1RRV21GOHptVHc2UFVtbXdvZHhnTlBCblFhcTBrNzU4blJsMk51UkxWQ0FnUmhlZTJaQXpZc0ZDdUkrMkdETG9seDF6Y1JpRUFtWFJoNlVzd2lMb01pYkxHbXJ4OEVNNEppeXhVcGhhWjF2ME9Ed3JrREl4d05OV21CRWZlcFdBbGtodjdPVzNieWpwUEQycHdFdG1FQjMwdXNXMHprWG5sYzNMUTNzWTcrd0grUnN6WHZpSU5MSmZRalk3SDRxNjJIRVJQdHhGTVRvZlM0SjJ6K2Z5SXQxOVhEaDBSV2pCYzFHWmkyWjBwWDVlODEwdkpncVh0cllOUXk0VkM5WUl3d3dacDdjZVlBenkyWnpqMG1KL1BDZDBPbDNvVGh3T0RqQmZCSlB4Q0syam0xRHphSzZZemVReW1xTHpzVVdNRng0K2ZEaVArdXNyRlZyNEhoanFkb2VEWWF2VDJ0emE2UGNISUJFd2tETFVzd1E0U1RBek9rbVJNK2lQQzRYc0hJTGxRdDdNbGRVOFZDbkVaZ1RQd1RSblFVQjJVTkhIazRtbTBVSXgzVGF0c1VFUGkxaVdUTTdRQXBSRFpvdGFLcklHRHhXRUJMMmlxbHEzMzdkTWVqaXcxK21mbnRmQm1FR3YwS0ptcTQzbUFDaWdXQkFMV1JMUkl2Z1lzaXpCRmNhdVZGSWY5WHFTd0owMzJwM1JDR3lrMnh1dUZiSXdaWnpJOVViVFVqRmJLS1JuQVdkWkZzOUhORU92MTFyNVFxN1Q2aVJ5K1VRNlZhODNKU0crZDJVM21VcDk5enR2YWttREUySndJY3lwQlRRUGFRWHdHY1QvNVBTMFVpd3Vnb0NUNE9oSENxVU1QWGliaHhTZHdlc1FaWHJ3S2lhVXZ2Q2YvczBvVytZM0RFdnZsSTB4RzN0Q0xtMCt4Y3hIUXBpRURDRXN3a0Q1MlRhbFlJTjFCN0JNdnl4YzdMLzRXWjRwM0kxSXFGUFpoL0xRRHhrSStxV3NyTWpJZ3VQamlWU2lzcVhsVjFldXZiajdzUy9jZi9CVzgreGtkN1VrS2VMVjU3L3ZmUCtOcENoUEUyc2tKMkVJQy94d213SXJkQmtRb2FvdW93amhxWWpDY1ovNzlDZVRjYTdhb1VVdlJJN1BhaEw4MC9FRW1sZ0JYTVdFTVIwT3M5blV1RC8wQXI4L0djTjBEb1lEei9WU3lkUjBPcTJBclVaam1XeTZlbGFGUVFlQStyMEJaQUJHZ0dZZXpXZFFucFBKaUo0Q2NUMlFwWHdtOS9ycmJ4UkxCZHVhNmJvU2pjU0hvOTZNSG9VZUF1aUJ2NEFua0NzVTBGbU9aVWRqdkcxNTU2Zm5IQi81MUtjL3Jtc2FuTWtCdkxQSmRIT3pRcFBqYVIzcWVZSHVHUUVZc2RPVHMxS3BBTWRnWTJNZG9yYndBOU9tU1dPYXJtZHpkRUZHNGpsNmVZRW9MWUlGcURZRWtsNlFKQW1Hb1lOY3VUWXRuZzUzRllWYjB4SDA2NU1uaDlEbGlxYUJiTURoQnU0aGhMQmc5KzdlaDdXWlRxYm9scFNoZHZzVHVrRHBPdFZhczV6UGMzSzgyeHRsTW1rUzBYbWszKy9OZzhYWmVRMjhhK2Z5NWZHZ3I2cGlNcW5IT0JGNklaZFBQYmo3OE9ZejExLy96cHVqYnUvU3BjczRoSzI5RXowOXJkNisvVXl0MnRRTkdkUzIyZW1CNnVieVJSRU1VcEVTQmowSk1PNzBMbi9pUjMvcTcvK2FUMWluMFVVaURTK2lCS253bHdJREFLR1BNZmZsaDNhelNCaUFTUnlMd0I3VVcyNlJZbDRXZElIMWkwUHdIZWIvOEtvOElFVTVtRFpuZStnVEhrdkhVQVp5bkVQSWhqd0ptV05SS1pHU01oa2xrMW05L054N3I3LzY2TkdqeTV0cks1WFZoYXJPYW5lNHhMWXRxTWpNVEFjWkdqcU92bGlBRW41YUUvemdROW1XOVZ5bXMyTzR0ZlYxTGk2Q2pFWmp0TzdYcEQvS3JWWW1kRjlubWltbU1maUR3VEJmTHRSUEdrOU9qMjNQQmNyQmdCMlhGcVJGK3lSVk51bHRocFAxalhVZmhKcXVjTWNsVllsQmh5L21wbW5CLytwVUczQnFMKzFlYWRYcStVS20zZWlOekVrcW1VMm1EWHBodEM1Z2dLQTRhVFlZMUxvZ3c2TWJEWWVKVEFxOVBwcE9MKzNzalFmanFXV3hDUXRnTExRZWR5S2xnbXNJY1pEVkpOd0dtRWI0ckIvNytBdGc3WWY3QjJCS2cyNC9GaGQwdUt2UThqd3RFMEljU2RlSG81RWZ6R2hhdml5bk0xbFpFQlZWZnZhNVM1MXVMNWxPeldhZXJodnp5R3d4Q3lycmxkcDVBd3dJM2dLTXlhRGZkMkhPRmd2NEZ1bGt4clNKeFo5VTY0WWtCTkVZK0l3Tm1oZmxpaXZGWnJjTHh3T0VDcWg5Y085eHNaRFRFOGJaMGVsNE9ybDg0MGF2MTJuWG11N0U3dlY3NVpVVmNMeDJ1d2Q0RGJvOXVra0xMdWY1czdtTCtrTnRCOEVza1NDK2h6SHpaNUZnNXBWWGltTnpBcVdReWFiUVN4Lzd2aC84MUgvMks3TjVqQzJNUWFDazBiMEFBb05mdU1YWUI2VXNGVC9oSU15TWVQaHpFWjVtSU5nekpZcHlrTVJLWXhoYVJzSW9oVkIzNGcrUVFFNkMyakpRY3ZpaFl5N0twZExvUTh5YXRpbHBXUWt0bWE3czNIai91MTk3OVJ2ZmpDNW0xNTU5L3NuOWQ4cFMxRTV1enlCVXdFQ1lqLzFDaGxoQ21QYTBlQVJVZ1pwOGtabk9UVEM3ZWVzR2FNekVOTk5aQS9vMVZ5cWh0M3VOcHNCejV0Z2FkL3YwL3U4Rm5DM2g0UGpNOVQxb05LQUhoM2Q3R0tRNU5MVHZ6cnpaYkREb0ZndkZYcThIM1E4T0RZVUtXd3cxMUc2MVJWSDAzRmx4cFpSSXAzdjBZTWM2SE5BZitwRWZncGYyNmgrOHlpMzhiMzdqMjRWU1FSQ0l4ZVFMV1RhcHkzZk5LVHcybXBrb2M2bFU2bmovMUhNOHk2RzNKTkNWVGRQcXRvZThDSTNyMEJPeDlHWlFXc0lPVkNkZktJQ1owTE1kSXEyK3JTbWlwdEtDWlAzK0VCMEFIZzhRY1h3TXhDYnczT0ZvWEZuTlpkTTZ5REhJUFZ5SFJxMTVkbFROVjhwblJ3MU5UNmFUU2RpSmNyRzBzcktpQ1hLdjM4OFY4b0lZaHlhT2NyRmd2aGhPcDVsc3J0M3BZbXlCMW5hM04rZ05mRnBHYTk3cERqUk5reVM2b1R6cWRRK09UMWRXeXJCRDRZMDJTR0N2MjAxbk0rMVdKNVhTSlpvRkZsTTAvZnowNU9Ub0NEME1Bd3ZQV0NISmxPZ2RrWWtFek1KZzBMdDhhUS9weDRlSHB1VmMvZVFQNWE3ZXBGbGlhQ3JwT0Ria0FBRzJhWVRERk1RWThHZ252aGtNMlgrNHdkUXkyOGNDeFpiZ28rTVJhQzlsWVQvNE1Ca0lyUVRUdE5qQmZBSldJTXRKVUVQNmhiQlFLbk1qYWNmRjlVcmFoUzA2aE1Vb1A2RjNZV1FMNWUyYkovZmVmdjNicjcvOTNUZk9UODV1YnBaMFZaM0krVkN4MHo4MWtCM3pGTkpVWjRxekhHd2ZpNkF2c0JGbTR0Ylgxb0Z5dW5vNEN4cm5MWGh1Z2lSWlk0dUxMVGhKekdWeVJrS2o1YURvK2ZuSjJESnhIRDNxenRIa1cwQXRuMC9KQ3IyTzdPUzgzaDhNNlFsUlZlZTRxQ0lKMEhZdVBjTTZuMHluQ2QwWTludXlLaVZ6YVRZSE9EZVBCSlBKZUdWbDlaMzM3cno0L0l0d1ZPQUh3Nzg4UDZ1NXJnV1BMWjFKRXI0dDJ6VE5SU3hXTEpYOVlBRUxNQm9QWDN6cE9VVVVwOU1KbkJzNGVhRHVNMzkyOCtiVnhubDdOdk5sVWZBOE94Nm42NkhSUlZETXBZSVpQVmxDYjhXejZCMFY2Q0JSRkd4d0d6YkxZSXAwY3lKTHl0YnVwbW5aenozemJDWlhOTTNwMUtTWEZYTWlueVV4SHNDb0N5SnYyemJZVHZpZ2t4czQ2RWtqbVVvYUtyZytxSnNraVdnZHhOVklKTUMxQUlrNXJZMnNEM3Y5d0tWN1ZXbE5TZVF6azlIVUJUMmYrMEk4Tmh5TSsvMCtMYWJITFM1ZjJZVmZVY2psZEMxSnQ4Sm1zNmxsRndyNVRxdTl0N1cxdGJOaGpxWkJoTllXUHRnL1FJdXlwZXMvL0t2L0ZiM0paRG5vR0ZaQ0VodFpCTnE4K05DNFA0MGpoQ3Fjd1JISHM0UERRRHN2NHBTZElaZ08rNU1GQTBSTUdnQmVZdlFmN2wzR0tOT0hZaENtUEMyUm1Rc2s0RHY4SUxCSStCZEo1SXJyMTU0L1A3alhQYTJpcTBRK3NwbVRJbHJGaXN1VWVTa2o0VUhoNzBXRUJXelFhVWgyaUgyRkthVGRWd3A1ZEJ3cUJmNnRhbXJ6N0J4b3ptVlRNOGRONXJPMHBPMllKdGxGWWh6ODBhbmwwQzFZZW80SnZoUHNaeVNUekRRNm5XZWV2UW5Cckt4V0lMa1FZT3lTUlFtMEI4WjlOdmNyS3hYd0FYRFpYcWZIOHdMUUQrbHF0L29RQnN1WmJtOXZHYWswaHBCa1l6R1g0K0xweWJtcWFkMXV6ekFTTGppQlpjSjUyTnJlT2p3NHp1VXlzT3l4aUEvZm1wY1ZQWldDU3dBdHZiVzlpbFpVNkczb2FCYjh6aDdzQU1nVjZMV2lDSkRlR0FlTWlwSWlKdzBEOGdPRDRMSjFnTkh3UWpIZmFyWnUzTHdzQ2p3Y2NjdHlIdHk5WjF2MmVEUWFUVVpuSjZkUVM1VktxZE5zMjVZSktEOTZ1TjlzdE9aUk9MSEJjQUNabmR5NGVRMCtBT0RKbHR5UVBjY3BsUXN6U0I3TlBBNlNldEtrMlpxR3JPa3I2eXY5VHE5MmZJSVJRQysxT3ozNEE2aFhPcVZQcGxaa3djTjF6NVh5NVVyaGd6dDM1OUVZWGV5Q3orRE1KRDUyZkh5MFVpN3ZIeHhOSFJQYTU1bnYrek4vN3IvNXRSbWIvUitPTVF0c2hFbVZVaUJjRWFpV09jSmxSVEZDaUxQOXBHdEpTYk5BMkNXSTREODhqaDBaUnRnZWRsaTQ5V0Znc0tYZmorNUNXbGptVXFwWUlHTDBkR09aakcvS2krOFk2V0JLREl0QlpqV2RLZTFldi8vYTc4M2QrWGcwdnJxenBuTHptYkVCOFE1em9XdzY0Q05BcHdRbWdtRUlZK0U1d2t6Y2VxbE1MNVlCOVhSZE9HU2dIRURKZURnU2RZMlB4UWlDVWQ0Y1RneE5pVWRqMEY3RENTMW5CL3VPekR5OExkaHBTUVFJb0FoNy9RRjRqdWU1NFVRcktPWkxsL1k2elU2MzN3Yzd5UmR6NXRUT3IrVG5ydGRzTnZrNDMycTJVK2trRGh4Mk9sQjE4SFFCZC9EWFZEb05Pak1hVG5FNlZMbmJCbllCdm5HeFVKaU14OUN5Ky9jZmNZdUZyQ2NmMzNzQVF3K0hiemdjWndzWkRMSTdjM2xPQUNtSC9vT0NMNVJMc3FvNThDRzZ2WEJwWUdoeVJkRTlQd0Fnd0swaEpNN1VmTHgvb210eUxwOXB0cnJUNFNDcEorS3lyTVQ0aDQvM2dWbXdua2F6bVdhdkNvVGdyNitVZ0FuYnRTRXpoVUpwTXBuUUs5azByWHJla0RRTkJBdzk2OEFUQitzUDVrS2NvNldtUEcvanh2WDc5eC9zNzhNRE9rMW5NdWczMTUvQjc2ODMyNUlvZ0JOQ2ttL2Nmdkgrdlh1eHhkdzJuVmE3RFVha1NOSkdlU1VTTEF4RGc3bXhKK1p6THp6bldiTjBPcDNLcjI5OC9KT2tpU2dRd2xtRWdJWXZTZzNCUUVrWEE4OStRb0NHZ0E0QkU4YVhZYWwyUTd6U0VTUWV5TERFKzU4TXkwVDJ3dzZoc055OFNMOEliTmV5TG1IQXVmQkJDak16VEdTZUNnamllaUxsVGtmTncwZEk5V2ZlamN0cmk1aHVTYWtsenIrM3JEQXdFYVkyL0lsenNRdXBFZTdXamVzUk4rQ2pFVjRRUkZtaytUQ2pxUzd4R09hWVA0ZXkxRE5KWFJRY2srNlNLdEZZQXk0Z2NCT0pycFZMeFh4UzFnejRjR2tvNDE1dk9yR20xZ1NHRFV5QW5TOEczSytzVkdiT2JBeTBqa2ZReFBWcVE1TWxjSjU2dlFsdVVDd1ZvWGVuNDBrMEhsTmtaVFNDTEduQm5GWlBMcFh5Z2UrMzJ6VHhpNHZ4ZEUwOUVpbVVjMC91UCs0TWhxS2lEd2I5M2QxdE9KZFA5ZzloRGRBOGxBK05teTJrSVRtdTZZQm5hN28ySG93S2xUSzhpRGtINzBCYytITmFHb0c5Z0hjNEhCMGZuNlRUZE45K0hvbGR2L0dzSEVsMVdnMDRJOGkxdXJVQnAyUk1qNDNTbEdabzRzMk5OZHZ4UnFQcFNybFFQYStDL2pWcFBsbk1NUFJMbDNaT1RzOVJMaTE5aXdPOEdiQ09Wc0FuemtKUVZMbDJkdEp1TmREdFNPLzBlZ2xhYVBMeHhzYUdaWnJGUWhhZVF5YVhIblRhcnUyQTZXWHpHUWhMbzlGTWEvcjY1anJQYzZQKzRLUmV4UWluTUJyd2lMcnRSRGE5OS9IUDBzdW9xYXR4cXFkNHBBZ05MZzAzL1JObUx6Q0lEMDBVWTZENEVGamhnUi9CR1FzZjJXUkpGK2tVb1RqTHozZy90a25ZRUZzZXcrTGhIaUlUTEN6VHcyT1htK0ZPaXJIclA4dWpsMEtJLzFoc2JlL1dwTjhZMXM4andUeWJUcXhrMUVESjIxR2V4QnhuUUU1R2JIQmlLaWdzQ3k1d2pNd2JLNE5Ta1llS0I5eGZldWtGVmFkVkdrR3lPWjZEODVUTXByRUhIaVRBTVI0UjNZVWVSUldzeVRTWFRNTHk3cCtmNnduTnNUMUFPRmpNNFpWaXREUmQyVnBkZS96a1FKSWtuQ09SMEgzMmlza3hyVmNmMVZRbG1Vd3gvc0FQUjBPQUtaRklIeDRjeUtwTUQxdXc5d2tQaHdPWlhuUVJwV2Q4Wmk0NEZXb09QbE03cnhVclJaaCtzQXNvTTJ0czdsMjVwR3ZHcEQ4R3VHdm5EUmkrWnJOMTZmSk9MQXFDSTd1MjY5Z3U3QXc4UnpRYjNCZGtiZXE0WUJibXhJWm5VcXZYZ1hXVUQwa281clAxYWowUzR3MDlrVENVYkQ3OTFodHZYTHQyT2ZDODl6NjQ1MWhXUHBlRGRZS0lncU5Ea1ZjcVpUaW1zRGJnRmNQQkVENzNBQjczZURMbzkvZ1lEMmFEbnA3N2N5NFdneHlpSDhDL2JXdWFORFJVRzRlZy9LU1JnQThOVlkyNkRZZkRWREl0eG5ueXFoZXhZamxIVFpEaXdEZFk0dEhSQ1h4aTJ6RmJ6VVpDbGNkRHN6MGNDUUlNRW14YjBLeWVQLy81SDF5SUNrQVJVbVFhNkRDRXNkQTNwTUZubzc0a09QaGxFVVpxdy9BVTkyR2d3MEo0MExVd0hBbDVDVE9BRFRIc0xBTkZVRDVTbVFWZ2FlSEp3MzBzUXZIdktUODhLZ3pMOUZCS2NKcnZ6VXlSV0p5dkFQSHQwN2s1QXJPOWR1T3FJdkpEemdoWUdVL0xvZ1BacWNNdStONEdJVkRaMk0xQkU0cTZDc09xMG5xY015TnBkSnV0R0JSd0lqVWVEakdFYWpxdEpmV1l4RWY4QlhUa2VpRU4wTlI3QTBVV0RGM0hlYnlacnh2YVpEZzJFbnBDMGFxdGx1ZXpCWFYxbzFSYWlmcVJack1CQmkveWNYY0d5RTZnK3g4K2VyS3l0aEtMOEkxbUErcFdFdUhoY2E3clFHWW1kSHVTeitleTlQb05qdDdaaExFZkR5ZXlwclFiclhRbVZTaXRRSTdnSDJieStkSkt3UjZiN2U3QTgyZUNDTEdDNGVHSldFR0JSNk9XN2FaVEtkZXlmSHFnMW9ha1FWb0dvL0ZwdFlwaWtYbDlZN1ZjS1NaMUphSHBsMjljZlhqL3NUbnBYcjkyYXppMWFxZG5rS0pNT2ptZ1daWmV2bENZZVc2d29HZlBnbUNHbm9YRG1rMmxZUU0xUlFNYktaY0wvUkhSZDhnWWlDZWI1ZTlqNUlBWElKNjRIOXlWYnUrOFdzc1ZzbkUrZm5wYVplNysvTm5yVjFSUmlpSXBMdExWZ21yTDhSdzRyd2VIUjYxV0c4UlM1UG5lWURDWm10ZWZ1VmF0Vjhmak1ZWnpNQmlJY2ZtbFAvM1RFU0Y4elF2OUE4OHcyVXpoc2xGbmwva0FiUnBvOXFFME51cjRzRjhHa1dVcUM0UU03RVd0R1pDWVlTQXdMcDYrMFRROEc0V2xCV0ZmeU1CeWhudklINkE5N0ZBNmhKMHN4SEVvTFI5aW1ucG9HWG1haHhLWGdVcm5KV24xOG0xdk9veTRFMGtRTnpmWFpndCtFaEVqNkZaMlNuYXFDN2l6cmJBTG5uNlFGT2JoTG05dFFxZENaMGNGV2hYRG1mbGsyZWUrNTlncXp5ZHphWThlWVk2MXptc0xQcVp6L0p0dnZmbkt5OWU1aFJqRW96TUhBTlZjNHZxRFVxbUlQbGtFUG56SVRyK25xakpZTEpRV2pqV241aUs2cUJUTHc4bGtiVzExMGg5TnBuYTlVZi8wWjE2eWg5TlVOcm0rdmdhZkRnUWJsQlExb1VWa0FOczQ5Qmo1YzNFa2dZckE1MHNtQUFoYXdENVlPSUFkbkFjSWhDQTRqamVaVE5HZXRmV3Rack82bUVjZ2Z2QVJGWGlwOUlSZ0RDUWVQeGhOc0tONm8yTW82dDdPbm1OUFZWVTZPenNOWmdIY1dBT2V3TU1uMjd2YmNaa3ZGSXVPYVZrVHM5NXFnbWUzMnIzdDdYV01CQVlZOVVrWkdsQUZ4eGRHeExiZHRTMjQ0dVh6ODNxNzNTVWx3aEEyRDRCMWRubVFEY2dVSXVmUFFMMUFjbEJWM1RCZ2ppQithRm0yUUxZaXlrSERpRWgvLzczM0R3K1BUaytxOEVhZy9tRXFhV21rYUhSaVRrK3JaeEk4SHZqY2NWNFNwZUxPTlNtcDJYQnF6bzZUNVZVMm5DSENnUlZXRFRiNGlDNjM4U0VPUTBxZk1nSExsQmppNENtOEtMQWpsaWtoaEdnalRBZ0xDZ1B5VVp4bG9ZTENIWFFzVGsyT2FiaWZJbVJBd3QxUjlteHRxTTdEQ0tVVHZnbjRGL0duQWJ0UjdnSWRrZCs4cW9reU4zZVQyV3hHbDRkKzNLSHpmSGdhcWc5eWgwZWprS2Zub0ZNdlU3bFBmUHc1WG95N0pxMDQ2d1lXRjQwVjhnV0I0eFZkaThVV0lDMktic3lDR2NqOTBlR0piS2pYazFLRzNwZ1ZiYlg2YWxJclp0TzJhVUhYamNmbVBFcnZiNmlzbFJ2TnJ1LzdzQXhnRTVvc2swNGREdFdrNFZvZVhVcW5OZWhLbGZMcS92N0IzdDR1TDhTblUwdFU2QkllOUNqUWNIcHlsaXZtYVgzR0NJZE5WTFBiN2dJWjNXN1hjMmVRYUM0ZVR5UVM4UGJBWXZzOVd0ZXozNmRWTVRZM054YkJBaDE2ZkhMODVPQ3cwMmxuTWprb2Zucnl6WnNOT2wwam5RQTV6dVZTSU4rNVROcXh6VzU3VUd0MmtobGd6alFNcFZtdlRVY1dTRjJFb3pXTlhZdFdHb09wYUxiYlVPVHBqQTRIZEhWdHhUTEI0UjJjc1RjY0hoK2Y4eHd0cDlQcDlJZ1FzbXREOE5kaGFVUmFGdzZ5UzI4NmdXQk1Ka000OXJaTmQ2RFlxNm5ta01sMnA2TnBHdWhMdjl1bDlTSWRONXRJb2dMd0hxQzhmRnJzbDk3OURTY2VvMXJJWmpjM05nQUFTRUczVmIzNzdWY2JkOTVNNTh1Y0FxbkF1TTZtclZOSlRVWWcyMng0a1pPUWZSRVBFd2hnN0k4RlFodUxML09FbVNFU1RFRVM5SlpGc1cva3VNaU9EMW9hM2tPbE1sa1NoVER6OHFSME1rQ2ZObWtIa0lkczdJdHRVcDVRbzdPdkVKWVg0S1E4bEl0S3daOFFsM01WUFpGQlQyU1Roc2hIdTE2VTFEczdHUldJUE96QThDaEUyY21Yc2hCdVFMdXZ4MFJCVnBSaGI3aS9menlkam9FWExhRlBSNllYK09BazVtZ01MOEV3QUZhcjJtZ1hNOG00TEQ0OE9DMG0wMEJTVG9zNnRnOHpQNXBPWkZHcHQ5b2ptcmlpUXU5Qlk0SHNybTl0dXE2YlNtVzZQWm9TQ0loQ3ZjQ1BTNllUc3FnMWFnMDlsVVJkQUNCNkxwWnUxc2JwOVpFemdHTUtsZ24wT0pZTnN3V2xjUC91dmQwcmwxZFdWaUJGOUY0LzErWGkvUEhoOGZwR09aVktvYm05VmhNQ29BTjZtdDdyRDlJcGVxMEFHNEVGdmNTbTFUazhPZ0ZlQVRWVlZjUzRBTi9EU0JuZDduQjNaM3ZZNi9UYm5ZU1c4S09MQjNmdndnS0FPblBSUlNHZmdSbWhsNDdNdkJ5OEducHJyQ1RHNDR1QVhrVkV6NWlMVXEvWFIrdmczOEtNUUttajAwRk40QnVnK3FnM2xIMHVsd09Dc1oxUWRaSGpjVlNvN0hoQlFBYTROSWFxd2srWWpFYUZmTEZZeUkvZ3ZRUTBDU095bUF1Q0FOZElsZVVYbnJ1Tjl1TFQ2ZlpjejgxQ1JFMVRVNVRUdzRjUHZ2WjdyLy8yYjN6dysvL3U5SzNYOXA3N0dLOGxNZGdNZVFRSEZzZloyRCtMMFRiVDlLSGVZOGltL2V3QUZtUG9XS1lDTVhRWWZWSGF4VGROSkdiUjVlY2lMUE9HKzFnNnpjajlNQXVsRStCcEwzWERNaFBWQmVIaS9QUmhleWduQXpMTWVpem1DMm9ncWhqK29pSGI4OWg0Umcya1RQUk5SMUdoRktPQXhySFVEd1AzVENIWHFqV0RTR0JQbld3bUM4L3I5UFJjMW1RRlJFUUNWaUlZVlZHS3cyWkduU0JmTHNEbk96enJkbXczdTVFMm03Mng1M3JSaU8xNm1xb09SeU1NQjdnMlVBNkNCRFUyYzkyVDAxUGY5NkQvb0ovQU1lYUxBR3JTZGh5Wmk2WVNHajFpT1I1UHB0TWN2WXNZcWxRMkREaVJISVlaN0Z3U0pMaW5ZTjcwVGl4SnpHYnpra0x2cWRRMUZWYmVjaHl3bW5yMXZIMWVlM0o4RE5VT0NnWnRtQy9sNFFKdWJrTE1ISndYZ2plSGVtNTFUODVweGVwc0puVitYa3NiZWpxVGhoSVQ0dEVuQjZlcUxvSHVnR1ZIWlJHK3FXTTcrVXE1ZVY2N2VlTjZvWnhmWDkrNGQrOFJGRElZUlRCZkNCS2ZMK1RCekh0ZGVtRU9xcy94aEhLYTBjbnpvUGlnWW5Od2Q5S1J3QlNvU0FUc0V5Q3VONW93Q0pjMk4yZk9iR0xac1NpbkdEcmdEb3VxS3JUR0pkU09BN29UelBKbHVqL3RlUTRLOEgxZmlndlhybHlKeTlKb1BKUWxaVHlaTkZ0dElCN3RRdWZVems3bEdOK29uaFV6S1F6dytjSGpHNS82L0R4QzErTkQ5VWJEajRKbzZHbjBROFpEZUdZelcwS0VNTlNFVUFzRHBaSVB1dHlpNnpsc0Z4MGJmck84ZEFSRjJKbkNWTXJBZHRHSDl1SHp0Qmc2T0l5dzZvVDdQL3hlSHNaaTdKc2xYT0FYdjBFMDZpNDRieDVUdUhsT2srczJQUkcwRE45NzROT0E3YWRKM0tkMk5zQklaakd4WEtsVUc0M1ZyZFZjSW5OeWNqS3hUU2dreTV5czVmUCtvQi84Lzh2NjBpYkhqZlJNNGlKdUFyekpJdXZ1cXU0YXFYVzVOZEpvZDJMR3V6TVJuZzllTyt6WS9lWXY5bjdiQ0VmNGgvbFhPR0pqZHkzTmpLVHBsalJkM1hXUnhac0VpWXNnQUhLZk40R3Fsc0paTENEenpST1pUNzc1dkNDWWtPV0ZDMEppdVE1dHF5S0o4cmN2TDk4N2FyOTZmUmVHY1JCdEVtNWJyMVpoQlVBbG8vUG9XZkR0Rm1zM2JZcmt1aXR2Q1o3ak9zc3BHTVpvQkxYVTYvYzNjWEN3M3psdE5mL3ZsMy93d29DK0ZmSURtTXVMbVFPOUNNeEo5QzFtZ0NHRlBzWGt3ZVY0bm9zQ3NmUkRRNk56dCt0TlM1VkxRc0V3eTdBSGJTd1pkbmt4bndOd2dlOFZ3ZHhwcXpNc0E4bmV3ZEdmWG41ZnE1V0FrRnFsRHR4Y1gxMlBKdVB6aS9NL2Z2V3l1ZGNzMnphWkxzRzYzcXBIZmdqVjVjR0c0UXFTdVB2amwxK1hxNVdEL1c1UlZvYURDWWk0SUF1ZGczYm9CbUFZbi8vRlI1aXZzOWtDTXhtOEJhREJ2QlhGSXJROEtrWlhRd2Y2bnVmUXN4WDArRFNtZXJ0UlF5RzB1eXdTWWZCM3U3MTJjekNlME41TXIxNWljTDc3NFhWSUNkS2lUQThVN1hlN21ONjREbnJsV0Jnb0t0bEY3WGFUZHVMM1BKZ1RzRklZWExqYmZ0OFpENUhsNktOUE1RcnNUa29HTDNaZ2FZalVVMnJpMDB6QVNBbUxaTWZjeXpKUmtBZ3k4MlJGc0VRQUhqTFRNVTlQQ2JJd0N6QVpLWFh5czF4WnZrZEhoYkhGSVU5TlRDUXZQNHNrQnkrVjkzQmtqbmtqanZNMnU0WmVYTUdLaXpNeHNnTVJWQlpUNmZSUHRKSWkzem5odi96eUY2a29EaWFMYUJNT2V3TnZFM2IyOTdRQ1BhNExhOHR6L012cnQxcFJUS0p0c0ZydkJBRlE2TFFiaHFwYjRQV1d2bzZTRlVaRktkYUFDTjF3aGhPUWdRSzl2NEQyamtQRldKTkJQTUlJSnRvS1FsWFZhamE0cVhoKy92VHE2dmI2dG1mdnRZODYzZm5kS09Fd0g1eHlvMlpaSlZBQk5MaC9ONFR5T3pnNUFGc0FGMWl2UTFWUlladGlRcWVGTFhROEYwZHIxNFhGQUhYb3JtRXh1NUlpUU1XcnVyWnlsa204QWFzQnFnQXlaSWUraE9XTWEwYUxZUE4xRGc1RVVZSEZjbko4OVBxSE4ra21sc1RpK1h2bnZkdDcxZENnK3lkRGV0cUhMd3A3emVwaXVuU0MxWDUzanlzSW51c08ra1BmZDVNa1hXK2lTazIzTkdXYmNGNFlZWWFENFFqUTdsdmFSUnAxWVFvbGJBOTFBTHRpMjJ0Z0ZvdGRnaWxYMWxRWmFFWTdRZGlnSFd6VnVMMjdXL2tCMkNCR09rNWloU3g5cVdTWWU2MjJwaHB2Mzc0NTJOOFBveEE4cDlsc3pwMUYyUzVuL1V4UG9tb0dycVZhdGhlTDVhLy83bi9hKzBjNThwZ0Q4L2dSaXVpVHlSa3NFR1Nvb0tpSFUrN1AwTUxTcytJWXVrbmJNaEUrdVp5VlRxU0ZKRGl3eUR6Sm8yNW5qbVlZeFZBaHVVT1M3TWdBVC8rNXl6MVowb3ppazJNcG94MjNqTGJKanFmbjF2T2tMQ2ZMbitXazQ3dHM1SVFrcEovNTFHV3hHRVZXbys3NW01M3YxanZOY3AwV1gxVVVKK1BGM3RIK01nNVBucDBKc21UWkJsbE5ncUNVNU9GbzFodE9wc3RsdW9OUmEzcFlFT2c3MFhJQWlySU93YWVobnpSTnIxWnJxREtLTnA5Ky9rSVdpbnhSYkhlNnE5VVNOcXVJWVlqREpGamJqYklpd2ZRay9JSGJsR3RsS0hWTlYwRk8wT1E0am9GQ0RIKzlXVS9vVzZLMGdscENYNUhCdjkyNUYwRjVkdzY2OUpRS3ZldEdwVVZGNEQ3NCtQbHM1b0FCKyt3SkdOcVlHang0SGZtQlgydldIZEF6ampOMEU5WUVnRjZyVjBIcmZjZUJYZG5yM1cyNTNlZGZ2QmlQNW51dG11OHVYNy90VFdkTHZrQWdWdFFpU2xPVjR0blovbUc3RHVzYmZQcmkrYzhtNHpucmNHb3RadW5EeUcxaE4ySU9JR05LejhsUUNUN01YRW1palJnTXMxYXJnSjZCdDBCbHdQeWxkaGJwaGJVMVFIbTdmWFo2cXNxeVlaWWtXUXFEZGJwTE1mTnR5d0p2UlA4Y0hCeU9Sc09xWGI3cjkwOVBUelJWQldkNy90R252LzZuL3hVemFESUZ6QnlEQUtNM3Uxd0habURNTkN3bGV3RGFRdzZvcWt4ZmsrSmttaXNMc3hTTWUyZHBrWXN1bFdHVkZVZGE5cWNPUXFSa09Tajl3NWxpZnVRb2tOZVF5NmtpQ3BHVXlYL2l1R2hiMkxCN2tRL0ZvQWxBTjBJUEplY1JkSUlZRnk1VWpYSzRjb3Q4ZXZMc2Fib1QybzAyS0FjbkNEZkRrZSs1RXYxUVdqbytQZmorNWFXdVNxUCtuYnR5ekxLMW5NMDBSV3MyMmtxOHV4a09vb1IrakxOY2VZUEpkREtiZ29xZ0FrV1dJL3FsMGpvTXdPMWhidEV1ekFlSEI3NGYxS3BWRVl4RUZFdVdYbEoxV3hLM0M0Y1RzUGlLSGoxblpnTHlBUFRTV1lLNXdGQ2V6aGJkZ3k1d1hLM1g1dE81WFM3VGN5K3k3UHBodWRHR1NWMXBWQXhUNi9jSDdYWjl6VjcwUjFZZy9iNEoxY1pwc29VV0JDTUNvNkQ3TFZFRWRSdEhzQ3pXaXdXOUs3UFh1MGRQOGJ5SWhJcWgzTnpjWWtHUVZRbTYyQ3FiTURuc2N0V1pMeXRsRXlRYlBLVGRhbzVuTXloZ1V5ODZZQ2R4aWs0TDEyR2E3aEo2dVFNNERFd2V1aGVKam9kMmtEVU55d3NXT3RvNmsrZGh4eHdlSHBRc3pOZ1FNMkV5bmhRRWZqZ2NzVzJPWTdCQmpKY2s4VWYwWWdMa2dDazhXM2xlMWFhN3RHQnlXRUhzU25rMkdNa0NiK3I2Y0RKcE5Sb1c3Wml3M2ovb3RpOCs2Mzc2Qy9hVkx0d0RHREx0emo2RTMzZmdZWGhpYUNLWTVKcVVPUkt4RUlHSDRNeVVMeVI1RW9ZcCtqQVBUdmtDa3NmU2pHQVZQcVpoNTh6L2tJb2NGZmNZekExVzh2eEkraFBIOEl3VGF3Yk5hV28rNnM0S3B0V0RWWk1sQS9weFpwR1VXUGlyTDE1SUpWMnAxY1plQk82cEdiS0U0Vml2M2FVRGJkcHQxbmxSeEpEb3NncVdzdmFUOFdUbWp1YXJsVmVJNC81Z2dOVzJJQWhZbmFIVVFWdzJhV3BvcGlEUnZVVU1hNlZjQnFZM01iMmlLNmIzZks3cFptSkNEd01HWHJpRUd2ZjhORmh2d3dBTTlIWTQ2ZC9meTBVSjYzV24yL2JkUUZWbEFTTnFHWUF2R0E3UDhhQVFRSlVvd0xEa3N0OHIwWE84OUZaQUhpekI4ejJFMW1Ib0I2RlpNakhUY0ptTlJnTWpBWTNMY1NBVkluckpvcGQyeENJUFppOEJGc0NsTEd1d0pZcEZORnlZamNkYnVydlBMeDBYRFVZL2pVYUxkcmU5bWt4ZGYvWHM0a1FWRkQ3ZFJ1djR1TnVHWXI3OGN3OExpRTVid0hLTHBRT0RGUmRMUFUzZGozNm1EUWtoeE1JVkJmU2xNc1lERjBJMFNlQU5YVVBmekJjT21nM0pMdDNXeWpib2Y3Q09zVHdkSGgraGgwRC9zSnJhZHRXcVZLclZDbTBOZ3JVampuaGlPOFhDZG5jN0dDaXFKb25LL21HM3FHcS8vc2Qvd2N3bVZESnNzbEZta0NLWGVlbkRGQzUwSVIxekVrMUJ4TEY4RU9mcEtSVmRSMTRlU2VqZVUrNW9DakJFNGZ3VHBVNUY1bDZXbTF5V0xKTlF4aXptWFZsMFFDVzBNREtZc29JeklmdkxYSDVtWmVHZk1Ta0taRWZXREJTVnRabWtXV3V6YXhUMmo0L3ZKNDRvU3MxNkNUTmxmbjNuT3RQMWRtZWJwZDB1QVZOZXhORm9OZ1dxZG1GMDhmNUZ2Vm16RmJWaVYwdVZTc3J4MWIxR0FveW5TYkpObXEwNjNiSXNnNkdHVUprd0xxTW9sQVRScFkwLzZkMXVJTHVzQ2J6dmVycXBXeVV6OU55eWFVUkpBZnhINGdSRFZXOUdvNm9pODZIejJ5OCsrUHJWVmJqWktJcmE2WFJIZzFHeEtBNEd3MXExaHFrRDlZeEplUDMyV2xGQWtYY2hlMHVaQ05iTWkxWGFWcmRFZDc0TDZlSHhJU2JQSnRrMEdxMXR1c1Z5YjVaS3RCRUNiWUt3bGVrRjlpckErdjZINzY4V3JzaHptSUtnY0hhMXJNdGdGSnVEbzMzSDhaNDhPUjMxZW5iZGNoWXJRZU1qWEZnUTc4UnR2YUUybXBYanM1UFZhRzdyNW5MbEM5QVhPdTE3Q28zT3ZqVEZITVAxZ3RMRDFpaWdzb1M5L3dmOXZzSGszNnlESUhBY2VxTXFMZ2RFcTFtdkFZU3FvaFcyVzZCZlo1dmlZMW5FcklhU1g4ZWIyN2R2dTUyTzR6cFNZZnYwL0d6c09QVkdjN0p3dXZ0ZGc1enBPL096di96cndnUGMyZkF6VEpBUDliSjdKOVFBMG9nMEZpd3VhMUlteWVIT3hFZ0ZFV1doOU5sOUhFcVRzWEZLU0lWU2JPYkpFRTlCcEdNZVNGbHQ5S0Z5czFia0VpcUlQR3orVTdHVWdTVmxjdkptRWhaaTRseU9FMFA1VDZaWTFpcUlIZ3BDZlk5OWdBQlZLSFRLNWFwbDhKRS91dTVQUXI5c0ZnMllQWmJ0SjRWLyt6Ly83c1ZoVGRDdWUvZS8rczFmR2tYTmF0V01ja1V2NlV2Zlc2NkNZQnZnQW1iamlhbktWM2Y5ZUpjU2FVa1MxL1diclFiWUFrRFBDVnljd0E0ayt4bHd4QkdqVzdMc1h2KyszKzlqTUdIV3RTbzIyblh4Wk45U3hjblVXd1IrbWhZc0xSVzBXcWxhcGkvZ1ZiblJhSzY4QUR6SDgxek1xT1hDd2JLVHhpa1lMYTRGQzFySnNnSXZLQWowZlNlR2FibjBwU0wvNnV2ZnI5ZE9yZGFtbCtnYUJxb0dneGZFZ2lEeW85SDR2bmV2R2ZydHpaMnFpYzE2L2U3MjF2RmNlaENnd0l0RndiQ01YbTh3bnp1Vm1ubHlkamlpRnllbFAvejVyaWdyb0J2eE9yMi9tMVJxOXJmZnZKSjFUVlNLQUVLOVhwN09GNVpsWFZ5Yyt6NzkyQnl6RHFZR2xEckgwKzZ3MU5Uc2JneFhtTlBQbytpMkViQU9heFY2SFRHcndIZFdxOE85UGF5QUJtM0NRNWFBYnBtNllRWnVzTmZ0dXY0NmdvNG9XMG1hbUpqVjBjWXNXYTdyQXFhS0loOC8vN3o1NHBkb0Nmb3owMm9Nbm9RVDVxY1llTmd2VG1uNDJZZHNNU0NEVWpCSmZxQXpDYk1BR2s1SktRUEx4REJLc012dnZqK3lpVHd2elJpSTh5elpoNlZqRTRGVjlqQUJIaXJKTTdOc2xPaHh6bEI2NW1ISGg1WXlHZnQvY0ZrQnVSU3BIcXJPTEFvcVZ2amRpMDlTVmRtNS9tRGl2TDNxZzRadXRydjVaQmFGYmtQVkFWSllqVTkvZGpaMzNZS2lRQ2VCdi9hdWJwTHRkam1hQUN1YmFBM3RMb2c3VXpmdkIyTjZIakNpQndJRGFQZ3d0R3hUVnhTTWRBQldRTzhIbHRCVy9JRm1ITzN2N3paeHExVkhkUXZQTjFROWpGYlBUK29mSHJhdmIrZVdyVjYrbWY3MmwrZjM4K2k3UDN4YlZNWHBkR1paOUZ3WGFYQXVGWXN5RmcwUUcrQUFaTGZkYnF5V3krbGticFJVVFZjYXJSclA3Nzc1NnZkYWNUZWR1cWRQenpEcG9XUHI5ZnB5UHZ2K3UrK1R6YWFrRzFhcGROdnJBU1g5M2owQWlmbnBMaHhGTEtxNm9tdmE0SDRJd3MwSi9HUXkrZUdIUzlmMUJKNSt4bFZJWUdKd2h3Y0hoaUdXNjhabm4zM3kzYmR2b3pENTdQUFAvLzMzWDhNbUdVL21kMzBVV3dUdGh2bUxYc2ZTaUh6b2NaQ1c3TzRORmloQUhJZ2hUR045aVpQem84UHBZZ0hZd2RxUWVVN1NWRkdXNXJQcGNiZXJHaFpBM3Q3djNON2VMSmVMcW1sTW5FV24xYnA4L2ViSms1TlZHSDd3MFljd05yWlIyRHg5V3J2NGhHQ1U0Um91SC9Nc1JCb3hBekhKNExJcHdaSmtna2ZjNXk0REZZdW5Ed0dRZ0U2TUFVSW1venVaTEJHVGtTMU1CYks2RVAwanBESzltd2R6RDVYL0NIZ21wVk9XaEQ0WkIwRVFpakxYMjNsczVxY0d3ckc2S0o2K0s0QVgyUjR1TXZ2Z256ekMzLzdxUlpXUHB1T2xvR25QTysyYjRSaTZyeEFuWXJTcDYzSnNhTjFLMVYzNXI3NjduRHB6dEE3MGR6b1k2WWJjN25TSGc4bHdNQVlEd1NBZUh4eUVVUXlhcmVzYWpTTlFLWWp6eFJ5dFVEVU5veDZ0UXhwZzlBVTdwdHNZYUZOMFZSUmwrRzFKcXBmTXlXZ0JwZ0FGSm5DY1pxajlQczJvOC8xdTcrcXFWS3VBNlk5SEkyaEgzL012djM5OWMzdGJLaG4xZGt0U1pGZ2FJQU9TTElJYjNGN2ZEUHE5MlBVeGNQM0o1SDQ0SC9mNnk5V3EzcXpEVm83WFlkbXlWRjJqTjNEVDdTTjY3L0ZrTk51czEzL3h5Y2ZMeGJMYjdhdzNRYTFSVGJaUTh4ek0zOUNQUEM4eVRiMXEyUnQ2UjdIV2FGVnJWUU9UNFlmWDExSGd0L2VhUmFnTVZDOG9ieTh2MGJtYWJrQjVZeFN3c3FtS0F1ME5IUUFrb2ZGa1JUQWZQQnRJSTlvWkZEenQ3UFQwelp1clN0a3VGb3QyeFlwaTJpc3o4SHhkMVlDdTlTYWRUU1l3OGQzNW5EYnQ0ZWxXTEpyNmg1ZmZhcVhTMnpkdkpGQjVWZW1jWEpTZmZZeVJwbEhQSElFbTl6SnM1TStyTUVUU1hSckVRd0NpZ2laQjlDNHRnMkorWm80eXM5bVFUeWRFRXV3SWhDd3F5L3RvSExKSU90RUJpZkxuWTlnSGYwai96dEdjeWNRc05RV1lZeEVQbElYQVI0dEpuanlMWS9PQlhRWmJiUEppczdabG00VXdBWVh3TDZoYThlLy8rKzlTSnpCajc1TkQ1ZWYxMHBmOWhXblNOM3liTkJGMXRXT0k5V1pGTld0Zi92NlBqVmJGVU16WmJMNTNzQ2VxS3BRVjhGMXZOVS9Qbit6aTFGMHNiL3A5dTJ4RHY0Ty9nblp1dDdUcGJoRDRiTXRzdXU4QUt3dDE2N3F1eUNBRkN0Q2c2MnJnZ25zSG96NjRxSGMxY1piUWlNSU81a0JSTjd3b0FwK29ObHF6eWRnUFhFd2J6QlZZbG1Dcjg4azBpdFpTZGtkUDBUMC9tRVBwemVnSDFEQmk5NC8yUkxvRlNLK2xoZ0dnS2ZLclA3M2FKYWtHclN1SVgzNzFSM2Zsd2VBbUhyVk5QdnY0QTQ2VGprNE94ek1uakRlWU9MQmJ4cU1aQ0FrVXN3Q3JzZHVCWVZ0dmd2aVpnOUVVOElYcHZGd0V1MVNTSmVuSjB6Tk1OY2Z6Q3R1NEVFUjJ5WVNlUnYvR0VUMzRndnBKamZNOGZRVUJ2Z0x1Z042bllBcUVvWkcyWldIRnVycTVRUnJiTHRHK0RGNm9xeW91YmJkTmw1N2JialNDZGFLcHl2M2Q3ZEh4U1lnWklvdWFLdmNHV005V3NDVkFsaTdPVHdSSmthejIzb2Vmb29JY3FZVEJmTHpoSHZDV1FaMk83SjhsL1E5WXp3NE1VbytZQVdwWjhFY091VmtsSkFmUFlHaWpmQ1NqbFp3U1ovOTAzUWdqSVdyTkVsSWljcG1IeXFFeld6bXlBa2xLdnF3STRQa3hndmFVWng5TUFBSXlaYWRaU0prUm9Bd1VwQXdndU5Sd2tnZ2ZuWjRXbk12Zi9QWUx0dytrdVlmdkgvM3dlbEU3NkJRTFNVSGllNzJSdjlsME9rMHcxOUY0NHEwampJRnE2RmpXRnd2WVdHbUZ2V2JvemR0TDBkU2I3V3BWczN3L2tIaGVLZERMQzJERW9qYW9NV2d4VEFNTWNNUmVKSTAxSFFzNk9JOG9FcHMzREVXTTQ2cEdCdFkyaXJTU0RtYWxpSnhTbEVGMUtwVUsvVUl0NXJDWStJRW5pV0t0MGZLV00xbWdSeThsNk00ZEZoQjYzZ0hFWURxWktMS0lwcXFTMk84Tk1OTzZlL1hRVzg4WERsVGowZUUrdXF6V2Jtb0YzakpBamJqVHN4TzdacVZjWW1ncTJudDlkWU1XRmlVaDlDSk5OU0kvRERDbE5wdnBmRDZaek4xZ0pjaGl0VmE1dXJxRHVicmw0bmdYL3V6RjJXTHVEbnJEMTY5K1FMTG56NStxVUNHWXladEUxMVRZbWhoWlhEK1FnRm1FSlEvWHk0dHN4NkVkUFFvRVU3NjcxKzczaDFnTXdmRm96NThDRDlLMVdNNWhCbWhheVRRc3NDSk9LSzU5Nytqa3hBc0NyU2lnOHpDVFRqdWRBRXRxUks4VDlNS1FWK1NENTUvYlR5N1lHTlBvMHRobjkxWG9uMVFzTzBQR2dFQUhwdXdaMURLWEorQUltemw0V1ZPUmprV3hQT1JoY2tyUFRqOTFrRENzMFg2bU9MSnRVUW1OQkZpeUZGaW1IK2ZML0ZsTmVmZ2hPc011aWVtY1NaaVFCSVJ1Tko2YWxrbnpGRmtwTEF1VDBabVNDdi9wc3hkZUlMejkwK1hrM3A5NDR2VWlxWW83Zzl2OTcxZHZGRkhSdWUxbkg3KzM0UVRIdzBpSXl5REUyTWd5M2YrcU5HcXZMMjl3T1ZFUWM1eVNjb1hSYUZKdjF3VkZTZUxZTUxScWhYNWJ2ZlQ5ZXEybXlIS2MwQk5VRVh2ckx4eEd1dDFzQmlzUGltL3RlaGNISFJsbGJRdTZ4Q2ViSFNkSzdtYno0dGxSeWhleFVteDJXOXUyc2VBc0Z5dk1wVlozejF2NmdlTU1hSU1rcjJRWUFOQUN1dDJabGN3U3RGMTN2NjN3SE5Zby9HMjU3ZE1uUjhQeGJQK29NeG5QZkhvcGlOL3E3cStXM3JZUSsrdjFZdVgzZThOTkVvTkl5QVVPYmZZQ3Y5RnVsT3pTKys5ZFNIeEJrT1J5dVV4M1YzYUYrejZtMGh5MjVYZzhCZW02dmg1OTlmOWU5ZnVnV0x0ZHVoV2xJaFJ1cmROQXlJTzkzbXl3RzdEMFRSbDFPNGdnM2RWTmRJTmVNWWx1YURZYUlHYUJIK3kxMjh2bEVxdGlEZXJkTUllVENiUit5YlNmUGozZmJHTVZSbmFhd21SeDNWV2oyUWJBVzVZT0t4ZnFBNFYzRHZkaERmaFlUbDMvVi8vd3o1SmxvVEtHVkdwVVB1eE1DYU1KVEpMRlpUSGtxRzA1VUhJSGZPWEFvUVA1OC9RRTJ2eURiSFNnWWltSStFY2hDMUd4N0p5RnNqQkxDM0VtZVhCWkhuSjVkbFlpL2FQNHg2VHdaQzBoQ2NQNVl6NVdLaXM3eTBVaEZzaUM3RU1KaEl2alk5T3lWOXVpVWRLbGt1NkdtM2E5T25QY0Q1K2N2TitwUER0cENVSjhQNTBWZEZzMnJVcTFESmFwYUhxMFNmdTkvbXJwRkVYWk1MWHIyQWFqQUFBRklVbEVRVlQyWVdkNGQ0OU9MMWVyeTVWYlk5dTg3SFZiM1dyVkM4SUJ2U1NqNUs5OE5nekFPZlVRRm5WM3RSS0x4WkpWVWtSNU1wMUlxb3Jsd0U4d3JwZ3lVaGlubkFnZHd4VjFTU3J3dnVkVjl2YmFod2Z0L1QzYTN0RXkxSkorOHVRTUJNRlpPb29xQTI1N25ZNUdMeEd4c1Z5MHVxMSt2eS9EdEUxcEUzZlRMTm4xQ2xpU3QzQWxTUUc3Mk8rMmIyNTZpcWFGYmxBVWVOaktzOGxNdHpRMERQcDhPQnJQWnd2WFdkNzFCNldLZFh0N0N4c1VDSU1kdVY1dmFKdUFUWkxHV0tOU1FOOXh3S2lYZ2lodWQ3RGE1VDk5ODkxMEN2TTd1Qi9jWjgrMDBEVmprSGlPZnFvTmpFYjBkSmNzeXpCUzZRbzVMdGxFc2xURVV1aUhhL3JsVjdrU2IzZDFXelYxRXlweE1CeHVvclZBVDl0enRXYmx6eSsva1lXQ0pvcTd0Q0RJMnRmZnZFeTNpZWY3NzMvMlh6LzhtLytCRXJjRWtwOENLbmNQd29mWURCRk1HeklOQ1Q5RlpSLzZaM0NEaUlKd0JMQ0hUeWFpTE9SblJJUDgrVG1MZ2FOQ1VBeWxvWEl5VnNGbVRlNGU1MlRtV0N4T2VUc1FwS1FzKzdzOHBCamZ1U3gvaG0vR2ZXZ09VajNzUTNKRzZ4RXRISFQzOWs2YVM4ZHpBbDh1S1FsZlZNU3Q1N2ovK3VVZk1KQmYzdzNTVk92UFBidW1ROE81bzNsRVArRFkzZDMxeC9US3F3OHFGVHNJdzk3ZEhWVHAwZm1wWGpLNUhkUlFYRzQycEtJRXF1M1Nyc0o4UUQ5VmpzVWl2ZmdYU3c5b08xb0FkZmpGSngvQmpoUUxzWTdCNXZtS2JVcWlmRGNleWFZQ2JJMm5TOGdUTjJ5Ym5DcHVCd3R3R2ZZcVRPb3V0b3Vxb3RScTllbDRLZ283Tk9QNjZ0cWdCNVg5YXNONjlmVjMwOGtTbldhV3kvdm5KK3MwSFU2bVlSQ2NQenVienFhd1JLSE9XKzFLNTZEUjdUWjEzYkxMcGNQajF1WHJ0MUNURjZkSHA4ZUhxcUlkSFIxRVVmTDk2MHNvMFV5YkFyam9XSGd3WVlvU2ZlMktJTmlqYVpycE5nVUx4M1MyN1VxeGlQWUg3SHN1Y3VBd0tqM1hGWUs2STBnY2hqMVJnNkhHMG81MVQ1R0twNmNuSEM5R213VEZzdmRYSmtXT0cvV0hkcms2bkMzQ2xTZUl2R0xxUG1qOU5tbTEybU5uS1NxS0d3Ym5wNGR6WjRVV3Z2anRmMnU4L3hFcUlDaGtFSGpuRU01RVJDMllraWNKUnpZdDRaQmhqa2tvVlphU3NNNmdobUNHSURqbXh6L0xuRG1XaHNHZkl2TFlCNWRGc3VPUDVLeVVQQVE5alNCS2U0ek5YSGFQRTBtekdQclBXd2N2UHVSRjMyY3h6TEhmdTFLUXdNMGtqeDdtd09KLy90NkpPM0JIeStYRjA4NTlmK1g2cmxiWWpWZStMTW03ZExmZmJqMzU0S3hhcnM5dmVsOTkvVkl5MUFEcTJ2ZTFvdFJxTjZEWFZ5djM1czFWR0s3dnhzTzE1K21HcUpnYXg0bXZYbjJmN01CWXR4elcvZEVFMVlLMDBNc2pxYXUzWjUxMjltdWR2Yks2Q1QwMHNsMjJCbzY3aG5HSE5oVjRtSjhWdzFCVnBWUXFWVXJtYWdtOUdnVmJ2a2p2b1UvWDY3UmtHWU83SGk4V29qZ3AyOVo4TnZZOGYrbjQ3c0s1SDQ0MTJJOUpvV1NYaTZwbUdzWWNISDlFMzhURHlKWkVmclYwMDhLMmZ6OWNKOEZ5NVlFNFdaYUJ5Zm5keSsrQnZvdG5QN09yWlFjTVR4S2dtNkhKcDdNRnlCSUFBU3JDK0lnQXd3TzlCMVdmZlUwTGdBRnRBREhzWUZqZ004ZkJqQUpMd1FWbVpCMVJTVUsvTnllekN0Mk9EcUppeENKOUxjWnY0bGpUOWNQakk5Q3c0KzVlbU1UandiQlRxNGQrMkdvM2VWMFRSS25WcWtORG9vZURhTjNhNzhBbUJ3Mkx0M0haTUFSK0M3UGJDOWIvK2UvL29kUTlRSHZRenhrWVVSSE9WR1VHQXVaaE00NWhoYzZVTGt0TGZvQUZPZklFTkZTWko0YzZIRUh6SWZxZEJDN2JPWVBDZEhpTS9hbDdoSGhlSUNzc2d6c0VEM1ZranRxZU5ZODVTa2x6TXN1WGhSOXFlU3dXRGo0S1VNTEh2QSt1VVBqLzEwNFpEUVJydG5vQUFBQUFTVVZPUks1Q1lJST1cIjsiLCJpbXBvcnQgeyBRdWV1ZSB9IGZyb20gXCIuL1F1ZXVlXCI7XHJcbmltcG9ydCB7IFJhdGlvbmFsTnVtYmVyIH0gZnJvbSBcIi4vUmF0aW9uYWxOdW1iZXJcIjtcclxuaW1wb3J0IHsgU3RhY2sgfSBmcm9tIFwiLi9TdGFja1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFyaXRobWV0aWNFdmFsdWF0b3Ige1xyXG5cdHB1YmxpYyBzdGF0aWMgdG9SZXZlcnNlUG9saXNoTm90YXRpb24oY29kZTogc3RyaW5nKTogc3RyaW5nW10ge1xyXG5cdFx0Y29uc3QgdG9rZW5zOiBzdHJpbmdbXSA9IGNvZGUubWF0Y2goL1xcKHxcXCl8XFxkKyhcXC5cXGQrKT98XFx3K3xbXFwrXFwtXFwqXFwvXFxeXS9nKTtcclxuXHRcdGxldCBpOiBudW1iZXIgPSAwO1xyXG5cdFx0Y29uc3Qgb3V0cHV0UXVldWU6IFF1ZXVlPHN0cmluZz4gPSBuZXcgUXVldWU8c3RyaW5nPigpO1xyXG5cdFx0Y29uc3Qgb3BlcmF0b3JTdGFjazogU3RhY2s8c3RyaW5nPiA9IG5ldyBTdGFjazxzdHJpbmc+KCk7XHJcblx0XHR3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHtcclxuXHRcdFx0aWYgKHRoaXMuaXNOdW1iZXIodG9rZW5zW2ldKSkge1xyXG5cdFx0XHRcdG91dHB1dFF1ZXVlLmVucXVldWUodG9rZW5zW2ldKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmlzT3BlcmF0b3IodG9rZW5zW2ldKSkge1xyXG5cdFx0XHRcdGxldCBvcDE6IHN0cmluZyA9IHRva2Vuc1tpXTtcclxuXHRcdFx0XHR3aGlsZSAoIW9wZXJhdG9yU3RhY2suaXNFbXB0eSgpICYmIHRoaXMuaXNPcGVyYXRvcihvcGVyYXRvclN0YWNrLnBlZWsoKSkpIHtcclxuXHRcdFx0XHRcdGlmICgodGhpcy5pc0xlZnRBc3NvY2lhdGl2ZU9wZXJhdG9yKG9wMSkgJiYgKHRoaXMucHJlY2VkZW5jZShvcDEpIDw9IHRoaXMucHJlY2VkZW5jZShvcGVyYXRvclN0YWNrLnBlZWsoKSkpKSB8fFxyXG5cdFx0XHRcdFx0XHQodGhpcy5pc1JpZ2h0QXNzb2NpYXRpdmVPcGVyYXRvcihvcDEpICYmICh0aGlzLnByZWNlZGVuY2Uob3AxKSA8IHRoaXMucHJlY2VkZW5jZShvcGVyYXRvclN0YWNrLnBlZWsoKSkpKSkge1xyXG5cdFx0XHRcdFx0XHRvdXRwdXRRdWV1ZS5lbnF1ZXVlKG9wZXJhdG9yU3RhY2sucG9wKCkpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG9wZXJhdG9yU3RhY2sucHVzaChvcDEpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2Vuc1tpXSA9PT0gXCIoXCIpIHtcclxuXHRcdFx0XHRvcGVyYXRvclN0YWNrLnB1c2godG9rZW5zW2ldKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0b2tlbnNbaV0gPT09IFwiKVwiKSB7XHJcblx0XHRcdFx0d2hpbGUgKCFvcGVyYXRvclN0YWNrLmlzRW1wdHkoKSAmJiBvcGVyYXRvclN0YWNrLnBlZWsoKSAhPT0gXCIoXCIpIHtcclxuXHRcdFx0XHRcdG91dHB1dFF1ZXVlLmVucXVldWUob3BlcmF0b3JTdGFjay5wb3AoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghb3BlcmF0b3JTdGFjay5pc0VtcHR5KCkgJiYgb3BlcmF0b3JTdGFjay5wZWVrKCkgPT09IFwiKFwiKSB7XHJcblx0XHRcdFx0XHRvcGVyYXRvclN0YWNrLnBvcCgpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIHBhcmVudGhlc2VzLlwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aSsrO1xyXG5cdFx0fVxyXG5cdFx0d2hpbGUgKCFvcGVyYXRvclN0YWNrLmlzRW1wdHkoKSkge1xyXG5cdFx0XHRpZiAob3BlcmF0b3JTdGFjay5wZWVrKCkgPT09IFwiKFwiKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBwYXJlbnRoZXNlcy5cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3V0cHV0UXVldWUuZW5xdWV1ZShvcGVyYXRvclN0YWNrLnBvcCgpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG91dHB1dFF1ZXVlLnRvQXJyYXkoKTtcclxuXHR9XHJcblx0cHVibGljIHN0YXRpYyBldmFsdWF0ZUZyb21SUE4odG9rZW5zOiBzdHJpbmdbXSk6IG51bWJlciB7XHJcblx0XHRjb25zdCBzdGFjazogU3RhY2s8bnVtYmVyPiA9IG5ldyBTdGFjazxudW1iZXI+KCk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICghdGhpcy5pc09wZXJhdG9yKHRva2Vuc1tpXSkpIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKHBhcnNlRmxvYXQodG9rZW5zW2ldKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IG9wMTogbnVtYmVyID0gc3RhY2sucG9wKCk7XHJcblx0XHRcdFx0bGV0IG9wMjogbnVtYmVyID0gc3RhY2sucG9wKCk7XHJcblx0XHRcdFx0c3dpdGNoICh0b2tlbnNbaV0pIHtcclxuXHRcdFx0XHRcdGNhc2UgXCIrXCI6IHN0YWNrLnB1c2gob3AyICsgb3AxKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIFwiLVwiOiBzdGFjay5wdXNoKG9wMiAtIG9wMSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBcIipcIjogc3RhY2sucHVzaChvcDIgKiBvcDEpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgXCIvXCI6IHN0YWNrLnB1c2gob3AyIC8gb3AxKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIFwiXlwiOiBzdGFjay5wdXNoKG9wMiAqKiBvcDEpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBzdGFjay5wb3AoKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgaXNOdW1iZXIoY29kZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gL15cXGQvLnRlc3QoY29kZSk7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIGlzT3BlcmF0b3IoY29kZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gL1tcXCtcXC1cXCpcXC9cXF5dLy50ZXN0KGNvZGUpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBpc0xlZnRBc3NvY2lhdGl2ZU9wZXJhdG9yKG9wZXJhdG9yOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAvW1xcK1xcLVxcKlxcL10vLnRlc3Qob3BlcmF0b3IpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBpc1JpZ2h0QXNzb2NpYXRpdmVPcGVyYXRvcihvcGVyYXRvcjogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gL1tcXF5dLy50ZXN0KG9wZXJhdG9yKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgcHJlY2VkZW5jZShvcGVyYXRvcjogc3RyaW5nKTogbnVtYmVyIHtcclxuXHRcdGlmICgvW1xcK1xcLV0vLnRlc3Qob3BlcmF0b3IpKSB7XHJcblx0XHRcdCByZXR1cm4gMTtcclxuXHRcdH1cclxuXHRcdGlmICgvW1xcKlxcL10vLnRlc3Qob3BlcmF0b3IpKSB7XHJcblx0XHRcdCByZXR1cm4gMjtcclxuXHRcdH1cclxuXHRcdGlmICgvW1xcXl0vLnRlc3Qob3BlcmF0b3IpKSB7XHJcblx0XHRcdCByZXR1cm4gMztcclxuXHRcdH1cclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IuXCIpO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGVudW0gVG9rZW5UeXBlIHsgUGx1cywgTWludXMsIE11bHRpcGx5LCBEaXZpZGUsIEV4cG9uZW50LCBOdW1iZXIsIExQYXJlbiwgUlBhcmVuLCBFbmQsIFVua25vd24gfVxyXG5leHBvcnQgY2xhc3MgVG9rZW4ge1xyXG5cdHB1YmxpYyB0eXBlOiBUb2tlblR5cGU7XHJcblx0cHVibGljIHZhbHVlOiBudW1iZXI7XHJcblx0Y29uc3RydWN0b3IodHlwZTogVG9rZW5UeXBlLCB2YWx1ZT86IG51bWJlcikge1xyXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcclxuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHR9XHJcbn1cclxuZXhwb3J0IGNsYXNzIExleGVyIHtcclxuXHRwcml2YXRlIHRva2Vuczogc3RyaW5nW107XHJcblx0cHJpdmF0ZSB0b2tlbkluZGV4OiBudW1iZXI7XHJcblx0Y29uc3RydWN0b3IoaW5wdXQ6IHN0cmluZykge1xyXG5cdFx0dGhpcy50b2tlbnMgPSBpbnB1dC5yZXBsYWNlKFwiIFwiLCBcIlwiKS5tYXRjaCgvXFwofFxcKXxcXGQrKFxcLlxcZCspP3xbXFwrXFwtXFwqXFwvXFxeXS9nKTtcclxuXHRcdHRoaXMudG9rZW5JbmRleCA9IDA7XHJcblx0fVxyXG5cdHB1YmxpYyBnZXROZXh0VG9rZW4oKTogVG9rZW4ge1xyXG5cdFx0aWYgKHRoaXMudG9rZW5zLmxlbmd0aCA9PT0gdGhpcy50b2tlbkluZGV4KSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLkVuZCk7XHJcblx0XHR9XHJcblx0XHRsZXQgaW5wdXQ6IHN0cmluZyA9IHRoaXMudG9rZW5zW3RoaXMudG9rZW5JbmRleCsrXTtcclxuXHRcdHJldHVybiB0aGlzLmdldFRva2VuKGlucHV0KTtcclxuXHR9XHJcblx0cHVibGljIGdldEN1cnJlbnRUb2tlbigpOiBUb2tlbiB7XHJcblx0XHRpZiAodGhpcy50b2tlbnMubGVuZ3RoIC0gMSA9PT0gdGhpcy50b2tlbkluZGV4KSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLkVuZCk7XHJcblx0XHR9XHJcblx0XHRsZXQgaW5wdXQ6IHN0cmluZyA9IHRoaXMudG9rZW5zW3RoaXMudG9rZW5JbmRleF07XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRUb2tlbihpbnB1dCk7XHJcblx0fVxyXG5cdHB1YmxpYyByZXZlcnQoKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy50b2tlbkluZGV4IDw9IDApIHsgdGhyb3cgRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7IH1cclxuXHRcdHRoaXMudG9rZW5JbmRleC0tO1xyXG5cdH1cclxuXHRwcml2YXRlIGdldFRva2VuKGlucHV0OiBzdHJpbmcpOiBUb2tlbiB7XHJcblx0XHRpZiAoL1xcKy8udGVzdChpbnB1dCkpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuUGx1cyk7XHJcblx0XHR9XHJcblx0XHRpZiAoL1xcLS8udGVzdChpbnB1dCkpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuTWludXMpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9cXCovLnRlc3QoaW5wdXQpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLk11bHRpcGx5KTtcclxuXHRcdH1cclxuXHRcdGlmICgvXFwvLy50ZXN0KGlucHV0KSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRva2VuKFRva2VuVHlwZS5EaXZpZGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9cXF4vLnRlc3QoaW5wdXQpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLkV4cG9uZW50KTtcclxuXHRcdH1cclxuXHRcdGlmICgvXFxkKyhcXC5cXGQrKT8vLnRlc3QoaW5wdXQpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLk51bWJlciwgcGFyc2VGbG9hdChpbnB1dCkpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9cXCgvLnRlc3QoaW5wdXQpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLkxQYXJlbik7XHJcblx0XHR9XHJcblx0XHRpZiAoL1xcKS8udGVzdChpbnB1dCkpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuUlBhcmVuKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLlVua25vd24pO1xyXG5cdH1cclxufVxyXG5leHBvcnQgY2xhc3MgUGFyc2VyIHtcclxuXHRwcml2YXRlIGxleDogTGV4ZXI7XHJcblx0cHVibGljIHBhcnNlKGNvZGU6IHN0cmluZyk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdHRoaXMubGV4ID0gbmV3IExleGVyKGNvZGUpO1xyXG5cdFx0Y29uc3QgZXhwcmVzc2lvbjogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLmZvdXJ0aE9yZGVyT3BlcmF0b3JzKCk7XHJcblx0XHRjb25zdCB0b2tlbjogVG9rZW4gPSB0aGlzLmxleC5nZXRDdXJyZW50VG9rZW4oKTsgLy8gaXMgYWxyZWFkeSBhZHZhbmNlZCBiZWNhdXNlIG9mIG51bWJlcigpXHJcblx0XHRpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLkVuZCkge1xyXG5cdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcclxuXHRcdH1cclxuXHRcdHRocm93IEVycm9yKFwiRW5kIGV4cGVjdGVkXCIpO1xyXG5cdH1cclxuXHQvLyBhZGRpdGlvbiBhbmQgc3Vic3RyYWN0aW9uXHJcblx0cHJpdmF0ZSBmb3VydGhPcmRlck9wZXJhdG9ycygpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRsZXQgY29tcG9uZW50MTogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLnRoaXJkT3JkZXJPcGVyYXRvcnMoKTtcclxuXHRcdGxldCB0b2tlbjogVG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdHdoaWxlICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuUGx1cyB8fCB0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTWludXMpIHtcclxuXHRcdFx0bGV0IGNvbXBvbmVudDI6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy50aGlyZE9yZGVyT3BlcmF0b3JzKCk7XHJcblx0XHRcdGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuUGx1cykge1xyXG5cdFx0XHRcdGNvbXBvbmVudDEgPSBjb21wb25lbnQxLmFkZChjb21wb25lbnQyKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTWludXMpIHtcclxuXHRcdFx0XHRjb21wb25lbnQxID0gY29tcG9uZW50MS5zdWIoY29tcG9uZW50Mik7XHJcblx0XHRcdH1cclxuXHRcdFx0dG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdH1cclxuXHRcdHRoaXMubGV4LnJldmVydCgpO1xyXG5cdFx0cmV0dXJuIGNvbXBvbmVudDE7XHJcblx0fVxyXG5cdC8vIG11bHRpcGxpY2F0aW9uIGFuZCBkaXZpc2lvblxyXG5cdHByaXZhdGUgdGhpcmRPcmRlck9wZXJhdG9ycygpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRsZXQgZmFjdG9yMTogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLnNlY29uZE9yZGVyT3BlcmF0b3JzKCk7XHJcblx0XHRsZXQgdG9rZW46IFRva2VuID0gdGhpcy5sZXguZ2V0TmV4dFRva2VuKCk7XHJcblx0XHR3aGlsZSAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk11bHRpcGx5IHx8IHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5EaXZpZGUpIHtcclxuXHRcdFx0bGV0IGZhY3RvcjI6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5zZWNvbmRPcmRlck9wZXJhdG9ycygpO1xyXG5cdFx0XHRpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk11bHRpcGx5KSB7XHJcblx0XHRcdFx0ZmFjdG9yMSA9IGZhY3RvcjEubXVsdChmYWN0b3IyKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuRGl2aWRlKSB7XHJcblx0XHRcdFx0ZmFjdG9yMSA9IGZhY3RvcjEuZGl2KGZhY3RvcjIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRva2VuID0gdGhpcy5sZXguZ2V0TmV4dFRva2VuKCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmxleC5yZXZlcnQoKTtcclxuXHRcdHJldHVybiBmYWN0b3IxO1xyXG5cdH1cclxuXHQvLyBleHBvbmVudHMgYW5kIHJvb3RzXHJcblx0cHJpdmF0ZSBzZWNvbmRPcmRlck9wZXJhdG9ycygpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRsZXQgZmFjdG9yMTogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLmZpcnN0T3JkZXJPcGVyYXRvcnMoKTtcclxuXHRcdGxldCB0b2tlbjogVG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdHdoaWxlICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuRXhwb25lbnQpIHtcclxuXHRcdFx0bGV0IGZhY3RvcjI6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5maXJzdE9yZGVyT3BlcmF0b3JzKCk7XHJcblx0XHRcdGZhY3RvcjEgPSBmYWN0b3IxLmV4cChmYWN0b3IyKTtcclxuXHRcdFx0dG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdH1cclxuXHRcdHRoaXMubGV4LnJldmVydCgpO1xyXG5cdFx0cmV0dXJuIGZhY3RvcjE7XHJcblx0fVxyXG5cdC8vIG51bWJlcnMgYW5kIHBhcmFudGhlc2VzXHJcblx0cHJpdmF0ZSBmaXJzdE9yZGVyT3BlcmF0b3JzKCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGxldCB2YWx1ZTogUmF0aW9uYWxOdW1iZXIgPSBuZXcgUmF0aW9uYWxOdW1iZXIoMSk7XHJcblx0XHRsZXQgdG9rZW46IFRva2VuID0gdGhpcy5sZXguZ2V0TmV4dFRva2VuKCk7XHJcblx0XHRpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLlBsdXMgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk1pbnVzKSB7XHJcblx0XHRcdGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTWludXMpIHtcclxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLm11bHQoLTEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRva2VuID0gdGhpcy5sZXguZ2V0TmV4dFRva2VuKCk7XHJcblx0XHR9XHJcblx0XHRpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLkxQYXJlbikge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLm11bHQodGhpcy5mb3VydGhPcmRlck9wZXJhdG9ycygpKTtcclxuXHRcdFx0dG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdFx0aWYgKHRva2VuLnR5cGUgIT09IFRva2VuVHlwZS5SUGFyZW4pIHtcclxuXHRcdFx0XHR0aHJvdyBFcnJvcihcIlVuYmFsYW5jZWQgcGFyZW50aGVzaXNcIik7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTnVtYmVyKSB7XHJcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5tdWx0KHRva2VuLnZhbHVlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBFcnJvcihcIk5vdCBhIG51bWJlclwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH1cclxufVxyXG5cclxuLypcclxuXHRwdWJsaWMgc3RhdGljIGV2YWx1YXRlKGV4cHJlc2lvbjogc3RyaW5nKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdHZhciBkaWdpdFBhdHRlcm4gPSBuZXcgUmVnRXhwKCcwIHwgMSB8IDIgfCAzIHwgNCB8IDUgfCA2IHwgNyB8IDggfCA5Jyk7XHJcblx0dmFyIHNpZ25QYXR0ZXJuID0gbmV3IFJlZ0V4cCgnXFwrfFxcLScpO1xyXG5cdHZhciBudW1iZXJQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnWycgKyBzaWduUGF0dGVybiArICddJyArICd7JyArIGRpZ2l0UGF0dGVybiArICd9Jyk7XHJcblx0dmFyIGZhY3RvclBhdHRlcm4gPSBuZXcgUmVnRXhwKG51bWJlclBhdHRlcm4gKyAnfFxcKCcgKyBleHByZXNzaW9uUGF0dGVybiArICdcXCknKTtcclxuXHR2YXIgY29tcG9uZW50UGF0dGVybiA9IG5ldyBSZWdFeHAoZmFjdG9yUGF0dGVybiArICdbeyggXFwqIHwgXFwvICknICsgZmFjdG9yUGF0dGVybiArICd9XScpO1xyXG5cdHZhciBleHByZXNzaW9uUGF0dGVybiA9IG5ldyBSZWdFeHAoY29tcG9uZW50UGF0dGVybiArICdbeyggXFwrIHwgXFwtKScgKyBjb21wb25lbnRQYXR0ZXJuICsgJ31dJyk7XHJcbn0qL1xyXG5cclxuLypcclxuZXhwcnI6IDR0aE9SREVSKztcclxuNHRoT1JERVI6IGNvbXBvbmVudDE9M3JkT1JERVIgKChQTFVTfE1JTlVTKSBjb21wb25lbnQyPTNyZE9SREVSKSs7XHJcbjNyZE9SREVSOiBmYWN0b3IxPTJORE9SREVSICgoTVVMVElQTFl8RElWSURFKSBmYWN0b3IxPTJuZE9SREVSKStcclxuMm5kT1JERVI6IGZhY3RvcjE9MXN0T1JERVIgKEVYUE9ORU5UIGZhY3RvcjI9MXN0T1JERVIpK1xyXG4xc3RPUkRFUjogKFBMVVN8TUlOVVN8ZW1wdHkpIChMUEFSRU4gdmFsdWU9NHRoT1JERVIgUlBBUkVOfCBOVU1CRVIpXHJcbiovIiwiaW1wb3J0IHsgUmF0aW9uYWxOdW1iZXIgfSBmcm9tIFwiLi9SYXRpb25hbE51bWJlclwiO1xyXG5pbXBvcnQgeyBDb2x1bW5WZWN0b3IsIFZlY3RvciB9IGZyb20gXCIuL1ZlY3RvclwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIE1hdHJpeCB7XHJcblx0cHVibGljIHN0YXRpYyBhdWdtZW50KEE6IE1hdHJpeCwgQjogTWF0cml4IHwgVmVjdG9yKTogTWF0cml4IHtcclxuXHRcdGlmIChBLm0gIT09IEIubSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdHdvIG1hdHJpY2VzICh2ZWN0b3IpIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygcm93cyAoZWxlbWVudHMpLlwiKTsgfVxyXG5cdFx0bGV0IHJldDogTWF0cml4ID0gbnVsbDtcclxuXHRcdGlmIChCIGluc3RhbmNlb2YgTWF0cml4KSB7XHJcblx0XHRcdHJldCA9IG5ldyBNYXRyaXgoQS5tLCBCLm4gKyBBLm4pO1xyXG5cdFx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgQS5tOyBpKyspIHtcclxuXHRcdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgQS5uOyBqKyspIHtcclxuXHRcdFx0XHRcdHJldC5lbGVtZW50c1tpXVtqXSA9IEEuZWxlbWVudHNbaV1bal07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBCLm07IGkrKykge1xyXG5cdFx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBCLm47IGorKykge1xyXG5cdFx0XHRcdFx0cmV0LmVsZW1lbnRzW2ldW0EubiArIGpdID0gQi5lbGVtZW50c1tpXVtqXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChCIGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcblx0XHRcdFx0cmV0ID0gbmV3IE1hdHJpeChBLm0sIEEubiArIDEpO1xyXG5cdFx0XHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBBLm07IGkrKykge1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IEEubjsgaisrKSB7XHJcblx0XHRcdFx0XHRcdHJldC5lbGVtZW50c1tpXVtqXSA9IEEuZWxlbWVudHNbaV1bal07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBCLm07IGorKykge1xyXG5cdFx0XHRcdFx0cmV0LmVsZW1lbnRzW2pdW0Eubl0gPSBCLmVsZW1lbnRzW2pdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9XHJcblx0Ly8gcm93LW11bHRpcGx5aW5nIHRyYW5zZm9ybWF0aW9uc1xyXG5cdHB1YmxpYyBzdGF0aWMgbXVsdGlwbGljYXRpb24objogbnVtYmVyLCByb3cxOiBudW1iZXIsIHJvdzI6IG51bWJlciwgbXVsdDogbnVtYmVyKTogTWF0cml4IHtcclxuXHRcdGlmIChuIDwgcm93MSB8fCBuIDwgcm93MikgeyB0aHJvdyBuZXcgRXJyb3IoXCJDb2x1bW4gaW5kZXggbXVzdCBiZSBsZXNzIG9yIGVxdWFsdCB0aGFuIG1hdHJpeCBzaXplLlwiKTsgfVxyXG5cdFx0Y29uc3QgbWF0cml4OiBNYXRyaXggPSBuZXcgTWF0cml4SWRlbnRpdHkobik7XHJcblx0XHRtYXRyaXguZWxlbWVudHNbcm93MV1bcm93Ml0gPSBuZXcgUmF0aW9uYWxOdW1iZXIobXVsdCk7XHJcblx0XHRyZXR1cm4gbWF0cml4O1xyXG5cdH1cclxuXHRwdWJsaWMgc3RhdGljIHJhbmRvbVNxdWFyZSgpOiBNYXRyaXgge1xyXG5cdFx0Y29uc3QgbWF0cml4OiBNYXRyaXggPSBuZXcgTWF0cml4KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpICsgMywgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCkgKyAzKTsgLy8gbWluaW11bSBzaXplIDN4MyBtYXRyaXhcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBtYXRyaXgubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBtYXRyaXgubjsgaisrKSB7XHJcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCAtIDUwKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBtYXRyaXg7XHJcblx0fVxyXG5cdHB1YmxpYyBzdGF0aWMgcmFuZG9tMigpOiBNYXRyaXgge1xyXG5cdFx0Y29uc3QgbnVtYmVyT2ZVbmtub3duczogbnVtYmVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCArIDMpOyAvLyBiZXR3ZWVuIDMgYW5kIDcgdW5rbm9ud3NcclxuXHRcdGNvbnN0IHVua25vd25zOiBudW1iZXJbXSA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IG51bWJlck9mVW5rbm93bnM7IGkrKykge1xyXG5cdFx0XHR1bmtub3duc1tpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwIC0gMTApO1xyXG5cdFx0fVxyXG5cdFx0Ly8gdG9kbzogY2hhbmdlIGJlbG93XHJcblx0XHRjb25zdCBtYXRyaXg6IE1hdHJpeCA9IG5ldyBNYXRyaXgoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCkgKyAzLCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KSArIDMpO1xyXG5cdFx0cmV0dXJuIG1hdHJpeDtcclxuXHR9XHJcblx0cHVibGljIG06IG51bWJlcjsgLy8gcm93c1xyXG5cdHB1YmxpYyBuOiBudW1iZXI7IC8vIGNvbHVtbnNcclxuXHRwdWJsaWMgZWxlbWVudHM6IFJhdGlvbmFsTnVtYmVyW11bXTtcclxuXHRjb25zdHJ1Y3RvcihtOiBudW1iZXIsIG46IG51bWJlcikge1xyXG5cdFx0dGhpcy5tID0gbTtcclxuXHRcdHRoaXMubiA9IG47XHJcblx0XHR0aGlzLmVsZW1lbnRzID0gW107XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50c1tpXSA9IFtdO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgZXF1YWxzKE06IE1hdHJpeCk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKHRoaXMubSAhPT0gTS5tIHx8IHRoaXMubiAhPT0gTS5uKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbaV1bal0uZXF1YWxzKE0uZWxlbWVudHNbaV1bal0pKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0cHVibGljIGFkZCh4OiBNYXRyaXgpOiBNYXRyaXgge1xyXG5cdFx0aWYgKHRoaXMubSAhPT0geC5tIHx8IHRoaXMubiAhPT0geC5uKSB7IHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgZGltZW5zaW9ucy5cIik7IH1cclxuXHRcdGNvbnN0IHJlczogTWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLm0sIHRoaXMubik7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgcmVzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgcmVzLm47IGorKykge1xyXG5cdFx0XHRcdHJlcy5lbGVtZW50c1tpXVtqXSA9IHRoaXMuZWxlbWVudHNbaV1bal0uYWRkKHguZWxlbWVudHNbaV1bal0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHRwdWJsaWMgc3ViKHg6IE1hdHJpeCk6IE1hdHJpeCB7XHJcblx0XHRpZiAodGhpcy5tICE9PSB4Lm0gfHwgdGhpcy5uICE9PSB4Lm4pIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBkaW1lbnNpb25zLlwiKTsgfVxyXG5cdFx0Y29uc3QgcmVzOiBNYXRyaXggPSBuZXcgTWF0cml4KHRoaXMubSwgdGhpcy5uKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCByZXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCByZXMubjsgaisrKSB7XHJcblx0XHRcdFx0cmVzLmVsZW1lbnRzW2ldW2pdID0gdGhpcy5lbGVtZW50c1tpXVtqXS5zdWIoeC5lbGVtZW50c1tpXVtqXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cdHB1YmxpYyBtdWx0KHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyIHwgTWF0cml4KTogTWF0cml4IHtcclxuXHRcdGxldCByZXM6IE1hdHJpeCA9IG51bGw7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmVzID0gbmV3IE1hdHJpeCh0aGlzLm0sIHRoaXMubik7XHJcblx0XHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCByZXMubTsgaSsrKSB7XHJcblx0XHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHJlcy5uOyBqKyspIHtcclxuXHRcdFx0XHRcdHJlcy5lbGVtZW50c1tpXVtqXSA9IHRoaXMuZWxlbWVudHNbaV1bal0ubXVsdCh4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIFJhdGlvbmFsTnVtYmVyKSB7XHJcblx0XHRcdHJlcyA9IG5ldyBNYXRyaXgodGhpcy5tLCB0aGlzLm4pO1xyXG5cdFx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgcmVzLm07IGkrKykge1xyXG5cdFx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCByZXMubjsgaisrKSB7XHJcblx0XHRcdFx0XHRyZXMuZWxlbWVudHNbaV1bal0gPSB0aGlzLmVsZW1lbnRzW2ldW2pdLm11bHQoeCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoeCBpbnN0YW5jZW9mIE1hdHJpeCkge1xyXG5cdFx0XHRcdGlmICh0aGlzLm4gIT09IHgubSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGRpbWVuc2lvbnMuXCIpOyB9XHJcblx0XHRcdFx0cmVzID0gbmV3IE1hdHJpeCh0aGlzLm0sIHgubik7XHJcblx0XHRcdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHJlcy5tOyBpKyspIHtcclxuXHRcdFx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCByZXMubjsgaisrKSB7XHJcblx0XHRcdFx0XHRcdGxldCBzdW06IFJhdGlvbmFsTnVtYmVyID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBrOiBudW1iZXIgPSAwOyBrIDwgdGhpcy5uOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRzdW0gPSBzdW0uYWRkKHRoaXMuZWxlbWVudHNbaV1ba10ubXVsdCh4LmVsZW1lbnRzW2tdW2pdKSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cmVzLmVsZW1lbnRzW2ldW2pdID0gc3VtO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblx0cHVibGljIHZlY3RvclByb2R1Y3QodjogQ29sdW1uVmVjdG9yKTogQ29sdW1uVmVjdG9yIHtcclxuXHRcdGlmICh0aGlzLm4gIT09IHYubSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGRpbWVuc2lvbnMuXCIpOyB9XHJcblx0XHRjb25zdCByZXM6IENvbHVtblZlY3RvciA9IG5ldyBDb2x1bW5WZWN0b3Iodi5tKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRsZXQgc3VtOiBSYXRpb25hbE51bWJlciA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdFx0c3VtID0gc3VtLmFkZCh0aGlzLmVsZW1lbnRzW2ldW2pdLm11bHQodi5lbGVtZW50c1tqXSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJlcy5lbGVtZW50c1tpXSA9IHN1bTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cdHB1YmxpYyB0cmFuc3Bvc2UoKTogTWF0cml4IHtcclxuXHRcdGNvbnN0IHJldDogTWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLm4sIHRoaXMubSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdFx0cmV0LmVsZW1lbnRzW2pdW2ldID0gdGhpcy5lbGVtZW50c1tpXVtqXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9XHJcblx0cHVibGljIGRlZXBDb3B5KCk6IE1hdHJpeCB7XHJcblx0XHRjb25zdCByZXQ6IE1hdHJpeCA9IG5ldyBNYXRyaXgodGhpcy5tLCB0aGlzLm4pO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm47IGorKykge1xyXG5cdFx0XHRcdHJldC5lbGVtZW50c1tpXVtqXSA9IHRoaXMuZWxlbWVudHNbaV1bal07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG5cdHB1YmxpYyBzd2l0Y2hSb3dzKGlkeDE6IG51bWJlciwgaWR4MjogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5tIDwgaWR4MSB8fCB0aGlzLm0gPCBpZHgyKSB7IHJldHVybjsgfVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubjsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IHRtcDogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLmVsZW1lbnRzW2lkeDFdW2ldO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzW2lkeDFdW2ldID0gdGhpcy5lbGVtZW50c1tpZHgyXVtpXTtcclxuXHRcdFx0dGhpcy5lbGVtZW50c1tpZHgyXVtpXSA9IHRtcDtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIG11bHRpcGx5Um93KGlkeDogbnVtYmVyLCBzY2FsYXI6IFJhdGlvbmFsTnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5tIDwgaWR4KSB7IHJldHVybjsgfVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbaWR4XVtpXSA9IHRoaXMuZWxlbWVudHNbaWR4XVtpXS5tdWx0KHNjYWxhcikuc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGFkZFJvd3MoaWR4MTogbnVtYmVyLCBpZHgyOiBudW1iZXIsIHNjYWxhcjogUmF0aW9uYWxOdW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLm0gPCBpZHgxIHx8IHRoaXMubSA8IGlkeDIpIHsgcmV0dXJuOyB9XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5uOyBpKyspIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50c1tpZHgxXVtpXSA9IHRoaXMuZWxlbWVudHNbaWR4Ml1baV0ubXVsdChzY2FsYXIpLmFkZCh0aGlzLmVsZW1lbnRzW2lkeDFdW2ldKS5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgYWRkUm93MVRvUm93MihpZHgxOiBudW1iZXIsIHNjYWxhcjE6IFJhdGlvbmFsTnVtYmVyLCBpZHgyOiBudW1iZXIsIHNjYWxhcjI6IFJhdGlvbmFsTnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5tIDwgaWR4MSB8fCB0aGlzLm0gPCBpZHgyKSB7IHJldHVybjsgfVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbaWR4Ml1baV0gPSB0aGlzLmVsZW1lbnRzW2lkeDJdW2ldLm11bHQoc2NhbGFyMikuYWRkKHRoaXMuZWxlbWVudHNbaWR4MV1baV0ubXVsdChzY2FsYXIxKSkuc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gYSBzcXVhcmUgbWF0cml4IGlzIGEgbWF0cml4IHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnNcclxuXHRwdWJsaWMgaXNTcXVhcmUoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5tID09PSB0aGlzLm47XHJcblx0fVxyXG5cdC8vIGEgZGlhZ29uYWwgbWF0cml4IGlzIGEgbWF0cml4IGluIHdoaWNoIHRoZSBlbnRyaWVzIG91dHNpZGUgdGhlIG1haW4gZGlhZ29uYWwgYXJlIGFsbCB6ZXJvXHJcblx0cHVibGljIGlzRGlhZ29uYWwoKTogYm9vbGVhbiB7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGkgPT09IGopIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbaV1bal0uZXF1YWxzKG5ldyBSYXRpb25hbE51bWJlcigwKSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHQvLyB0aGUgaWRlbnRpdHkgbWF0cml4IG9mIHNpemUgbiBpcyB0aGUgbiDDlyBuIHNxdWFyZSBtYXRyaXggd2l0aCBvbmVzIG9uIHRoZSBtYWluIGRpYWdvbmFsIGFuZCB6ZXJvcyBlbHNld2hlcmVcclxuXHQvLyBbQUxJQVNFU106IHVuaXQgbWF0cml4XHJcblx0cHVibGljIGlzSWRlbnRpdHkoKTogYm9vbGVhbiB7XHJcblx0XHRpZiAodGhpcy5tICE9PSB0aGlzLm4pIHsgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgc3F1YXJlIG1hdHJpeC5cIik7IH1cclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoaSA9PT0gaikge1xyXG5cdFx0XHRcdFx0aWYgKCF0aGlzLmVsZW1lbnRzW2ldW2pdLmVxdWFscyhuZXcgUmF0aW9uYWxOdW1iZXIoMSkpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tpXVtqXS5lcXVhbHMobmV3IFJhdGlvbmFsTnVtYmVyKDApKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdC8vIGEgbWF0cml4IGlzIG5vcm1hbCBpZiBpdCBjb21tdXRlcyB3aXRoIGl0cyBjb25qdWdhdGUgdHJhbnNwb3NlXHJcblx0cHVibGljIGlzTm9ybWFsKCk6IGJvb2xlYW4ge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xyXG5cdH1cclxuXHQvLyB0aGUgY29uanVnYXRlIHRyYW5zcG9zZSBvZiBhbiBtLWJ5LW4gbWF0cml4IEEgd2l0aCBjb21wbGV4IGVudHJpZXMgaXMgdGhlIG4tYnktbSBtYXRyaXggQeKIlyBvYnRhaW5lZCBmcm9tIEFcclxuXHQvLyBieSB0YWtpbmcgdGhlIHRyYW5zcG9zZSBhbmQgdGhlbiB0YWtpbmcgdGhlIGNvbXBsZXggY29uanVnYXRlIG9mIGVhY2ggZW50cnlcclxuXHQvLyBbQUxJQVNFU106IEhlcm1pdGlhbiB0cmFuc3Bvc2VcclxuXHRwdWJsaWMgdG9Db25qdWdhdGVUcmFuc3Bvc2UoKTogTWF0cml4IHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcclxuXHR9XHJcblx0cHVibGljIGlzVXBwZXJUcmlhbmd1bGFyKCk6IGJvb2xlYW4ge1xyXG5cdFx0Ly8gdG9kbzogY2hlY2sgaWYgZGVmaW5pdGlvbiBpcyB2YWxpZCBmb3IgYSBub24gc3F1YXJlIG1hdHJpeFxyXG5cdFx0Ly8gaWYgKHRoaXMubSAhPT0gdGhpcy5uKSB7IHRocm93IG5ldyBFcnJvcihcIk5vdCBhIHNxdWFyZSBtYXRyaXguXCIpOyB9XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAxOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IGk7IGorKykge1xyXG5cdFx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tpXVtqXS5lcXVhbHMobmV3IFJhdGlvbmFsTnVtYmVyKDApKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHB1YmxpYyBpc0xvd2VyVHJpYW5ndWxhcigpOiBib29sZWFuIHtcclxuXHRcdC8vIHRvZG86IGNoZWNrIGlmIGRlZmluaXRpb24gaXMgdmFsaWQgZm9yIGEgbm9uIHNxdWFyZSBtYXRyaXhcclxuXHRcdC8vIGlmICh0aGlzLm0gIT09IHRoaXMubikgeyB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBzcXVhcmUgbWF0cml4LlwiKTsgfVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IGkgKyAxOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbaV1bal0uZXF1YWxzKG5ldyBSYXRpb25hbE51bWJlcigwKSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHQvLyBhIHN5bW1ldHJpYyBtYXRyaXggaXMgYSBzcXVhcmUgbWF0cml4IHRoYXQgaXMgZXF1YWwgdG8gaXRzIHRyYW5zcG9zZVxyXG5cdHB1YmxpYyBpc1N5bW1ldHJpYygpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzLm0gIT09IHRoaXMubikgeyB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBzcXVhcmUgbWF0cml4LlwiKTsgfVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm47IGorKykge1xyXG5cdFx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tpXVtqXS5lcXVhbHModGhpcy5lbGVtZW50c1tqXVtpXSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHQvLyBhbiBvcnRob2dvbmFsIG1hdHJpeCBpcyBhIHNxdWFyZSBtYXRyaXggd2l0aCByZWFsIGVudHJpZXMgd2hvc2UgY29sdW1ucyBhbmQgcm93cyBhcmUgb3J0aG9nb25hbCB1bml0IHZlY3RvcnNcclxuXHQvLyBbQUxJQVNFU106IHJlYWwgb3J0aG9nb25hbCBtYXRyaXhcclxuXHRwdWJsaWMgaXNPcnRob2dvbmFsKCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgTVQ6IE1hdHJpeCA9IHRoaXMudHJhbnNwb3NlKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0KE1UKS5pc0lkZW50aXR5KCk7XHJcblx0fVxyXG5cdHB1YmxpYyBpc1Jvd0VjaGVsb25Gb3JtKCk6IGJvb2xlYW4ge1xyXG5cdFx0bGV0IGZvdW5kWmVyb1JvdzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdFx0Ly8gYWxsIG5vbnplcm8gcm93cyAocm93cyB3aXRoIGF0IGxlYXN0IG9uZSBub256ZXJvIGVsZW1lbnQpIGFyZSBhYm92ZSBhbnkgcm93cyBvZiBhbGwgemVyb2VzXHJcblx0XHQvLyAoYWxsIHplcm8gcm93cywgaWYgYW55LCBiZWxvbmcgYXQgdGhlIGJvdHRvbSBvZiB0aGUgbWF0cml4KVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLmlzWmVyb1JvdyhpKSkge1xyXG5cdFx0XHRcdGZvdW5kWmVyb1JvdyA9IHRydWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKGZvdW5kWmVyb1JvdykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0fS8vIGlmIGN1cnJlbnQgcm93IGlzIG5vdCB6ZXJvLCBidXQgYSBwcmV2aW91cyByb3cgaXMgemVybywgdGhlbiBtYXRyaXggaXMgbm90IGluIHJvdyBlY2hlbG9uIGZvcm1cclxuXHRcdH1cclxuXHRcdC8vIHRoZSBsZWFkaW5nIGNvZWZmaWNpZW50ICh0aGUgZmlyc3Qgbm9uemVybyBudW1iZXIgZnJvbSB0aGUgbGVmdCwgYWxzbyBjYWxsZWQgdGhlIHBpdm90KSBvZiBhIG5vbnplcm8gcm93XHJcblx0XHQvLyBpcyBhbHdheXMgc3RyaWN0bHkgdG8gdGhlIHJpZ2h0IG9mIHRoZSBsZWFkaW5nIGNvZWZmaWNpZW50IG9mIHRoZSByb3cgYWJvdmUgaXRcclxuXHRcdGxldCBwcmV2aW91c0lkeDogbnVtYmVyID0gLTE7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Y29uc3QgY3VycmVudFBpdm90SWR4OiBudW1iZXIgPSB0aGlzLnJvd1Bpdm90UG9zaXRpb24oaSk7XHJcblx0XHRcdGlmICgwID4gY3VycmVudFBpdm90SWR4KSB7IGNvbnRpbnVlOyB9Ly8gdGhpcyBpcyBhIHplcm8gcm93LCBubyBwaXZvdFxyXG5cdFx0XHQvLyBsZWFkaW5nIGNvZWZmaWNpZW50IG11c3QgYmUgMVxyXG5cdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbaV1bY3VycmVudFBpdm90SWR4XS5lcXVhbHMobmV3IFJhdGlvbmFsTnVtYmVyKDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0aWYgKHByZXZpb3VzSWR4IDwgY3VycmVudFBpdm90SWR4KSB7XHJcblx0XHRcdFx0cHJldmlvdXNJZHggPSBjdXJyZW50UGl2b3RJZHg7XHJcblx0XHRcdH0gZWxzZSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHB1YmxpYyBpc1JlZHVjZWRSb3dFY2hlbG9uRm9ybSgpOiBib29sZWFuIHtcclxuXHRcdGlmICghdGhpcy5pc1Jvd0VjaGVsb25Gb3JtKCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHQvLyBlYWNoIGxlYWRpbmcgY29lZmZpY2llbnQgaXMgdGhlIG9ubHkgbm9uemVybyBlbnRyeSBpbiBpdHMgY29sdW1uXHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Y29uc3QgcGl2b3RQb3NpdGlvbjogbnVtYmVyID0gdGhpcy5yb3dQaXZvdFBvc2l0aW9uKGkpO1xyXG5cdFx0XHRpZiAoMSA8IHRoaXMubnVtYmVyT2ZOb25aZXJvRWxlbWVudEZvckNvbHVtbihwaXZvdFBvc2l0aW9uKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRwdWJsaWMgdG9SZWR1Y2VkUm93RWNoZWxvbkZvcm0oKTogTWF0cml4IHtcclxuXHRcdGNvbnN0IHJlczogTWF0cml4ID0gdGhpcy5kZWVwQ29weSgpO1xyXG5cdFx0bGV0IGxlYWQ6IG51bWJlciA9IDA7XHJcblx0XHRmb3IgKGxldCByOiBudW1iZXIgPSAwOyByIDwgcmVzLm07IHIrKykge1xyXG5cdFx0XHRpZiAocmVzLm4gPD0gbGVhZCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBpOiBudW1iZXIgPSByO1xyXG5cdFx0XHR3aGlsZSAocmVzLmVsZW1lbnRzW2ldW2xlYWRdLmVxdWFscygwKSkge1xyXG5cdFx0XHRcdGkrKztcclxuXHRcdFx0XHRpZiAocmVzLm0gPT09IGkpIHtcclxuXHRcdFx0XHRcdGkgPSByO1xyXG5cdFx0XHRcdFx0bGVhZCsrO1xyXG5cdFx0XHRcdFx0aWYgKHJlcy5uID09PSBsZWFkKSB7XHJcblx0XHRcdFx0XHRcdGxlYWQtLTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJlcy5zd2l0Y2hSb3dzKGksIHIpO1xyXG5cdFx0XHRpZiAoIXJlcy5lbGVtZW50c1tyXVtsZWFkXS5lcXVhbHMoMCkpIHtcclxuXHRcdFx0XHRyZXMubXVsdGlwbHlSb3cociwgcmVzLmVsZW1lbnRzW3JdW2xlYWRdLnJlY2lwcm9jYWwoKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHJlcy5tOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoaiAhPT0gcikge1xyXG5cdFx0XHRcdFx0cmVzLmFkZFJvd3MoaiwgciwgcmVzLmVsZW1lbnRzW2pdW2xlYWRdLm9wcG9zaXRlKCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRsZWFkKys7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHRwdWJsaWMgZGV0ZXJtaW5hbnQoKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0Ly8gdG9kbzogaW1wbGVtZW50IGFuIG9wdGltaXplZCB2ZXJzaW9uLCBsaWtlIEE9UExVXHJcblx0XHRpZiAodGhpcy5tICE9PSB0aGlzLm4pIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRGV0ZXJtaW5hbnQgY2FuIG9ubHkgYmUgY2FsY3VsYXRlZCBvbiBhIHNxdWFyZSBtYXRyaXhcIik7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5tID09PSAxKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnRzWzBdWzBdO1xyXG5cdFx0fVxyXG5cdFx0bGV0IHJldDogUmF0aW9uYWxOdW1iZXIgPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5uOyBpKyspIHtcclxuXHRcdFx0Y29uc3QgbWlub3I6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5lbGVtZW50c1swXVtpXS5tdWx0KHRoaXMuY29mYWN0b3IoMCwgaSkuZGV0ZXJtaW5hbnQoKSk7XHJcblx0XHRcdHJldCA9IHJldC5hZGQobWlub3IubXVsdCgoLTEpICoqIGkpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG5cdHB1YmxpYyBjb252b2x1dGUoa2VybmVsOiBNYXRyaXgpOiBNYXRyaXgge1xyXG5cdFx0aWYgKGtlcm5lbC5tICE9PSBrZXJuZWwubikgeyB0aHJvdyBuZXcgRXJyb3IoXCJLZXJuZWwgaXMgbm90IGEgc3F1YXJlIG1hdHJpeC5cIik7IH1cclxuXHRcdGlmIChrZXJuZWwubSAlIDIgPT09IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiS2VybmVsIGlzIG5vdCBhbiBldmVuIHNpemUgbWF0cml4LlwiKTsgfVxyXG5cdFx0Y29uc3Qgc3ogPSBNYXRoLmZsb29yKGtlcm5lbC5tIC8gMik7XHJcblx0XHRjb25zdCByZXM6IE1hdHJpeCA9IG5ldyBNYXRyaXgodGhpcy5tLCB0aGlzLm4pO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm47IGorKykge1xyXG5cdFx0XHRcdHJlcy5lbGVtZW50c1tpXVtqXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdFx0XHRmb3IgKGxldCB0aTogbnVtYmVyID0gMDsgdGkgPCBrZXJuZWwubTsgdGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKGkgKyB0aSAtIHN6IDwgMCB8fCBpICsgdGkgLSBzeiA+PSB0aGlzLm0pIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRmb3IgKGxldCB0ajogbnVtYmVyID0gMDsgdGogPCBrZXJuZWwubjsgdGorKykge1xyXG5cdFx0XHRcdFx0XHRpZiAoaiArIHRqIC0gc3ogPCAwIHx8IGogKyB0aiAtIHN6ID49IHRoaXMubikge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHJlcy5lbGVtZW50c1tpXVtqXSA9IHJlcy5lbGVtZW50c1tpXVtqXS5hZGQodGhpcy5lbGVtZW50c1tpICsgdGkgLSBzel1baiArIHRqIC0gc3pdLm11bHQoa2VybmVsLmVsZW1lbnRzW3RpXVt0al0pKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGlzWmVyb1Jvdyhyb3dJZDogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLmVsZW1lbnRzW3Jvd0lkXVtqXS5lcXVhbHMobmV3IFJhdGlvbmFsTnVtYmVyKDApKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRwcml2YXRlIHJvd1Bpdm90UG9zaXRpb24ocm93SWQ6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLmVsZW1lbnRzW3Jvd0lkXVtqXS5lcXVhbHMobmV3IFJhdGlvbmFsTnVtYmVyKDApKSkgeyByZXR1cm4gajsgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIC0xO1xyXG5cdH1cclxuXHRwcml2YXRlIG51bWJlck9mTm9uWmVyb0VsZW1lbnRGb3JDb2x1bW4oY29sdW1uSWQ6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRsZXQgYWNjOiBudW1iZXIgPSAwO1xyXG5cdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubTsgaisrKSB7XHJcblx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tqXVtjb2x1bW5JZF0uZXF1YWxzKG5ldyBSYXRpb25hbE51bWJlcigwKSkpIHsgYWNjKys7IH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBhY2M7XHJcblx0fVxyXG5cdHByaXZhdGUgY29mYWN0b3Iocm93SWQ6IG51bWJlciwgY29sdW1uSWQ6IG51bWJlcik6IE1hdHJpeCB7XHJcblx0XHRjb25zdCByZXQ6IE1hdHJpeCA9IG5ldyBNYXRyaXgodGhpcy5tIC0gMSwgdGhpcy5uIC0gMSk7XHJcblx0XHRsZXQgcm93T2Zmc2V0OiBudW1iZXIgPSAwO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubSAtIDE7IGkrKykge1xyXG5cdFx0XHRpZiAoaSA9PT0gcm93SWQpIHtcclxuXHRcdFx0XHRyb3dPZmZzZXQgPSAxO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBjb2x1bW5PZmZzZXQ6IG51bWJlciA9IDA7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm4gLSAxOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoaiA9PT0gY29sdW1uSWQpIHtcclxuXHRcdFx0XHRcdGNvbHVtbk9mZnNldCA9IDE7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldC5lbGVtZW50c1tpXVtqXSA9IHRoaXMuZWxlbWVudHNbaSArIHJvd09mZnNldF1baiArIGNvbHVtbk9mZnNldF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTWF0cml4SWRlbnRpdHkgZXh0ZW5kcyBNYXRyaXgge1xyXG5cdGNvbnN0cnVjdG9yKG06IG51bWJlcikge1xyXG5cdFx0c3VwZXIobSwgbSk7XHJcblx0XHR0aGlzLmVsZW1lbnRzID0gW107XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50c1tpXSA9IFtdO1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5tOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoaSA9PT0gaikge1xyXG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50c1tpXVtqXSA9IG5ldyBSYXRpb25hbE51bWJlcigxKTtcclxuXHRcdFx0XHR9IGVsc2UgeyB0aGlzLmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIGVsaW1pbmF0aW9uIC0gbXVsdGlwbHkgb24gdGhlIGxlZnQgKEUqQSk7IFJvdy1hZGRpdGlvbiB0cmFuc2Zvcm1hdGlvbnNcclxuLy8gdG8gbXVsdCoocm93MiBvZiBNYXRyaXggQSkgYWRkIChyb3cxIG9mIE1hdHJpeCBBKVxyXG5leHBvcnQgY2xhc3MgTWF0cml4RWxpbWluYXRpb24gZXh0ZW5kcyBNYXRyaXgge1xyXG5cdHB1YmxpYyByb3cxOiBudW1iZXI7XHJcblx0cHVibGljIHJvdzI6IG51bWJlcjtcclxuXHRjb25zdHJ1Y3RvcihtOiBudW1iZXIsIHIxOiBudW1iZXIsIHIyOiBudW1iZXIsIG11bHQ6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKSB7XHJcblx0XHRpZiAobSA8IHIxIHx8IG0gPCByMikgeyB0aHJvdyBuZXcgRXJyb3IoXCJDb2x1bW4gaW5kZXggbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG1hdHJpeCBzaXplLlwiKTsgfVxyXG5cdFx0c3VwZXIobSwgbSk7XHJcblx0XHR0aGlzLnJvdzEgPSByMTtcclxuXHRcdHRoaXMucm93MiA9IHIyO1xyXG5cdFx0dGhpcy5lbGVtZW50cyA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbaV0gPSBbXTtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubTsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGkgPT09IGopIHtcclxuXHRcdFx0XHRcdHRoaXMuZWxlbWVudHNbaV1bal0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMSk7XHJcblx0XHRcdFx0fSBlbHNlIHsgdGhpcy5lbGVtZW50c1tpXVtqXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAodHlwZW9mIG11bHQgPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50c1tyMV1bcjJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKG11bHQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKG11bHQgaW5zdGFuY2VvZiBSYXRpb25hbE51bWJlcikgeyB0aGlzLmVsZW1lbnRzW3IxXVtyMl0gPSBtdWx0OyB9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBwZXJtdXRhdGlvbiAtIG11bHRpcGx5IG9uIHRoZSByaWdodCAoQSpQKTsgUm93LXN3aXRjaGluZyB0cmFuc2Zvcm1hdGlvbnNcclxuZXhwb3J0IGNsYXNzIE1hdHJpeFBlcm11dGF0aW9uIGV4dGVuZHMgTWF0cml4IHtcclxuXHRjb25zdHJ1Y3RvcihtOiBudW1iZXIsIHJvdzE6IG51bWJlciwgcm93MjogbnVtYmVyKSB7XHJcblx0XHRpZiAobSA8IHJvdzEgfHwgbSA8IHJvdzIpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ29sdW1uIGluZGV4IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBtYXRyaXggc2l6ZS5cIik7IH1cclxuXHRcdHN1cGVyKG0sIG0pO1xyXG5cdFx0dGhpcy5lbGVtZW50cyA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbaV0gPSBbXTtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubTsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGkgPT09IGopIHtcclxuXHRcdFx0XHRcdHRoaXMuZWxlbWVudHNbaV1bal0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMSk7XHJcblx0XHRcdFx0fSBlbHNlIHsgdGhpcy5lbGVtZW50c1tpXVtqXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLmVsZW1lbnRzW3JvdzFdW3JvdzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0dGhpcy5lbGVtZW50c1tyb3cxXVtyb3cyXSA9IG5ldyBSYXRpb25hbE51bWJlcigxKTtcclxuXHRcdHRoaXMuZWxlbWVudHNbcm93Ml1bcm93Ml0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHR0aGlzLmVsZW1lbnRzW3JvdzJdW3JvdzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDEpO1xyXG5cdH1cclxufSIsImV4cG9ydCBjbGFzcyBRdWV1ZTxUPiB7XHJcblx0cHJpdmF0ZSBxdWV1ZTogVFtdO1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0dGhpcy5xdWV1ZSA9IFtdO1xyXG5cdH1cclxuXHRwdWJsaWMgaXNFbXB0eSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMDtcclxuXHR9XHJcblx0cHVibGljIGVucXVldWUoZWxlbWVudDogVCk6IHZvaWQge1xyXG5cdFx0dGhpcy5xdWV1ZS5wdXNoKGVsZW1lbnQpO1xyXG5cdH1cclxuXHRwdWJsaWMgZGVxdWV1ZSgpOiBUIHtcclxuXHRcdGlmICh0aGlzLmlzRW1wdHkoKSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJRdWV1ZSBpcyBlbXB0eVwiKTsgfVxyXG5cdFx0cmV0dXJuIHRoaXMucXVldWUuc2hpZnQoKTtcclxuXHR9XHJcblx0cHVibGljIHBlZWsoKTogVCB7XHJcblx0XHRpZiAodGhpcy5pc0VtcHR5KCkpIHsgdGhyb3cgbmV3IEVycm9yKFwiUXVldWUgaXMgZW1wdHlcIik7IH1cclxuXHRcdHJldHVybiB0aGlzLnF1ZXVlWzBdO1xyXG5cdH1cclxuXHRwdWJsaWMgdG9BcnJheSgpOiBUW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMucXVldWU7XHJcblx0fVxyXG59IiwiaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSBcIi4vQXJpdGhtZXRpY0V2YWx1YXRvclwiO1xyXG5pbXBvcnQgeyBRdWV1ZSB9IGZyb20gXCIuL1F1ZXVlXCI7XHJcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSBcIi4vU3RhY2tcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBSYXRpb25hbE51bWJlciB7XHJcblx0cHVibGljIHN0YXRpYyB0b1JldmVyc2VQb2xpc2hOb3RhdGlvbihjb2RlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcblx0XHRjb25zdCB0b2tlbnM6IHN0cmluZ1tdID0gY29kZS5tYXRjaCgvXFwofFxcKXxcXGQrKFxcLlxcZCspP3xcXHcrfFtcXCtcXC1cXCpcXC9cXF5dL2cpO1xyXG5cdFx0bGV0IGk6IG51bWJlciA9IDA7XHJcblx0XHRjb25zdCBvdXRwdXRRdWV1ZTogUXVldWU8c3RyaW5nPiA9IG5ldyBRdWV1ZTxzdHJpbmc+KCk7XHJcblx0XHRjb25zdCBvcGVyYXRvclN0YWNrOiBTdGFjazxzdHJpbmc+ID0gbmV3IFN0YWNrPHN0cmluZz4oKTtcclxuXHRcdHdoaWxlIChpIDwgdG9rZW5zLmxlbmd0aCkge1xyXG5cdFx0XHRpZiAodGhpcy5pc051bWJlcih0b2tlbnNbaV0pKSB7XHJcblx0XHRcdFx0b3V0cHV0UXVldWUuZW5xdWV1ZSh0b2tlbnNbaV0pO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuaXNPcGVyYXRvcih0b2tlbnNbaV0pKSB7XHJcblx0XHRcdFx0Y29uc3Qgb3AxOiBzdHJpbmcgPSB0b2tlbnNbaV07XHJcblx0XHRcdFx0d2hpbGUgKCFvcGVyYXRvclN0YWNrLmlzRW1wdHkoKSAmJiB0aGlzLmlzT3BlcmF0b3Iob3BlcmF0b3JTdGFjay5wZWVrKCkpKSB7XHJcblx0XHRcdFx0XHRpZiAoKHRoaXMuaXNMZWZ0QXNzb2NpYXRpdmVPcGVyYXRvcihvcDEpICYmICh0aGlzLnByZWNlZGVuY2Uob3AxKSA8PSB0aGlzLnByZWNlZGVuY2Uob3BlcmF0b3JTdGFjay5wZWVrKCkpKSkgfHxcclxuXHRcdFx0XHRcdFx0KHRoaXMuaXNSaWdodEFzc29jaWF0aXZlT3BlcmF0b3Iob3AxKSAmJiAodGhpcy5wcmVjZWRlbmNlKG9wMSkgPCB0aGlzLnByZWNlZGVuY2Uob3BlcmF0b3JTdGFjay5wZWVrKCkpKSkpIHtcclxuXHRcdFx0XHRcdFx0b3V0cHV0UXVldWUuZW5xdWV1ZShvcGVyYXRvclN0YWNrLnBvcCgpKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRvcGVyYXRvclN0YWNrLnB1c2gob3AxKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0b2tlbnNbaV0gPT09IFwiKFwiKSB7XHJcblx0XHRcdFx0b3BlcmF0b3JTdGFjay5wdXNoKHRva2Vuc1tpXSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW5zW2ldID09PSBcIilcIikge1xyXG5cdFx0XHRcdHdoaWxlICghb3BlcmF0b3JTdGFjay5pc0VtcHR5KCkgJiYgb3BlcmF0b3JTdGFjay5wZWVrKCkgIT09IFwiKFwiKSB7XHJcblx0XHRcdFx0XHRvdXRwdXRRdWV1ZS5lbnF1ZXVlKG9wZXJhdG9yU3RhY2sucG9wKCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoIW9wZXJhdG9yU3RhY2suaXNFbXB0eSgpICYmIG9wZXJhdG9yU3RhY2sucGVlaygpID09PSBcIihcIikge1xyXG5cdFx0XHRcdFx0b3BlcmF0b3JTdGFjay5wb3AoKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBwYXJlbnRoZXNlcy5cIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGkrKztcclxuXHRcdH1cclxuXHRcdHdoaWxlICghb3BlcmF0b3JTdGFjay5pc0VtcHR5KCkpIHtcclxuXHRcdFx0aWYgKG9wZXJhdG9yU3RhY2sucGVlaygpID09PSBcIihcIikge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgcGFyZW50aGVzZXMuXCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG91dHB1dFF1ZXVlLmVucXVldWUob3BlcmF0b3JTdGFjay5wb3AoKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBvdXRwdXRRdWV1ZS50b0FycmF5KCk7XHJcblx0fVxyXG5cdHB1YmxpYyBzdGF0aWMgZnJvbVN0cmluZyhjb2RlOiBzdHJpbmcpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRjb25zdCBwOiBQYXJzZXIgPSBuZXcgUGFyc2VyKCk7XHJcblx0XHRyZXR1cm4gcC5wYXJzZShjb2RlKTtcclxuXHR9XHJcblx0cHVibGljIHN0YXRpYyBncmVhdGVzdENvbW1vbkRpdmlzb3IoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIGIgPyBSYXRpb25hbE51bWJlci5ncmVhdGVzdENvbW1vbkRpdmlzb3IoYiwgYSAlIGIpIDogYTtcclxuXHR9XHJcblx0cHVibGljIHN0YXRpYyBsZWFzdENvbW1vbk11bHRpcGxlKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBNYXRoLmFicyhhICogYiAvIFJhdGlvbmFsTnVtYmVyLmdyZWF0ZXN0Q29tbW9uRGl2aXNvcihhLCBiKSk7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIGlzTnVtYmVyKGNvZGU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIC9eXFxkLy50ZXN0KGNvZGUpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBpc09wZXJhdG9yKGNvZGU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIC9bXFwrXFwtXFwqXFwvXFxeXS8udGVzdChjb2RlKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgaXNMZWZ0QXNzb2NpYXRpdmVPcGVyYXRvcihvcGVyYXRvcjogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gL1tcXCtcXC1cXCpcXC9dLy50ZXN0KG9wZXJhdG9yKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgaXNSaWdodEFzc29jaWF0aXZlT3BlcmF0b3Iob3BlcmF0b3I6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIC9bXFxeXS8udGVzdChvcGVyYXRvcik7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIHByZWNlZGVuY2Uob3BlcmF0b3I6IHN0cmluZyk6IG51bWJlciB7XHJcblx0XHRpZiAoL1tcXCtcXC1dLy50ZXN0KG9wZXJhdG9yKSkge1xyXG5cdFx0XHRyZXR1cm4gMTtcclxuXHRcdH1cclxuXHRcdGlmICgvW1xcKlxcL10vLnRlc3Qob3BlcmF0b3IpKSB7XHJcblx0XHRcdHJldHVybiAyO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9bXFxeXS8udGVzdChvcGVyYXRvcikpIHtcclxuXHRcdFx0cmV0dXJuIDM7XHJcblx0XHR9XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yLlwiKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgZXZhbHVhdGVGcm9tUlBOKHRva2Vuczogc3RyaW5nW10pOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRjb25zdCBzdGFjazogU3RhY2s8UmF0aW9uYWxOdW1iZXI+ID0gbmV3IFN0YWNrPFJhdGlvbmFsTnVtYmVyPigpO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoIXRoaXMuaXNPcGVyYXRvcih0b2tlbnNbaV0pKSB7XHJcblx0XHRcdFx0c3RhY2sucHVzaChuZXcgUmF0aW9uYWxOdW1iZXIocGFyc2VGbG9hdCh0b2tlbnNbaV0pKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc3Qgb3AxOiBSYXRpb25hbE51bWJlciA9IHN0YWNrLnBvcCgpO1xyXG5cdFx0XHRcdGNvbnN0IG9wMjogUmF0aW9uYWxOdW1iZXIgPSBzdGFjay5wb3AoKTtcclxuXHRcdFx0XHRzd2l0Y2ggKHRva2Vuc1tpXSkge1xyXG5cdFx0XHRcdFx0Y2FzZSBcIitcIjogc3RhY2sucHVzaChvcDIuYWRkKG9wMSkpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgXCItXCI6IHN0YWNrLnB1c2gob3AyLnN1YihvcDEpKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIFwiKlwiOiBzdGFjay5wdXNoKG9wMi5tdWx0KG9wMSkpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgXCIvXCI6IHN0YWNrLnB1c2gob3AyLmRpdihvcDEpKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIFwiXlwiOiBzdGFjay5wdXNoKG9wMi5leHAob3AxLnRvTnVtYmVyKCkpKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RhY2sucG9wKCkuc2ltcGxpZmllZEZvcm0oKTtcclxuXHR9XHJcblx0cHVibGljIG51bWVyYXRvcjogbnVtYmVyO1xyXG5cdHB1YmxpYyBkZW5vbWluYXRvcjogbnVtYmVyO1xyXG5cdGNvbnN0cnVjdG9yKG46IG51bWJlciwgZDogbnVtYmVyID0gMSkge1xyXG5cdFx0aWYgKGQgPT09IDApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRGl2aXNpb24gYnkgemVybyFcIik7XHJcblx0XHR9XHJcblx0XHQvLyB0b2RvOiBwb3RlbnRpYWwgZm9yIG92ZXJmbG93LiBXaGVuIE1hdGguc2lnbiBiZWNvbWVzIGF2YWlsYWJsZSBpbiBUeXBlU2NyaXB0IHVzZSBpdCBpbnN0ZWFkIG9mIHRoZSBtdWx0aXBsaWNhdGlvblxyXG5cdFx0Y29uc3Qgc2lnbjogbnVtYmVyID0gbiAqIGQgPj0gMCA/IDEgOiAtMTtcclxuXHRcdHRoaXMubnVtZXJhdG9yID0gc2lnbiAqIE1hdGguYWJzKG4pO1xyXG5cdFx0dGhpcy5kZW5vbWluYXRvciA9IE1hdGguYWJzKGQpO1xyXG5cdH1cclxuXHRwdWJsaWMgc2ltcGxpZmllZEZvcm0oKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0Y29uc3QgZ2NkOiBudW1iZXIgPSBSYXRpb25hbE51bWJlci5ncmVhdGVzdENvbW1vbkRpdmlzb3IodGhpcy5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpO1xyXG5cdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcih0aGlzLm51bWVyYXRvciAvIGdjZCwgdGhpcy5kZW5vbWluYXRvciAvIGdjZCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZXF1YWxzKHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBybjE6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yID09PSB4ICYmIHJuMS5kZW5vbWluYXRvciA9PT0gMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IHJuMjogUmF0aW9uYWxOdW1iZXIgPSB4LnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yID09PSBybjIubnVtZXJhdG9yICYmIHJuMS5kZW5vbWluYXRvciA9PT0gcm4yLmRlbm9taW5hdG9yO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgbHQoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IHJuMTogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIHJuMS5udW1lcmF0b3IgPCB4ICogcm4xLmRlbm9taW5hdG9yO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3Qgcm4yOiBSYXRpb25hbE51bWJlciA9IHguc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdFx0cmV0dXJuIHJuMS5udW1lcmF0b3IgKiBybjIuZGVub21pbmF0b3IgPCBybjIubnVtZXJhdG9yICogcm4xLmRlbm9taW5hdG9yO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgbGUoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IHJuMTogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIHJuMS5udW1lcmF0b3IgPD0geCAqIHJuMS5kZW5vbWluYXRvcjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IHJuMjogUmF0aW9uYWxOdW1iZXIgPSB4LnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yICogcm4yLmRlbm9taW5hdG9yIDw9IHJuMi5udW1lcmF0b3IgKiBybjEuZGVub21pbmF0b3I7XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyBndCh4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3Qgcm4xOiBSYXRpb25hbE51bWJlciA9IHRoaXMuc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gcm4xLm51bWVyYXRvciA+IHggKiBybjEuZGVub21pbmF0b3I7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBybjI6IFJhdGlvbmFsTnVtYmVyID0geC5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0XHRyZXR1cm4gcm4xLm51bWVyYXRvciAqIHJuMi5kZW5vbWluYXRvciA+IHJuMi5udW1lcmF0b3IgKiBybjEuZGVub21pbmF0b3I7XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyBnZSh4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3Qgcm4xOiBSYXRpb25hbE51bWJlciA9IHRoaXMuc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gcm4xLm51bWVyYXRvciA+PSB4ICogcm4xLmRlbm9taW5hdG9yO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3Qgcm4yOiBSYXRpb25hbE51bWJlciA9IHguc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdFx0cmV0dXJuIHJuMS5udW1lcmF0b3IgKiBybjIuZGVub21pbmF0b3IgPj0gcm4yLm51bWVyYXRvciAqIHJuMS5kZW5vbWluYXRvcjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIG11bHRpcGxpY2F0aXZlIGludmVyc2VcclxuXHRwdWJsaWMgcmVjaXByb2NhbCgpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRpZiAodGhpcy5kZW5vbWluYXRvciA9PT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJEaXZpc2lvbiBieSB6ZXJvIVwiKTsgfVxyXG5cdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcih0aGlzLmRlbm9taW5hdG9yLCB0aGlzLm51bWVyYXRvcik7XHJcblx0fVxyXG5cdC8vIGFkZGl0aXZlIGludmVyc2VcclxuXHRwdWJsaWMgb3Bwb3NpdGUoKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcih0aGlzLm51bWVyYXRvciAqICgtMSksIHRoaXMuZGVub21pbmF0b3IpO1xyXG5cdH1cclxuXHRwdWJsaWMgYWRkKHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIoKHRoaXMubnVtZXJhdG9yICsgeCAqIHRoaXMuZGVub21pbmF0b3IpLCB0aGlzLmRlbm9taW5hdG9yKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IGxjbTogbnVtYmVyID0gUmF0aW9uYWxOdW1iZXIubGVhc3RDb21tb25NdWx0aXBsZSh0aGlzLmRlbm9taW5hdG9yLCB4LmRlbm9taW5hdG9yKTtcclxuXHRcdFx0Y29uc3QgbjE6IG51bWJlciA9IHRoaXMubnVtZXJhdG9yICogbGNtIC8gdGhpcy5kZW5vbWluYXRvcjtcclxuXHRcdFx0Y29uc3QgbjI6IG51bWJlciA9IHgubnVtZXJhdG9yICogbGNtIC8geC5kZW5vbWluYXRvcjtcclxuXHRcdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcihuMSArIG4yLCBsY20pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgc3ViKHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIoKHRoaXMubnVtZXJhdG9yIC0geCAqIHRoaXMuZGVub21pbmF0b3IpLCB0aGlzLmRlbm9taW5hdG9yKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IGxjbTogbnVtYmVyID0gUmF0aW9uYWxOdW1iZXIubGVhc3RDb21tb25NdWx0aXBsZSh0aGlzLmRlbm9taW5hdG9yLCB4LmRlbm9taW5hdG9yKTtcclxuXHRcdFx0Y29uc3QgbjE6IG51bWJlciA9IHRoaXMubnVtZXJhdG9yICogbGNtIC8gdGhpcy5kZW5vbWluYXRvcjtcclxuXHRcdFx0Y29uc3QgbjI6IG51bWJlciA9IHgubnVtZXJhdG9yICogbGNtIC8geC5kZW5vbWluYXRvcjtcclxuXHRcdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcihuMSAtIG4yLCBsY20pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgbXVsdCh4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKCh0aGlzLm51bWVyYXRvciAqIHgpLCB0aGlzLmRlbm9taW5hdG9yKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIoKHRoaXMubnVtZXJhdG9yICogeC5udW1lcmF0b3IpLCB4LmRlbm9taW5hdG9yICogdGhpcy5kZW5vbWluYXRvcik7XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyBkaXYoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcigodGhpcy5udW1lcmF0b3IpLCB0aGlzLmRlbm9taW5hdG9yICogeCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKCh0aGlzLm51bWVyYXRvciAqIHguZGVub21pbmF0b3IpLCB4Lm51bWVyYXRvciAqIHRoaXMuZGVub21pbmF0b3IpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgZXhwKHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIodGhpcy5udW1lcmF0b3IgKiogeCwgdGhpcy5kZW5vbWluYXRvciAqKiB4KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICh0aGlzLmRlbm9taW5hdG9yICE9PSAxKSB7IHRocm93IEVycm9yKFwiRXhwb25lbnRpYXRpb24gd2l0aCByYXRpb25hbCBwb3dlcnMgbm90IHN1cHBvcnRlZC5cIik7IH1cclxuXHRcdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcih0aGlzLm51bWVyYXRvciAqKiB4Lm51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvciAqKiB4Lm51bWVyYXRvcik7XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyB0b051bWJlcigpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMubnVtZXJhdG9yIC8gdGhpcy5kZW5vbWluYXRvcjtcclxuXHR9XHJcblx0cHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5udW1lcmF0b3IudG9TdHJpbmcoKSArICgxID09PSB0aGlzLmRlbm9taW5hdG9yID8gXCJcIiA6IFwiL1wiICsgdGhpcy5kZW5vbWluYXRvci50b1N0cmluZygpKTtcclxuXHR9XHJcblx0cHVibGljIGRlZXBDb3B5KCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIodGhpcy5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IpO1xyXG5cdH1cclxufSIsImV4cG9ydCBjbGFzcyBTdGFjazxUPiB7XHJcblx0cHJpdmF0ZSBzdGFjazogVFtdO1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0dGhpcy5zdGFjayA9IFtdO1xyXG5cdH1cclxuXHRwdWJsaWMgaXNFbXB0eSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMDtcclxuXHR9XHJcblx0cHVibGljIHB1c2goZWxlbWVudDogVCk6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGFjay5wdXNoKGVsZW1lbnQpO1xyXG5cdH1cclxuXHRwdWJsaWMgcG9wKCk6IFQge1xyXG5cdFx0aWYgKHRoaXMuaXNFbXB0eSgpKSB7IHRocm93IG5ldyBFcnJvcihcIlN0YWNrIGlzIGVtcHR5XCIpOyB9XHJcblx0XHRyZXR1cm4gdGhpcy5zdGFjay5wb3AoKTtcclxuXHR9XHJcblx0cHVibGljIHBlZWsoKTogVCB7XHJcblx0XHRpZiAodGhpcy5pc0VtcHR5KCkpIHsgdGhyb3cgbmV3IEVycm9yKFwiU3RhY2sgaXMgZW1wdHlcIik7IH1cclxuXHRcdHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XHJcblx0fVxyXG5cdHB1YmxpYyB0b0FycmF5KCk6IFRbXSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGFjaztcclxuXHR9XHJcbn0iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi9NYXRyaXhcIjtcclxuaW1wb3J0IHsgUmF0aW9uYWxOdW1iZXIgfSBmcm9tIFwiLi9SYXRpb25hbE51bWJlclwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFZlY3RvciB7XHJcblx0cHVibGljIHN0YXRpYyBhcmVMaW5lYXJseUluZGVwZW5kZW50KHZlY3RvcnM6IFZlY3RvcltdKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBtOiBudW1iZXIgPSB2ZWN0b3JzLmxlbmd0aDtcclxuXHRcdGlmICgwID09PSBtKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRjb25zdCBuOiBudW1iZXIgPSB2ZWN0b3JzWzBdLm07XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAxOyBpIDwgdmVjdG9ycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAobiAhPT0gdmVjdG9yc1tpXS5tKSB7IHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgZGltZW5zaW9ucy5cIik7IH1cclxuXHRcdH1cclxuXHRcdGlmIChtID4gbikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIik7XHJcblx0fVxyXG5cdHB1YmxpYyBtOiBudW1iZXI7XHJcblx0cHVibGljIGVsZW1lbnRzOiBSYXRpb25hbE51bWJlcltdO1xyXG5cdGNvbnN0cnVjdG9yKG46IG51bWJlciB8IG51bWJlcltdKTtcclxuXHRjb25zdHJ1Y3RvcihuOiBhbnkpIHtcclxuXHRcdGlmICh0eXBlb2YgbiA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHR0aGlzLm0gPSBuO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzID0gW107XHJcblx0XHR9IGVsc2UgaWYgKG4gaW5zdGFuY2VvZiBBcnJheSkge1xyXG5cdFx0XHR0aGlzLm0gPSBuLmxlbmd0aDtcclxuXHRcdFx0dGhpcy5lbGVtZW50cyA9IFtdO1xyXG5cdFx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLmVsZW1lbnRzW2ldID0gbmV3IFJhdGlvbmFsTnVtYmVyKG5baV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyBhZGQoeDogVmVjdG9yKTogVmVjdG9yIHtcclxuXHRcdGlmICh0aGlzLm0gIT09IHgubSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGRpbWVuc2lvbnMuXCIpOyB9XHJcblx0XHRjb25zdCByZXM6IFZlY3RvciA9IG5ldyBWZWN0b3IodGhpcy5tKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCByZXMubTsgaSsrKSB7XHJcblx0XHRcdHJlcy5lbGVtZW50c1tpXSA9IHRoaXMuZWxlbWVudHNbaV0uYWRkKHguZWxlbWVudHNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblx0cHVibGljIHN1Yih4OiBWZWN0b3IpOiBWZWN0b3Ige1xyXG5cdFx0aWYgKHRoaXMubSAhPT0geC5tKSB7IHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgZGltZW5zaW9ucy5cIik7IH1cclxuXHRcdGNvbnN0IHJlczogVmVjdG9yID0gbmV3IFZlY3Rvcih0aGlzLm0pO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHJlcy5tOyBpKyspIHtcclxuXHRcdFx0cmVzLmVsZW1lbnRzW2ldID0gdGhpcy5lbGVtZW50c1tpXS5zdWIoeC5lbGVtZW50c1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHRwdWJsaWMgbXVsdCh4OiBSYXRpb25hbE51bWJlcik6IFZlY3RvciB7XHJcblx0XHRjb25zdCByZXM6IFZlY3RvciA9IG5ldyBWZWN0b3IodGhpcy5tKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCByZXMubTsgaSsrKSB7XHJcblx0XHRcdHJlcy5lbGVtZW50c1tpXSA9IHRoaXMuZWxlbWVudHNbaV0ubXVsdCh4KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cdC8vIFtBTElBU0VTXTogaW5uZXJQcm9kdWN0LCBwcm9qZWN0aW9uUHJvZHVjdCwgc2NhbGFyUHJvZHVjdFxyXG5cdHB1YmxpYyBkb3RQcm9kdWN0KHg6IFZlY3Rvcik6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGlmICh0aGlzLm0gIT09IHgubSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGRpbWVuc2lvbnMuXCIpOyB9XHJcblx0XHRsZXQgcmVzOiBSYXRpb25hbE51bWJlciA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB4Lm07IGkrKykge1xyXG5cdFx0XHRyZXMgPSByZXMuYWRkKHRoaXMuZWxlbWVudHNbaV0ubXVsdCh4LmVsZW1lbnRzW2ldKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHQvLyBbQUxJQVNFU106IGRpcmVjdGVkQXJlYVByb2R1Y3QsIHZlY3RvclByb2R1Y3RcclxuXHRwdWJsaWMgY3Jvc3NQcm9kdWN0KHg6IFZlY3Rvcik6IFZlY3RvciB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xyXG5cdH1cclxuXHQvLyBbQUxJQVNFU106IG1hZ25pdHVkZSwgbm9ybVxyXG5cdHB1YmxpYyBsZW5ndGgoKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0Y29uc3QgbGVuZ3RoOiBSYXRpb25hbE51bWJlciA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRsZW5ndGguYWRkKHRoaXMuZWxlbWVudHNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGxlbmd0aDtcclxuXHR9XHJcblx0cHVibGljIGRlZXBDb3B5KCk6IFZlY3RvciB7XHJcblx0XHRjb25zdCByZXQ6IFZlY3RvciA9IG5ldyBWZWN0b3IodGhpcy5tKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRyZXQuZWxlbWVudHNbaV0gPSB0aGlzLmVsZW1lbnRzW2ldO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9XHJcblx0cHVibGljIHRvTWF0cml4KCk6IE1hdHJpeCB7XHJcblx0XHRjb25zdCByZXQ6IE1hdHJpeCA9IG5ldyBNYXRyaXgodGhpcy5tLCAxKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRyZXQuZWxlbWVudHNbaV1bMF0gPSB0aGlzLmVsZW1lbnRzW2ldO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9XHJcbn1cclxuZXhwb3J0IGNsYXNzIENvbHVtblZlY3RvciBleHRlbmRzIFZlY3RvciB7XHJcbn1cclxuZXhwb3J0IGNsYXNzIFJvd1ZlY3RvciBleHRlbmRzIFZlY3RvciB7XHJcblx0cHVibGljIG1hdHJpeFByb2R1Y3QobTogTWF0cml4KTogUm93VmVjdG9yIHtcclxuXHRcdGlmICh0aGlzLm0gIT09IG0ubikgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGRpbWVuc2lvbnMuXCIpOyB9XHJcblx0XHRjb25zdCByZXM6IFJvd1ZlY3RvciA9IG5ldyBSb3dWZWN0b3IodGhpcy5tKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRsZXQgc3VtOiBSYXRpb25hbE51bWJlciA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IG0ubjsgaisrKSB7XHJcblx0XHRcdFx0c3VtID0gc3VtLmFkZChtLmVsZW1lbnRzW2ldW2pdLm11bHQodGhpcy5lbGVtZW50c1tpXSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJlcy5lbGVtZW50c1tpXSA9IHN1bTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG59Il0sInNvdXJjZVJvb3QiOiIifQ==