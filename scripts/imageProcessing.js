/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/exercises/imageProcessing.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./src/exercises/imageProcessing.ts":
/*!******************************************!*\
  !*** ./src/exercises/imageProcessing.ts ***!
  \******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../structures/Matrix */ "./src/structures/Matrix.ts");
/* harmony import */ var _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../structures/RationalNumber */ "./src/structures/RationalNumber.ts");


function imageDataToRGBA(imageData) {
    const imgR = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
    const imgG = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
    const imgB = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
    const imgA = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
    let idx = 0;
    for (let x = 0; x < imageData.width; x++) {
        imgR[x] = [];
        imgG[x] = [];
        imgB[x] = [];
        imgA[x] = [];
        for (let y = 0; y < imageData.height; y++) {
            imgR.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
            imgG.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
            imgB.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
            imgA.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
        }
    }
    return [imgR, imgG, imgB, imgA];
}
function imageDataFromRGBA(rgba) {
    const imgR = rgba[0];
    const imgG = rgba[1];
    const imgB = rgba[2];
    const imgA = rgba[3];
    const width = imgR.m;
    const height = imgR.n;
    const imageData = new ImageData(width, height);
    let idx = 0;
    for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
            imageData.data[idx++] = imgR.elements[x][y].toNumber();
            imageData.data[idx++] = imgG.elements[x][y].toNumber();
            imageData.data[idx++] = imgB.elements[x][y].toNumber();
            imageData.data[idx++] = imgA.elements[x][y].toNumber();
        }
    }
    return imageData;
}
$(document).ready(() => {
    const canvas1 = $("#canvas1")[0];
    const ctx1 = canvas1.getContext("2d");
    const image = new Image();
    image.onload = () => {
        canvas1.height = image.height;
        canvas1.width = image.width;
        ctx1.drawImage(image, 0, 0);
        const imgData1 = ctx1.getImageData(0, 0, image.width, image.height);
        const rgba = imageDataToRGBA(imgData1);
        // duplicate
        const imgData2 = imageDataFromRGBA(rgba);
        const canvas2 = $("#canvas2")[0];
        const ctx2 = canvas2.getContext("2d");
        canvas2.height = imgData2.height;
        canvas2.width = imgData2.width;
        ctx2.putImageData(imgData2, 0, 0);
        // convolute
        const canvas3 = $("#canvas3")[0];
        const ctx3 = canvas3.getContext("2d");
        const kernel = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](3, 3);
        /*kernel.elements[0][0] = new RationalNumber(-1);
        kernel.elements[0][1] = new RationalNumber(-1);
        kernel.elements[0][2] = new RationalNumber(-1);
        kernel.elements[1][0] = new RationalNumber(-1);
        kernel.elements[1][1] = new RationalNumber(8);
        kernel.elements[1][2] = new RationalNumber(-1);
        kernel.elements[2][0] = new RationalNumber(-1);
        kernel.elements[2][1] = new RationalNumber(-1);
        kernel.elements[2][2] = new RationalNumber(-1);*/
        kernel.elements[0][0] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        kernel.elements[0][1] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        kernel.elements[0][2] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        kernel.elements[1][0] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        kernel.elements[1][1] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](1);
        kernel.elements[1][2] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        kernel.elements[2][0] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        kernel.elements[2][1] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        kernel.elements[2][2] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        const newRgba = [rgba[0].convolute(kernel), rgba[1].convolute(kernel), rgba[2].convolute(kernel), rgba[3].convolute(kernel)];
        const imgData3 = imageDataFromRGBA(newRgba);
        canvas3.height = imgData3.height;
        canvas3.width = imgData3.width;
        ctx3.putImageData(imgData3, 0, 0);
    };
    image.src = "data:image/png;base64," + encodedImg;
    // Other ways of doing it
    const imgSrc = $("#imgSource").attr("src").replace("data:image/png;base64,", "");
    const binSrc = atob(imgSrc);
    const img = Uint8Array.from(binSrc, (c) => c.charCodeAt(0));
    // reverse
    let binDest = "";
    for (const i of img) {
        binDest += String.fromCharCode(i);
    }
    // String.fromCharCode.apply(null, img); // throww "Maximum call stack size exceeded"
    const imgDest = btoa(binDest);
    $("#imgDestination").attr("src", "data:image/png;base64," + imgDest);
});
const encodedImg = "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";

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./src/structures/ArithmeticEvaluator.ts":
/*!***********************************************!*\
  !*** ./src/structures/ArithmeticEvaluator.ts ***!
  \***********************************************/
/*! exports provided: ArithmeticEvaluator, TokenType, Token, Lexer, Parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArithmeticEvaluator", function() { return ArithmeticEvaluator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenType", function() { return TokenType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lexer", function() { return Lexer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony import */ var _Queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Queue */ "./src/structures/Queue.ts");
/* harmony import */ var _RationalNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RationalNumber */ "./src/structures/RationalNumber.ts");
/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Stack */ "./src/structures/Stack.ts");



class ArithmeticEvaluator {
    static toReversePolishNotation(code) {
        const tokens = code.match(/\(|\)|\d+(\.\d+)?|\w+|[\+\-\*\/\^]/g);
        let i = 0;
        const outputQueue = new _Queue__WEBPACK_IMPORTED_MODULE_0__["Queue"]();
        const operatorStack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();
        while (i < tokens.length) {
            if (this.isNumber(tokens[i])) {
                outputQueue.enqueue(tokens[i]);
            }
            else if (this.isOperator(tokens[i])) {
                let op1 = tokens[i];
                while (!operatorStack.isEmpty() && this.isOperator(operatorStack.peek())) {
                    if ((this.isLeftAssociativeOperator(op1) && (this.precedence(op1) <= this.precedence(operatorStack.peek()))) ||
                        (this.isRightAssociativeOperator(op1) && (this.precedence(op1) < this.precedence(operatorStack.peek())))) {
                        outputQueue.enqueue(operatorStack.pop());
                    }
                    else {
                        break;
                    }
                }
                operatorStack.push(op1);
            }
            else if (tokens[i] === "(") {
                operatorStack.push(tokens[i]);
            }
            else if (tokens[i] === ")") {
                while (!operatorStack.isEmpty() && operatorStack.peek() !== "(") {
                    outputQueue.enqueue(operatorStack.pop());
                }
                if (!operatorStack.isEmpty() && operatorStack.peek() === "(") {
                    operatorStack.pop();
                }
                else {
                    throw new Error("Mismatched parentheses.");
                }
            }
            i++;
        }
        while (!operatorStack.isEmpty()) {
            if (operatorStack.peek() === "(") {
                throw new Error("Mismatched parentheses.");
            }
            else {
                outputQueue.enqueue(operatorStack.pop());
            }
        }
        return outputQueue.toArray();
    }
    static evaluateFromRPN(tokens) {
        const stack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();
        for (let i = 0; i < tokens.length; i++) {
            if (!this.isOperator(tokens[i])) {
                stack.push(parseFloat(tokens[i]));
            }
            else {
                let op1 = stack.pop();
                let op2 = stack.pop();
                switch (tokens[i]) {
                    case "+":
                        stack.push(op2 + op1);
                        break;
                    case "-":
                        stack.push(op2 - op1);
                        break;
                    case "*":
                        stack.push(op2 * op1);
                        break;
                    case "/":
                        stack.push(op2 / op1);
                        break;
                    case "^":
                        stack.push(op2 ** op1);
                        break;
                }
            }
        }
        return stack.pop();
    }
    static isNumber(code) {
        return /^\d/.test(code);
    }
    static isOperator(code) {
        return /[\+\-\*\/\^]/.test(code);
    }
    static isLeftAssociativeOperator(operator) {
        return /[\+\-\*\/]/.test(operator);
    }
    static isRightAssociativeOperator(operator) {
        return /[\^]/.test(operator);
    }
    static precedence(operator) {
        if (/[\+\-]/.test(operator)) {
            return 1;
        }
        if (/[\*\/]/.test(operator)) {
            return 2;
        }
        if (/[\^]/.test(operator)) {
            return 3;
        }
        throw new Error("Unknown operator.");
    }
}
var TokenType;
(function (TokenType) {
    TokenType[TokenType["Plus"] = 0] = "Plus";
    TokenType[TokenType["Minus"] = 1] = "Minus";
    TokenType[TokenType["Multiply"] = 2] = "Multiply";
    TokenType[TokenType["Divide"] = 3] = "Divide";
    TokenType[TokenType["Exponent"] = 4] = "Exponent";
    TokenType[TokenType["Number"] = 5] = "Number";
    TokenType[TokenType["LParen"] = 6] = "LParen";
    TokenType[TokenType["RParen"] = 7] = "RParen";
    TokenType[TokenType["End"] = 8] = "End";
    TokenType[TokenType["Unknown"] = 9] = "Unknown";
})(TokenType || (TokenType = {}));
class Token {
    constructor(type, value) {
        this.type = type;
        this.value = value;
    }
}
class Lexer {
    constructor(input) {
        this.tokens = input.replace(" ", "").match(/\(|\)|\d+(\.\d+)?|[\+\-\*\/\^]/g);
        this.tokenIndex = 0;
    }
    getNextToken() {
        if (this.tokens.length === this.tokenIndex) {
            return new Token(TokenType.End);
        }
        let input = this.tokens[this.tokenIndex++];
        return this.getToken(input);
    }
    getCurrentToken() {
        if (this.tokens.length - 1 === this.tokenIndex) {
            return new Token(TokenType.End);
        }
        let input = this.tokens[this.tokenIndex];
        return this.getToken(input);
    }
    revert() {
        if (this.tokenIndex <= 0) {
            throw Error("Index out of range");
        }
        this.tokenIndex--;
    }
    getToken(input) {
        if (/\+/.test(input)) {
            return new Token(TokenType.Plus);
        }
        if (/\-/.test(input)) {
            return new Token(TokenType.Minus);
        }
        if (/\*/.test(input)) {
            return new Token(TokenType.Multiply);
        }
        if (/\//.test(input)) {
            return new Token(TokenType.Divide);
        }
        if (/\^/.test(input)) {
            return new Token(TokenType.Exponent);
        }
        if (/\d+(\.\d+)?/.test(input)) {
            return new Token(TokenType.Number, parseFloat(input));
        }
        if (/\(/.test(input)) {
            return new Token(TokenType.LParen);
        }
        if (/\)/.test(input)) {
            return new Token(TokenType.RParen);
        }
        return new Token(TokenType.Unknown);
    }
}
class Parser {
    parse(code) {
        this.lex = new Lexer(code);
        const expression = this.fourthOrderOperators();
        const token = this.lex.getCurrentToken(); // is already advanced because of number()
        if (token.type === TokenType.End) {
            return expression;
        }
        throw Error("End expected");
    }
    // addition and substraction
    fourthOrderOperators() {
        let component1 = this.thirdOrderOperators();
        let token = this.lex.getNextToken();
        while (token.type === TokenType.Plus || token.type === TokenType.Minus) {
            let component2 = this.thirdOrderOperators();
            if (token.type === TokenType.Plus) {
                component1 = component1.add(component2);
            }
            else if (token.type === TokenType.Minus) {
                component1 = component1.sub(component2);
            }
            token = this.lex.getNextToken();
        }
        this.lex.revert();
        return component1;
    }
    // multiplication and division
    thirdOrderOperators() {
        let factor1 = this.secondOrderOperators();
        let token = this.lex.getNextToken();
        while (token.type === TokenType.Multiply || token.type === TokenType.Divide) {
            let factor2 = this.secondOrderOperators();
            if (token.type === TokenType.Multiply) {
                factor1 = factor1.mult(factor2);
            }
            else if (token.type === TokenType.Divide) {
                factor1 = factor1.div(factor2);
            }
            token = this.lex.getNextToken();
        }
        this.lex.revert();
        return factor1;
    }
    // exponents and roots
    secondOrderOperators() {
        let factor1 = this.firstOrderOperators();
        let token = this.lex.getNextToken();
        while (token.type === TokenType.Exponent) {
            let factor2 = this.firstOrderOperators();
            factor1 = factor1.exp(factor2);
            token = this.lex.getNextToken();
        }
        this.lex.revert();
        return factor1;
    }
    // numbers and parantheses
    firstOrderOperators() {
        let value = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](1);
        let token = this.lex.getNextToken();
        if (token.type === TokenType.Plus || token.type === TokenType.Minus) {
            if (token.type === TokenType.Minus) {
                value = value.mult(-1);
            }
            token = this.lex.getNextToken();
        }
        if (token.type === TokenType.LParen) {
            value = value.mult(this.fourthOrderOperators());
            token = this.lex.getNextToken();
            if (token.type !== TokenType.RParen) {
                throw Error("Unbalanced parenthesis");
            }
        }
        else {
            if (token.type === TokenType.Number) {
                value = value.mult(token.value);
            }
            else {
                throw Error("Not a number");
            }
        }
        return value;
    }
}
/*
    public static evaluate(expresion: string): RationalNumber {
    var digitPattern = new RegExp('0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9');
    var signPattern = new RegExp('\+|\-');
    var numberPattern = new RegExp('[' + signPattern + ']' + '{' + digitPattern + '}');
    var factorPattern = new RegExp(numberPattern + '|\(' + expressionPattern + '\)');
    var componentPattern = new RegExp(factorPattern + '[{( \* | \/ )' + factorPattern + '}]');
    var expressionPattern = new RegExp(componentPattern + '[{( \+ | \-)' + componentPattern + '}]');
}*/
/*
exprr: 4thORDER+;
4thORDER: component1=3rdORDER ((PLUS|MINUS) component2=3rdORDER)+;
3rdORDER: factor1=2NDORDER ((MULTIPLY|DIVIDE) factor1=2ndORDER)+
2ndORDER: factor1=1stORDER (EXPONENT factor2=1stORDER)+
1stORDER: (PLUS|MINUS|empty) (LPAREN value=4thORDER RPAREN| NUMBER)
*/ 


/***/ }),

/***/ "./src/structures/Matrix.ts":
/*!**********************************!*\
  !*** ./src/structures/Matrix.ts ***!
  \**********************************/
/*! exports provided: Matrix, MatrixIdentity, MatrixElimination, MatrixPermutation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix", function() { return Matrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatrixIdentity", function() { return MatrixIdentity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatrixElimination", function() { return MatrixElimination; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatrixPermutation", function() { return MatrixPermutation; });
/* harmony import */ var _RationalNumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RationalNumber */ "./src/structures/RationalNumber.ts");
/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector */ "./src/structures/Vector.ts");


class Matrix {
    constructor(m, n) {
        this.m = m;
        this.n = n;
        this.elements = [];
        for (let i = 0; i < this.m; i++) {
            this.elements[i] = [];
        }
    }
    static augment(A, B) {
        if (A.m !== B.m) {
            throw new Error("The two matrices (vector) must have the same number of rows (elements).");
        }
        let ret = null;
        if (B instanceof Matrix) {
            ret = new Matrix(A.m, B.n + A.n);
            for (let i = 0; i < A.m; i++) {
                for (let j = 0; j < A.n; j++) {
                    ret.elements[i][j] = A.elements[i][j];
                }
            }
            for (let i = 0; i < B.m; i++) {
                for (let j = 0; j < B.n; j++) {
                    ret.elements[i][A.n + j] = B.elements[i][j];
                }
            }
        }
        else {
            if (B instanceof _Vector__WEBPACK_IMPORTED_MODULE_1__["Vector"]) {
                ret = new Matrix(A.m, A.n + 1);
                for (let i = 0; i < A.m; i++) {
                    for (let j = 0; j < A.n; j++) {
                        ret.elements[i][j] = A.elements[i][j];
                    }
                }
                for (let j = 0; j < B.m; j++) {
                    ret.elements[j][A.n] = B.elements[j];
                }
            }
        }
        return ret;
    }
    // row-multiplying transformations
    static multiplication(n, row1, row2, mult) {
        if (n < row1 || n < row2) {
            throw new Error("Column index must be less or equalt than matrix size.");
        }
        const matrix = new MatrixIdentity(n);
        matrix.elements[row1][row2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](mult);
        return matrix;
    }
    static randomSquare() {
        const matrix = new Matrix(Math.floor(Math.random() * 4) + 3, Math.floor(Math.random() * 4) + 3); // minimum size 3x3 matrix
        for (let i = 0; i < matrix.m; i++) {
            for (let j = 0; j < matrix.n; j++) {
                matrix.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](Math.floor(Math.random() * 100 - 50));
            }
        }
        return matrix;
    }
    static random2() {
        const numberOfUnknowns = Math.floor(Math.random() * 4 + 3); // between 3 and 7 unknonws
        const unknowns = [];
        for (let i = 0; i < numberOfUnknowns; i++) {
            unknowns[i] = Math.floor(Math.random() * 20 - 10);
        }
        // todo: change below
        const matrix = new Matrix(Math.floor(Math.random() * 4) + 3, Math.floor(Math.random() * 4) + 3);
        return matrix;
    }
    equals(M) {
        if (this.m !== M.m || this.n !== M.n) {
            return false;
        }
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                if (!this.elements[i][j].equals(M.elements[i][j])) {
                    return false;
                }
            }
        }
        return true;
    }
    add(x) {
        if (this.m !== x.m || this.n !== x.n) {
            throw new Error("Mismatched dimensions.");
        }
        const res = new Matrix(this.m, this.n);
        for (let i = 0; i < res.m; i++) {
            for (let j = 0; j < res.n; j++) {
                res.elements[i][j] = this.elements[i][j].add(x.elements[i][j]);
            }
        }
        return res;
    }
    sub(x) {
        if (this.m !== x.m || this.n !== x.n) {
            throw new Error("Mismatched dimensions.");
        }
        const res = new Matrix(this.m, this.n);
        for (let i = 0; i < res.m; i++) {
            for (let j = 0; j < res.n; j++) {
                res.elements[i][j] = this.elements[i][j].sub(x.elements[i][j]);
            }
        }
        return res;
    }
    mult(x) {
        let res = null;
        if (typeof x === "number") {
            res = new Matrix(this.m, this.n);
            for (let i = 0; i < res.m; i++) {
                for (let j = 0; j < res.n; j++) {
                    res.elements[i][j] = this.elements[i][j].mult(x);
                }
            }
        }
        else if (x instanceof _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"]) {
            res = new Matrix(this.m, this.n);
            for (let i = 0; i < res.m; i++) {
                for (let j = 0; j < res.n; j++) {
                    res.elements[i][j] = this.elements[i][j].mult(x);
                }
            }
        }
        else {
            if (x instanceof Matrix) {
                if (this.n !== x.m) {
                    throw new Error("Mismatched dimensions.");
                }
                res = new Matrix(this.m, x.n);
                for (let i = 0; i < res.m; i++) {
                    for (let j = 0; j < res.n; j++) {
                        let sum = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
                        for (let k = 0; k < this.n; k++) {
                            sum = sum.add(this.elements[i][k].mult(x.elements[k][j]));
                        }
                        res.elements[i][j] = sum;
                    }
                }
            }
        }
        return res;
    }
    vectorProduct(v) {
        if (this.n !== v.m) {
            throw new Error("Mismatched dimensions.");
        }
        const res = new _Vector__WEBPACK_IMPORTED_MODULE_1__["ColumnVector"](v.m);
        for (let i = 0; i < this.m; i++) {
            let sum = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
            for (let j = 0; j < this.n; j++) {
                sum = sum.add(this.elements[i][j].mult(v.elements[j]));
            }
            res.elements[i] = sum;
        }
        return res;
    }
    transpose() {
        const ret = new Matrix(this.n, this.m);
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                ret.elements[j][i] = this.elements[i][j];
            }
        }
        return ret;
    }
    deepCopy() {
        const ret = new Matrix(this.m, this.n);
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                ret.elements[i][j] = this.elements[i][j];
            }
        }
        return ret;
    }
    switchRows(idx1, idx2) {
        if (this.m < idx1 || this.m < idx2) {
            return;
        }
        for (let i = 0; i < this.n; i++) {
            const tmp = this.elements[idx1][i];
            this.elements[idx1][i] = this.elements[idx2][i];
            this.elements[idx2][i] = tmp;
        }
    }
    multiplyRow(idx, scalar) {
        if (this.m < idx) {
            return;
        }
        for (let i = 0; i < this.n; i++) {
            this.elements[idx][i] = this.elements[idx][i].mult(scalar).simplifiedForm();
        }
    }
    addRows(idx1, idx2, scalar) {
        if (this.m < idx1 || this.m < idx2) {
            return;
        }
        for (let i = 0; i < this.n; i++) {
            this.elements[idx1][i] = this.elements[idx2][i].mult(scalar).add(this.elements[idx1][i]).simplifiedForm();
        }
    }
    addRow1ToRow2(idx1, scalar1, idx2, scalar2) {
        if (this.m < idx1 || this.m < idx2) {
            return;
        }
        for (let i = 0; i < this.n; i++) {
            this.elements[idx2][i] = this.elements[idx2][i].mult(scalar2).add(this.elements[idx1][i].mult(scalar1)).simplifiedForm();
        }
    }
    // a square matrix is a matrix with the same number of rows and columns
    isSquare() {
        return this.m === this.n;
    }
    // a diagonal matrix is a matrix in which the entries outside the main diagonal are all zero
    isDiagonal() {
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                if (i === j) {
                    continue;
                }
                if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                    return false;
                }
            }
        }
        return true;
    }
    // the identity matrix of size n is the n  n square matrix with ones on the main diagonal and zeros elsewhere
    // [ALIASES]: unit matrix
    isIdentity() {
        if (this.m !== this.n) {
            throw new Error("Not a square matrix.");
        }
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                if (i === j) {
                    if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1))) {
                        return false;
                    }
                    continue;
                }
                if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                    return false;
                }
            }
        }
        return true;
    }
    // a matrix is normal if it commutes with its conjugate transpose
    isNormal() {
        throw new Error("Not implemented");
    }
    // the conjugate transpose of an m-by-n matrix A with complex entries is the n-by-m matrix A obtained from A
    // by taking the transpose and then taking the complex conjugate of each entry
    // [ALIASES]: Hermitian transpose
    toConjugateTranspose() {
        throw new Error("Not implemented");
    }
    isUpperTriangular() {
        // todo: check if definition is valid for a non square matrix
        // if (this.m !== this.n) { throw new Error("Not a square matrix."); }
        for (let i = 1; i < this.m; i++) {
            for (let j = 0; j < i; j++) {
                if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                    return false;
                }
            }
        }
        return true;
    }
    isLowerTriangular() {
        // todo: check if definition is valid for a non square matrix
        // if (this.m !== this.n) { throw new Error("Not a square matrix."); }
        for (let i = 0; i < this.m; i++) {
            for (let j = i + 1; j < this.n; j++) {
                if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                    return false;
                }
            }
        }
        return true;
    }
    // a symmetric matrix is a square matrix that is equal to its transpose
    isSymmetric() {
        if (this.m !== this.n) {
            throw new Error("Not a square matrix.");
        }
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                if (!this.elements[i][j].equals(this.elements[j][i])) {
                    return false;
                }
            }
        }
        return true;
    }
    // an orthogonal matrix is a square matrix with real entries whose columns and rows are orthogonal unit vectors
    // [ALIASES]: real orthogonal matrix
    isOrthogonal() {
        const MT = this.transpose();
        return this.mult(MT).isIdentity();
    }
    isRowEchelonForm() {
        let foundZeroRow = false;
        // all nonzero rows (rows with at least one nonzero element) are above any rows of all zeroes
        // (all zero rows, if any, belong at the bottom of the matrix)
        for (let i = 0; i < this.m; i++) {
            if (this.isZeroRow(i)) {
                foundZeroRow = true;
            }
            else {
                if (foundZeroRow) {
                    return false;
                }
            } // if current row is not zero, but a previous row is zero, then matrix is not in row echelon form
        }
        // the leading coefficient (the first nonzero number from the left, also called the pivot) of a nonzero row
        // is always strictly to the right of the leading coefficient of the row above it
        let previousIdx = -1;
        for (let i = 0; i < this.m; i++) {
            const currentPivotIdx = this.rowPivotPosition(i);
            if (0 > currentPivotIdx) {
                continue;
            } // this is a zero row, no pivot
            // leading coefficient must be 1
            if (!this.elements[i][currentPivotIdx].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1))) {
                return false;
            }
            if (previousIdx < currentPivotIdx) {
                previousIdx = currentPivotIdx;
            }
            else {
                return false;
            }
        }
        return true;
    }
    isReducedRowEchelonForm() {
        if (!this.isRowEchelonForm()) {
            return false;
        }
        // each leading coefficient is the only nonzero entry in its column
        for (let i = 0; i < this.m; i++) {
            const pivotPosition = this.rowPivotPosition(i);
            if (1 < this.numberOfNonZeroElementForColumn(pivotPosition)) {
                return false;
            }
        }
        return true;
    }
    toReducedRowEchelonForm() {
        const res = this.deepCopy();
        let lead = 0;
        for (let r = 0; r < res.m; r++) {
            if (res.n <= lead) {
                break;
            }
            let i = r;
            while (res.elements[i][lead].equals(0)) {
                i++;
                if (res.m === i) {
                    i = r;
                    lead++;
                    if (res.n === lead) {
                        lead--;
                        break;
                    }
                }
            }
            res.switchRows(i, r);
            if (!res.elements[r][lead].equals(0)) {
                res.multiplyRow(r, res.elements[r][lead].reciprocal());
            }
            for (let j = 0; j < res.m; j++) {
                if (j !== r) {
                    res.addRows(j, r, res.elements[j][lead].opposite());
                }
            }
            lead++;
        }
        return res;
    }
    determinant() {
        // todo: implement an optimized version, like A=PLU
        if (this.m !== this.n) {
            throw new Error("Determinant can only be calculated on a square matrix");
        }
        if (this.m === 1) {
            return this.elements[0][0];
        }
        let ret = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
        for (let i = 0; i < this.n; i++) {
            const minor = this.elements[0][i].mult(this.cofactor(0, i).determinant());
            ret = ret.add(minor.mult((-1) ** i));
        }
        return ret;
    }
    convolute(kernel) {
        if (kernel.m !== kernel.n) {
            throw new Error("Kernel must be a square matrix!");
        }
        if (kernel.m % 2 === 0) {
            throw new Error("Kernel must be an odd size!");
        }
        // todo: refactor for any size kernel, not just 3 x 3
        const res = new Matrix(this.m, this.n);
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                res.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
                for (let ti = 0; ti < kernel.m; ti++) {
                    for (let tj = 0; tj < kernel.n; tj++) {
                        if (i - ti < 0 || j - tj < 0) {
                            continue;
                        }
                        res.elements[i][j] = res.elements[i][j].add(this.elements[i - ti][j - tj].mult(kernel.elements[ti][tj]));
                    }
                }
            }
        }
        return res;
    }
    isZeroRow(rowId) {
        for (let j = 0; j < this.n; j++) {
            if (!this.elements[rowId][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                return false;
            }
        }
        return true;
    }
    rowPivotPosition(rowId) {
        for (let j = 0; j < this.n; j++) {
            if (!this.elements[rowId][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                return j;
            }
        }
        return -1;
    }
    numberOfNonZeroElementForColumn(columnId) {
        let acc = 0;
        for (let j = 0; j < this.m; j++) {
            if (!this.elements[j][columnId].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                acc++;
            }
        }
        return acc;
    }
    cofactor(rowId, columnId) {
        const ret = new Matrix(this.m - 1, this.n - 1);
        let rowOffset = 0;
        for (let i = 0; i < this.m - 1; i++) {
            if (i === rowId) {
                rowOffset = 1;
            }
            let columnOffset = 0;
            for (let j = 0; j < this.n - 1; j++) {
                if (j === columnId) {
                    columnOffset = 1;
                }
                ret.elements[i][j] = this.elements[i + rowOffset][j + columnOffset];
            }
        }
        return ret;
    }
}
class MatrixIdentity extends Matrix {
    constructor(m) {
        super(m, m);
        this.elements = [];
        for (let i = 0; i < this.m; i++) {
            this.elements[i] = [];
            for (let j = 0; j < this.m; j++) {
                if (i === j) {
                    this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
                }
                else {
                    this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
                }
            }
        }
    }
}
// elimination - multiply on the left (E*A); Row-addition transformations
// to mult*(row2 of Matrix A) add (row1 of Matrix A)
class MatrixElimination extends Matrix {
    constructor(m, r1, r2, mult) {
        if (m < r1 || m < r2) {
            throw new Error("Column index must be less than or equal to the matrix size.");
        }
        super(m, m);
        this.row1 = r1;
        this.row2 = r2;
        this.elements = [];
        for (let i = 0; i < this.m; i++) {
            this.elements[i] = [];
            for (let j = 0; j < this.m; j++) {
                if (i === j) {
                    this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
                }
                else {
                    this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
                }
            }
        }
        if (typeof mult === "number") {
            this.elements[r1][r2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](mult);
        }
        else {
            if (mult instanceof _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"]) {
                this.elements[r1][r2] = mult;
            }
        }
    }
}
// permutation - multiply on the right (A*P); Row-switching transformations
class MatrixPermutation extends Matrix {
    constructor(m, row1, row2) {
        if (m < row1 || m < row2) {
            throw new Error("Column index must be less than or equal to the matrix size.");
        }
        super(m, m);
        this.elements = [];
        for (let i = 0; i < this.m; i++) {
            this.elements[i] = [];
            for (let j = 0; j < this.m; j++) {
                if (i === j) {
                    this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
                }
                else {
                    this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
                }
            }
        }
        this.elements[row1][row1] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
        this.elements[row1][row2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
        this.elements[row2][row2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
        this.elements[row2][row1] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
    }
}


/***/ }),

/***/ "./src/structures/Queue.ts":
/*!*********************************!*\
  !*** ./src/structures/Queue.ts ***!
  \*********************************/
/*! exports provided: Queue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Queue", function() { return Queue; });
class Queue {
    constructor() {
        this.queue = [];
    }
    isEmpty() {
        return this.queue.length === 0;
    }
    enqueue(element) {
        this.queue.push(element);
    }
    dequeue() {
        if (this.isEmpty()) {
            throw new Error("Queue is empty");
        }
        return this.queue.shift();
    }
    peek() {
        if (this.isEmpty()) {
            throw new Error("Queue is empty");
        }
        return this.queue[0];
    }
    toArray() {
        return this.queue;
    }
}


/***/ }),

/***/ "./src/structures/RationalNumber.ts":
/*!******************************************!*\
  !*** ./src/structures/RationalNumber.ts ***!
  \******************************************/
/*! exports provided: RationalNumber */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RationalNumber", function() { return RationalNumber; });
/* harmony import */ var _ArithmeticEvaluator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArithmeticEvaluator */ "./src/structures/ArithmeticEvaluator.ts");
/* harmony import */ var _Queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Queue */ "./src/structures/Queue.ts");
/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Stack */ "./src/structures/Stack.ts");



class RationalNumber {
    constructor(n, d = 1) {
        if (d === 0) {
            throw new Error("Division by zero!");
        }
        // todo: potential for overflow. When Math.sign becomes available in TypeScript use it instead of the multiplication
        const sign = n * d >= 0 ? 1 : -1;
        this.numerator = sign * Math.abs(n);
        this.denominator = Math.abs(d);
    }
    static toReversePolishNotation(code) {
        const tokens = code.match(/\(|\)|\d+(\.\d+)?|\w+|[\+\-\*\/\^]/g);
        let i = 0;
        const outputQueue = new _Queue__WEBPACK_IMPORTED_MODULE_1__["Queue"]();
        const operatorStack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();
        while (i < tokens.length) {
            if (this.isNumber(tokens[i])) {
                outputQueue.enqueue(tokens[i]);
            }
            else if (this.isOperator(tokens[i])) {
                const op1 = tokens[i];
                while (!operatorStack.isEmpty() && this.isOperator(operatorStack.peek())) {
                    if ((this.isLeftAssociativeOperator(op1) && (this.precedence(op1) <= this.precedence(operatorStack.peek()))) ||
                        (this.isRightAssociativeOperator(op1) && (this.precedence(op1) < this.precedence(operatorStack.peek())))) {
                        outputQueue.enqueue(operatorStack.pop());
                    }
                    else {
                        break;
                    }
                }
                operatorStack.push(op1);
            }
            else if (tokens[i] === "(") {
                operatorStack.push(tokens[i]);
            }
            else if (tokens[i] === ")") {
                while (!operatorStack.isEmpty() && operatorStack.peek() !== "(") {
                    outputQueue.enqueue(operatorStack.pop());
                }
                if (!operatorStack.isEmpty() && operatorStack.peek() === "(") {
                    operatorStack.pop();
                }
                else {
                    throw new Error("Mismatched parentheses.");
                }
            }
            i++;
        }
        while (!operatorStack.isEmpty()) {
            if (operatorStack.peek() === "(") {
                throw new Error("Mismatched parentheses.");
            }
            else {
                outputQueue.enqueue(operatorStack.pop());
            }
        }
        return outputQueue.toArray();
    }
    static fromString(code) {
        const p = new _ArithmeticEvaluator__WEBPACK_IMPORTED_MODULE_0__["Parser"]();
        return p.parse(code);
    }
    static greatestCommonDivisor(a, b) {
        return b ? RationalNumber.greatestCommonDivisor(b, a % b) : a;
    }
    static leastCommonMultiple(a, b) {
        return Math.abs(a * b / RationalNumber.greatestCommonDivisor(a, b));
    }
    static isNumber(code) {
        return /^\d/.test(code);
    }
    static isOperator(code) {
        return /[\+\-\*\/\^]/.test(code);
    }
    static isLeftAssociativeOperator(operator) {
        return /[\+\-\*\/]/.test(operator);
    }
    static isRightAssociativeOperator(operator) {
        return /[\^]/.test(operator);
    }
    static precedence(operator) {
        if (/[\+\-]/.test(operator)) {
            return 1;
        }
        if (/[\*\/]/.test(operator)) {
            return 2;
        }
        if (/[\^]/.test(operator)) {
            return 3;
        }
        throw new Error("Unknown operator.");
    }
    static evaluateFromRPN(tokens) {
        const stack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();
        for (let i = 0; i < tokens.length; i++) {
            if (!this.isOperator(tokens[i])) {
                stack.push(new RationalNumber(parseFloat(tokens[i])));
            }
            else {
                const op1 = stack.pop();
                const op2 = stack.pop();
                switch (tokens[i]) {
                    case "+":
                        stack.push(op2.add(op1));
                        break;
                    case "-":
                        stack.push(op2.sub(op1));
                        break;
                    case "*":
                        stack.push(op2.mult(op1));
                        break;
                    case "/":
                        stack.push(op2.div(op1));
                        break;
                    case "^":
                        stack.push(op2.exp(op1.toNumber()));
                        break;
                }
            }
        }
        return stack.pop().simplifiedForm();
    }
    simplifiedForm() {
        const gcd = RationalNumber.greatestCommonDivisor(this.numerator, this.denominator);
        return new RationalNumber(this.numerator / gcd, this.denominator / gcd);
    }
    equals(x) {
        const rn1 = this.simplifiedForm();
        if (typeof x === "number") {
            return rn1.numerator === x && rn1.denominator === 1;
        }
        else {
            const rn2 = x.simplifiedForm();
            return rn1.numerator === rn2.numerator && rn1.denominator === rn2.denominator;
        }
    }
    lt(x) {
        const rn1 = this.simplifiedForm();
        if (typeof x === "number") {
            return rn1.numerator < x * rn1.denominator;
        }
        else {
            const rn2 = x.simplifiedForm();
            return rn1.numerator * rn2.denominator < rn2.numerator * rn1.denominator;
        }
    }
    le(x) {
        const rn1 = this.simplifiedForm();
        if (typeof x === "number") {
            return rn1.numerator <= x * rn1.denominator;
        }
        else {
            const rn2 = x.simplifiedForm();
            return rn1.numerator * rn2.denominator <= rn2.numerator * rn1.denominator;
        }
    }
    gt(x) {
        const rn1 = this.simplifiedForm();
        if (typeof x === "number") {
            return rn1.numerator > x * rn1.denominator;
        }
        else {
            const rn2 = x.simplifiedForm();
            return rn1.numerator * rn2.denominator > rn2.numerator * rn1.denominator;
        }
    }
    ge(x) {
        const rn1 = this.simplifiedForm();
        if (typeof x === "number") {
            return rn1.numerator >= x * rn1.denominator;
        }
        else {
            const rn2 = x.simplifiedForm();
            return rn1.numerator * rn2.denominator >= rn2.numerator * rn1.denominator;
        }
    }
    // multiplicative inverse
    reciprocal() {
        if (this.denominator === 0) {
            throw new Error("Division by zero!");
        }
        return new RationalNumber(this.denominator, this.numerator);
    }
    // additive inverse
    opposite() {
        return new RationalNumber(this.numerator * (-1), this.denominator);
    }
    add(x) {
        if (typeof x === "number") {
            return new RationalNumber((this.numerator + x * this.denominator), this.denominator);
        }
        else {
            const lcm = RationalNumber.leastCommonMultiple(this.denominator, x.denominator);
            const n1 = this.numerator * lcm / this.denominator;
            const n2 = x.numerator * lcm / x.denominator;
            return new RationalNumber(n1 + n2, lcm);
        }
    }
    sub(x) {
        if (typeof x === "number") {
            return new RationalNumber((this.numerator - x * this.denominator), this.denominator);
        }
        else {
            const lcm = RationalNumber.leastCommonMultiple(this.denominator, x.denominator);
            const n1 = this.numerator * lcm / this.denominator;
            const n2 = x.numerator * lcm / x.denominator;
            return new RationalNumber(n1 - n2, lcm);
        }
    }
    mult(x) {
        if (typeof x === "number") {
            return new RationalNumber((this.numerator * x), this.denominator);
        }
        else {
            return new RationalNumber((this.numerator * x.numerator), x.denominator * this.denominator);
        }
    }
    div(x) {
        if (typeof x === "number") {
            return new RationalNumber((this.numerator), this.denominator * x);
        }
        else {
            return new RationalNumber((this.numerator * x.denominator), x.numerator * this.denominator);
        }
    }
    exp(x) {
        if (typeof x === "number") {
            return new RationalNumber(this.numerator ** x, this.denominator ** x);
        }
        else {
            if (this.denominator !== 1) {
                throw Error("Exponentiation with rational powers not supported.");
            }
            return new RationalNumber(this.numerator ** x.numerator, this.denominator ** x.numerator);
        }
    }
    toNumber() {
        return this.numerator / this.denominator;
    }
    toString() {
        return this.numerator.toString() + (1 === this.denominator ? "" : "/" + this.denominator.toString());
    }
    deepCopy() {
        return new RationalNumber(this.numerator, this.denominator);
    }
}


/***/ }),

/***/ "./src/structures/Stack.ts":
/*!*********************************!*\
  !*** ./src/structures/Stack.ts ***!
  \*********************************/
/*! exports provided: Stack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stack", function() { return Stack; });
class Stack {
    constructor() {
        this.stack = [];
    }
    isEmpty() {
        return this.stack.length === 0;
    }
    push(element) {
        this.stack.push(element);
    }
    pop() {
        if (this.isEmpty()) {
            throw new Error("Stack is empty");
        }
        return this.stack.pop();
    }
    peek() {
        if (this.isEmpty()) {
            throw new Error("Stack is empty");
        }
        return this.stack[this.stack.length - 1];
    }
    toArray() {
        return this.stack;
    }
}


/***/ }),

/***/ "./src/structures/Vector.ts":
/*!**********************************!*\
  !*** ./src/structures/Vector.ts ***!
  \**********************************/
/*! exports provided: Vector, ColumnVector, RowVector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return Vector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColumnVector", function() { return ColumnVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RowVector", function() { return RowVector; });
/* harmony import */ var _Matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix */ "./src/structures/Matrix.ts");
/* harmony import */ var _RationalNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RationalNumber */ "./src/structures/RationalNumber.ts");


class Vector {
    constructor(n) {
        if (typeof n === "number") {
            this.m = n;
            this.elements = [];
        }
        else if (n instanceof Array) {
            this.m = n.length;
            this.elements = [];
            for (let i = 0; i < this.m; i++) {
                this.elements[i] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](n[i]);
            }
        }
    }
    static areLinearlyIndependent(vectors) {
        const m = vectors.length;
        if (0 === m) {
            return true;
        }
        const n = vectors[0].m;
        for (let i = 1; i < vectors.length; i++) {
            if (n !== vectors[i].m) {
                throw new Error("Mismatched dimensions.");
            }
        }
        if (m > n) {
            return false;
        }
        throw new Error("Not implemented.");
    }
    add(x) {
        if (this.m !== x.m) {
            throw new Error("Mismatched dimensions.");
        }
        const res = new Vector(this.m);
        for (let i = 0; i < res.m; i++) {
            res.elements[i] = this.elements[i].add(x.elements[i]);
        }
        return res;
    }
    sub(x) {
        if (this.m !== x.m) {
            throw new Error("Mismatched dimensions.");
        }
        const res = new Vector(this.m);
        for (let i = 0; i < res.m; i++) {
            res.elements[i] = this.elements[i].sub(x.elements[i]);
        }
        return res;
    }
    mult(x) {
        const res = new Vector(this.m);
        for (let i = 0; i < res.m; i++) {
            res.elements[i] = this.elements[i].mult(x);
        }
        return res;
    }
    // [ALIASES]: innerProduct, projectionProduct, scalarProduct
    dotProduct(x) {
        if (this.m !== x.m) {
            throw new Error("Mismatched dimensions.");
        }
        let res = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        for (let i = 0; i < x.m; i++) {
            res = res.add(this.elements[i].mult(x.elements[i]));
        }
        return res;
    }
    // [ALIASES]: directedAreaProduct, vectorProduct
    crossProduct(x) {
        throw new Error("Not implemented.");
    }
    // [ALIASES]: magnitude, norm
    length() {
        const length = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        for (let i = 0; i < this.m; i++) {
            length.add(this.elements[i]);
        }
        return length;
    }
    deepCopy() {
        const ret = new Vector(this.m);
        for (let i = 0; i < this.m; i++) {
            ret.elements[i] = this.elements[i];
        }
        return ret;
    }
    toMatrix() {
        const ret = new _Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](this.m, 1);
        for (let i = 0; i < this.m; i++) {
            ret.elements[i][0] = this.elements[i];
        }
        return ret;
    }
}
class ColumnVector extends Vector {
}
class RowVector extends Vector {
    matrixProduct(m) {
        if (this.m !== m.n) {
            throw new Error("Mismatched dimensions.");
        }
        const res = new RowVector(this.m);
        for (let i = 0; i < this.m; i++) {
            let sum = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
            for (let j = 0; j < m.n; j++) {
                sum = sum.add(m.elements[i][j].mult(this.elements[i]));
            }
            res.elements[i] = sum;
        }
        return res;
    }
}


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXhlcmNpc2VzL2ltYWdlUHJvY2Vzc2luZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9Bcml0aG1ldGljRXZhbHVhdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9zdHJ1Y3R1cmVzL01hdHJpeC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9RdWV1ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9SYXRpb25hbE51bWJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9TdGFjay50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9WZWN0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSxLQUEwQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxZQUFZOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsSUFBSTs7QUFFcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztB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QUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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aEU7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFLHNDQUFzQywyQkFBMkI7QUFDakU7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksdUVBQXVFO0FBQ25GO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFFBQVEsR0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLDBCQUEwQix3QkFBd0I7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxzQ0FBc0M7QUFDOUUsb0NBQW9DLHVDQUF1QztBQUMzRSxvQ0FBb0Msc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNK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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGNBQWMscUNBQXFDO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0Es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Q0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztB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QUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxzREFBc0Q7QUFDcEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxjQUFjLG1DQUFtQztBQUNqRCxlQUFlLDZEQUE2RDtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxJQUEwQztBQUMvQyxDQUFDLGlDQUFrQixFQUFFLG1DQUFFO0FBQ3ZCO0FBQ0EsRUFBRTtBQUFBLG9HQUFFO0FBQ0o7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUNyMlVEO0FBQUE7QUFBQTtBQUE4QztBQUNnQjtBQUU5RCxTQUFTLGVBQWUsQ0FBQyxTQUFvQjtJQUM1QyxNQUFNLElBQUksR0FBVyxJQUFJLHlEQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbkUsTUFBTSxJQUFJLEdBQVcsSUFBSSx5REFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25FLE1BQU0sSUFBSSxHQUFXLElBQUkseURBQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNuRSxNQUFNLElBQUksR0FBVyxJQUFJLHlEQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbkUsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDO0lBQ3BCLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFHO1FBQ2xELElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDdkQsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLHlFQUFjLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDaEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLHlFQUFjLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDaEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLHlFQUFjLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDaEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLHlFQUFjLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDaEU7S0FDRDtJQUNELE9BQU8sQ0FBQyxJQUFJ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TTtDQUN2QztBQUNNLE1BQU0sU0FBVSxTQUFRLE1BQU07SUFDN0IsYUFBYSxDQUFDLENBQVM7UUFDN0IsSUFBSSxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7U0FBRTtRQUNsRSxNQUFNLEdBQUcsR0FBYyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0MsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDeEMsSUFBSSxHQUFHLEdBQW1CLElBQUksOERBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNoRCxLQUFLLElBQUksQ0FBQyxHQUFXLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDckMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDdkQ7WUFDRCxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztTQUN0QjtRQUNELE9BQU8sR0FBRyxDQUFDO0lBQ1osQ0FBQztDQUNEIiwiZmlsZSI6Ii4vaW1hZ2VQcm9jZXNzaW5nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvZXhlcmNpc2VzL2ltYWdlUHJvY2Vzc2luZy50c1wiKTtcbiIsIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My40LjFcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE5LTA1LTAxVDIxOjA0WlxuICovXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHQvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxuXHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0Ly8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcblx0XHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XG5cdH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0gKSggdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKCB3aW5kb3csIG5vR2xvYmFsICkge1xuXG4vLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcbi8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuLy8gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIgKHRyYWMtMTMzMzUpLiBCdXQgYXMgb2YgalF1ZXJ5IDMuMCAoMjAxNiksIHN0cmljdCBtb2RlIHNob3VsZCBiZSBjb21tb25cbi8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xuICAgICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIjtcbiAgfTtcblxuXG52YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH07XG5cblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9uY2U6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksIHZhbCxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuXHRcdFx0XHQvLyBPbiB0aGUgb3RoZXIgaGFuZCwganVzdCB1c2luZyBgZ2V0QXR0cmlidXRlYCBpcyBub3QgZW5vdWdoIGFzXG5cdFx0XHRcdC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcblx0XHRcdFx0Ly8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvaHRtbC9pc3N1ZXMvMjM2OVxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuXHRcdFx0XHQvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG5cdFx0XHRcdC8vIGBqUXVlcnkuZ2xvYmFsRXZhbGAgc28gdGhhdCBpdCBjYW4gZmFrZSBhIG5vbmNlLWNvbnRhaW5pbmcgbm9kZVxuXHRcdFx0XHQvLyB2aWEgYW4gb2JqZWN0LlxuXHRcdFx0XHR2YWwgPSBub2RlWyBpIF0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIGkgKTtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSggaSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjQuMVwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgT2JqZWN0LnByb3RvdHlwZSBwb2xsdXRpb25cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIG5hbWUgPT09IFwiX19wcm90b19fXCIgfHwgdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXHRcdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHByb3BlciB0eXBlIGZvciB0aGUgc291cmNlIHZhbHVlXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSAmJiAhQXJyYXkuaXNBcnJheSggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IFtdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICFjb3B5SXNBcnJheSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSB7fTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUsIG9wdGlvbnMgKSB7XG5cdFx0RE9NRXZhbCggY29kZSwgeyBub25jZTogb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlIH0gKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuNFxuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pzLmZvdW5kYXRpb24vXG4gKlxuICogRGF0ZTogMjAxOS0wNC0wOFxuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmRlc2NlbmQgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCJ8PlwiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcblx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmh0bWwgPSAvSFRNTCQvaSxcblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID9cblx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHQvLyBCTVAgY29kZXBvaW50XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArIGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRpbkRpc2FibGVkRmllbGRzZXQgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZpZWxkc2V0XCI7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOCBvbmx5XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdChub2RlVHlwZSAhPT0gMSB8fCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIpICkge1xuXG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXG5cdFx0XHRcdC8vIHFTQSBjb25zaWRlcnMgZWxlbWVudHMgb3V0c2lkZSBhIHNjb3Bpbmcgcm9vdCB3aGVuIGV2YWx1YXRpbmcgY2hpbGQgb3Jcblx0XHRcdFx0Ly8gZGVzY2VuZGFudCBjb21iaW5hdG9ycywgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC5cblx0XHRcdFx0Ly8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcblx0XHRcdFx0Ly8gbGlzdCB3aXRoIGFuIElEIHNlbGVjdG9yIHJlZmVyZW5jaW5nIHRoZSBzY29wZSBjb250ZXh0LlxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB0ZWNobmlxdWUuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiYgcmRlc2NlbmQudGVzdCggc2VsZWN0b3IgKSApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gXCIjXCIgKyBuaWQgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1kaXNhYmxlZFxuXHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0Ly8gKiBsaXN0ZWQgZm9ybS1hc3NvY2lhdGVkIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgZmllbGRzZXRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHQvLyAqIG9wdGlvbiBlbGVtZW50cyBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICYmIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gMTFcblx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdC8vIFdoZXJlIHRoZXJlIGlzIG5vIGlzRGlzYWJsZWQsIGNoZWNrIG1hbnVhbGx5XG5cdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdGluRGlzYWJsZWRGaWVsZHNldCggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBuYW1lc3BhY2UgPSBlbGVtLm5hbWVzcGFjZVVSSSxcblx0XHRkb2NFbGVtID0gKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdC8vIEFzc3VtZSBIVE1MIHdoZW4gZG9jdW1lbnRFbGVtZW50IGRvZXNuJ3QgeWV0IGV4aXN0LCBzdWNoIGFzIGluc2lkZSBsb2FkaW5nIGlmcmFtZXNcblx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzQ4MzNcblx0cmV0dXJuICFyaHRtbC50ZXN0KCBuYW1lc3BhY2UgfHwgZG9jRWxlbSAmJiBkb2NFbGVtLm5vZGVOYW1lIHx8IFwiSFRNTFwiICk7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuXHRcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbXNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggZXhwciwgdHJ1ZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID9cblx0XHRcdFx0YXJndW1lbnQgKyBsZW5ndGggOlxuXHRcdFx0XHRhcmd1bWVudCA+IGxlbmd0aCA/XG5cdFx0XHRcdFx0bGVuZ3RoIDpcblx0XHRcdFx0XHRhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cblxuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufTtcbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXG5cdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdGlmICggdHlwZW9mIGVsZW0uY29udGVudERvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuXHRcdC8vIFRyZWF0IHRoZSB0ZW1wbGF0ZSBlbGVtZW50IGFzIGEgcmVndWxhciBvbmUgaW4gYnJvd3NlcnMgdGhhdFxuXHRcdC8vIGRvbid0IHN1cHBvcnQgaXQuXG5cdFx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG5cdFx0XHRlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0gaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDMgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCxcblx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRpc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIHRvVHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIGFsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuXHR2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdFx0fSxcblx0XHRjb21wb3NlZCA9IHsgY29tcG9zZWQ6IHRydWUgfTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBpT1MgMTAuMCAtIDEwLjIgb25seVxuXHQvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcblx0Ly8gU3VwcG9ydDogaU9TIDEwLjAtMTAuMiBvbmx5XG5cdC8vIEVhcmx5IGlPUyAxMCB2ZXJzaW9ucyBzdXBwb3J0IGBhdHRhY2hTaGFkb3dgIGJ1dCBub3QgYGdldFJvb3ROb2RlYCxcblx0Ly8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXG5cdGlmICggZG9jdW1lbnRFbGVtZW50LmdldFJvb3ROb2RlICkge1xuXHRcdGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Um9vdE5vZGUoIGNvbXBvc2VkICkgPT09IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHR9O1xuXHR9XG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0aXNBdHRhY2hlZCggZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9IGVsZW0ubm9kZVR5cGUgJiZcblx0XHRcdCggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMDtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHR9XG5cblx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGF0dGFjaGVkLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRhdHRhY2hlZCA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggYXR0YWNoZWQgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcbi8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzLCBleGNlcHQgd2hlbiB0aGV5IGFyZSBuby1vcC5cbi8vIFNvIGV4cGVjdCBmb2N1cyB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYWN0aXZlLFxuLy8gYW5kIGJsdXIgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBub3QgYWxyZWFkeSBhY3RpdmUuXG4vLyAoZm9jdXMgYW5kIGJsdXIgYXJlIGFsd2F5cyBzeW5jaHJvbm91cyBpbiBvdGhlciBzdXBwb3J0ZWQgYnJvd3NlcnMsXG4vLyB0aGlzIGp1c3QgZGVmaW5lcyB3aGVuIHdlIGNhbiBjb3VudCBvbiBpdCkuXG5mdW5jdGlvbiBleHBlY3RTeW5jKCBlbGVtLCB0eXBlICkge1xuXHRyZXR1cm4gKCBlbGVtID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICkgPT09ICggdHlwZSA9PT0gXCJmb2N1c1wiICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBBY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gdGhyb3cgdW5leHBlY3RlZGx5XG4vLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzOTNcbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGV2ZW50IGlzIG5hbWVzcGFjZWQsIHRoZW4gZWFjaCBoYW5kbGVyIGlzIG9ubHkgaW52b2tlZCBpZiBpdCBpc1xuXHRcdFx0XHQvLyBzcGVjaWFsbHkgdW5pdmVyc2FsIG9yIGl0cyBuYW1lc3BhY2VzIGFyZSBhIHN1cGVyc2V0IG9mIHRoZSBldmVudCdzLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGhhbmRsZU9iai5uYW1lc3BhY2UgPT09IGZhbHNlIHx8XG5cdFx0XHRcdFx0ZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IHRvIGVuc3VyZSBjb3JyZWN0IHN0YXRlIGZvciBjaGVja2FibGUgaW5wdXRzXG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHQvLyBkYXRhUHJpdi5zZXQoIGVsLCBcImNsaWNrXCIsIC4uLiApXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIsIHJldHVyblRydWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyaW5nIGEgY2xpY2tcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgc3VwcHJlc3MgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHQvLyBBbHNvIHByZXZlbnQgaXQgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIGxldmVyYWdlZCBuYXRpdmUtZXZlbnQgc3RhY2tcblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cdFx0XHRcdHJldHVybiByY2hlY2thYmxlVHlwZS50ZXN0KCB0YXJnZXQudHlwZSApICYmXG5cdFx0XHRcdFx0dGFyZ2V0LmNsaWNrICYmIG5vZGVOYW1lKCB0YXJnZXQsIFwiaW5wdXRcIiApICYmXG5cdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0YXJnZXQsIFwiY2xpY2tcIiApIHx8XG5cdFx0XHRcdFx0bm9kZU5hbWUoIHRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBFbnN1cmUgdGhlIHByZXNlbmNlIG9mIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaGFuZGxlcyBtYW51YWxseS10cmlnZ2VyZWRcbi8vIHN5bnRoZXRpYyBldmVudHMgYnkgaW50ZXJydXB0aW5nIHByb2dyZXNzIHVudGlsIHJlaW52b2tlZCBpbiByZXNwb25zZSB0b1xuLy8gKm5hdGl2ZSogZXZlbnRzIHRoYXQgaXQgZmlyZXMgZGlyZWN0bHksIGVuc3VyaW5nIHRoYXQgc3RhdGUgY2hhbmdlcyBoYXZlXG4vLyBhbHJlYWR5IG9jY3VycmVkIGJlZm9yZSBvdGhlciBsaXN0ZW5lcnMgYXJlIGludm9rZWQuXG5mdW5jdGlvbiBsZXZlcmFnZU5hdGl2ZSggZWwsIHR5cGUsIGV4cGVjdFN5bmMgKSB7XG5cblx0Ly8gTWlzc2luZyBleHBlY3RTeW5jIGluZGljYXRlcyBhIHRyaWdnZXIgY2FsbCwgd2hpY2ggbXVzdCBmb3JjZSBzZXR1cCB0aHJvdWdoIGpRdWVyeS5ldmVudC5hZGRcblx0aWYgKCAhZXhwZWN0U3luYyApIHtcblx0XHRpZiAoIGRhdGFQcml2LmdldCggZWwsIHR5cGUgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHJldHVyblRydWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVnaXN0ZXIgdGhlIGNvbnRyb2xsZXIgYXMgYSBzcGVjaWFsIHVuaXZlcnNhbCBoYW5kbGVyIGZvciBhbGwgZXZlbnQgbmFtZXNwYWNlc1xuXHRkYXRhUHJpdi5zZXQoIGVsLCB0eXBlLCBmYWxzZSApO1xuXHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwge1xuXHRcdG5hbWVzcGFjZTogZmFsc2UsXG5cdFx0aGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIG5vdEFzeW5jLCByZXN1bHQsXG5cdFx0XHRcdHNhdmVkID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdGlmICggKCBldmVudC5pc1RyaWdnZXIgJiAxICkgJiYgdGhpc1sgdHlwZSBdICkge1xuXG5cdFx0XHRcdC8vIEludGVycnVwdCBwcm9jZXNzaW5nIG9mIHRoZSBvdXRlciBzeW50aGV0aWMgLnRyaWdnZXIoKWVkIGV2ZW50XG5cdFx0XHRcdC8vIFNhdmVkIGRhdGEgc2hvdWxkIGJlIGZhbHNlIGluIHN1Y2ggY2FzZXMsIGJ1dCBtaWdodCBiZSBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0XG5cdFx0XHRcdC8vIGZyb20gYW4gYXN5bmMgbmF0aXZlIGhhbmRsZXIgKGdoLTQzNTApXG5cdFx0XHRcdGlmICggIXNhdmVkLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGFyZ3VtZW50cyBmb3IgdXNlIHdoZW4gaGFuZGxpbmcgdGhlIGlubmVyIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRcdC8vIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSBhcmd1bWVudCAoYW4gZXZlbnQgb2JqZWN0KSwgc28gdGhpcyBhcnJheVxuXHRcdFx0XHRcdC8vIHdpbGwgbm90IGJlIGNvbmZ1c2VkIHdpdGggYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdC5cblx0XHRcdFx0XHRzYXZlZCA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgc2F2ZWQgKTtcblxuXHRcdFx0XHRcdC8vIFRyaWdnZXIgdGhlIG5hdGl2ZSBldmVudCBhbmQgY2FwdHVyZSBpdHMgcmVzdWx0XG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTErXG5cdFx0XHRcdFx0Ly8gZm9jdXMoKSBhbmQgYmx1cigpIGFyZSBhc3luY2hyb25vdXNcblx0XHRcdFx0XHRub3RBc3luYyA9IGV4cGVjdFN5bmMoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0XHR0aGlzWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRyZXN1bHQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0XHRpZiAoIHNhdmVkICE9PSByZXN1bHQgfHwgbm90QXN5bmMgKSB7XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIGZhbHNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNhdmVkICE9PSByZXN1bHQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhbmNlbCB0aGUgb3V0ZXIgc3ludGhldGljIGV2ZW50XG5cdFx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0LnZhbHVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCBmb3IgYW4gZXZlbnQgd2l0aCBhIGJ1YmJsaW5nIHN1cnJvZ2F0ZVxuXHRcdFx0XHQvLyAoZm9jdXMgb3IgYmx1ciksIGFzc3VtZSB0aGF0IHRoZSBzdXJyb2dhdGUgYWxyZWFkeSBwcm9wYWdhdGVkIGZyb20gdHJpZ2dlcmluZyB0aGVcblx0XHRcdFx0Ly8gbmF0aXZlIGV2ZW50IGFuZCBwcmV2ZW50IHRoYXQgZnJvbSBoYXBwZW5pbmcgYWdhaW4gaGVyZS5cblx0XHRcdFx0Ly8gVGhpcyB0ZWNobmljYWxseSBnZXRzIHRoZSBvcmRlcmluZyB3cm9uZyB3LnIudC4gdG8gYC50cmlnZ2VyKClgIChpbiB3aGljaCB0aGVcblx0XHRcdFx0Ly8gYnViYmxpbmcgc3Vycm9nYXRlIHByb3BhZ2F0ZXMgKmFmdGVyKiB0aGUgbm9uLWJ1YmJsaW5nIGJhc2UpLCBidXQgdGhhdCBzZWVtc1xuXHRcdFx0XHQvLyBsZXNzIGJhZCB0aGFuIGR1cGxpY2F0aW9uLlxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge30gKS5kZWxlZ2F0ZVR5cGUgKSB7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIG5hdGl2ZSBldmVudCB0cmlnZ2VyZWQgYWJvdmUsIGV2ZXJ5dGhpbmcgaXMgbm93IGluIG9yZGVyXG5cdFx0XHQvLyBGaXJlIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCB3aXRoIHRoZSBvcmlnaW5hbCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHNhdmVkLmxlbmd0aCApIHtcblxuXHRcdFx0XHQvLyAuLi5hbmQgY2FwdHVyZSB0aGUgcmVzdWx0XG5cdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwge1xuXHRcdFx0XHRcdHZhbHVlOiBqUXVlcnkuZXZlbnQudHJpZ2dlcihcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTErXG5cdFx0XHRcdFx0XHQvLyBFeHRlbmQgd2l0aCB0aGUgcHJvdG90eXBlIHRvIHJlc2V0IHRoZSBhYm92ZSBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmV4dGVuZCggc2F2ZWRbIDAgXSwgalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSApLFxuXHRcdFx0XHRcdFx0c2F2ZWQuc2xpY2UoIDEgKSxcblx0XHRcdFx0XHRcdHRoaXNcblx0XHRcdFx0XHQpXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBBYm9ydCBoYW5kbGluZyBvZiB0aGUgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNvZGU6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXG5cdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdGlmICggYnV0dG9uICYgMSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgMiApIHtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgNCApIHtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC53aGljaDtcblx0fVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxualF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIHR5cGUsIGRlbGVnYXRlVHlwZSApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSA9IHtcblxuXHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJmb2N1c1wiLCAuLi4gKVxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImJsdXJcIiwgLi4uIClcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlLCBleHBlY3RTeW5jICk7XG5cblx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRkZWxlZ2F0ZVR5cGU6IGRlbGVnYXRlVHlwZVxuXHR9O1xufSApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCAmJiAhbm9kZS5ub01vZHVsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRub25jZTogbm9kZS5ub25jZSB8fCBub2RlLmdldEF0dHJpYnV0ZSggXCJub25jZVwiIClcblx0XHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIG5vZGUsIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgaXNBdHRhY2hlZCggbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTY0XG5cdFx0Ly8gRG9uJ3QgZ2V0IHRyaWNrZWQgd2hlbiB6b29tIGFmZmVjdHMgb2Zmc2V0V2lkdGggKGdoLTQwMjkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdi5vZmZzZXRXaWR0aCAvIDMgKSA9PT0gMTI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhciBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGUsXG5cdHZlbmRvclByb3BzID0ge307XG5cbi8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwb3RlbnRpYWxseS1tYXBwZWQgalF1ZXJ5LmNzc1Byb3BzIG9yIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIGZpbmFsID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgdmVuZG9yUHJvcHNbIG5hbWUgXTtcblxuXHRpZiAoIGZpbmFsICkge1xuXHRcdHJldHVybiBmaW5hbDtcblx0fVxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXHRyZXR1cm4gdmVuZG9yUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fTtcblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcblxuXHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHR2YXIgbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKTtcblx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMiBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApIDpcblx0XHR2YWx1ZTtcbn1cblxuZnVuY3Rpb24gYm94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIGJveCwgaXNCb3JkZXJCb3gsIHN0eWxlcywgY29tcHV0ZWRWYWwgKSB7XG5cdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRleHRyYSA9IDAsXG5cdFx0ZGVsdGEgPSAwO1xuXG5cdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdC8vIEJvdGggYm94IG1vZGVscyBleGNsdWRlIG1hcmdpblxuXHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gQWRkIHBhZGRpbmdcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBib3JkZXItYm94IChjb250ZW50ICsgcGFkZGluZyArIGJvcmRlciksIHdlJ3JlIHNlZWtpbmcgXCJjb250ZW50XCIgb3Jcblx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiLCBzdWJ0cmFjdCBwYWRkaW5nXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyBhIHJvdW5kZWQgc3VtIG9mIGNvbnRlbnQsIHBhZGRpbmcsIHNjcm9sbCBndXR0ZXIsIGFuZCBib3JkZXJcblx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRkZWx0YSAtXG5cdFx0XHRleHRyYSAtXG5cdFx0XHQwLjVcblxuXHRcdC8vIElmIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBpcyB1bmtub3duLCB0aGVuIHdlIGNhbid0IGRldGVybWluZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyXG5cdFx0Ly8gVXNlIGFuIGV4cGxpY2l0IHplcm8gdG8gYXZvaWQgTmFOIChnaC0zOTY0KVxuXHRcdCkgKSB8fCAwO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtNDMyMikuXG5cdFx0Ly8gRmFrZSBjb250ZW50LWJveCB1bnRpbCB3ZSBrbm93IGl0J3MgbmVlZGVkIHRvIGtub3cgdGhlIHRydWUgdmFsdWUuXG5cdFx0Ym94U2l6aW5nTmVlZGVkID0gIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCBleHRyYSxcblx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3gsXG5cblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0b2Zmc2V0UHJvcCA9IFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICk7XG5cblx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRpZiAoICFleHRyYSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHRcdHZhbCA9IFwiYXV0b1wiO1xuXHR9XG5cblxuXHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0Ly8gU3VwcG9ydDogSUUgOS0xMSBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3Igd2hlbiBib3ggc2l6aW5nIGlzIHVucmVsaWFibGVcblx0Ly8gV2UgdXNlIGdldENsaWVudFJlY3RzKCkgdG8gY2hlY2sgZm9yIGhpZGRlbi9kaXNjb25uZWN0ZWQuXG5cdC8vIEluIHRob3NlIGNhc2VzLCB0aGUgY29tcHV0ZWQgdmFsdWUgY2FuIGJlIHRydXN0ZWQgdG8gYmUgYm9yZGVyLWJveFxuXHRpZiAoICggIXN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSAmJiBpc0JvcmRlckJveCB8fFxuXHRcdHZhbCA9PT0gXCJhdXRvXCIgfHxcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApICYmXG5cdFx0ZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblxuXHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIjtcblxuXHRcdC8vIFdoZXJlIGF2YWlsYWJsZSwgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGFwcHJveGltYXRlIGJvcmRlciBib3ggZGltZW5zaW9ucy5cblx0XHQvLyBXaGVyZSBub3QgYXZhaWxhYmxlIChlLmcuLCBTVkcpLCBhc3N1bWUgdW5yZWxpYWJsZSBib3gtc2l6aW5nIGFuZCBpbnRlcnByZXQgdGhlXG5cdFx0Ly8gcmV0cmlldmVkIHZhbHVlIGFzIGEgY29udGVudCBib3ggZGltZW5zaW9uLlxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBvZmZzZXRQcm9wIGluIGVsZW07XG5cdFx0aWYgKCB2YWx1ZUlzQm9yZGVyQm94ICkge1xuXHRcdFx0dmFsID0gZWxlbVsgb2Zmc2V0UHJvcCBdO1xuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJncmlkQXJlYVwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtbkVuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZENvbHVtblN0YXJ0XCI6IHRydWUsXG5cdFx0XCJncmlkUm93XCI6IHRydWUsXG5cdFx0XCJncmlkUm93RW5kXCI6IHRydWUsXG5cdFx0XCJncmlkUm93U3RhcnRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvbiwgdGhlbiB1bnByZWZpeGVkIHZlcnNpb25cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAoIHJldCA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmIHJldFsgMSBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIG51bWJlciB3YXMgcGFzc2VkIGluLCBhZGQgdGhlIHVuaXQgKGV4Y2VwdCBmb3IgY2VydGFpbiBDU1MgcHJvcGVydGllcylcblx0XHRcdC8vIFRoZSBpc0N1c3RvbVByb3AgY2hlY2sgY2FuIGJlIHJlbW92ZWQgaW4galF1ZXJ5IDQuMCB3aGVuIHdlIG9ubHkgYXV0by1hcHBlbmRcblx0XHRcdC8vIFwicHhcIiB0byBhIGZldyBoYXJkY29kZWQgdmFsdWVzLlxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICYmICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIGRpbWVuc2lvbiApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0XHRcdC8vIE9ubHkgcmVhZCBzdHlsZXMucG9zaXRpb24gaWYgdGhlIHRlc3QgaGFzIGEgY2hhbmNlIHRvIGZhaWxcblx0XHRcdFx0Ly8gdG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdy5cblx0XHRcdFx0c2Nyb2xsYm94U2l6ZUJ1Z2d5ID0gIXN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpICYmXG5cdFx0XHRcdFx0c3R5bGVzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIsXG5cblx0XHRcdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtMzk5MSlcblx0XHRcdFx0Ym94U2l6aW5nTmVlZGVkID0gc2Nyb2xsYm94U2l6ZUJ1Z2d5IHx8IGV4dHJhLFxuXHRcdFx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgP1xuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdFx0KSA6XG5cdFx0XHRcdFx0MDtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG5cdFx0XHQvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxuXHRcdFx0aWYgKCBpc0JvcmRlckJveCAmJiBzY3JvbGxib3hTaXplQnVnZ3kgKSB7XG5cdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gfHxcblx0XHRcdFx0XHR0d2Vlbi5lbGVtLnN0eWxlWyBmaW5hbFByb3BOYW1lKCB0d2Vlbi5wcm9wICkgXSAhPSBudWxsICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG5cdFx0Ly8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRpZiAoICFsZW5ndGggKSB7XG5cdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0aXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBEYXRlLm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHRpZiAoIGEgPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9IClcblx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdID1cblx0XHRcdFx0XHRcdFx0XHRcdCggcmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdIHx8IFtdIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmNvbmNhdCggbWF0Y2hbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaC5qb2luKCBcIiwgXCIgKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXG5cdFx0Ly8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcblx0XHQvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuXHRcdC8vIG9mIHRoZSBkZWZhdWx0IGNvbnZlcnRlciBpcyBrbHVkZ3kgYnV0IGl0IHdvcmtzLlxuXHRcdGNvbnZlcnRlcnM6IHtcblx0XHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oKSB7fVxuXHRcdH0sXG5cdFx0ZGF0YUZpbHRlcjogZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHJlc3BvbnNlLCBvcHRpb25zICk7XG5cdFx0fVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIG9yIGZvcmNlZC1ieS1hdHRycyByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gfHwgcy5zY3JpcHRBdHRycyApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApXG5cdFx0XHRcdFx0LmF0dHIoIHMuc2NyaXB0QXR0cnMgfHwge30gKVxuXHRcdFx0XHRcdC5wcm9wKCB7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9IClcblx0XHRcdFx0XHQub24oIFwibG9hZCBlcnJvclwiLCBjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9zdHJ1Y3R1cmVzL01hdHJpeFwiO1xyXG5pbXBvcnQgeyBSYXRpb25hbE51bWJlciB9IGZyb20gXCIuLi9zdHJ1Y3R1cmVzL1JhdGlvbmFsTnVtYmVyXCI7XHJcblxyXG5mdW5jdGlvbiBpbWFnZURhdGFUb1JHQkEoaW1hZ2VEYXRhOiBJbWFnZURhdGEpOiBbTWF0cml4LCBNYXRyaXgsIE1hdHJpeCwgTWF0cml4XSB7XHJcblx0Y29uc3QgaW1nUjogTWF0cml4ID0gbmV3IE1hdHJpeChpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xyXG5cdGNvbnN0IGltZ0c6IE1hdHJpeCA9IG5ldyBNYXRyaXgoaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcclxuXHRjb25zdCBpbWdCOiBNYXRyaXggPSBuZXcgTWF0cml4KGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XHJcblx0Y29uc3QgaW1nQTogTWF0cml4ID0gbmV3IE1hdHJpeChpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xyXG5cdGxldCBpZHg6IG51bWJlciA9IDA7XHJcblx0Zm9yIChsZXQgeDogbnVtYmVyID0gMDsgeCA8IGltYWdlRGF0YS53aWR0aDsgeCsrICkge1xyXG5cdFx0aW1nUlt4XSA9IFtdOyBpbWdHW3hdID0gW107IGltZ0JbeF0gPSBbXTsgaW1nQVt4XSA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgeTogbnVtYmVyID0gMDsgeSA8IGltYWdlRGF0YS5oZWlnaHQ7IHkrKykge1xyXG5cdFx0XHRpbWdSLmVsZW1lbnRzW3hdW3ldID0gbmV3IFJhdGlvbmFsTnVtYmVyKGltYWdlRGF0YS5kYXRhW2lkeCsrXSk7XHJcblx0XHRcdGltZ0cuZWxlbWVudHNbeF1beV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoaW1hZ2VEYXRhLmRhdGFbaWR4KytdKTtcclxuXHRcdFx0aW1nQi5lbGVtZW50c1t4XVt5XSA9IG5ldyBSYXRpb25hbE51bWJlcihpbWFnZURhdGEuZGF0YVtpZHgrK10pO1xyXG5cdFx0XHRpbWdBLmVsZW1lbnRzW3hdW3ldID0gbmV3IFJhdGlvbmFsTnVtYmVyKGltYWdlRGF0YS5kYXRhW2lkeCsrXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBbaW1nUiwgaW1nRywgaW1nQiwgaW1nQV07XHJcbn1cclxuZnVuY3Rpb24gaW1hZ2VEYXRhRnJvbVJHQkEocmdiYTogW01hdHJpeCwgTWF0cml4LCBNYXRyaXgsIE1hdHJpeF0pOiBJbWFnZURhdGEge1xyXG5cdGNvbnN0IGltZ1I6IE1hdHJpeCA9IHJnYmFbMF07XHJcblx0Y29uc3QgaW1nRzogTWF0cml4ID0gcmdiYVsxXTtcclxuXHRjb25zdCBpbWdCOiBNYXRyaXggPSByZ2JhWzJdO1xyXG5cdGNvbnN0IGltZ0E6IE1hdHJpeCA9IHJnYmFbM107XHJcblx0Y29uc3Qgd2lkdGg6IG51bWJlciA9IGltZ1IubTtcclxuXHRjb25zdCBoZWlnaHQ6IG51bWJlciA9IGltZ1IubjtcclxuXHRjb25zdCBpbWFnZURhdGE6IEltYWdlRGF0YSA9IG5ldyBJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XHJcblx0bGV0IGlkeDogbnVtYmVyID0gMDtcclxuXHRmb3IgKGxldCB4OiBudW1iZXIgPSAwOyB4IDwgd2lkdGg7IHgrKyApIHtcclxuXHRcdGZvciAobGV0IHk6IG51bWJlciA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG5cdFx0XHRpbWFnZURhdGEuZGF0YVtpZHgrK10gPSBpbWdSLmVsZW1lbnRzW3hdW3ldLnRvTnVtYmVyKCk7XHJcblx0XHRcdGltYWdlRGF0YS5kYXRhW2lkeCsrXSA9IGltZ0cuZWxlbWVudHNbeF1beV0udG9OdW1iZXIoKTtcclxuXHRcdFx0aW1hZ2VEYXRhLmRhdGFbaWR4KytdID0gaW1nQi5lbGVtZW50c1t4XVt5XS50b051bWJlcigpO1xyXG5cdFx0XHRpbWFnZURhdGEuZGF0YVtpZHgrK10gPSBpbWdBLmVsZW1lbnRzW3hdW3ldLnRvTnVtYmVyKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBpbWFnZURhdGE7XHJcbn1cclxuXHJcbiQoZG9jdW1lbnQpLnJlYWR5KCgpID0+IHtcclxuXHRjb25zdCBjYW52YXMxOiBIVE1MQ2FudmFzRWxlbWVudCA9ICQoXCIjY2FudmFzMVwiKVswXSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcclxuXHRjb25zdCBjdHgxOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjYW52YXMxLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHRjb25zdCBpbWFnZTogSFRNTEltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xyXG5cdGltYWdlLm9ubG9hZCA9ICgpID0+IHtcclxuXHRcdGNhbnZhczEuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG5cdFx0Y2FudmFzMS53aWR0aCA9IGltYWdlLndpZHRoO1xyXG5cdFx0Y3R4MS5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xyXG5cdFx0Y29uc3QgaW1nRGF0YTE6IEltYWdlRGF0YSA9IGN0eDEuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xyXG5cdFx0Y29uc3QgcmdiYSA9IGltYWdlRGF0YVRvUkdCQShpbWdEYXRhMSk7XHJcblx0XHQvLyBkdXBsaWNhdGVcclxuXHRcdGNvbnN0IGltZ0RhdGEyOiBJbWFnZURhdGEgPSBpbWFnZURhdGFGcm9tUkdCQShyZ2JhKTtcclxuXHRcdGNvbnN0IGNhbnZhczI6IEhUTUxDYW52YXNFbGVtZW50ID0gJChcIiNjYW52YXMyXCIpWzBdIGFzIEhUTUxDYW52YXNFbGVtZW50O1xyXG5cdFx0Y29uc3QgY3R4MjogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gY2FudmFzMi5nZXRDb250ZXh0KFwiMmRcIik7XHJcblx0XHRjYW52YXMyLmhlaWdodCA9IGltZ0RhdGEyLmhlaWdodDtcclxuXHRcdGNhbnZhczIud2lkdGggPSBpbWdEYXRhMi53aWR0aDtcclxuXHRcdGN0eDIucHV0SW1hZ2VEYXRhKGltZ0RhdGEyLCAwLCAwKTtcclxuXHRcdC8vIGNvbnZvbHV0ZVxyXG5cdFx0Y29uc3QgY2FudmFzMzogSFRNTENhbnZhc0VsZW1lbnQgPSAkKFwiI2NhbnZhczNcIilbMF0gYXMgSFRNTENhbnZhc0VsZW1lbnQ7XHJcblx0XHRjb25zdCBjdHgzOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjYW52YXMzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHRcdGNvbnN0IGtlcm5lbDogTWF0cml4ID0gbmV3IE1hdHJpeCgzLCAzKTtcclxuXHRcdC8qa2VybmVsLmVsZW1lbnRzWzBdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMF1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzFdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcig4KTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMl1bMF0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7Ki9cclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcigxKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGNvbnN0IG5ld1JnYmE6IFtNYXRyaXgsIE1hdHJpeCwgTWF0cml4LCBNYXRyaXhdID0gW3JnYmFbMF0uY29udm9sdXRlKGtlcm5lbCksIHJnYmFbMV0uY29udm9sdXRlKGtlcm5lbCksIHJnYmFbMl0uY29udm9sdXRlKGtlcm5lbCksIHJnYmFbM10uY29udm9sdXRlKGtlcm5lbCldO1xyXG5cdFx0Y29uc3QgaW1nRGF0YTM6IEltYWdlRGF0YSA9IGltYWdlRGF0YUZyb21SR0JBKG5ld1JnYmEpO1xyXG5cdFx0Y2FudmFzMy5oZWlnaHQgPSBpbWdEYXRhMy5oZWlnaHQ7XHJcblx0XHRjYW52YXMzLndpZHRoID0gaW1nRGF0YTMud2lkdGg7XHJcblx0XHRjdHgzLnB1dEltYWdlRGF0YShpbWdEYXRhMywgMCwgMCk7XHJcblx0fTtcclxuXHRpbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxcIiArIGVuY29kZWRJbWc7XHJcblxyXG5cdC8vIE90aGVyIHdheXMgb2YgZG9pbmcgaXRcclxuXHRjb25zdCBpbWdTcmM6IHN0cmluZyA9ICQoXCIjaW1nU291cmNlXCIpLmF0dHIoXCJzcmNcIikucmVwbGFjZShcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxcIiwgXCJcIik7XHJcblx0Y29uc3QgYmluU3JjOiBzdHJpbmcgPSBhdG9iKGltZ1NyYyk7XHJcblx0Y29uc3QgaW1nID0gVWludDhBcnJheS5mcm9tKGJpblNyYywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSk7XHJcblx0Ly8gcmV2ZXJzZVxyXG5cdGxldCBiaW5EZXN0OiBzdHJpbmcgPSBcIlwiO1xyXG5cdGZvciAoY29uc3QgaSBvZiBpbWcpIHtcclxuXHRcdGJpbkRlc3QgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcclxuXHR9XHJcblx0Ly8gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBpbWcpOyAvLyB0aHJvd3cgXCJNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiXHJcblx0Y29uc3QgaW1nRGVzdCA9IGJ0b2EoYmluRGVzdCk7XHJcblx0JChcIiNpbWdEZXN0aW5hdGlvblwiKS5hdHRyKFwic3JjXCIsIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LFwiICsgaW1nRGVzdCk7XHJcblxyXG59KTtcclxuXHJcbmNvbnN0IGVuY29kZWRJbWc6IHN0cmluZyA9IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVBvQUFBRlFDQUlBQUFBWmZ2UldBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFQK2xTVVJCVkhoZWhQMW5sRzFiZHQrSG5YUDJ5YUhxVks2YjQ4dmQ3NzJPYUFEZFFEY2FxUUUwMEJFRW82VXYvdUp2OXRBSHlhWnNrN1NHTEV1eVBLaEJ5VFlwV1JpTUlpV0JKQWdTQUlsTUFJMXVvRisvMkMvZThHNnNXN2xPblJ6OC8vM25PblhyTlVCNzFUNXJ6elhYWEhQTnRPWmVlNTlRK2YvUGYvYy9GZ3E1ZkQ1ZktHUlVoWHcwOHZtWnorN0xnOVNSNVl6SnFUZjNHSi9MeldqazFEVVRXbjlnWnZtWjZjUW9seE5yRlhwVnozVE9UYW1uRU9vMW0rV25NeHFxcHNMRW9hWXFuY1lhTloycU9SR2xoMGY5dUp3MFR3MVRFUnBoTk54eUFlZVFRajNTd2sxS0FCS01FNnpSeDhJWm5DSlNiaW9KTkphQmxHbm9JZjVTWExveUF4YnpVSjN6dGtWK0lzUVVVK2dQeEV5OGFNSk5HSFZOSjhITklvSlN4UVF3MTVCcFNPMENlNnR5VW9Vd003eG1EUDZ6OTlTVVE0V0NJZ1J5Z2Z4VXNRNHE0T2V3eFpvWE4rZm9PUWFEaUNTcEpnV2d0K09zeXpTNGpUM0lNNHJTQm1TRXRVTVVMSUxGb2tCbXZHb3greDVKWTk0UFFENWh6QStPamFKUVVZMExzQzExd1BuLy91LzhmVWxqS3hHVER0Q3dEcWlBd3BFRkVUQkNOczd3Y3NIRW9paGtDb1FDRG5NemIwL1pGV21pNE9VZVJ0aEpXQWdyNkVSUnVBZk9BV1RSYUZBcDhBd0tGakR2c0xyMG1pTmRqSVJ6ZEVjUmFBSmhIRkR6a3M5bFNUb0trUnVqOUVvbmoxV1pNUG04RjhHa1JNRnRPUTRPaWJzT3IyZHp0V1ZDV3drZ0FnVklzSXRJUWtZeDQ4dzg3b0kwbXNFaXI3aDNneGJGaWlqNlUwbFk0MDlLaExzNjV3RGxoT2FFUGdBVjV2YnNKeVV3S2lkd3JIYXZ3ems5V0owbTlwcGlIS1VVVDE0RWlDeEMwYWpMS0FZQzRrb01RRVBTK1h3aTJHbXBUa29nMDBBT1BPQnhJSDJtbk9Zd3h5T0p4QlB5QStIK1AveDNmMDhuOFZNSFJWZ01SUmN2bDVCdURndXBsQi9XRkRJU3QwcGtHcUFReVE3WGFhYjVsR2ZtekZMWWhiWVdEd0d0U1l5YUN5eUpmY0p5QkFmZ1NYRVB4UktwZ3dvb3dSOG9US3BpMlhtSlFCZXF4eVhDM1RQSkhjeWl4UnNvaGJ0ZDZNaWwxMlBwbW5zUm5wckFrS1Rrei9aS2tpR1BabGJRYUdqU0VjQWQ1TWw1ZzFDbUUzNjBRbUVXVmJJOEY5ZmMxRmZYWkVwVFUwNEh0NHBhMzROUkVWblVwNHRWaTFrcDBhUWdJMDNFRHNTOEh6eDVXaDEwSVNkb0NIVHhsWEFCQjNXY1VHZmVET1VpVlVUUWdYU3RJRkdvQ1BhbGozSmE0RFJjczU0S0VSWFRRRjhvRkdsUHZDeHRXVm43TkFlWS8rSi8vL2NGYVhMaCtWT3hUd3liMkVNQTRoVWtEdmM1eE45TUwxT29FQnVhM2pDaUtkbWtzVEVxcUN6V1hHNm93dHNXMGZqb1VwWXpRS0FKSGNnWWFEaE42VHFWaU5XUTJ4MFJVSmJLMHd1YnBGTkJ2c1FQQitLSnlOOHVZZnJVVUNzWWdLTGlGUEphTDV6dFRzd2lrOGZzanpjenFWTWx1TTBGQmNGUVE1RTNoRGFXM0tRSlhMQ2lqNFNET0NyMXplUGJBS2lUaFJGZEFhcytLVEg1Q1h5Q29TRHZxYWFLV3RJK0NTVkFMOVVNRTlNZ2thVTBKU3RZU0JEd1lNcGdGVWcxblV5VU1pRTdKWml0bDB5aTVnaytTaURWalQ4RXVJWW5OSUZEMzhqaTJzellqOENuUy83di91SS85Q3d4cTRWTlZNd2U4OGFrTm5mTVlxM1RUQWt2MEFCVHBsNXJGMEVzcFlsNVJvalFOSUhYQkJBeEJpTjRHRld3U0p5U0hLZnFBQ253bzBRYjJFWSt3YWdFUVJUUFQ1M2tOS05rWWdjN295YVJ0K2JSU0laelJwa1hOUkpYVmRva3ByWjV5NHNhSis2bloyV00rRDBXeWZ5RmwxUHNlNEVXN01RUmFiNncza25ncWhBbGovMFFYVFFFR05hK2xCTEUzMU5paUlyZ0pNQzhEdUFFVmpHY2tydXhFNkYwS2doREhxZWMwQXNRejdsV2JrSUdwRm5OSTRXVnd4OHJjWEk1RVN5VUZKWEpreW5BMjUrMjN1TVVtU0xFZHltY21TakJNVHpnN3luNXYvOTMvNUVYVE9JdU81MFFha3d3Q0l4aDlib1Y0Y0xPRXJScWwrU0grV1NuUjRzR1p4aGdJM0dhQWpVOE1zMm5zNkc1dmg5UXdJQ2I3azBrSW5XLzJDQmgvS21rUVhORzlGUEN0bmhremh4ZDVWeDd4bG5yOFkyeFhzSkVtbzlSYXRzQU5MaVhUSmFHOFFsM1JwdEV1ejJCNmtraVVTSUFuUDBMb1JGRkF6VmFEVE9CeGl5cElwUUZaRHd2Z05ROXByUW84eEJQZ09tajl3T0ZhZWJsWkY1a01YeFNCekNkSmhPUUJTSUY4RkkxOXBtV09BWjhVdFFFb3lIaEUwWnpEdjAvSUlFbFBLbVJXRFFlQlFkTWhtVzVUcXJOVEpNZytKNGlndUNpaW9GL3Fwd2c4Ly9nNy8xRFRVYm1WM2xNQ1NTYVFsd20vRGlDeTZwTG5DMlRRT1FLY1ZYK1ZNU25FcTJnT2lFT1RpamtpUVB2K252R1JwTTY0SVR3elJ6bitVRGg0VVovNGhEMDZYcGlRV21CRXJFYUJMaGdhUi9SSFA1bHYrNkFKUHp0WjVuVXBKaWJJNjEyZGFvRWU2T3RqRXdRVFJXa2dWeVVjZlZLTWpQT0swV25JR09zUmFNWkt5VGFZVk1LK0hsaHlubi85KzViNXFHZmlycE9SMythY1E2b0NBajRneGdwTEVzSWx0WVJzMFpMTU1pVURkQkZmSVVSUU1NQjRUTzBHa0dJbitLcFd2Tkc4NlFFaG56UGNDSmMzb2d1bGZuZDhHTW1vazROQjdwS2NDQSs1ZUpUczN6UDFDcloxNy8yVlozc0pCbEZkR3FsQjFzQ0dBYktlMTJEK0RLeEVndU1xRTZwQnBDUXFUYkdqZFI4YkRLR21NQzFLZVpEVE9HUjgrSXVuOU9nazRxekpNUkdab0trUnM2SGZFL0J3ZTdCWkdqbG1OWUk0MTNBK1k5QW4wenQwNkFDWStkRFl4U1lreUt1NnZWQXM2TmhHWlVxd0hvYTBUUEVXVk1XOHpqTFBvOFdZempUMGtzRjc2ZEx5ZW1DM3RZWDZIUTc2aE9NeWtremdOTWx6ZVQ2Z3dWSnlLcUlHUVp3bFRxdFRvQXVZaTRpVGFBak1OR3JocXMvemY4RDhnZ1dSVEtjOUhYY28za0V0MCtxRXJIdmhUUUdPRkF1UXFvWlRsSHpoRjRGbURHei9QLzREOGp1SHBybUQvS1RWZnVuaW1ibTJST2dWeTh2VHU1TXE5R1E3dmQ4UlRqaG81V3JPYUlsZWkrcXh6UEg5SE1wS0FKdHhPaGdSb0pwWGtRcHppZjBwd2VxeEtUUW5GeVZqQlNWb3dla21zUWhaNHFZUjlFUXg2M2RUTmhhakJBYlZWVURJdE5qMVlJbDRqR3BZRTFqa1VKK1huU0xRSjF3VnNhRjJ3ZjNqNmZWQ1pjRHVBUXVFbmNpY0JIczVKMHVBb1dNcENVNGNueFFudFNuZ1ZBaEFDUkFMNTFWNlNRRDZDcG5vNXhrZDNxNW9kRmlaZjJSOWowK1J1TXBRTE1CbzVJWEtVMmlSQ2dwZWpJN2lkbUtNOHdGRG41MEdIb0xJOWRGUEFsUWIrVHlQMTAwNUdSR3lYdEtRUXBTNldTQzdPZS85alZQOEFFS0ZTSFRzTy9wSXRvOTNqMW81M2RVb3FBeWl1SFUwREtwbENoQXVXSGdOSjQwa3FBQVZCSk1VTm5ZcDdxK3B5UlI1MFdVSnhnTkNqZ050MlVDREl4cTJTaUFLTHFFTTErRXUwL0t4MVlySVNOUEN3VGc1TkZFaVBpb1NaN3k5b2poSXREWm0zbjNHNGxJNW5ReUxUd01HNkNJdThpaUpKUnQ3dm94TWdEYVJEM21ubTlkNkEwNDJKNE1jU0VaOHFlU09rUnpNanVTSVBCY1locTJoQm9pRmxhWUlCWGtpdE5qcEdIYkNITXdFWXNrcld5bTA2UXhNREE2bVRORkZyUmt3bEdmTUQzRi9JTzYvTHRLRXRNTU9MSmYrTnJYTlZDRE5Wb0htMHdMRit6a0U0bHBBaDJSV0R5TkdpRUtEUWhrVjhIMEliVHV2eUNLdVV6bFVSWTMyblBGUTVUVHhlSkpVQm5EY2VMRkk3VFhtVjlSUXNKVEpacVBBMTBGZ1JtSDJvR3hmcHhqWHRXRUpWa0JqQXR4NklBbVFPTjJUWFFPWms3R2ErdktMUEFPWW8vM1ZaNUY0SGtNNG1vUFl5cGpHVzVoYU04UFdTT1FMaGJiL09mYm1GT1lLQUp0OWc4VVIvRGozZ1JGRGNwRjZTUFF3V3plTlQrOExJMHhzWW9za0t3UStqUFMyczZKNWlVV3VLNm5xcm4rKytxQUpIWU5PRHRDY3lvK01FeG9ySnR2REVDc2kwbVNXVjNKS2hBSjBLRlkxQ2gyK2YvdUV2UlJ6REFCS29LelAwZTR3MVp0M1V3SnFlazRxS0FMV1YxT2dNQlROT0FFTnU4VEdodFBKZEZGd1BrSTJZMk5JMlluTk9nTlBDVmgwbUdCL24rVzAzNDlnUVZFc1RqQitZUU1TaHZJVUFyNWNHckFjd3Bpd0NjTG8ySldZRndqcHlrY0ZjU0YvSUpEd2FmWU1ObmpnZlFsZ0VjRkU5WFJaV0hwQ2cxVUcwT2hQUzhKRTRQbXVrY3Q4N296TFJWUElhVGhoSkNkWTREbENTMVpuVDZmS0M5QU5uR29lNjFERWt6VlNBRnFmbWJEUUFHaHBzaURUaFJwclR1K05RYVlQd2VDU2xMVTlDY3FVQkpHeGNORDJNZklLRW1HZVVtVWlhTmh3SVJYdU90V2xmaVRHQkhaNk1NWkdSUDNHT0dUcDNUTE1nc1ZoL1JQV0wwd2pTTEE5T242RUJ2TE1MSC9UaGZZSkJIL3JLSU9qWXlKSVFyUldlWGZPd1I4ekNPYWZDNHpvWWc0eFN4cWVyaXF4M1drSlFESlBYOGVrUXJpZzNZUDZIZ2lNYzJOU1lTK0tnUXhONnBNQkJpR1k2Y3VHUTJhUkZnQVpJbVd5VlI3TVFxMGFkU0ZzbXpCRVRjRmhhQjQ1bW4vQUFVeXRTajBwbUlDbWpFYktOenI5REhqcVVTeXA1RFJpVHhKdHBCVkJZaUdYN3h2b3o2aW1QQ2Z4N3BCVVVSSXV6SStPclFWMStDOHRvS2FTZnlZRFRrOE9DcXVBNzZ0WjlDZlVZdzMxOGZsUk0wMGwwdHdtemNoMFVSRzBwWXNxaHp1dG9zLzUyUno4T0l2RmZXaEkxNzNVQmhGQ1pLVEtlUW5Xd3JTazJuQ0UvT0pwL0lWckduRjRhTHUrZnNGcDh2Y2pWRmlsZytRSVkxcE5Pc0hpVjFPREp2R0d0QWZNbklDSTVsU1VnZVlnelRDZzZZQlVsdW5rMzZRcG9JRTJBT0llWStZejBnSkVyUFMrUVEwZHhLTkF4eVVSSTBqU0ZYd1RMU2xuZ0NqUE5RZ0s0S3dqUkw5bkV6cUZ4WVFGQVBVMGtSQ3VkL2pxUFJDZ0tBeGxBcnJIZzBmMjRYdWVVT3d3TFFrUEZBTTZJOWVja05pN1FWUFFWWWtwaWtSTUpXblY2SHJoQXp4NWkxNGZhQUVBdkpvbnlxUE1lYWdJaEVFbnZESWZ1R3JYdzJEK09DUExpYU1FVUduR3F4aDEzRVJ0NUMwUW9MRU5jR0FsTWVCaUxucDFjb0toTWE3TCswbVZkVEw0ZWIzd0ZFQ09SLy9aeFhuUHhFb2dURTY0WkxZanF3UEZ0QXU5bVBBdUN4QjRkeTVEM1ZZTjk0aEVoTFlTVUNYaEJDTnRqbTY2WUhNN05IdVYyMVQrNXlpVVMxdlNjTUtzaGRuSndDcm9xYmd5QWpSZ29CQUQyN2dnMUZxQ1F4V05EZ2U1M0xCWEI0UWh3T1BDSkNVRVh0YXN5ZUxseE1hek85ZXBLU0l0QVNJVjVxcVlTU21ZYVJnUkpjUDcrd0VTQUlEVVFKd0hTTHFUQklNQ29rZi9hZ2VzV2d5QS9DS0NtenEvZFBGdXF0cnpoNnF0TVN5UC9mVkw4OFIwZTlwUWNSSkxha1ZtQ2lCaDg2eXBRNzBORmN4Q2RoRlFNd3E0QlF5ZEhJZm5raStlVnptM3ZwM0ZYci8vOUU4bm00T2NlWWhLa0NNRlJDZWpjU3RzLzJtNG5NMEh5TmRJQXdBRzNDV1l5VUxrYUtTWWlHWU00OHBLUUMyc3VZV1BWZlRGS3BZd0NwNWpKQnUra1UzWlE3RUlrN01YWENCWjJGUWtGSGpIV1BvQmVlQlZDNld5cEphdkJCU05TVTJiWTU2SDdhQWpjQTJiMDZuR250aFFMcTB4UkdSZXlneGtnZUxrSnRnWGs3Z2tDWENTRENVSjRwNkdMMkozdWRvRy9aZkttNWp6OEFhTDQ1TW5RYk42d2ozK1hYbE5EV0JDNmd4anZkVXdvQkdhT3VqWVN6Nk1ITlN3eEd2b2xvTE5JWmkrQk5MdTh1djVORTh1MG56blZNQ0JzRWMrR0FSOXVRd016TVhzVTlRdUFTQnFrQjVpU2NqZ0ZmOTJEOHE2R2tYNHJlNWgxUHl0c1BpRUJ2M0MyY2VNV3B1dUpRbXdhT0hoMGc2dXYzV0FYMXdTY2F4dHVodWpHU1hlRG9ZQzFwL0VRcUNyR1BNSXRoblQrT0ptRUtVUWFPTFQ0eWw1VjVEODk0UEZDUlVseXBkc1pGV21sbzN3V0VBQStxYVRwem1CVnZadUF5SU5walFKVWtZUFVidENmdDFrWWlwbFVzVFBTN3pwaVdUVjN3T1RKeFNQM05CR3dkRjNUYnNIQmZrS3NMRjJPZzd3YzlMUHZ2NXIzeFpxdkpuR3BWMFlxeEhFYjRjd0dIazZCQTNKazJoaEZGYzB1bmZYWkxhYzlQYkdjSWczU2wvUU1UbFRPVlBTYTJTbURCOGZtMjJRRVpSZmFBSVk5dERaWms5SWhYZU9xVUVLbm42QkRoRkNFck1HTUhMS1pCWFJMcDVSZzMvRUVKQXF0VWw1V1EvT3RBWnVTMXdvc1RJNks4YWpTQ2VrL0lwbVdoQVNZclJsSm8rUDUrYVRuT08rZUtjYm1yOUViU1kxOFRmV3l4dGl0eG91cWh0bEVzNjJTQkVpL0RjdVVKQ3pwdmJTaStQQjNIQ0tFck1SQVZFcDE5ekdFT2c2WnpVUlNTT2F1UFNXUzltQXZ4ZVphUmdzc0RjclBPb3BaY0IzS3ArNWN2d1VDTXhZUmJ2em9BNDI5RHFrakVzbFRYbUpGdTd4R0M0aWo4WkxJMzJ3Q2pCT1FvKzlZT0JrTW15R1I5N1UrT3QrMXpxUDZ2UW13cnp4Z0NQSm1qQWVzWkVodGxFRk0veTAwQXdEbG5IY01yZnJ0eGhxd3FwWWNFS0JqSElSWnhWbTQvZ0FFMlZqb0NaVDRvSmlrVTVEMlVMWk1xQ2tLZTFFUWpNS2FDNVJmQ2RaZytqS01ibXpTUVFXTkVISlNQaUZpYWVHeVlPSGpGbE96U1gxOC9JcGJUNkhMUVJTNXdmQXlwanZaVGEvZTY5MEVyaEdnVS8wcHpTTjIxUjg3MHZjMkN5S0pyQ0V3V1FKazJLcGFhM1o5akFOQ2dTdEVsRVpKNERqN0dwbkc2NHg2TVRGblBvOERDOUVLeUFRbVpwaVNsV0ZQV0Z3Qmh6QmZDZHgxQWNPdkJ4VjlReEZ5VW1taGYxcXFGRHB0ZmgwYW9vUVlEK29sZHJqaGZ2bE5ybkpmQUJCR1p1dEZUY25RZ0FUeEVZbjBiUkh5UUJ5TDdKKzRwNkhWQ0drOUV4S0xHSnJnQVNEcmRieXRSVWx6a0djOFlhZUZ5c2wwUFRCV042MHRRdEVETW1Qa1pRZE1iWUJpQ3dBZWVqMUk5YkV1a0hCNm9FREdvZW5XYVRJQlhmZW1xOVROSUg0ckEydTNJZ0RYS0JXSFNHQ1JBT3ZHYUVLYTJMRzFSOHFVSWM1bDBueFJTTWpTN3hBUkJmRTU5SWRTTGJ2Smg0amoybDNPTmlIdWJtS1JKMlB0SWxXb21WVEtGRG01a3ZRUlcyRE1nRkw4d0w2OWQ1NkRFTzg2dmdSN1gwZ29FNGtsVTBnN21aeW41SzVIUWJjSFNiSUowL1VBSnBHcVI0M1B5emlGVXNWL1IvTDRFdzdoVkVKVGlKQmtCV0Q0eU00Z0J6ZzhmSzRaY1RJd0lveDZVRzF3Y3hpU05LNU95RWp4UitnZ21oVktkbWtpVlgwQjBMNWdJZGpPaDJ0ak1sVFZOQ0lqeTBFcy9FS1JkWWRsMFVKV0FNWVJyTTdPR3FHYWdSUXNhQ29hVDZWSmxyN2hJeHhONmJ4U0FqSkdBeXRtT1o4eVNqdzlaWndrdklqRFhhMUNmOEhFaVNLZDI1SUliZml6RTJ5UkV3QUtQU1FCQmlIWUFLazd1bG9qazh3ZzBWazgrYlRQRVk5QWt6Z0pwL2JZZUFsaDg1WUd5WlQ0b1pmUkNWK0UzOFZvc1NIbThLcXN6eEZOb0pUS0lGWDVwekRxbUc1SU1sUnVLdkV4NFUyKzV4aWVHbnkvZlFuOHh5R3FDY21wT1c2bE9kOHZFcDJnL0Fib1llRVdFYXE4TStENVU5ditQenBJdmFOK05zTGJ3VTZKcmtKdkV0VDgydlFZdzdMYVNKb3JqRlFNWitJTXNxcWlLK1ZIalB5d21ieUV0Rm9RVWp5bndJRU5uYUdIenVUQ20wNnBTaHpmLzBFTlVXRGhEQkk1OGhpWG81c2NqU01ENXhZSnowRytjdGo4WlkwU0FXSUtuQXd6SVFETkZ5SXBZOHhOUE5TOGpBQko3T2VTZG1PU2xRbVJKRFFleW1hL3dpU0xVS24wN2xQRitGSGlKZUozR3NibjhETjRiUFM3QmtZQlIveHdYeFhjUlVoMVRTOEJCY2h2Uk5leXFNOERCRkI4M1RyRnpVam5Ra3FUZ2M2S0xFY0NtcUNJODBQSVZYc2hIai82eHkwZ1dSMU1YakZFSUNPRmdqSkRTNEFWTDB3cUR5Z1pUQmRzS2VGdUJVVVZPSFlsSWozVGFneWpCYXdKb2NBNUVPMnp4WmpnTk1rRkFTdldSMURaa0R5d2ZtOVJpRzIxa2lDSlhDLzRLOXg1RE13Unkvb0NvbWsxckdRd2tnajQvRkZwaEhLZXh6V0RuTzZNcUJic0lQczRnM1owY2JyMWdrNEdsZ0tkb3NJYXVqSTRPUUN3S3pUeWNGdUVIUFlsT29CQjZkTUFic0VaOFNiTzNiUk84REJhaFoxMTQyMElORE1ZMFNaRU55TnBJbTdQbE1aWXhMbytrTElyT0l3VkxBczduREpTaFBGNkVJRlhYaFh4alliSTk3ZGFUODVPR3VBU0lVb2hBanA1b25oY3o0cDlCQkhDV2hqRXpRdkhndUhSR3A4eEl5aGFDb2h1OUI0RkhIUXhyQ2FxT1haand1L2NDOHA0c0lWT2tvOE4xZDNpVXE4SVExallyWm90Qk1DOGUxTUphRTJXQ1FkTVdjam5VdXVoNXR3WkxuRlFXNk5PdVF4TzZodHVkSk53cWdDQVdHdUhpNGtJRVBqVlFIeGdTT3lEU0xDMEtBRnpjQmhDWk5lbUlVQTFrVmFTSmlXbnNnYjZwWmZtcHpqMnU2eElxeHFVUlR6S01aa1JZRldnWlExRlRYU2U5cE1yVVFYNHNyaEZIWHZITk9oc0R1VFNYNzJzOTlNYlJSQ2U0WTB4TlJlY21SajREREM4YWIyR2NnQ1I1TlNyUWZkNFJsWVdHbkVSTmViRVIrQklvZ1Vjdy90c29zN0Y5MW1qZFZSQUFwcDhkSUZaRHpjbXJjOTVTSWxwREtCWDZXMHJJWmhjbU1FMkRucFJKcjFscEVNSHBPUG10TGsvMjM1T1pzd2FLQWZTd3Nnd3lvamhPUUdSaUQyR21wcUdoNU1HUFFoR3M4dFhDeExKenVBQkVYR05sMDFqZ3hZZ2pEVDJ3aFRveEtaSGFvR3I3Mm9oalp5ZGJ4Tkk4anc1ME9CZ014djl1S0tzUVJLZVJJd2NsVTVIVkI1c21zektSaVFkQUw3VG1CUml5Uld2TkVJamJ6SWN5VnBreTF1MzJFa09oQlV3T0JWY3dEa2lnNmd5Q3FJS1FVNUZpdHNGZ05KMHVIWlFJNXNDdUtOWTJyaWJXY2o0Si9VQ1E1VWxHSU9id2ZjMUJoVGpCenFlYTlCbE1kRmtuT0NwRlZoMmNUN3M4dUp3T2puRWFlbEg5WFE2QU9uT2VackszK3VLZmlPT0ZjNE9zVE9oUk1HZCtmMENwMXJJTlVGekVXSlFpZ09EM2NVQnh6dkxRS2I2Rzhvd283S0N5ZG9jT3BiRFp3cWpENWliSTl2ZmxKdmlCcFJUYkpzNW1KajZ6NVVKZWFzMUV1TnhaemJYYlpydWdnUE5tbE9DVlRQRjNFdnc3ZUc1NHZQS1RpMHFTSlRxU2xRalkrM3UwQTBYQmQwbU1GK0NEMkVqSGVCNllKckFJa2FlaGxOYVREajBBd3RjakVTUFRRaGdjZUI1U1lSdzQ2UVFGYkZ4Z2FnNDR3OFdHeDRKbWkxTnl5cjN6eFo5eHBXYUlJTXV5eml4ODFlQkE1S1lqc0IrUFFHbWxETXgrbmhrTVFPTWNyVkhZNXljdmJTZmVwcVMyQW9IbElVRTVpQlJNWTQwNThBUWVIbHRGd2hwZ0pPQURwZWR6RU5JSWVpMlh4azZlQmRBNjdNQURmZVNCSDR1WFpITmhzVm1nRlppNVRhbEpiVHNnOGkyekh4b1pKVDdaRDFQNWhKN3hMbXZlVlRmcWZUQmRrbkN3R0xZTFlxb2tzVE9rUDNkT3JHRFdTQTJMbURUYWVBZ0poOEtHYW9iVXdmUFpCNHBtWDllYWdCOHNrTnpQSXkwdzJvVGVPQ0xXZzkrYkFKbVF1eDVXMWNCd2pMb2RJZEVabHhSS2RTVG9vTGFwMUJ4QUxsb0hPRmdocG1ReGhRaVQ3aGovaHhNQVdvQ1VMQml4QVpNbThoSmpuTWszMnBaLzVLVFJ3MFJuY255cTJqL3FpUVJIQ3l4b3NML0QrY3dtTVJOU0VpQkp0cTVZbWxpQTZPVUNNUURUOUNXa0xuR0FoaXdha1FORnQrRFIrM293Q2hna011Q0REWEFNWHcwalBud3N4THRkcVFEVFZ3WHlRMnF6OENnQ1JIckREbVFaODVvZzVhSmQ2ck9VQ282cVlPdmtsQmx5aWJyR2I5NG8rY2NQek9KNGdJWkhEaVkvRVl4N0hnWHpvcHdpUVNkakFPeE03MEkxbmJ0OFJTeEUrZ1FjTmxCaUJ0SzJtOE5RcVhNUk9OMDAyZDIvOGVjQ01UMVFqWGZSNGxBZm9KVmpqZFFydERIcWQrNUNnd21NTHF4NjdZNXBFdG5XM0NUQzBHaUdGQlBVc3dKQVI2VlR1dGdRV0swb01QQ25CQmlSckFoWTBjOW5QL2N4UE1sQnBRcjRXR1JNSXIwNXo1Tm9wa091Z0Jta21EbmVvRzJsT1NxS0hoaFpkWG81U3hwVjRobUttbFNQSWRLSUlPVlhyaEYxQzBsUHl3eWlnZVVFK0JsT2ZMakJ4QVo2VFJMRThuT2RqYUZyZTFCVjFTR2pOS01GTEI1SE5qMmlxU2x1VzJMY2dMTXNnQ0V3TTJ0ZzQ4VWMzZ2EwdTFBTjJIOFZ4VHgvbTBHRzd5UGUyakRBYW9DUGlGZEU0N0tUQzNJa09jYUxCVTJsVURBa2pxY2xZUE9HSG9RcDBhTlNhRC9jWHo4TGp0Z0ExUE1uZHd0TVRHTHBrRng1SXhOSUxEU1NLQlk0L0tzZXUrcTJ3eUtRdFhTbFRDQkhVTHU0SkVNcDBGayttdEZRQ1VQZFVVWThmMTh6ak5CWGJGSkVFVzF4eHRrb3hoVGxtUC92VGhIdTZQSUJDemNRMkpqSldnOVJCUmpkU2lBaHJJbjVPckFNVGd1SWpTbEhjelZEQmM1ekhZbmV6bUl1SXc5VW1BRklKL0o4dXd1cElkSE9TN3lGV0E2bU1zM2duSlVRMU5NY0hBQWM2YWNUckEzdHgzNXdTNjZlUTBvRWZrblc0SjVGa1c1clV3VE96U25LUEVIT0c5RElhSndVcWlJZytqMVBUZ1VnV2REVGJ2ZmFmakttME9wMkhxWTVJOHlLTFZVSFN0UUNpVjFmTWJlTG9sWUxFT21PUjF0TjZUak5CZlc0YjFBeGtHRWRGWkhhbFZiTUtTS1N6dzNtZXIrSENDWjFjbVRLSTVnWFdhZ1pmMmpUQkJVYkZjMXBsQVVpQUdKekIrcVhEbkJqb21JRUxYRDJObTdhb0RrWUVuSDN4SjM3U3FzMDVFcTNCa0RvWWN4TnZHdDB4cVY5ZzBCSzFKeWZqQkxrVnk4cXZwTDJFVUpWS0NLV0s2emFBSlV4UzRpcWowNEFBNXFKenNLQUVPRTRnTlpMWmdvR0xSUW9CcUNrNml6aGtwZUQzZ0ZKaEJOb3dVSmtnemF1VFl0cHRKeWpOQUlBQWlFb0JxYUxsb2RxNVMxc0xCekl5R2hGN1NSTnltSStwZFlhQlVNUTZiQlc3ZkNOQXNoSytQa1JETTJIWXNzc0pqNE5icU16TlFrRmRZc3N1UDhRdzl5RFRkaUsySDFoQmFtcG5RaitvdElUbzFBdXpjSVNCYkEwVkRDTVpSVytlMkFhbExTb2lNMEF5U0FXQlRFNWlNSkVsd1ZUUTAwd0JWM1NQaEZGWGlJc2dUQStCWkdQNkpBa1luVDB1Q21lRU1RZWRiRHJWd1JLS3gvMjVuSGFTR3B2OXpFLzhlSENJUE8yemFYV2FLK3FQaUtmSm95ZjI3U2dRTlBCMGwrblk5WVFPb3BISjNTMjhhZXdBaExQaDFMQTBycUlJTkNMTXlRQmpUWjBLUmp2ZG5rL0VzQk5aS0FqUDZXVGFWQklsblg2Wkttd0VIRGUrU1VKY0tHcnhENWtaT0E5QitoVmtOSWx2dFJYVjhxTDZ2QmhWQkh1M3d6bll6TVBjS3drOHF5aUdxQktTTzBpSXFSMkZEQVR3REFTNnhTWUp5ZFNpVndERmRwek1sSVpEYjJ0NElHUWFTOU5qeFJDWmdhTjJseTJDRDlHTGdlb0VwOW9DSXB5T3BKbUtFWWlYRkxISDlHZU5UdmRhSkJlTUpvNk1DSmxOSkNwWkY1RXNsZEJhV3NJeXZRNE5DUkdCUldZU0Q0dXhNUmVDWVVrS0U0Z2NKbWpvQVZyd1AvMFRQeWJGZUNPSkNFNGJjMVV5b0Z1a2MrRmQwUlZQb1F0YTZoTEJ4RWlBZUdvSmc0Mll6TlNCWjJKWFNHdUVYd2lleE5WNUh0eFVITGF4aUdPa3JDQXdtdk9EcTNLNkZNaUY1aE4xMGxRdkdqNjU0M3RLbUV5RmFVSjZCTWJwdXBXeHVUVUZCRWprZE00QVJua210aE1UeFJ3bVVUREowQW8xSmhRK2xBRXVLTytpWnJqZktVK1pFQyt3eWNGQndWNnZ0QU1SR1RMRmZxUGd4WWFhRWtoZGZvQ28zc0lZRXhHUkU1c1Jlb1U0TU5ORlRCUG9BUmpHYlV5RTlUUXhTQVFtY2RLTElUVzcxR2ZHdU1pbHd6Sm9KMlpoa1pZem9rb0hpam9jV0E3M0lqVFl6ZVRVNUh1dFpFR2V4WmJFbzB4RWVNTGQrT1FBOUVoSXBEOVYwTTdDVVBNV0czeDEzY1VCSVlzcThRNGQ1aTlWaVUzK2IvMlgvemZCNklSV3dqTmxaQmxNTEpuNGkyZEtacWVwTUFIZURuN2NjU005Y1lLMU5SMktJcnVYR3BMREVtbVlWZFpWS1hDeko5VGo3YkUxRndhblcyMEsrSGtCUnJxRUNScFZNSTFsN0hKNkNFNGpUcnhjc1k3Ykx1bHhyRENHSmhNdlpCN1A2RFNtUnFFNFRZcWw4dWFaTStWU2VXbGx1WHZjcmRhcW1rWmRhOHNyTjIrOHZiSzBWTTZ5M2QzdGNTRzdlL2RPNy9nQS9RaHN1UTc3S0t5eWVEeU1hcmhWY0ZKWWVzaWNFbDlUSWptUnh3aWVxWk5zTUNkcVM1aEpqTlFBalJCYmxxaGhqRktRMXpWU25MQ1FHQkY0R0FNclkyU1JzQ2NyWlBqQ0hrcVRBK0ZlREtxMHg0VUJBeUVGSHlBUUJWWlFyMnlERWhLRkpjSTZKeDM2K1RHQWJZWUlERkVpUUJoZGRUQVV5UU5oMUIvKzE3em9qd3dSV09vaHY2SUtrOW14N2tXUXFEaDUxYnFwYmlvbWw0b0NtTWxxMHVGK0ZaM21Fd1BuLzlaLy9wL0ZlUFZoWFBUWGVOT1p4SndGVVpndVdBZ2huc0VjVEV4QWVBV2xDdGFURkJqM2hHT1NnaW5ramJqNWs1eFF4UkN1KzFPeUh6YUtlTEJDYzI2ZXg2QnN5Wmt3NElRWkNBMG1Za2JDd0tZTlFOemlPaVZGWGNmYjdRNTVsNmsvWHVKZ3QxZTVVZUVOOGRXMTlRKy84R0s3M2E3Vkdyd3BybzVodjlwbzdlN3NaTDJEUW1IYUc1SGhPOGZkYkRUKzFtLysycmtQZjZSU2J5MmZPZnZhYXk4ZDdlMUlSOXlFNUk1VkhjU2ZZSFJDYmxXV0VDSGRJTXVRc3gzdWRFMTlNWWczanpRT21xQlhnSG1SY05Lb3g5NklHSGNGek9GS0w0VTg5b2tjeFNYQmh2VUx5M0RvR29Da3NoMlJXWkIyVE1oblczUWkxdFZVTE5PTitiQW5QdUpoanNkSkVOSXpva01xQ3Z0UWgyMUIyeTIwd2V1R2Zja1RoK2lhRnhpYU9pd0JBRWY5elQzcm1ja3R4QkRzMUxSaHhSdWJhRWlFbmt2MmhSLy9VV1NBQlVXOXdkZ3QxalZVYU1SWjZEaDVoVm9ROXpFK0tIejVOQlU0TUtrTFdNSUVtVjdBZEFjY2tGVVRCUllBVGp3dEhKaG9ZcDQwVmtWQUlsSUh6aFg0V0QwVk5TUVNOREVvOVdwcDJGbE1va0xjZUQ3UkFveW40OVdOelUvOTRBKys4T0pITmpmUFRpYkRScU14NnZleS9KZzl3V1JhVmpXYmxKc0x3ODVoWTNHNU5CdTkrZFpieTV1YkZ6WTNpL3cvazhtWk0yZlhOODd1SCs2UEJocEYycEhaY1lmRExWeWdpck9zSXRsQ1BId28ySTkvdmQ5d05FeW1lVzlhL0prdmp4SU1tWkNrWU1LVzkxTVpBaklHTWxhaE53VXYxdXp2eFR5c3JSMi9ybG8yR0RTc0xNK09MT0lzbk5vSjhnaE9DSzlEZ0pjVEtxRVlTT21FNDBCcFk2TjUwajJzQ0ZqYk1KamIzbFVVOVhQU3RPSmlzUjkzTW5VQ1lhWXFpT21oUzV4Tm52RndqRnp0ZnNtditjUklSU3ViRXNPc1gvYVRQL3FqdUoxbWVCMU90UEU5S0RDUUE5TTBhTmY0b2tkRGM1RGhHR3h4dWM1Q0JpVkk0VlRGTmRFVHFhYmZlR21hMkxwWVVOb2c4WUhBazNtVWQyakRLMmFDQVJYOWhCRnVTS0hqUTBYUzhYbE1DS01KclZuQTB6Vi9jWldRYkFyaXBmVzFMM3p4UzFldlBiSFVibWZGNG5nMGt2K0cvWDUzNzlIQzZ1cDBQSnFPeDBlN0QvSlp1ZEZvVHN1bDRteDI2N3V2UFBuaEYvcTdPNVZxb2JHKzNseGRieTRzbHJMaXVEc29OaHY5M3BGa1VYNVVDTWdiOGN5SFNKRVUxR29RTkJnRXNYMFBnTzVLa281Z2VpSjM2allVWFp4VnVGVkZYclRUWllmMHIxVXhNUUg1RnBVVUJHRXpYVEp0Q3hKZTZySUJ2WXBTZU5pYXRyVzdFQUxoUEVaQTdJZ0ljV3dQS0tRWFZUUWhFU1BXQWlzN0ZDUk9HUWRQL1VrRzJKdXJneGg5WTdLWWxJS2lLblN4OVFNdnE3bkFpWm9pSUpJNktHOGRtVkNqQ0FPUFlzbnByUGhCQlJrZys4S1BmRjZRUXhFVGVTS2RyTGhzRlhOWkZJc1FSYTJFNTc4MHpWSHdtUnVPNFJiSW5OSlZpcVlEVGgya0J5TkNQbmRTQk5rVWlTeldTNGdGclY2MlR5d0FIV0ZBRVBDTUFyYzVYcVB3cTBCZlljMEtHVlRFMmFFQWhwRGlLT1ErL3FsUGYrYUhQbGR2Tk11Vmlub1ZtbG1XSDQwRzVXcTFzZGhtOXZ5a1ZDd3VMNi9teTZWUjkzallPVkxXM0xod2NURG9EbWE1amJNWGp4L2UzYnB6OC82TnQzdTcyd3VMdGZWMk8xOXNIQStPY3VNUjdyRUxWWENONERpc214MU1nT0p2dGlpeUdsOFRJcXpKMEFJVXlpS1Fhc0FrY2tjNXVTMm5tMWZWMnQvSGN4aHJCR2V4RGdKTklielZCSDlDRU5ZNHdjL3RQeS9FSkJUQTZpT2gwR0lNQ08rMEFIeVFVSFV5dGFuSXRmcnp2MFVENFUyWEI1c0dqa3c5UjBYRFVYcUNDajhhSTFINE13Y2VoUm1JN0E1V1pFekd0UEJWaTI0TzlkR1QvY1RuZndSL3V4R3J5dkhBaW9qbzUwK1djWmtieG1Sb0FpdU5FcDZsWVh5YXdOa2o2Q0JsblBCdTZPWGkrU3laWmFFaGhYUksvWjdOaW51MGl1Umdsdm1pT3NGVEVNWUlDMllBVnFrUS9RSEZWVnRFNlNFU2VCWk5icHFWaWovMzFUOTMvdHg1cms3OEFoVFhlakVwVjJ2YWpvKzZSNlZ5WlRJYVpLV0tpRHY3TzduaFFibDlSck1OUnAzK1lGU3Z0ODZldnpRWjlidURZYVBWcWxlcW0rZlB6TEtTUE54U3FxOHZidTA5WU91aHFKVEwyY2xqUUYrRkxSQnhJQzFzQ1REU2tjODhFZlFrWXo5S3g4eXMwc0J3czZpOWltczdTWGoyTm1JaEJxTHphaEZlMHdsMjVIR0lFL29hZGx4b0NCR0JZWmpaTXdGNGJacEE2ZHJDcHFhS2d3MWkraUNJbGpWeVh4YnJBTCtvNlRHaU1GMnNJVTNpcTRCRmtPU0N6RUxDSVFuZGREbkdvekJTRmV6Tmt2dStMTzFwWXFoZWFTNDNWTFIxRDgzRWNKYjk1T2MvRDNlbVlCSWd6MlNMUk5FWldlQ0lKUkVyWWQydElxd2JTa3Z6V1FJSkQ1dVZRVFI1TVo2T09FeWFtblE2NHUwcS9qVFlzd2lYYUFXakRQU21NWHphSmk0aTkvYjNGRmJNdUZLa3VHY3NNakdYd20reXVMenlVMS84eXNMQ3duUXlHZlBkaEZtcFZPd05KM0tYN0ZVc1pncXlTclV5SG8wTHhlSjBraXVWS3NWaWVmdmV6V0orcUlYVDI5OHVOUloyNzk5YVhOMm9OK3FEL3RHNFVNbVBoOVdGbGNNN3QzVkJhTFNYTmxmUDM5KzdONTJPTWhZZmQxRGVyVnAxdklna2dyMWRZVytJQ3M3eGp4TTVDMEN6alQyS3JPOTltaWg1TG1tdnpzbm9sVzFzSW1zcURrem94V01ueVF3TWNacDNFWTRoU0NJc1FhUEpTZDZ5dDJPS1FsT1FvODNrWGdVSmZneEFob0thZ3BER1NkRnJTWkxYZ2x4emVWUVUrd1dSZlJNYUZNSEhvTXQ4TUp5akRhQXFXR2x1cXhJVHdkRTBNTWwrL0hPZmM1YzBjeEV1QlJrUTR4a1ZWdk0wMEFZM2NBb2drRUxZUkI0TlNqWFA1aldHRlFJNWxnOWlydFZHZVJiTmJLd0tCUHJ6bkJ6T2hVUkc5THUyRGdIaVlOT0I5aUkyR0tNRjArbmV1UGFBa1pZUUNVMkkrMXNJZklKMGNYM3p5dldQZnZ1MU83LzhyOSs0ZDIrbjMrMGRIdlZlZXZtV2lQZDJqL2p3N1hSVXJwUTFZRFFjandiOTNHUW91RmlZRll1MTRYQlNMWmVtaFhwaGNuell5NzM1Yi8vMTR2Snk3K0JnMmo5c243dDhzUFZvNDhyMVYvN29kM3Z2dlhIeCtVL1ZXNnVQSHQwa1lxV0hKYkdvSndZaGRtMmdlQnNFUy9GdlpYa2ZBQ1JxU213clpxZG95eTc2Mk1ZNDN4UE5QSy8wcjJPQzlJNGRRRFVUcXVCcVd3Q2JoRDNCMmtCQlFvOTdpWEthbU5jR1Jtd1ZvaDNKaVdqYXVoNUdjSnVhYlhRdzBtS0JLelQwZ0RKcm1ETjZqdFhMbnFHVGZsQ0dLWE04SUdMNFV4bnUxalRwYVl5N0FSRURJUzJXSThTYmUxdEQrUC9pYi93MUxBTU5pbU1WcnVOb0dGR0d3UDVqTk9QWTVNelpwMTQ2WVFMbUF3WEtBT2dKRVRTRjVuZmFZQnk5VXNMWFAycXNvQmtRbWRXTHlNeWlsdWs5eEhENENVUlVzTUg2VGc3TVNCMlVCSkFGVU5CUTY2UTQwUzVnekRQMTJrSisrYmxTdFRhYVpjZmQ3bWc4eVEwSHBXWnBzVkxwOUJUVEN2WHg0WEd2WGNrT0R3K2V2bnFtMisxVThzTlB2SEJkOCswOTJxcE51K1cxU3cvdTNsNG9qVys4ZC9meWxjdkh3MEdyMFN3VXBrZjk4ZTc3N3k0dEw3VTJMdDE0NVp1VHp0RXNhNjI5K01uZi85MS9VaW9VZVFkV01zMFRSdklDUlpJUnV6d1g1V1ByaWs3RjhVaExSQkV2KzRrZW41SS9TTmdPWENMWVlRVy8wQm5iekUzcjNhM01FeGQvQlVBQzJHeGpGNFVyTnlsK3g2WW9nUlJFaEJWdmtXbFVTWHhZYUZ5UTJCV1pIa0h4Z1dhT21ieEdqWlZFZGdNdzNjYWloeXFFRkFVRnAzSENHUXdLTk95Q0VLWUN4ZDNzcFRWSWlSQWRVUkxzVG9ZSEtUSW1WbEFZVmd6a3N4Lzc3T2VnZEdIR3FOd3d3UEJnQ1R2SmF2WGNEQnBtWUo1QWZFK1pJelFWSU01MXJFdHVydGErWUFXZnFFd1hjRHBSR09nS0M4NHhXTkpoamdVQ0c0S29RMmtRN1FQSG1mbklhZ2lpUThseVBKMk9pNVg2NnZXUGJWeDZ2cjJ5dU5odUxyV3JtNnV0dGFWbW8xNnFseFQvdFVhNUtQcEN1YWpkUTYzZXJOVExOKy9kMisvM0QwYUZiMzdueG5KNzhkeVo5amhmdVBIcWQ2NCsrL3pEMnpkWHpweHZMSy9PeHNPOUIzY1VXcm5ScUZtcmxrcmxRYjUrZVBmV3RlLzdiTCsvMDMzMHFMeTBlbnk0YmJNcmdtUUdTNDE4aHJFQ2FWNkhyai9DSzZ4Tk1Sbm50Qllsdkpwam90ODBqdzlVazZiUnhGcm1MNDhKaTBFY051cGlWYWlMaDBRNGhJYXZBRUFzcFdoRURqV3A0SG55WVJ5bmVKMk13QVdrRmxPd3NGSVBUWWE0WVMrUXQ0SURqNmtTQ2FlWUJYSkRDV0NJaXRhblZtZ3NXQmZlUVBBZEFJVmFYQzBabFVhcEI4Z3JYMXV5RUh1bWNQK3NRTFBFNm9hOUxwMkdOVEQ2aUdsT0hHRWg0N0VqdVBuS0J1SmtiNlhZNHBCdnhCUUhTUTVzYWRlYXlMeGdodEIyazdpNEdlQjhuamdsUUN6c1B4RTR4dlV5Ry9VR1htZXVVU1NPa05leHJrT1M1cVpqN2M0M3Juem9pWS8rOEdKN3FkNG8xeXJGU3FsWXEyUlRmNDFZTksxbWRXLy9zSlRsS2tVd2V6dVArc05SOTNpbldXLzFlNTFTb1gzaHlldXYzWHFZOVk4M1ZscmE3bS9mZkxPNnNMRDc0SFpoMnBrTkJwdlhuNUdDeFdaN09Ncy9lUE5QU3JueCtsUFA3ajE2dUhidTJ1TFNrblpLQjkxSHMra0lUVFViajhhbGVUS2FVNTBFVmF3cnRjZDNsSFRpTWJuSWRIczZTWHNZdm8wdjdhWXpyUUVBb2tjR2lFeHZWVU45OFpmK1hIL0RHaGpJQVVoc0NHTnpNZGIreHRXRUZOMXFxM1lZUjR4cUpBVjZ3bDkxMEJyQjRYSkNrdHFlRE43dWlEOFQwNmJCOGdoNi9hVmozaDJYcDZCSmlLZ2c0M0lEbmJUVGlibThKTlFIN0RNV2NaUEl5VDcvMmM5aUhrZWl6MGFuOEFHS2dsTjhJY09HNnNDZVVmTkhuR0h0azV6RWlnbTBFaTJrSkZ5ZGtZMkJ1RTMwMmxsaVF2aExYdkFoTW14WmM0eWtXN1VqVjFTbWh4aFozWmdmZnVpQi9Hbk5nTkpJYldTOThSWE1WK0RHay9IQzZ0bm5mdkFMRjY0OFZTdVY2dFZxVml6MmV3UHRpVnVONmlTZmxiSlp1MUc4ZjI5YjIvVHU0ZUdqZys1UnB6TWFhNE96MzF5c2YreXAvbWMrYzNWdjU4WS8vWHYvK3Rubm45ODZHR3pVaHRyOXJLeXZIenk0ZC83YXRkeXN2SHJoVW45U2VuVHJyWEhuY08zcytmWExUK2VieXcvZWZuTlNLT21xY254OHNMQjZ2dDVvUDNyMER2NExTUkVWUDhoNjFNUjhHSk0wb3VBbStuMFlnNFlUM1o2Q0YraFZrSGJuRWI2eUlEMFloTFlzSVBjNTBMRmhNcU9OaGExdE53WXBVcUNlWnVFWFZRSXNwTWdrcVd1NEJHYXEzUmd3Qkl5ZVJ5VFRBWGhYcFVGYUtrRmxnTUd1V1MvRUxuMEFBYlBYVW4rSVFpR3ArM2xCRUhnYWlqSytHWnJLV2tjL2hjVUpjMWhScERkOStleEhmdmlISVpSVVdCcmpoOEhRRTMwWmIxZW9ZaFQ4Q1I1QUc0K1dZakc4SWtKQUQ3SEQ3QmtpV3k4TWJnN2ttNkF3RTAwbzAyaHZhQlBqY2laaEhzRm1waUpQc3ZOaEZuTVREMndkQktEVkpOblIxRmwvd1lzeDR5bDc5TWxrdExoKzRibnYrL3kxcHovV3FEZFFERksrTjkrb1pxMUtUaFJIbmU1ME9McHg4ODd0QjN1RDNraUIzaDlPQnQxZVFiZCtXZTNMbjl1c056YkhnL3J6SDNxNnZqVDQ5Vi82ZzgzTDF6dVAzcjkrWVhQMy92c0xxeXRaSWFlVmNmem9ibjQyS0JScngvM3g3VmYvNEoxdi9NYmk0c3J5eGNzeXpWdS8vNnVONXZMdS9tR3pYQzNVNjkzOSs0U3laVVVsbmh2S0hqS2hZNXAwcnBNQWRVbE81ZlhBcTZockxFTXdGdDBaNXM5RmhIOE1ZUXpVRndjc2l4UHBBWTREbjhoc0lzVE5FV0QrTXhBQklsaGhaYmJHQ0pYR09IdEdYS1VPY0s0VWR4SHZjbEtLb2FEUjhrSEVpRmp4RmJsNHVNbkdKQzRpSXVXa1N2aENmS2hhMkxTYkVWRVVuNW5QWjA2ZWhmTUp4cjJnZFNMMHM4OTlqczJNUUtJY1E4c2lOa2JJaWgyeEhTd3dJQ0hFWUFOMkVwVUliR0Z1cnFoMTJPRHdOSUVIYWhRczFRc2o5cDRoSUlNNWk4YVNnbVlVdFVEbXBZVVVTS1FKeEhndW9FUmxKbXdGcVpramxlSkNVK2xDSC9Lc243LzZrVTkvNGRyVEw5WnFMZDhEMGpzWmowcmwvUEpTczd0MzhOWjc5OTU0NS83TjIvZGZmdTN0NFhTZ3JZMTJ6ZU5SWVRnZDd4MGM2RTZ4bHMwKys1bW4vbmYvMi8vc3YvbXYvODVmK3ZlL2RuWno0Zi8xLy9qYlQzLzhCMXVGNDgzVjVtZzhIQndjSHZZRytkR3dzWEp1T2hxV2F2VjZzMUVwRmM1OCtKTy8rYy8veWVqaHJkV3psNTc4ekJkMnRyY2FLeHUzWG5rNVA1N3REeDZRWWhEN1pDY2oyZGkzV0d3TENUQ1pwTkJYUnVldXd5RXRWVWtvU1ZQYlN6VWpTZk5DOHRRcDNjV0tyUUJNeGl4NGdqaFVqeXBPOFY2TlpZa2dGTk1VL3JJMEdHTFBkYUluVE0zQ2tjR2RDckF3cEh6V0FVVW9CcnZRU1VJM0ozQjBpU0pSbXJHWlNGcm9JOHhqUVRuU0JUamtQeGo0bm1NK0RaeDlwcHV4aUJWdHNkWGQ5K2QvK0xPb2hpd1NrNGt6M2dyR2RqVG1SVnlpQkg4WkM0b294c3VJSjRkZDRValZnZGs1dEhyRjFzUGk3NFFOb3czSC9EU004RmtPMGxrU3F5bGJjZ2tBVFJXMWwwUU0xY1JzcEpCZ29rdkpaREt1dDlxWG5uM3hVNS83d3RtTFQ1Ykx0U0ZSMlpjVlNsbWhWT1JtWnphY3ZQM2RtOTk5Zisrd241K1ZLa090am54eE5pbjJ4dVArcURBZUR2ZDJkeXFGMHViR1NwYnJQL2ZVcGZOWExuM20wNSs0ZUduMXdZT3QzLzZObDg5Y2ZlTHM4bUpwZUtUdGY3OTNkUDZKWjFZMjFzYTVZcU5XbXhWclIvc1BCOE5aNzlHZGovM296eXlkdTNpMDkrRDJtMjhlM1hzL20rWDZ4VnhKUXRacXg0TTlLK3BuaUpqTzBRbkFiNHlObGUrSllmYnVSTHd1Vk1ROWl3SmRzUi9CYlM5RVU2endyR3lDV2JBT0Z2SGhhcDdkRldTS1MrNnBIQS9oSzJBZ2xvVUFmOGpTNzAxQndjdXg1eVpFQ2NrakhicGdBWEZVbmdWUklBL3VxcmgxcHBpRkpDRSs5ZWRsQURxSUF4bkZrZXZ0ZXdwaVNvTFNHTWUrcndoR3VPRVhheVBhQU1LeG1iRnhiS2dZYmd0NHpUR2N4UmdxbTBBRlNsbFIrbUJtQmdwU1dpSE51TWo4SG9uL1RHNDh3cGgzUWtTT1lTUVljNmVDc1JnaGdQM0dNTjVJQjJjK3VNMDRoNGY0eWZGTXJhUXR4R1NjTHhTWDFqYVh6MTU4OFFkKzdOa1BmNks5dk5Idmo3VDh1c2ZINVVxcFZPUnpzZDNqN3Y3Mjd0YkQ3UnZ2Mys4TVJzV3NrRld5MGFBMzdPeFA4ck5pS1N0WGFxTWg5NHFhOS83dDI3UEJVWHRsY2FFeStkaEhucngwZVYyaDlaLzhYLzdtaHo3MStheFFicGRIbTZ2MXp2N2g2c2Jxdzl1M3B2bmEvczY5ZTIrLzF0L2ZhUzZkYVRYcnpiVUwzWU9kWEdteDNHaXZuVDIzM3p2K3ppLy9veWMvL3NPZHdYU2x2YmJidlQ4WkR3aEJDUzk5MEN1RlB0R3RtZnpPcUdMZHQ3WUd2Q3JpbjBPcEtSUGFDL3dsVTRjbE1XNjRSQmFtWVJ1bkx0cjJobUlBSzVPckNYRDhRMEFRTDFvUGFxcmlNOE5STXhva3NlNCtoMnE0Mnd3SnFyaEErQXJNRVBHaTIzT29qaEpqVTlOU3FkT3NJa3dWMEJ3aUVPaHhZdXdvZHdVM01GRWpyVjV1aTVvM1dzMEI5aUI1MFpQTC8vWC8rRCsyclVqMU1qTGpVSWhJczNsc0NvbnVJa291VmJaZEZDR1ZFTlgweGp4aGdwNHB6RWVxSUl0TkpwdHFjbnJsQXNZVWlwZ1lhdFJTeGlGL2kxaDVCUVBEV0RLeCs0VGVsMmJZYVFxNEM0bHR1V2lYRzQyTmN4ZlBYcjUyNGRLMS9vQTEwKzMxQnYyK2RuK1ZLczlleHVQcGtNKzFERG9IUjdPc2NIUndNTkprdW5VZDlHZkZZclhlT0R6czd4OGQxb3ZackZMdjkzdmJoN1BwNEhpb0swSnZ1TGYzNFBrWG4xTFk1WTl1cmk0M3Z2bnQ3OVkzbmwzZFhOdCsyRGs3ZWYvNnVYWmhPams2MkxsOC9aa3NtemJYejA4bC8rajQ0SER2L28zM3psMjYydDY4c0hQdlJtdHA4Nmh6bUJVcUQrL2NMR1dsWWFtNmQvZE9ZU2wzZCt0bHRGQXNTek1aVUtIczNVeWtjWUtiZFNlVVV2dDR3ay9IeU13S0pnZDZZY2FYcDdBc3dSUEJSVU9HNDNHN296STM0NFB1Z3VQYmhsbXU2QUFvRnJUTXk0VjhxWkF2WnZteVRNK0lmTW1mZkNuTCtzVmNNWmNyYWxER2twQ2pNc2VFMzFQUzVZSFp1T25UbkRLM0duaWZkMlh3UHN0VldjOFRzbnBCK1dWNkNsbnVjVnpSSkhnOE5yQ2NkVUJ2NVZpUDFpMzZnNCtIZXFUbUFnRHRTSUVrZXNqVzdPeUUrR3QvOWErU0tlWUZkcVk4S1dxaGdYQkVLT1BNQWtZYVpqR2xsMkQzMGtIZUZ4Tlptb25uREtOV0lmSlZYT01oSm9BbVZmVEw3bVpoRHVhRkdNd3FWOFRzNnRIaXpFcXQxZld6RjY1Y3VISnRaV1g5dURjY2ozVERPWndNeDNMbVpEUXBsNHVUeVZUNzcvNWdQQm1Pam84T0M2Vnl0emNZamtiaVZ5Nlh3MGk3ZS92RmFxM1JiSXFEY21paGxwWHkyYjNkanV6VTY0NE9ENCtIbytGaXEzWnVmV2xocFhYNy9idXoyYWhVckwveDdvTVBiZFkrOXRUeVpEUjRlUHU5UzllZXpzMzZ4U3kzdGJWOS8rNzc3VXIxOGtjL1hTa1ZqdzYySzRWc1VtdTk4VzkvL2Zyem43cDM5NzM2d25xdDJicnozcnVqNDI3bDh0S2JiL3lhdzhJZlpVUkZkb1RhdmNpcS90RlVSengzcVFyM2tmY3pvdkluSExHcUxJeVJOVXdCNkNTaGw2TWNVL0lSTjBBZGZKVkpFUTljNUUwbTNtYlMydU5xNTRndjhsazRoWEpKZ1M0enh6TFF2ayt5S2RDZGxMU3l0QUFrcXQrQmtpdnNRZm5SUUFSR0ZJTXB5RFZVSWdNVHNQUGkvUklVNHE4bVZ6TFVoeHRhcFgxQkt1aEFjZVR3eUNLeE9qV2pZSVVHMWtqdFV5WEk2UDNyLy92L2cwNjZVcEpieFlXWExXUzJDdUdranlyQmlFM3hXRDhSQUczSGlGZWFHd2Q1dkJneTNIRHc5QlJHMERaRVdrK05LUDU1Q3pzTU9rMWtXcGxNazh0QTVmcFNzOVZxTGJRM3oxMWNQM08rVWlxUHhvb1Q3amxtQlBzMEsyYVQ4YVRmMHhhR3JXKy9QNUN6QmtQbDl2R0FSelRTYTlicjlTdVZTcWxTbEcrUGo3dVNZalFlMUJ2MTQxbHRNRHErdUZ5ZFplVnF1ZFE1SHJ6NzRHQTBMdFRydFVlUEhoNXU3M1VIL2FWV285MXNhSE12TVNmRHdjWGE4Ym4xUmpZZGozUDV6YlBuQnIxZXBka3FGclRDT3NmRDhmMWJOemJQWFM3WEZ4cmx5YVBkdlZtbmMrR0ZIL3duZi9mdlBIM3hjdjNNMmVQdGg5WEcwaCsrKzYveWsyT25OZWNuZGl3a2VMVWxyaUQ1blcrYWtDK0hzcnBBTFFsU0VPWUxvOHBHaW13c0taZ2RIZ3ZJMGU4TEpiN2ptMFVBQlM0SUN1NUNsaFVMQmQzRkFDdU9pM2xnWXBweEd1MnNUNGlycVZvMHBZSW1JUzRjOFh5ZkxRVW9IaUpZSFJhSTQ3QVJ4SXdtUzJoVHUrQk1QNkNUUkF4VjBFRGxmdFI3bklLalJEZ3dUNUNZbjByaVRNRjZDZnl6aW5xekgvbk1aM1JtQnQrN1dMNEVhNzhjbHB6R2R4d2Z4N29zaWtoV3lXTlZJVGt2RGswTUUzdFFmK2FxZ2ZEMXd2RU9SR2JBTzFncTN0a204SlZGOEpNN3pJbmhNZTAwcTliT1huanlzei85cFNlZmZYN2p6TGxHYzBIUmRzQmprNWwyS1NQZEZSWUtvK0h3OE9EZ2NMK2pjTzkxajZmajRZVFBLSFo2M1lOUnY1UExEYWVEcnVaUW10UXViSEI4a011UHF5VnRxTWJsYk5KZVd0VHdSL2R1dnZEY1U4V2NOam1EN3RIK3huTGozR3FyMWF4c3JpMC9jZTNpeHRsMXliZS9lMy9RUGRqZjJTclVXZzhHOVQvOG96ZUtoZDQ3My9sMmNYaDg4Y2xuRnBlWDd0OTlPSjdtU3FYNjVwVW41SVQ4dU50Y1hLdnEwckMyOHZwdi8vSVAvZFRYNzczNXplYktoVnltUGRieC91aXcxOS9oOHFoNDlqVTNkakhld3N2bzJzTzdzR2VUNmRUaVBRNFpadnI0KzAwWVNpY0hqa2JoT0ZuZklTTVNnc1NPWUp6ekN6alpIRE9UNSt5RWdqZnhPTTVOQnppRHlGdlNnYUVwRFFsdnhsNFZuaDAvTWhNdkNHa0dDajd6L21BcVFITjZhWm9aM2VGL08xNkhLbmQ3YzBWMFdOUlVCRDl1SkVvT002SGw0d1BsTWVWZit3Ly9JMWt5MmlveUVFb2lOVmd1bU1xb1ZrbmhyanBaSHR1UzNUbVRkbzB4QmJCTEdNS0RJc0dJRzdmd25ObklLN1drU1ZXc2p5WlVobExRc3NwRTZHdUxPRThybGNiYWhTc3J5NnZWVXFWUXlyV1dWOHYxaHNLamUzUllhMmdUMHRyWjJ1MGM3ZzYxdXgyUHBMZzJBYVBKU0hIUzZ4ME91cjN4UU1reGx6a2ZhZnhRdS9qSmVEUVk0TDlpMWw1Ykh3M0hrOUZJeUZLMWZPMzZzMGVIQi9mdjNSbE55ZCtWZkdGVXlBMjZRMjN1ZTdueWVKSWZ6a3JENDBHMVVkSDEvTTZ0MjBlOS9LRGJ2MzVtWWJWeWNINnBVcXcxMTVmcTY1ZXZEOGFGN2R0djdtMXRqUWFINTY0K1g5UmxxTEU0SGVsU1V4cnVQaGpNQ2dkSGc4bkJWckZjZkZBWXZQSE9yeXRTWlNUZWpjT1c1RG91bU55UThyUUlHMHMrOHJwdVQ4T29NaGZiVVBYRUJkRm14UHIydk96c0FCSlRiSzJNVEhhWEE1VGR0YjZWMFJWTVJlV1hndTdlbFc0RWFPdmliUTdaWFlURkluNWpiK1BFVk16TmxPekZVRHVaa2tTU3ZQemVoeWFRSUo0TjV5T1lBR3I3SEppWDZSTmFSQUU2azlHSnA0bXlrK0JSRVp3eUhrd0M3MkVKZHBBRUFtTE5BT0NnVXpzYXArbVppM0FucjVCVHRSc0x5ZUVxa3dtdjJwVE1yV3ppV3FMaEVpNno1Z0VoenJDdzNCV1lqV0MwU2ZPcVNIT3VxN0liVnc0YUF0TjZOQUNTVE9JVG84eHBPcXZWVzV1cjZ3dU5hcU5WeVZVcXM5ckM4c3JaYVNHYlRrZTl6cEZ5OEVEYmtjNUI1M0J2MUIrVUtoV2x1RWQzNysxdDcyZ0hMM1ZLMVhxcFdtcTFsd2ZEWWFGY3IxVXJ4WXBDdDZYd1V6eFZxOVZ5cFRMU1ZuNldHdzc3dXJ4a0dXdGNPLzNGaGZhczBsU1lIUFhIRDdkMzc3NS9UNlc3dnpjYzlIdmowYkJ6VU1wTmU4TmVzOUpjTzM5eDcrSERhMmNXbnRoc1hubnl5c3E1QzQxNnVWSmI2UEd1N0FOOFZtNnNiZWcrOVRnL0c5YWI3YjM5L2NwNDlQTHYvSXVuZitpbjd0KzZjK2JaWi8veHIvd05tNFpNanRLeXB6OGtJRFBLQzl5elVtUmowcnVmRGhUOHRROFhNTEtiTEllN01LYUV4b3k0Z1NjQmJHRFVsTTFrYzJCdDByVnhZYWNPeUhNcHdkcXMreVpXeVlaRkFXMityRzFNa1BtaUs5TW9hYVFkUEE3Rzkxbyt6TUI4WEU3c1FzY0lDT0xJWjJMSUoxcGtWUUc4UzRiNDdvcCtvcFhZOGdCanJGM3crdE1sOFNiMDArNG5oVHVqVlNRWmtXaVlyVTcrYi94SC82Rk1hSDQyVnZvRDRjaDJqd2dacEVNMjl6SWhEL21XMUJkV3BYVWNKTHlGampPU2lOb1hDMDJHZW9TMTBFNEo1SE55QzE0aWk4ZlRBdVJqb0FjSldseGF2M3IyYkxWVjE0WmxsQy8xeDRWeXRUYWI5TFZSN3gvM3hzUCswZjcrVWFjNzRlRmRkVHJSYmoxWEtWZnJyWHA3Y1VGYkVOMytqQ1VRNGNMVEhjbXFUS1VOc2JhL2N1b295N3JhVDl0WFpYbFdHb2d1bXcySFErMXJ4Nk5jVnhrL1Z4amtxdnU5Z29KOE5oMXJkZWhpSXJYcTJhUlMxVXlWcmEySDIzZnZ2dkhPcmZHRE41N2RxQmRyOWUvNzVDZEwxZGxLZTNGMTgwSzVVdEt1dVQ4Y0Zjb1Yzc3JWOHFzMEo3bjhkMzdsRjZ1YlY2dWwrcU5PcnpnYmYvdjlYejNxUEpES01wMlkyNXkycCt5TTJON0I4N2lHRTNMYXduWmNzaFhSS1lQNXVSYkpuVzh3cVRFcmdkVkJuR3EzUXQ3Mkl4aHR6TFUxZDNBcnhSUFRXbThSeXM3MGhQdU1welFwMy9OMGh4dFc3L3cxbTZKRnVRMFhDY0Nka2tFQlJKQUxReEhBekhUcWNEZ0VSbExQNy9wTUNBWm9yb3gxUDEwZ2ZveUJ4K01DekN5UGgwU3Z4OGhLajRtVkJITFo1MzdvTTFLTVh0WmhiR1I4RDJReGc5QnlZWDVXcGZNTjYyQ0t1cURaeDN1QVhoeWtlQ3pCUVAwUjNHS21TNmdvdk5pOXJwak0wWTF6WkYrZG1GSTBYS081VEdidDlYTWZmdTVENDFLcFB4d2Y5YWVsWWxsK0ttYXpoZGJxZURDZWxTcFpzVkZaV05pOGNHbnR6TG5WemZVekY4NnZicHhiYUM4M1dpMEZkbjh3N25SSGszRysyeDBOK3NOK1h6djhnVFk4Zy9FNG41VU9PMGU2bTgyMFg4MUlnYnFrYTlSZ05oc1BCNlZTVVVlbFh1SFJUVEdyVml2MVJuVTRtQjdzSFl6SDQwcXBNSmdNWjZOaHQ5L1Zua2tyU1F0c09NNi9kMjlidTV6aFlQZkJPMit2cmE0dnJpN2Z1SDNuN25kZnprclo0dnI1UC82dFh4UFBOMTk3N2Q1cjN5cTJsZ1k1cGRMc2xYLzdyNTU2OFRPVDRmRzROTm5ldlpIaVBKNHdLclpUWkVjamtyc2RnV2VoOFRyRjdDcU96cE9Bc3g4Y1l3cFMwZ2lXbmlsYWNRTk5QTVg2VVBnUzhZUUNZMDNNc0toMGtnL2REVzhtRnBXdzZtWUtjbmpjR0ZORHBJUHVORFRtd044a05Ub0pNTnF3UzNSQnowU1B4MFp6WGdTeU9BMmVHaWJCNS9UaTZYZzZvUU12M1hUYlBXOHovU3o3c1IvK0lUWG1PSWhVNlEvZDRhS203RXV4bllsMWxFUlBGU25KQ29BZUEvcGd0TDNBU1IxK2JHdjJDbnpiSGkvb0pWQUhQdUJDYm1JaUh2OXAycVcxczA5Y2YvTG91TFB6NE1Hd1AyeXRuVmxxcjJ6ZHZuVzhjNyt6djFXcTVzZUR2bWF2YXZmQ2o3Z1VCb09wZ3JuTEhlcmc2S2gzZEhUYzdRNkdvM0YvcUxnYzlvYmE2UXg3dmE0OEoyUzNQOGlLK1NrZnA1VlcvSjVHdVZ6cDlyV1pRV21oZXFOcDU3aXJPMWVsOEh5aHZIVTAyTnZ2VkxKWmM2SGE2MDlxaGF4Y3Flb0tvS1NyelZCdm9CVlNHRTZ6WjY2dEhIZjd4ZGxvKzk3OTV2S2l6THR4N21KN1pZbFBvSTU3czk3eE01LzhkT2ZSamVQZDdmTlBmUGk3Zi9Tdjg3MkR6V2Mrc2RCczdIWjI3dTI4Z1pWSjVjUVFXUVVyazF1d054Z1FnQUlpTWRyZTZhWEpzREVQeGRRcFdGaGRBK01oK1lsaGJYeWJPaUtIK0dPZEZERTViTVNkZmc3MUF3ZC9laGdXaFN1bGU5MUZGdFJDOUJTZXhnQVBQYjJpb0tBNDNqMW50Rk1FdUtFS0FjQzQ0U1VSNE1rQmN3Mkh4d2tTTXMzQ3NKakZhNEErWUtvMGUyQ3luL2pjWjQwaURobUdqZHpKSVVvbjhoVFBZV3NmYWhQNThxTjdSRzJraHFJanMySWQvL0NVYjNSQ0NtWndBVkQrWlJuUWdjNitSbWdJMThaWlkzSHhtU2VmdmZIMk8rL2R1RFBReG5yYzdUMjZzWHYvcmZ6b29ERHI1NlpkM1dOT0NtVWVIcGVyRTkyWnNuR2JkSTU3bllPOTQrUEQ4YWl2bTFVdEJ0MjZ6aWFqWWI4cm1UT2V4a2lrb2lLODMrLzNGUDM5MFhHdk41N014cU94OXY5Ty9UendHMllsYmIwYmpkYXNWT3RNaXZlM0J3L3ZQZW9QdTYxV3ExeHF0R3BhWUpOT3Q2dGIzMHBaZDNMVFJyMnVXTHQyZnVQN3JyVy8vd2MrdWJDMnVkM3BDL1BHcTIvc1A3aC80ZHAxQ2JPOGVuWmIrNjY3dDgrOThPbHFlL0Zidi9TUFgvemhuOWplMmFzdHRMTFJxTlplZWVPZDMxYnNFTlk4aUNUWTFmQ1RHdWQxWWNDeG14Y1p0eGRnY0lQdEgzRVdSNFFEckRDbjNSamhUZ2Eya2FsTnhIaFpQOGlOWVEzb3FxSGFic2Jqd0hSQzQ1QnpzWURxRnpOSTFBRnpGU0xDZzh6WUE0V3l6MEc2eDcwUVFrR2dpOGljUXhoM3VDMkFwc1ZML05sOXpFY2dvSWxWTTRIT3FwaElCZjRLSitNRFhjai81Lytudnlxa2JDelVYRE1wYWxVeExIWWxzV0J3THFtb2pKMmRkUmdqR1hneDJHcjY1QjZ5aHRDRVBFVjR4QUZRMEhGVlZYRmJhZC8yb2dCSUw4OHoxRVpWTzJnK3REaWFjZDg1Sy9JeGdISzUxcWhVNnVQeHBONXM3UjEyOS9ZUE8vdDdsZUprY2JHcVpKejV5ZlEwTjBMMFRDeTArOVZXWU15VGpjbHNNRktPbng1MXhyM2ppcTROdWhuVERxbGFMVGJxelZxalhxclZ5dlhGMnVLaXBzaXk4aVJYSEE1eld6dEgxZEpNdDdhRFlYODhtcFNMMmZGeHY5V3NIbmM2V2JGUWJkUjE3N3ZTS0QvUjFpcmIxMFpZdDVKWnJmWGFOLy9veFU5ODZ1Yjc3Nzcxelc5ODhqTS9mTzdhVTgybGxiZC8vMWZQWEgwNlgyMi8vOXEzVnA1NDd0RWYvZHJtcDc5MDU5dmZ1UFR4SC9oSC8rci9QQmp0eTdZVDJZQ29KcUltOFpFdnc5cU40d3VaaXN3UTJ4cWlDRTl3Z2NSMitFOWJRK3pySDVIUnBWVk94c3BhZlh4aldqRCtjRTZTRHdnNVAzZlhEbDJEZkxzc0hQZXZqbEFsZlRiMElzL3hscE16Rjd0VDNsNGwwdXc1KzVYRUpZRGRQNUtJVW1POWVIUjRHdEFVVDAra0lCZkJJdWFjaUIxZndxS2hQd3lodG9jbC9LazZRaW5WQnN3SENja0dJS2lDY1pSQy92LysxLzZQWXN2ZVRla1JNV1JKWlFYK2t4NXJRTVFBM0NvWmlIQVhCKzBkRmZSY0ozR0ZpMFpwV1NqSTVTeWtPRlUwU3IwQ25JZWtwemhyMWtURm9oRGUySUlkQ3M0clNZQXNDZ29EYXhJdkpIN0hRUUNiSXhZbDhrZ3F5U3U1ZUU2bk9FRU5najZlWkNmTUpEL3k0MnpSakF1NTZWRXZ0N3VUZFk2V0RvK0ZrMXpxeXBYeTQySldYRnhjckN5MkJ3UE5VbDVkWDY2MkZpcU5oWFpySVplVmRyY2Y2b3B4dExjL25vektwY0kwWDE1Y3FGL04zWG51RXk4ZTdSMDJsbGJ1M3JtN3NiNlVLMWIrN2EvOHN4Yy84ZjFybDY3cFJsaVc2ZHg2YS8zS1U3L3p6LzdCczUvNDNHZzh5QlVxMjdkZXVmVGk1KzUvOXhzclQ3ejRQL3p5ZjhEN3FqaWZXTmVCL0xLWGN6dys1bVI3YzNNa0h5VTNPeFZoWEJsTFVRN2d2S2E0dzlxeWxKekNUMVhpclloNHVkZXh6alpUOTZrRUlLTlY4NGdHcEoybDJDWEsrVFJCcGx0NGJyRXdmNUZWeHN4c2xQQ2hZaDFQcUJmMkFBeVBYdTRkSE9vcUdxSnV2SVkvQXlzZnV5M0d1REgrT0FpemVTMy96Mk1zK29DNFovQ2Z3d2dVRE9sQlp3UTBBMCtpNFBDaXluNzZSMzlFaWt0QWlOSGZDMWppV3VTSVMvSFRIM3B4MkNIdVRHY05EZFB4WkZjM1lEYWtpeCs4cE1LN2VMNTNnSE4wWVJDRzJ6TGlKWlZZWVJ6WUZVSGtQemREQUYzRndxTWdlWjdET2pLQk5PTWhkTVMzNHQ0NWtkeWc5ZW5uZUxQeGxCOEEweTZkVDE2eExIZ3dONnkxQnEyMW5YcGxNSnBVem14ZXV2TGtzeGV1UDkxYU82KzkvT0hSY1NrcmRBNTNicno5NXIwYjcreHRiMjNmdmJHM2RXODBuVHg0cUlnZnI1L2RuR2Jsby9mZlB0dDc4NFdQUGw5dk5oWTN6N3p5UjkrNmZPMWFwNnNkMStUN1B2ZGptcnF6OWY2b2UxREs1L3F6L0J1Ly9TKysvNHQvK2NhYkw1MjcrdlJFZTZ6dXNWVGN1SEJCbW4vbjdkK1p6Z1pZd0Y3WG90VUo2Vm4xNFdSbGRVRFNPOTVRaDdTMktleExvZWpuMEpEWk5HSTZyRW9hZzRMbEF6MjB0TFZ3TkI4K1p3SWNyUklCWmRBelNoSVhUVVgrWTRpSnZIM0g4Z3oyN2hWaExFK0lJdEJDeG1DWVdjQVR6cUVJY1RSSG1EZ0dHTWJGam5YajRaOE85OEhmbE1FM09JQUFwWmh4VDJLQ1RMbjhmL09mL25Wc0kybWxzV1ZqS1NBRzZWeEZhcWptbjFsRmt2R1R2VkE1SmcxRG1pbXNsV2l3b2FieTR4Wldqa1V3WGhCa2JOd3hsWWpnd05XQXQ0RElXR1luR2pDeGhSUzFhWG13QUdOYkV3eVR3SllrTGlic3VpVTZuNkJ5clBCcFFxZElRbCt4UGxKR3p5dm9oUm1wU2RDelBSdXpNVEIrYjJ2dGNIdWp0YkQwc1U5OC8rYjVpOVZ5T1Y4cTdYYTZqeDd0YjIwL21BeTBnV2t1TGpTMW4xcGViR3Z2bjVXTDIyOThZM0RyMjUvK3dvOHZMbTlzNys1VTZ3dXQ5bEt1MThsS3VWSmpaV2YzcUgrd2ZlSDY5WVBEdlVLK25tV2ozUnZmR1I4OFhQL0UxNDRlM2loTytzM2xjOS82clgvNnhNZC9USG5pVjcvOXQ3ZDIzclNpYU1tbkhhUUp4VUdoZk9YYlE5eGhHN0NTTVJkOW1CTkRnYWF5STlSMDV0RTFiVnFrVnlpOG9SVkFzekRqZlQ3LytleERrSE96b29IN0lpY2NrbnJzajF4SE9zUXB6Q05RK1VjTlhRVGtsb3hIbmJBSitsaFdQSmFRVUJKR1p3R2laRm1vaFNKS2RaeVJqVWdqQ09WNjc5RFlTa2dSK1JNbEtlbzh1YXpSeC95ZUpjTE1BVVl6Zm8zZlpGaENvdnJKMFN6N3VTLzh1TVNUUXVwV2ZJb0tTVkE3Y2pheUsreWNwd1g3Z0JicFFjVXdnenBJNEpqSDc5YkFscUphWktwNXRCNDBkR0E5RjRuS0czNUpDWW5LMGhOU3NuTWw0UklzYXlnWkMwbU14eUg1SWVmSEUyVVhIcnpMS0h6UWR6YlRUYW96dXA5eXBIeFBqbWNaNk00di9tK3RBQ08xR0JUM2sxRnVVcWtmTkJjUGQ3ZHlXM2UzZmJNNzZmZDZ1ZWxvZWFGeDZkeTU1WlhsalkzMVVxWFM3dzZMcFZLN1Vhd2Z2TFgvMXJmV1ZsdUxpNjJOaTlmUFgzbGk2ODc3bFh4K01EamN1UHBzcVpDdk5ac1AzMzJsVkdzMUZsb1BiNzNYM1gxMDRVT2Z5SStPaDhYbTR0THFaSEI4NTQxdm5YbnFZOW83bCt2dFcxdXY3aC9ldGY2U1dzNk9aelNzWktKREIwYXdqVENad29vOWpSQU1vRWtZWXIrd2FRb0ZuYkNiRENaM3k2SkJZN0lnRUFJNFFnTU16SWc0QWI2YVlIRml6NVY2VW81anowbmJXd3JMcCtLWlVwUXh0Zi9FVUlleHVFOHNnUmlpWHM5b3FoZ0JZRlpNQXcxem1JUHdmQXBjb3l5QVozUnRJQXhoZHVhWCtQamt4UVZHVnZyeVQvOUVrZDBhV3paMEoycUpSY2VqaXlPYlJjNmZlelB1YkFoWDNZMlFCSXh6Mkl1cjd0VWkxc1ZXTldFdUp0NGtPbSt3SWRRc01Sczg1L3NXN09SckROZGZQS2xhWFhOSHNwT2hxVURuSW1oRE9BZDRjeUs3RStuRXJ1S1lIZ0tGZ3g2K3c1K0NXN0d1MnQ5dTFrRFJxMk04WkRkdi8rVUhpNnNIM2Q3Zy9adUh0OTY5cVhBdjY5YTRWcFhWNnJXeTdrMWJyZHJHMnNwaVpkWTZmdWZObC82NDJhdzg5Zkh2VzFoY3FEU1h1Z2M3V2JGVXJKYVh6bHpXUG1YUUh4M3YzbCs5ZVAzMmQvN3Q4cmtuRnRmUHR0ZldPa2NIeXhlZXFiWGE3N3p5UjVzWG4ram1NdDBSbENxTlFybjhqVmYrK1hCNGlEaXNZWVNKejM3S0VFclBNb0Fhc2dJV2NEcFFCMTQwU2lmNysrU2dTeXpTZXNCaTRYNjFzYUNhdUlvK3MzRCtGTVpFNmxlWE9CS09haExaT0lOY3l3c2syWmQzS1ZWckVJU2dxWUtqLzN6UlZwc2F2aWZkbGswbnkyQlNtREFUSzVncDRCeGVwa00yVVg0aW5VSGowU0JwbVQ1MElaejBCMk1JWFFlQXdOeTk2bEx5MVMvK1pNU2tZeFBBRVE5QTIyRk5DTHRMSUYyOExlZWR1SWtpdUU5Z1BvWXhoMWtjN05sWlQwVVdCRGtibE92STN6NFFpNFdMMjRobUpMVDU4Q3RBYUJpOVVsRDNsUVFxaHVEcitocXJJTmN1aXkyQWV1UWIvMEtMMGdHeEx0NktiUDh3dFlid2pVK0Z1M2l5eXlIdVdSSmloRWR6azlGczFHek5ybHo2NG52M2RyZTNIdTV0N2UzdEh2UUd2ZDN0dlZxajJhN2tWcks5aGZ6KzRmYkRTeGN2WFB6d3h5cWxiRHlaTFNoYjUwdWp6azU1Y2ZQdzRkMzhlRENiOUxxRDZjcVpTOHVyeTdudTluN25ZUGZ1blkwclQzZjI5dzYyN2x5NC90eGcwS3RrbGM1NG9uMVd1ZHA0NWQzZjdBOFBZcVVtUDRiUElwdkprLzdGZDdsQWwzOFhjTnp3aU9DeGF4bGk0d2pRM2wxZHJCLzZlUkJKa2lWQUNlNG9HSmJZRmNnOG1DcmlVeVc0RW5uZ2ZVWTZNV1VweHVWVkhQQ2E1aUhXVkVjYTUxQ2xFYWJ5ZWU1VGNYSlNFK1JPRjdoYmJQcm5nWTdmNGdDdnFjUDd5Qnp6UXV0NU5Ddk5OQzEyb1pFVVo3Z2dCVktoVkZRZzhqbC9CYTN5c1k1eWxvRk1SNkZZQWltb0pId3BLNVdWd2NwRjlRa3ZwRkIwZ2lpV3MzSlpGTkNhWEh4NGU1SVZVSExvTTR1V2pRNXY1WGpNeFhKQ2ViYVMrTW5TSnJVTnF5Z2krU1V0eGJUak9INUtUc2lSUHdLdW9QV2h6VG9QMzBhei9DaVhIL211bEIyT3NzTFlINlROcTZVYnpKazJQT01wbnlGemRtZTFzTWRSdExQN244d0tFOTJtcnZXT2U4MXF0VGNxOVhQWnlvVUxsNjQ5OVlrWG4zamhjdVBTMG1oenFicTdzOTg5T200dHJTNnVYeHdjOTNScnUvM2dnZUp3L1ltUGJyMzk3ZExDMnVIK3djTEZEMlg1MFIvL2k3OWZYVG8zbUpZMjI4dUt2cmQrL3plcXplYXN2OVB0OVZ2dHRlSEJYUmxtMXRtdDFocjFXcHNuTWZMTGJNclRGSHhGRE1tUklpbXlkUkdnakVFUUYyUUVvbDltY1FCaG5MRldDTmR0M2ZMZ1hFV3RmNnNBZHhNNExIb3ZiRXdsZGZrZ2hTeUF5c1NEUUREWVUxYWRUTWRqZnJWaGhKVjRyR3Y3MkZhVDZWQ01sUlFtMHhFME5wejQ2eXltdWkrU3RaMTdTQ3R5azQxUEp2SzNjRkRRQlVtVVhIUWdEVENQRmh5YWhya1VVMXUxY0wybDVmdnB1QldKNGNiQmVCd1plT2J5UU8xbStUMWtkR1dkOElHUzdPZS85QVd0TTRXaHRpdXlwcGFGbnlZUmczRTRRZlBaT2RWYWxRcGlwMmVXQjFtY1JFNFVxeGxWTkwyNWljMUxYQ25TdGw2SGdwaWE0UGFCaTNUeWF2YmFuZkt6d214ZENHdFd2T09TQ3pPR3dCWTJoT2lUNnlCd2ZGc3hwM1FaU0JTWURPdGdDNjBOM2NaQ1ErRHpScjJzcGRTcVhzaTAyeEVsamlCdFZEcDdHOE9qUjR2TjdOeFM5WWMvZHYzQ2V2UHlack00SFdoMWR6cUhPL2Z1TlJzMThXdzFGeFkyTmx1TFM3UHgrUEJnZjI5N2UrM0N4ZjdERyszTjgzdDNicXhmL1ZCK3VKY2I5UnFyWitXTXM1c1hicno5VW00NFhUaHp0Zi9vL2RGd1hGOVlMTmVhajdhMnNtcnQ1djF2N3g3Y1laM0xBMTd6ckhhMUl5M0pNVTZOeXA3ZVVZUzVSTUk2bGk3UWFrRW9ia2daVXA4OEFUZnBTNkI3bExPSi8wZ28waGNpazVrak5Sd1RZOXVDQ2hJaURkaVVPdEh0QlFuVG1FMUlEaElyWXp5T2t3bWpJZUlFblFET2NSWlBaQ0puVG4rTUFrZmpYMDEwNG5FRE9NNTRwSVNUWWtrZWpCWk1yQjJXU2RjQnBvQmUrOE0vLytXZjRVMEdndGxGY1lrNWFEazZBL0JOcFJvbmhVaG1kYWcvWW40ZTY2d0hzVk9KV2gwYTZuMjgrR3FBWWgyZmdVVU9TNGpDa2tadGhacmtSbmVTZ2FTVU4wbHlFcHdzaEFvb1RJQVN4bExiV1lwbDdTU21tSVlXdzVDdmhKR2JORXA0K1Zka1lxdGRqUTNCS3VKTFF5S0NUOXBxNnE5ZGV5SGZYeDMyajR1RmFWRmJqZTdCeGJObkd2WEtiREtjRnV2RFhxZkdUd0szOHNYYThhTzc5ZVgxZTI5K3AxaHB0TmJQN0QyOHA3dURVbk94V3F0bjFYcnZjSGZsNGhQRGZxOVlXNmcybG80ZXZuUDJxWTl0dmZGN1o1NzUrR0RRcmRUcW5iMUg3YlZOVFRRZGpSNGUzYnUzL1k2dWNqS0ZyS0liRjdhVnlUS2NzQjlCS0NIbFc1c0ZQQWhuRGZBYVNBakdUa2c4c0MxR2hPTzhpRmEyaTE3QzN3R2hNaTBvRVFRL0RKK0dFU2lpVk5abEhsbEpCQll2aXVVenkrakR3V2xPK0ZJeGRjd2ZIbWN4KzVzaDlES05tdlBkS2U0VmIwNXFja0dDVHdwMzRUMEUzNmxBS3VaY204Q29CVk1rOW95aFdreUJ4dWFRL1lXdmZwSGd0bWt4R1laTG9ZMWtFZE51S3NLQkNIU2lQR0VkNno3QklSSzZpcmNzVkluWWJFM0RuUmFTQ0lPczhkQTN4RVVyaFR1NkViNEtRWnZBLzJjaVhmV3dNOWNzeHpRS1JFWVhSQzA3ZVNXUXdybFFDcHR1U1ZrdExBQ05IV21ncm12eHN5MWdQRmJFbUVjMm0rYk9ydjNjd1U1bm9pdGhsbDlvclN5MGFxdHJLMnViNjN1SGg1MmR2VW0zVTZsWGkrVjZhMm1wVUswZGJkMXBuN3MyNmgzdFA3cS9mTzdLL1J0dkRYdURsWE1YcXZWYWRYR2x1Ny9iUG5QeDIvL3E3NWVMMWZibHAvY2YzbTF1bkI4UFp3L3VQMWc5ZS9ubzNodnRqU3ZqOGFqV2JIL3J6WDl6MkxrbkdXUTR2SVJIQ1E1Y0J5UThjb01oTWpCaFZBWXdKdmFFV0lvd1FpcTVJMVhFQWN5ZEZlaFBhSVduaGlqSHpPYzBDMU9JMGlsSGZRS2pvdWlTeUVrMDVtdTBSMXNDMDZoRGtPSUpiRUtrdFNHSEdnTWlkYW93SjNycGNBRGdYMStCYVpLTUVBbHN3cHVWRUlTRVZFczgxSXNNNmpXMUdiSlVxZUZNdURzY0ZZelNuRmlWTkJyaVI2eVJrRk54RkNzQWlHTVRxNm5Wd01NWmNPeGRPSUdsSTYyVHg5SHZFckVlK3NwemtsNjFCSlJrV0UweVdRSGlHeWw1UDRoVkhrbzZzbTJDdEozVVNab1F1R2tub3kyTlRuRHdTaGhyOTZiOGpkdW94Mmt6dzhEeGlGVUVXL25MUnJSRlo5T1Yxa2Q3QnhlR3h3Yzd1L2VYMXM1cjA5SnNOcXJWVWpXYlZHdXQvZTFIbTVldmpucjl5U3lyMWNybFdrc0RLL1ZHdmJWY2FXOTBENCtXMXRhcjljcmhvL3ZhUUplYUs1MTdyeFZMbFkxckwreTgrNDIydHZqMzNqdi94QXZIbmIzQjRmYmgzdmJaSjEvY2UzUmZWNFBlNGY2dmZlc1hjNFdKZHUxeWl3emwvK0tGZHJLTWJHZDMrdkdDcldUakNaSjNiVW1obk5SSWRZN3BFLys3WUZhUmE0aDBoSXdPc29OeHhLanpPa25RM29DTGpNZzB0cjVxalJFOTFqZW5PWCtNSmdIaEFFOTRzNjl5cC9EbXBBR3FKUlFUTUpJSUM5RmNJeHZDY0xhdjR6WkRuSnlNVkl1SGQrb2k4MlhFQStjSG1ndFFqL2dydkJCT3Ric3Nza0lyM29LYzViSy85UFdmSlhnZGdUNGNyRllIb3puS0JVU2xGem5iZTIrNkNXYWppWFRITkdlL2dvY1ptOUM4cUpCZG9BR3NoeTFKeGpZMjhTM3RwTE1PN2pVRmVBRUloU0ZtYk1HNWtXSWZqZ0pqaFQzSkc3TmpIV3JJTUkwOWxHSmRLb3VNMnk3MlFEb3dveGFEcHNaVW1KaGhNdWJGODE5NmRIdi96dTFiSzV1WGFyWHFRcVBHUDFmS2pTOWNmcUxJeDA1eTVVcVovOG8xNlkvNmc0V05DOGRIZTRzYlY3NzcwaCtVdEtHcEY3Vi9QLy9rODczZWtiWTc0OTdoMGFNNzljWDEya0s3dnJRK3F5OVBqbmV5U3IxY1g5dzhmNjEvdkRzNjd2YkcwNFZtczlQdi92NXJ2NlRrb1dCVElwRThZU3pjZ0dCNHowa0JMRVUxMnVIbk9SMXhtdkhPZnNLYnpJOXhwSmFkTDZ2UllxaTlFRnlNa0RkUUgzTzRHTy9rekZaRGNPUUcwRVl3T1VUMG1RR1RtUlUrbzlqSndtaU9PT2lqd3ZVR0haY2c0Ryt1T05vSE9ZNDU1ajdGYWN3UERxN1FXQW9WODlMNkFRdnMrYzJHSWZQMTVyR3o3Szk4L1djbGdQY1lvbkpBazk4VjBUdzFkQjUzc0taQUpvaFZpZG94TFpXZ0YwQWJQcG11Q0ZHNE50aDVzVmtYTE1VWUxpVHFoZEF5TkRMTlU2eGpGMVZQZml1TG1BNzlKOXh4UzI5dXNXMEZZdGIzbDJFVDM0TWJMMWEyblE2Q1hvQlhWT3dGRmVZYXpoMnNwa1lDUXpaSWJtUDlNNFhSczd2YjIwc3JHMXNQM3I5dzZjTE5OMTgvZCtIQ0QvL3dwNy83Mm10THk0dkQ3bkd6dlhTMGRYZjEvQld0N3R2djNwak9pdjJqM2VYTjg0ZTd1N2w4dG43dDJlUHRoMW0xY2VlNzM5bTRjTFZZTE92cXQzdlFxWlpMeC92YnErZXZIVDY2VjJtdGFPK2oyOW43Nzc2OGVlWFovdjVPdnJuNGg5LytYNHBGUWtGMjhxWlNGcE9KOEFiK2N4R0dyWjh0VEVwTFBad2dsbTJsQjNjL0dnTlMxMTVIbmZSV3JiRTJ2T05ZSFJDalByRDF4eG9pc0ZFVVBoUWxWVUVGdmhVTFV0MmtCeGNaMmVzaDhDNGFJRW5VTkZZOGtwU01vNXY1ZzlJajVKdFlUT0VYQmptcE9SS1kzTjdrSURJSWQvQTRPNkFZSHNRMEJiZ2tianl0VjlFSU94cUpzci95ODE5Q0FnSVRzUlNYYnFsd2NxQkh3VllReEpvZzdnbjBFd3FXQXNqb2lPS3JNSXg1d1JmV21qVGtRMlpFZEpOQXAwbTRLNkRIczVFVE03OHo0VWN1QktpUGtXSjk3SXhPcXA2TmRaa2l3N01xNEdPakVPVWFibE9xaWNmNGtEQ1dBcUFYQ3dxdjZiWFlKSmIzZjVQQzJaVXY1b2VOb3E0aHc5N3l5dnFIbjd1K3NOQmVYVjI0ZnYzeUs3Ly9PMCsvK05IeFlLQ05UYjJ4OFA0YmY3Sis3Ym50TysrVks1VmlWdGgrOEdCcGZhTmFuTDM5amQrdXI1eXBsd3Zubm5yeDltdS91MzdsZWVYNFVtRTBQTm9yVmV2YThmY0gzYXlZdmZUUGY3RllyaTFmZmJaV2JVcWduWU9kUDM3em4rc3UzOExJQzRRejlnbjdPVnFkVFdqUWxxcEI2UUMybWFONGljd0RNQmFFVUFvaVFzQ0doZ0xyd3lRaVJIWVAyTWxRWTlVRmpuQjB6bEJ2cEExR3pjTlFYU1ppLzZWRFRVMEhINjlXUVJEUVZLZU43TUcwdmUwUUtMSGxGTThmQnhsZGhVaUllR1VlSDJyQlNMQjNKbHovTFNRTHdXRk5ueW5nRXhnR2dnaVk1aXo3eTcvd2M3WnVGQU1TUThJNWNObHFlYjh1Vm5TNUlLWUlGT3Q0Z1VGTy9IU3BWZ2NmTzRCRDZyV0dtaFBqU3l5c0NZenhRemhpRjh0NG42Mjlpb05iWVozencxMmlYM2s5endZR1N1c3ZSZG1PUTZlS1FwcG50U1RkWklYVXBUV1FGMC84eFJKaS9lakNFV1M2UTdDYllKQTd0L2JqVjg1ODh1Sm03Uk1mZjNKbHRmM1p6MzVpb1Y3cWR6dkhCN3ZYcjExYzJqZ3IyYWVUVWJGY2xtYjMzbjE5a2l2VkZ4Ykh3K0g1SjUvYnYzY2pYMmt2WDdoY0xPYkcrV3E5MGR4OTlHQmhaVjFMcXJxd1VHNnRiYjMrQjYxelQvZDNicGViUzlwZ0xDMDN1dHQzcTB0bmR2WjJTcVhxT3pkZWV2ZkJIL0p3UFVJVkE4dXZObHBZRDFmRXJoaXpHaXR3eGgxU1pHc2JIRldNZDl0SlhIcHFuVUFkZXVvR0FBanJHM0JJKy9HVm02cUpid2pZUUVnaW51bXFpM2lTUGRQS2tmOTRWNVVMaGpmdWhERFN4UVhFL1k0U3VqUlk4d3VYM3Rwa0tzZ0pVUDg1Wk4xeWVNYStVcFZxWGRpUlRpOFJTQUQxNC9WNVFWQXJ4bExGdWJRMHE0aWRRSFVpcnpGY3NKYm0vK29Ydm96RUlpSmVFWEorU2dLcm90dDZlYzJDY1k4eEhCNDZMd3lUQzB6REFFd3Z3RFVBdW5HUVIyVFFFQ3RTTmU5TmFIZE94T2UwUVZlQzkzc1dDU2t0UlNOTXZMdUV6dFlmcFRFUVprUXIrMHRzTWFUTlJQWTN4SFZEOXdBc0dGdkI4a2cwekhuMTdFOWNPL05UbHk2dTZ5YTIxV3BjZStLSjJmQm8xRDllUDdPMmNmWkNyVnJpb1dTcGRMQjFmM0YxTlQ4YlBucm41ZTVndEhyK2VyN2MxSjNMK3FVbmJyejJyVWFqUFo0Vjd2emhQMnV1bktzMktnL2YrczV4ZjdTeXVyNi84NmphWHR4NjV6djFwVFAxUm1zMHl4WGI1eWZIajdMbXhzTEsycjN2dnJKL3ZIZmo0YmUwNjBNaUczRXVQNkZNdzVha3k0OVdmTGJ3aVI1aVVXRU9rY1dHRVdlQm5wdWVncmt4RnJ4bEJnMVVwRWRraDhtOGVZRlN0UkthOGdMOHlPZ09HWnNZam01cWN0SXIvMDNLWk9Zd0x5a2FZeEN5aXNaVGUzUzRUUlh6ZWZKSVR3UURGK2x3TnhHc0VTRWR0WDBGZzFTa0liV3c2R1FhOVZ0RjRvcWFOMkRNUjVjRmhmdFhKVVJrZFlkdStpaVdjblRJVHdlOWF0aUdCdjF3bGRRaWVxRkU2VUVVRW53MEVBcVZnRUpEckIzaWtzNlJIdmw4MDAwZGI5cEZSbGQ4QXhDajAvUVdxV0RGdldqOFJoMzhaQTd6aExPNWNiQUdLQmdyWm1TczhhRy9TTUhqVml3azFNWFZUMzdxMmI5WUxzM0toZEdWSzVkeVdTazNIcmI0ZjNtdDk5OSs3WnUvK2J0bno1L05GY3Y1UW5Hd2V6OWZYMWhZWGgrUHh5dWI1eVg1d1lPN3crbUVyNXkwMjZWcW85NXNUdnNIaTFjKzFHd3VaclBoOXQwYml5c2J3LzVSYzNGdGVXVnBiK3R1YmZuc3JIZVE5UjhWR212aVdTbVdPM3ZiaDFuM3ZUdC9RRWo0b0NnNHlDNUlTSjdoalZYc3I0SmhPU2RpcWFGdUhreDRaNitHRk5RRkJBMU5qRG5tdTFlMWxkMFZVUElaa2FxejU5TWFVbE1FTWFXU3F1SWdPQWpCbDlaRXI4RzZVcWl0ZVR3cG5vYXJnSXpSRXBCZUpJSUxjY0hrYWpPRHFNd2NCM0hIU1UyRnYvaVBzUGlYQ1I2NzByd1k0N05PREVrelVDUnRlQmF4N1Z6MUVlV3NHUzRsSWpROTgxRm4vOTVmK0VvSUxvSGlqQ1Y4MWtGcVNXRVJHUVdBaWRRL1A2RGxTRnNaeHBxTVVSb0x1WnVBek8wbDZGV0xvTURjY000bUl6Ymx5c1NLZGY4WXFlTmVpWG1jRy9LSkxvWnd6eHFMZzlGTUFVTlpNWjQwQVNCbnhBQzlXbFFTUVhNeHlzdGRvekJuM0xmWktjM2ErWi8vMG4rMTBLaGNPTCt4dXR5Ni9mN3Q1Y1c2N2k4YmplYjJuZHVkVHZmS1U4OVVTcm1EdXpjbFZhbGNhaXl1OVR1ZGpVdFBTcUQzWC81bXBkRnFiNTdOVGNkM1h2Mm03cFlMcFZKajZlejk3MzV6Y2VQeWJOZzUrK3dudTN0Ymkrc1haNGZ2bDVhdkhtN2RhQzV1RkZ2THM5Rm9WbDlXc0l4NnZVUGRBUnpkdUxQMUtyWkdlQXdkc3RuU2JCZVVoOVQwVlJna1pCamJXbUlCeVBpK3FlK1hNZ0QxUWFwWCttUTFEVTZFakE3ZFo4TEZmb0VIeTh0eFEveWJtZ0tGVHA1SEFBdUtFRGRyVFdYcnc5Y0gyeVJhSWJrNWlTUHloVFNFTWs1aWZyOVlpbkhaa0Y5VUM5WWdBMHdiSkV4aXlHSmJsT0FhWXVrbFFHNTJySjFhVTZLMXU2TU9NaWNPS29UbE9zbTNUVUo4OEJpWUxnNStWb3d4bERCd3NOQWZMZFJtdCtrak9FQnBPeU9IcFZlOHBhMFhockFXM3NLeHExRlRHWjJZWm84ZUNkNnhUb0tmaktkRGhkVDhhVHQ3RXVWNFBwZ0JEWXNCL2pCbHJ6TEdjUDdnQkQrYnF6RnFjajFoZW91blc4SVFYZm5wL1ByM0xWV3o1WGFqbU9VT09xUE56YlBUZnVmaGU2OXA4NzEvNTkzMjBrS3V0OTllTzdkKzRkS05iL3hXcTcweDZ1NXAyNzExOTUzYnYvZExsNTc5MEdqM2xtYXQxUnZubjNsaC8vWGZLdVlMQzZzYnE1ZWVPdGk2ZCt1VjM5UHVLYXMxOHFYU0tHdHQzWDZudm5KUlY4M2U0YVBld1Y0cHl5YWo2V3R2dmwxYjJoejFEMlF3eklYaDV3YjBnMFZqbzh1OTZaRGtpWXpRNXZrakhoTWd0Yno0ZVFRcEs4T05uSzlMOFpSZkNkT2ZOVmVveXQwWlRpRm1kR21RalR4SlhMbk5pQzdIWStSNVF0V1kySGpnVHBDUWNXbUJDd21NZkJRdTQrcU11OWlxY3FzMW5xamdSQ04wNEJ3L2ErQy9xZ2hrUDJ1LzI5SEtidHJRNnNJdUlEMm1reFRxRUV4aE5sZkVGNU1TUXQ0amtFL05PZDY2OFEwYk1hRHMvbVcwRDBOaEwyREpuK0xCS3J0UGhhc1p4VFVoeXdnTUdJYkczbUh4NEdNYW13dHhFaXo1VXFxV3VVS085Q2tpS2E4UTkwNkdKK3NqYjJuaUUxMGFLSEhtNnJGRVlNWWNYRmRWNlZLb1NsWm4yYUFlUWM5RnpiV0dhbm5ZV0xURDVmN0xWN09GanozMzcxODh1NWFiRE41NDVYVlphOVRaN3h3ZGJWNTZzc3kvb011MVY4NTBIdDdldlA2aE1yLzZNUzFVNnFPajNmYlpxNHZyNXlhRFFhN1dQdlAwODR1cjUxNzlyWDkyOWZudmIxOTZialRvSzc0cTFWcWxXczZOZTgybGpWS2xzbmZyTllYNDVwVVBEVHY3dys1ZWErM1MzczY5U3FVMkdJM0h3MzZ4MnZpWHYvL2Y1dk1qdG9heW5GT01QL1pNS1NyVnpPK09DRzB2Qmh2WkZlOTVZRy8rMUNUbHcwQ1JhVXJNZ3l1OTdXQ01rQ2NNMkRjRWlwVE5KcFN4ekJWSEJnc28rZG9wMDRQMFBQU3IxL01wVC9xaE5VTWdnMGNNRTZrWEhBMDduaXlEQjh5RERCZ09aSDA2V0ZpY0lPbENQTHNaUjRNQkp0QTl5cndoQ2w0UndFRmdlZ1VEWFRGV0NwdXZnNFhDWnNMTXRWWmhIS3pta3lFcVN3cEErenJQN2NkOHlxYmVJYWdiTHRSZUxVRTg1K000azVKRUlmSG1pUFg2NHphVXVLUjJ4T3NRa2xWSjBJLzVlSjJ5TzIvNE81RXpWSG5GRXhEQk5DZHNnWlEwUmxvYlh0RGFGTEVYZElLUm5INk95WFVwdnRDaUZ4ZFE0b0FyMXNlZS9mTDFpNWRxbGRMOUJ3OFhWOVkzTjViR3ZjN1pTMWYzN3J6enpzdC9VcXEyU3VWaVBwc1dzdUp3a2g4ZTdaVHExWEs5ZGYvMTN4MTFqMWF1UDErdjF1VGx2YnZ2bm4vNmhULzQ1WCs0ZC9QMVNxVThtd3h2L3VHLzdCMGR0QzgrdDcvOW9GaGI3QjNzMXBjMkpzTnVhKzFNZGZuaTBlN0RsVXNmT3RqYkxwV0tHMmN1M041OWE1cnZoSHQwTzZRdzBqWmRBQTVYT0NudzFlVmduQ215L0Q0R0N3QUYvQ1RIR0xiazNHMnhtVkZuS1pBRW80ZkNuTmpVd2JlTHROMmg1bGZ3c2t6UnFubGhGZkh1dzlUK3NnRnZpRnVtZUJkUlJXZmhJeDUxMWtWVkxySC81Vm1RZ29sNEhLMWdrWS9rRjd3OHhPT0FKSHB5RSsrbHlIRTRYRzZLSnhhT0pnYXhNQWdVdUliWGlDdXVKb3BlaDVZbmlpSXFKaFlwcmlma0JFUndFcDhFcWc3dDUrRTFqMGhrU3ZESlpGNHhrSEdvVjQzMFg0RWM5L1N5TXJSa21DT09LTEFTR1F3SnUwanRPcGpZZ1M2TVVBeFJvS3VwR0lZcCt4a2lPZVNpb0tvM0xUNTRnR1B6SWEyTFRsb293OW5ZSC8rU1dUMGpXeGUwc0FLeVA2NGdCUHpwWTNuejJ0a2YrTWl6UDdPNjNOemVlbmp6elRkYnpkcnVuYmZQUFBIMGJOeGZQbjk1K2V6VmNyMDZHdlFLcFVwbjUrNXc3NTZ1L3ROQmYrbk14Y2JpeHZiTjE1VkFpb3VMV3ZqOFdQYnl4c1VQZnlRMzZaYWFpd3ZMYTJ0UFBuMy85VDhwVnR2eXpQSDIzV0orZHV2YmYzaDAxQmxwY3o4YkhlMDlVc1FNdTBjeVFiMjkrSzNYL21kL1hEUlhrbENXakxlSCtFUTBINjFUYUJKdE9tY0tZaDc0S2hhbFFJa2Z1ZU4zN29oc2h5d0x4ZC9EY2VoN2YrTTN3Q1BNeGFHb2tDM21TOFZjc1RncnFoYW1wTnZ5R2YvaXdiODNvSjBZSC83Z3MzNU9CbDVZNGxBaTJ2bVd0bnJMR2tVdnk4MGZHWUUzQWVqNDkxbFc1cytGeitUaDBvZ2xlOW9SZ2tOOU1iYi9IUVoyS0xXNlRrS09UM2ZDZ1JqakUvOWlKWXoyMVQ0Q0p1MlNlVjNqY1VjNXdFbThwY2pKL3VLZi96bWhOSWxFWXh2TjRneFpvWE9ZQ0NEZ1ZEbTBkUVZRTFRrZ0V5WmlpVE40MGNCQWNsdGloNm5qMG56UXh4ZzAwWUdHcEhQMjZ5bXBUNGNPYUczZ1NQRE1hVlptQjMvKzRvUUVLckJVQ0lPUjZabVVmaDBheWQySSs2QkRRbUZ3a0Y2Yks4Ly8rUy85cDgxNi9lRFIzYTJkZzBaamtkOUVIWTZYVmpkbWs5NDBsMDFIZy95a1gxOVlIbzhHemVVTnNSa1BCNFZTdmIxMnB0SmVHWGFQaThXc2YzVHc2SjJYbXh1WHRtNjh1bmJ4aVVwalllZnVqWWQzM3QrODlvSVduVzRjY3RQaDhwbkx4Vkt4c253MkczZno1Y2FkVjM2enRueCswRGtrUmVYTC9kendOLy9nYi9sTE1jU09wSFBJQ2xTb09UY0g2RFdnVGxJcjN3eU5KUXRONm1kd0trTExJZ0kwZ0ZIUWlSVlhOTzV3b1RSdkNyL0dvU1pSN210RnBIQTNXVkVNOTBvTGpJZjRjNE1lTGpsMTBwRDBpU211SnFHQ1Y1N2ZLR0F5eXlMalI4WVI3T1doaGl1Rm5kYUUzQ1VJbDlxOVVJcU1JUUhEd1U0UGRpSTZLWm9DQ285U3dNUmMrTi9MejAwSHR1NVYvdEl2L0xRalQ2TUpMR0pId3lKaS9LTEFpVFNab2c0WjZOTThPZ0ZRWUtKaWd0aEZSUGFOUXdPNWVNRkgxN2I1SXZaRmpRME1RYzh5aUdlTzdGekFlNDBoSGhkR1QwTWRxdENVK3hETm9ydGZOcWFON2tTQ05nTHlBZWJBcDBwdzNoTHJwZnFyWC9pL2xndmw5OTk3L2ZCNDJHdzAzM3o1ajB1ejhiVm5uczJQanJSUkdZL3owM0h2N05Wblo0Vnk1OUZkQ1NxSFBucnZ0ZlZyVC9lUGovTlpsVis4S1ZmcnpjWGUwV0Y5YVdWOGRLQlJpeXNiQ3l1cmQzN3ZmNWtXU2h2WG5qMjY5MVp2NTM1OTdkS3MzT2gydWdmYnQ5Y3VQajNObDFxTGEwZmRvK04rcnRsYXVMdjMzdHUzL28zU3RyTXlndnFIR3lPWTFPUUwxTjdiQklad2pGbzBEbk9ITzM3bGx6WVlRaEVuWXFKRXA3bUtqRkEyYlF4bktqTWhjT21sVDFNNGN1SE1CMXFaVWhjQnlVVGl0MGg4cnR0NVhhTXRCa3VJNndIenFvKzF3REk1S1k1T09TRisyc3h5RWRUdXduY0VOT2RVQXFtaVVHR3NEK2RwZXg1NlVKSUJybXFaSSt6cGRVN2pDWkdhd3F2QmJ6QjVBamdVdksvUzduWTRmOXJOTHNxM2pNS3orK0Zhb01nak90V2wwQk9neUFKUE12YUZJd2k0WG9qVmhLMFlUeFZCRXNTRU8vZnBhdExsVFJnWVQwRzQ2eGp6NUVROFdYbGNha0o0clN2clkrRmxMVGJjeUk2ZXFNTkpoRmJNRGlaWEtmUHBFczgvWVNIalVPUWhldzRpdVVmbksyZSsvK3pHcFFkM2I3M3lKOTlSYjdWY1dGbmJIQTlHdFZwbDJEbTg5LzZkVXJYVWFEVHYzM3F2V3F0VzJodTl6bTZsMWxxLzhody9CNXBsNzMvcjEvdTc5L1BGOHZhRDJ3dm5ycFN6NHZyMVovZnUzK29lZDNLVjlybFAvT2pPN1hmazh0V3JMeTVmZlBLN2YvQ3Jzb20yRU4zZHJjN2UxdHFGNjlQQjBYQXdYR28xU3RYS285MGJXVW5iakVLeHBHMUdvYUx3S3ZKdjB0aHBaTHFUTHFCTHhnK21TUytsV0E3MkhvbEFCLzlXaGtqVVJsc0UwcENmWitNL0V5anUrUG5MdkV6Qm1za3lMU3ArNU5jQnJZME5QM1FkZTZTTXI2eFIrT2FhT1pjeTlSYUt1VkpKQkFoSVJIdDI1UXc0YUFsb09rbFN5Q1NiRjR4NldUTXNxSFNQUWRIYW9rL0lpRXM4R2w3a1BwRjlBT0ZFUGt4eFJRalE0dW1FdHlnS0dLVTdOa1g1Y2E0d3lldlFUcVl3NFc1TVMxeUhyMlljMnB0bkdzdDdaYXA5VXlGdTNndXBYNTEvL3VkL3dsTkcwTE1JRklVT09iWkJEbXVpRHhZYWE1RXNreWdSbVhqajhpRjZEVUJrQ2NkVEtxME5oelhMZ0R6Tm5TVXAzL3FZRjZ1RmpCOWY5MksvemtyendUSmpGQmJ4cFlTcmlmYWkyRTAyS09pcVJNTHo1Q3dEWWVKT2k4U0NiUTF3Y3hYWFdiVlVITzB5ZWJXeTl0T2YveHVOU3FHOXVsWXFsUzVjdktUaDQwbXVVcStkUFgrK2Y3VFhPVHE4Y08zcGNYZW4wVnJRYk1WeWJmZjIyL2xLWGZ2YzZhUmZYVmp0N0cvbHg5MkZqYXVWTExmOXpyZWFaNjdWR2kzZEtlZTFBZXAxczluazhPNDdpK2V1bFJaWFI0TlJ2ZFY2K09aTEY1Nzd2dTdoOXNyNUsrKzg4MDRwUCtQT2RYRFlYRnIvMTkvNG04UFJ2c0tINkZRNElMQU80aVlBNmNBRGhZZ1ppZStnRjRDWFNiTWE0V3NXV1UxRS9zVmVWajhiY2U1aVk0M3o2TVE4RldyY0pEaVhlenJSTXNROGRUaW1IYzNDZzZTTFhvRlJBTFNRK0JLUGpJbUp4ZEtCenYwR0ZtWmVFam5NNGU4WGFGb1NsRlFGa3R0cUFIS3lZcFUwYnhmalZVWkZ1Q3RPNS9zVGo0S3pkV2RtRHhlR1FDY1cvR3lINXp3bmVGc0dRcDJtQlcwbnhzcnIvSjRjK3djQVoySWwrL0ZrN0xhS2NqYjVPT1ZteGFXL2pFaUVlOS9pRlVJdUgrZmlTZUtRWURVVDFYNm9vaVlzSXJJbmZEQjlrUE5UbDdUKzRDbitzZHdsTHBsZXpwYXdxTzVMcTlhMVFDbXAyTEFYOFpadm0zU2d2N000VGlyNWd1eFlJWXo0WmlMeEJLcGNtSDdvcWY5MXZaUWRIQnk4L2UxdnZmL1dtM3dOcTF6YnVuZTd0Ykk1NkE4azBNTDZlWEdjNXJQcGVDamVzK0Z4NTJoL2RMeGZxbFo3QndlYTQ5d3pIMzkwNy81NFBLcXVuQ3MzbHZaMzkyVEV4dnFGMldpNHVMeStmUFhGeFF0WEI0ZTd4OXNQWC91Vlh4eU5jbzIxODRmYkQ5ZXV2ZWo5MnZGTHYvbXIyc1pvVzM4OFBEallmMmYrZFdIWFpOeFFoQ3pPemFsenVUS29VNzZTcmxTVmRNN1kxbE85V0tlWVZaVHBJNHVUc05XVnE3Z3BEdVJmcjN1ellpTHhLWlVZV3hGYkVkSEw3RnhuMUNVYk1sM0JWeEtHSzlrTHFiSGxrbnN6Ym5ETFhEV2dMeWVENDV0ODBXdkdvSmNLdXFnSEZMSUw0aUVTYjlvNlhjcmxYZzBDY1R5SmxhOFZ4ODBlRVp5eXJjS2VGTTdPbGxzeWRpOXkwYmpBRDV6TnNqeFpuNStUMGNGS0k3WDdNa0tVcDBOaFJIVDZnWGRFcDVzUjVHb081N0NSMGF0ak5ocHhFemFPSTdZb3dxZWFwZzVGUEZzanZqMFVPWnVFRFExSm5hQjNDdWZ3ZFlDc3p3UEVNQUVMY2w2SVlObk9GcFRadUV0akg0aVA0MG1Ga3hrVzlZckhkVVM4VHZZdUh2RjN6QlVidFN4M2Z2UHpUMS81cUxadTNZTjk2ZkdqWC9wcXRWWS9QdGlWRUdWWnJWUjhjUHU5U21PeGQ3ejM4TzFYSmFVR2F6VSsrYkVmWEQrN1djSFZ0YzdPdlVxamZlR0ZIK3p0UGhSVnJiMzU4SS8vNWRHRG01azAxZFRWK3ZIaDl1Qm9mLy8remNXMXMwdm56dmJ1dlhibTZqUGFEbFVYVmdiRDhkV25YcGdVU3IzajQ4UGUrSzBiZjFDdUt0b1ZRQlRMaWZRNmlEWkNtakNTT2xLU0RPcWJEMGV6a01Bc0RFZDhDaXpuWTFuS1BQamV2U2lGTDVSU0FoWlRBcEhJWm1ERXREYzVXYmxZOUVyQTJ0VGVxM2dmcGIxTkdvSUFZbWc1dVFRNHhiTHd2S2tnNGVzeWdqZDRLQlJwaUJCSGVGeUpzMlJrUktDVFA1Q3FGYnVLWmc0QkNsTTJNd3AwN3pjY0RvRW5oZk1vcHVCZFNrRUJyUTBBYTBTVEZnditSZTlVRUVPckFvYW5TdmIxcjM1MnZ1WHdabDFIM0VGNmUrS21JY0pSK1Z6UnlVeGVlWFNCSTFqWm5KRHNGYTlzVkNTVWNya3c2VEFUSlhmUmU2K1NIdGNveHd1akpTUTE5SkprQUE1NnNlS1RHbEtTakJCR2s5YXlrNHF2VHp4bkUxWUtVWk8rY0VSQm1RWWlNZzNJV0Fod0d1czFtM3pxeGYvTlFuTzVrazBiNWVuNTYwOXBLUThIL1hlLys5YVZwNTdaMkZnWkQvcWxTdTNPSzMvWVhqOVRhUzdtaTVWYW82a01VVzF2SGp5NHBjdGVZMldqLytodXJiMmFsYXVUZnJlMnVLYlZNdXdlWm9YWjRzWVY1WkNkKzdkcTFWTHZ6bmNXTHo1VmE2OW50V1ovTUdvdHIrL3Q3UTRPVmZaWHpwdy8yTnRXOUJ6Mng2L2UrRWVqOFlGRVZRRG9PdVlRUVdqVkRsd3JSK0ZhNWdXdUxnVzlTUnh1U1VsYlJlTWQ3YkhETVFMMXlRWWF6bGFjZ2JhYXI0MmVaTTVDdHRNcGJCcGJjUGRwSHBrVWRtRkowOXUyUEpNWFVyMlNuSDhPa2ZEYXNxaUd2Nm1wRFBrWnZ2eUdubDRKRnRxcFdpL1ZjeVdFNUlwT21IcXNkeU5tUlRwSFZ3N2ZsME9uSGxOUTRXRkNYeUFMZ09sTVRXRDV5TDc2bFU4VDN3NWMxcFBqa3JDbVZ1WUdDQ1FFcWxsaGZ0Z3BZbitzSnhZQUg5NGlXUG50eFJqcm5icHJiWVA0YUoySWVYdWZPMXFDbnAwTGk4RkxoU3NBZ1M0TzR4ei9lU0t1V2VIKzhFMXlwaFgyV1VsZVN0ckswcFBReDRFeVBFTkVodlZOSnlLOVpLQjY3ZktMei82Q0JHdzNLOE5CVjc0dGxzdjgwN0pScmw2dnR0c0wwKzcrNGNIKzJzV3J0ZGJpNHZxbDhYaklsWFF5MFZTSDJ3OG12Y1BteXRuWmRGQ1lES2VGNnY2dGx4cXJaeXZOSmVseWNQKzkrdXE1Um51bHQvTitZL1ZDZmZYaXRGQSsycnE3c0haR053TmNqR2V6NWVYbHQxNS9hZjM4eGVGZ3RMYTVNWmlNWHJueFB4VXovL0tEWDdqUW9QSXJrU0R0ckNxMVEwVjk5QVNTYXh6dUZLQ1RiUVBBV1lPREp3WHptYTNhOGRnUkVwbEwwNmtMdExxOUJrd1ZwTUFZMXIyNlZXSzFZRWdka2poV0ZKMlErWm1Qd2cwQjRBK1pKUW5KZWNBSnBZUkVCeC91RmFYQ1ZOdHUxcm1MeVpTLzFhTklGbEtraW1JakdNVWFnQTVaZ1gxendqcGlteE1yeE15REtJWDdxWko5NWFzL29HanpycGx3ZEZpVG0xVnBEVVNXZFJhUGNIU2dLd0NJV3QxSGltd3k0bjFXM1VaRHFVTmR5cVJ3b0pleDhPYytXNWNudjkvcDk0K0VKT2k1VUxCbTJHbnB1dVQ5SEU4ZHlXcHlpUXpGM1k5aDM1QmhFVlVCWUxMQXFJNEx1dG9Bd3BDdTFNWGpDTlk5WC8vT1AvZlVmNUFiNXArNGZ1N2VlNi9mdi9GT3RkbXUxRnZEMFZUV2JqWDRVdDU0ME8xMytGOElGYjZkV3N1TmVrZDdDdFpoTWFzcXozZjNIclRXenV2S054bjJ5bzJGWWE4eksvQjFWYzFWS1d2SFdpbFhhM3VQN2xVcWpmdHZ2bFFxbDBzVmJSS0s3WE5QNkc3M2NHK3JWbS9xWnFYUmJOKzdlN05RcXU1MXR1OXUvN2EyRHhJU0hlVXQxTFJhRGgwVVF6OUp6ODhzV2wzOEZ4MEEwQVZJSzNvVWlhaDdRa1FraTY4WWFxeHdKMTBSbW01NGUyRWNBRGpiVUllTUthS3daNUtPNElJUWQ3QXlHUUJPbzh4RFdLOEZkamR1Q2VrUnVtOGtGa0Z3VzB1c3ExZ0tGd1cwczdwNnViRHpCNDFqSFE3QUdrVWU5RDVlcDhTRVNvZkNIV0lFNHJCa2RNYVNRWXJzNTc3eS9RcDF4M3JLN3RySmtMQUpVRytzSGJXeCtTYjZuZGZ6aER1aDc4VHNkd2tJWDI0eWVBVGt1SGZ1SjZCakxFSHNSTzdWUXR5cnFXWGdmWkdhWHAzb0ZuY2JhQ0xyRU9VeW50YWxMWVFHVHVRNmxKelF3QmgycEJEelIvaGdLdklUOTNXRUJEUnJ5NTgrYythejF5NXYzbmpsVDhwWjd1cUhQdEh2SGQrN2MvdldqWGQxbFZsWldxdzFHcEpsTUJoV0crMTZyVHcrM20rdG50ZUZldi9PMi9YMmFxWGU2T3crWEZoZWxiT0sxVVVGUXBHdGNlMzRZS3RTS2hmcjdYcXJmYkIxKytDOVAxNDVlNjNTYU8wK3VIbDAyRmsrZjcxY3Erdk81ODZiTDlXWDE0NjYvWGF6Y2V2VzdVYTlzZHUvdlh2NEtvSmJMMTJYckxMMzMvYVJQWWUvRU44bEFHaU1rNFpzNEEwSnJUVVQ1b0Jqb055bUJ2QTB4aEpNeEMzQjZ2R3BoMFRNUGwrQTB6ZDRtSGsxQmdkdzZsSTdIYVlSZTRKYlo2VGxMN1pGTGlpRk9uSU9EZHdSNmxrUVhHenVCcGdGSk1QNHMraUNVM3lEVmE4aVBoa280aHNZekVtaEN3eWQ1b2xNcXJPZis5SW5GWTVPNm14RmRLR1BXQ2NYUjB3VHBrU3piNG9GakZYN3JWM3dDbWgvZkY0dmtqM3h6SXQ3VXk3Z0pPOWd5RUx5eHNZRDFWUW5NM0xGMEJCbGR4NmVGaWFPYXQ0UER5dllaQmhYaFNCT3BnSFFoWXlnSjZiSjVBNGJZUnpyZU5FZXBxVWhyUHR6NS81S3M3Szgwc2cxcXNXMWMxY1BEM1lsZzVKenBjSS9jbHBzdDBxVml1OVY4bzFtdFZLcGpJWjlpWmdyMVZyTG04UEpxRnh2REkvMk5IbDFZWldINUZsUkZ5M3Q0UE9qM3VCb2IvL3VtODB6VjZ1VmFtUDVYUDlvZStuaXM5clR2LzNLTjNvSHgxbTFPVGphTHRhYVdiSFNYdC9ZZnUvMVAvNzJHMCsvOE15MzN2aC81L05qUWlEOFFjUlRPMlpvNHl3N3JCaWVEcjA1SzVZU2doOWc5eUJwS2F3aG9SMDNRUnNBSTFNMGNiY3BEQSs3V0RiTzR5d2EyeFp4YUVjVVdoNC9tOUZJQnhyN0NwRWhORU1RREx5bjBjdFNNZG9UQlE1S2UwMU5oaU9LcnQ0aXhqZXdBeWR2YWlYNFdUTTRHQ2VHenRtdzlHKzdFaVJHc3UySGlRNmdkR1lXSTFPd3E0aGNVNm9TSnZ1WkwzK01PQ2I2RlBRYTRIaDFrbFkwKzYwZnAyUSsvUXZHZTNjd1BQTW43b2xYWjNIbGFVMm96SjNDV2ljSkYra2ZudXlVK09hWUl4Mk1ldG5Ec01zZ25Wc0gzNHVFYk42eGtUSWtzZTNPdmh4ekpLWEE0VW1kMlBvUjdrNlZ0cklWTk1waG8vZzhjLzdjWHp5N1hKd09PN1hXMHEzdmZsdkpXRHVXOGJBN0dBNlBENDYwWXlsbG1XNUdKNk54cFZiVlRxUllyUTA2SFdsU3JsU0huVjNacjdtd3BGdjQvS2liMVZyVFFiZmJPUlFUTFlmWmRGUmZQcnYxM3V0WnFWaHJiMDZVK1V1OEFkOXNyNDU2eDczRG5mRjR0TFMya2E4MmxFMlU3UGVPT3JQYTlxUDlsL3lQRytWMDYwaDhVRmxGQjVJS1huZnlzcjcwRU9Mb0swcHBGbkZrYmMwa2pyZ2lPcEJrTzZ5Um1Jb2FIUGNHd3JrTkJhYjFRS2pKSGVxVThianA5QWcxaGRUSlk5VURnRkFlTXdjUlU2K1lWWlVkcEw0UXpVcFFSYVFpUFppTW1GTS80aENoOElDUWpZMEN3REhna0orSHUvQ0tGa0ZhSUdJRmdpYnJSUXhFYUNKNEdHMXBZSW9oQzhydUgxV2s4ZzFuMHJPMkpjUWZuNmVOT0NhTFQveDdFR0xrcE03VUNuUXVCY0t3QUJ5N1dqQVIyZHlPSWlvZnovSytuQ2puRmpTa0o5YWxvV0NOa2hqU2dYVE9zckY1TFp2c2d5L2tORURDT1pCczZIWEN6L2pGZmlKYXlGRWE2NnVsS1NqeWl0eE8zdEsyWjNubGkvWEt1VXRuRnZZUDltKy85aWZEM3ZHWnEwOGZQWHJZN3cyMkh0eTlmUFhxeXNiR3NIYzA2WGNMeXV2ZG8wSzVVaW5YdW5zUGQ5OTdiZlhpTmI3S2xGZmNON0p5cVhlNFcya3Q1NVRZVzJ0N2QyKzBGaFpucGFxMk5wSzV1M1ZiVzV3SGQ5NmZUQ2VWaGxiSFJtRTZXcjV3YlRnZWpiZnZka2JUY3FXcGZjNnRSNi8xUjkvdEQ3Y2xaQW1CSlR5SlZ0cmhMbFFoVFBTU21VSWZIOWdHYWx3b2hhVmFFVmRySElrWUxNU0VMMmRaa3gyRkE5MUxCZU41b1lReCtad09LVnhUZXlEV1pzbjU4R3dhaFpXZE45Um5Ta00rZU1FY0J6Z1FpUkpnc3hlaEdvbTVaeUdVZzQ4OHJxWkhSRnVLaW9zb0lYVndXbkV4Q01jVGJZU0hWNFJHMlVpQ1JFVm9zQy9RTUljWUJHbVFTSkJSQUZFdnBCVDU0cGRmZENhTzNVdUV2T0tWdUNjRXZYWHhoOXFVdjUyTXRlRTV5ZlJFc1hZa2hMdVllZFBDbkRyaUNpQ2VTR3FreVNTZkp2SGlRV2lOc293RXVrekFyWXpkeHRzUU9FZzdCcVFWSkFYc0FWbys4QUFPd0NqejNBU2NJQTBseFRFSXk1WlcxdjY5QzZ2Tjd0Rk9aMi9uM2U5OGMvUGFjNjMyVXF2ZEdzM3kvY0dndGJUY2F0UkxwZUxnY0svWVduNTQ0L1Z5cVZScHRiZ1JLR1dsZW1NODZIZDM3NWZLaFZLcEpxRTZCM3ZUL3FIMkVidnZ2ZHhjdjZqSTF5U3pmTEc1ZnY3K1M3OXgrV00vK3Nadi9OUGF5cG5HZ25iejc3WFhMeDMzTzUzZHJWR2hMcFZmZWUvWERvNy82TGgzMTRHRnF4RVc0UWtYTmlTUzJndGZSbElQWkN4YmJ6d2lsdGdGMklRYXBkSGhYR0pEQnpFamhGMk9qMjBpMGNzL3BpZVV5ZjJDbUloSXhpa09mQUxPZUlIQVpjMHNpQ0dRdXNmZklkU1Vvdk1NTUlyQ09ZMFdNMHZuMFlSWk9saHNBU1lnU2t6QzZLQlZWRGlLM1NXRVlrUmNVeXpER08xUVNCMzBPTUxnRjEzMG1vc3JoQkNJbUZMd3A3LzhZUjdVOC9DSGZVcmNVSktESTRpSmV6RlY0UEk1QktZZytvWFM3anhtaVZWQlVkdnBLVzVreWVJaElxSGdrRWNsNnJsU3pLcHJrSzRlOXBJRmsxZzhrTUhBRkJzVDU4OGRpejBWN0hhTWZlWllWNGsweVRXWWpBSUJDQ0luWDYrL3NOVDZXSzNZSzJlbFYzL25WNXJMNXo3MHFVL1BSdDI3dDI4L2V2aG8rOUhPWW51NVZxK1Zpc1d0Tys4ZjdUeVV1QnErMEY1bWd6NGVpbVZSK2J0WW1QV1BTbzEyc2R3b2xncVQvbjYxdVR3Yzh6M0RhbXVsZDN5UXowb1NlemdhVnFxMXhzYWxkMS85azhXbHBhUDkzY2xvdEhMdStzSHVWcTVjeTRyWmErLytZcGJySVdib0VzN0dmbzQyMndBOXcwdU9OQ2xKK0JHVzJnd0t3ZFhSd1Jrc0dPTDQ5SzJueklUZEdYaGlMOWhoU21hSXpRcFdDK3R5Z2dhQmpOQW9IbWZaZElJdEY1ODJReHl2TXBLUzZiejhJTkdsRFJUZU00YVZxU1lqMUdCR2djSEFHR1JrWmhmaEJRV3RsWXlCRVVrRWtGQkVrQ1NRU0ZvTEhtV1R3WklLNjhVNHNPQnROL2ZHaXo0Qi9yTHplRlp3Q21jdnJvMktIeGY2cnBSbjVQNnhGOTdVelk5eXVVSGVHRFl3dm1ITjhkOGJGZG02WVIycFM0bS9RTzVYbDNZcHVnNk04N3oxNVNhZUlvdGJKVDkrNFFOTXM2TFNoY3dtaytBREVnTnZNT29PS1dVaGJwVGlmV3dRZkVhQTl4VDlKbm5HejJ3TEYwOWpYQVRJZnJQME1CdWZGdk96ZHZzejdWYng4TER6Nk9HOXhjc3ZmT1J6UHlrK2Uvc0g0MXcyMUI0cUt4OEtIZzhuazBtNTNpeVY2NjJOUzVWV2V6anNIKzl1S1FXTXh4TXhyaTZ1MTg1K1NHRTBubzZHM2VPc3RpZ25MWis1MU5tNVA1a01KWHR1TXV6dlBjemFGKys5Ky9ycXVjdXRScmxhcTgzS3RWdHZ2NUlialRhdVBWK3IxTHZqQjZVaWwzSVhOaG8rNUJmMHMrZVEzKzZFQUNYWWkrRTVDR3duSlh2MUpacmtZOXdjWkFTRTkyKytDSmliLzJkV2NOUEp3NkNsQU1XQkhJNUs0U0tLQkVXVGc2MnhlOVZJa0tuc1RkS2tUdlI0d3dtQVQyR3JBNkVnRmdrTHdzWExEMG90SHgreHpCTm5RZENUSjVVVHRlRXdIMWc1Zy9LblRoS3RzbkxLdGlydWR3bWVIc0lGVTZEN3NwLyt5alBhZGZnSnVuQzhQY3ZERXpZdGJHbUllMjFMR0trcHFjbjl1SWlGcDRseEYweXRBS2FXYU1yeG1pZzlUR1JXVmN6S1hvWDNGSmpJZHh0OG9raEdZYUJlNnVXTkRQblUyU0FwemtocEppQzhKVExoMkhjNk1rVHBSeE1RT1JRRU96bHBYaVVrRVZSS0Z5clZIK3Z1N2F3c3QzdmQ3alBQZjZUWnJDbVVhN1g2OXM1K3VicVFsYXBMU3d1dDlySnVOeDdkK3U2VWFDdzJ0TGxwdFBMRm9yWXhXYVZXcWxSN0IxdWovdEcwVUJ4M2ovajBSRllscnplV2EwdG50OTk5ZVdGdHMxUnBJUEYwK04xdi9PSFpKNThyVm1yNXlYRDV6Slh0M2QzVzBycHkvNTJ0VjIvYy9aWHhwSXZTb2tSVWpVRElGRmhTRnA5aHRmQThrZWNMdTJDeW01QkVEdTRUa3FCUU03akF4dm1ZTW1kdWdGR3luSzFCb1MyeVdGMFlVQkFtcG9jdUNEUTQyRkJBY3puNTNnTEdGMjBzcjRaU2gzbnpjaEFBSUNkVnhBTkk0aFVxS1lGdy9CQ2hGVFdDeW44RXVvWVJQUUU1K0pnTjBZeWd3UUZzK1dLUUtNRFA5UlZ6YmhIb0wyUS85ZVduRk5icGw2QUlZb1c0Qm5IbnlqSmdvOEoyUmFNeVpYR2FOcWtBRnFzdDdrbXNIWWR2USswYUtNRWpCN05aeWhUSE91QmptQnZrRXJMNDZtaS9hYmhPTXFIR2k0YmdjQUxVU1J6VWJRZjZRSVR3clcyWUpwaVY3QUJOV2E3L1VKYWRhNVlMMTU2ODNEM3VMTFpiazhHeDlGSVdyOVRxTXo0Q25WdGNiSXBSNytpd2QzaDh2TDlUYTlSMHcxMnUxNVdmang3ZHpVcDhsS0NrUU8vdEY3VjNuK1dHM2IzcXdpcGJ1ZnlzMyt0azFZVmVaN3U1dkttWXJqYWF1WExsK09EUjB2cUZvNGUzeW90ckI3dTduZVB1VVhmdjVUZi9GdS9JSXBhWExhWWtsT2RlSTNXUVBXaXA1anFIQ2FVZ0toRVRVRWJUenJNdHhFZGRzaDJ4WUd2Wko4R1dYdFcyRVViU3hUeWFnYWFZRjhJRXhya0RLOElOczlLd1RVbVQ1bXM2VVNJUTBzb0ZacVBpdVpHQkdVRkY5QVg4ZUJLUmlUdWtKN3ZjNkxJV3BuQVI0T1FORll5SU5FYTVOa0VRUndDaVdveU9vamtoZ1FieEtRcjM2OXhXOGtBd2JrbTVPckJYOFRSTzBuQlNVNGtaYVR5YmxaUCtOb2daaDJHWWpCZ05RWHhJVlZZWHdSY1lVanpncVh6aHl6UEdNOFlzYlRBUUlvdWNyVDZ2SXZJUmJXN2ZZR0tVUXgvSUltVDgveWUwbHk3dHhTK1ArN2xhZVZxUmY4YkRiTklwVmF2RHdlU3djelRvandianlmTHkwa0F4dTdkM3RMZGZMRmZiRzJmNUlQaDAwRnhlbVJYS3ZZUGQ2YWhYVzFqVkhpZFhLQTQ3aDZYR0lwdXBrdEozUy9mbXVrcnN2dmZxYk5UTHF0VjhzVHJ0ZDViT1hkRytwcjE2N3ZEQk8rWEc4dkx5U21lOC8vcDMvM1prR1FtZTdLQTJkc0p5TXF0REo5eGo4NEczTVd3L1FERHFpaXN6aWhJeU1WQ3dLS1V4eVNZU3VTS0VzU1lraVBFY2VZTXVZZVhhNUVhMVBabklGTkErbTUrTTc0bUVGakZwQlhmTTl6dndDR1k2T3gwaERkNlNKSVFmc2dpblhnMkVObEtpcDFSbklOa2cyTG5CaDRxeEJMY1NnUm9LUXR3ZVNJRmNob0paaEw0S2laYzlnMW9uZkJBcHpqVGp4UUFGRFB0MVAyYmhrU0o3R0cvS0ZmbzZ2UGcwcDIzbG9vSDJneVMyWGs3ODVxaW03S0d0Z0wvUDYwK29zVE5qRTZPdVNhNHd6aFdtY2dYK29pdGt3VDVZR1JQR1FjTzkyRVJBUklkVTBjU3NDMjc4STdoTnpTV0JPWmhUYmRhR0xoVWFJUkhFWmJGWVdidjkzbnNycTZ0aXRiU3k5T2orKzZWeXRkbGVxamRibzJsdWNXRkIrRktwMk9zY0hSeDFabGxaakpaV2wydUw3ZUhSL25SNFZGOWNFWi9oOGI0c3pGNS9lRHlkakxUWE9kaDUxTmwvZE56aForQlhuM3l4dFhsMU91aVd0UGZMaXJQSlpOUTdIbzBHQndlSHBWcTkxejN1ZGgrT3BuM2M1Y2dRUTBVZWwvNUlERmcwdmh0OXFobTkyc2xBRTNBaWs4R2lsNjg2ellyK3JIY2hQOVZPc0VRS1pqK2FUYjFQWktCdWZBaWRPQ2p5RDFQYjVtb1NjV2xTNlBHTm1pQUQ1cDlTd29jQlJJTkd5YXlZUGpsSnRrNmhSNEtCcGZYMEZRYy9xQzhSbUVXY0RHaEdWb2dMNDhUZHhiME9UaDBXejZIa0QrdElKSUpTU0M2TVNqZXFQUXdHTHFLUmZXSXFrclZRQWdrcjE5cWo2eFp6N0Z0VmQ3UDlSbVgxSTdlRTh2N0tDbWdBYjMvcVVOeHBaYUd5dWpnVXVGeWNsWFJ4Z2dNNnJ0bjJqNzJFZlZnZUtJT3VzRmJ0VDZ2YWZtcktwVFpqbURQTUd0bWRPMUovQXR5U3FWYS9aMkNJS29tT2FMTEZGR0hWbmRYcUg5ZGl2ZnprVTdwQmJMUmE5MjY4ZS9tcEY4Tkd3NEgyTStWYXZiRy9mekFhVC9LVFViNTdwS3RCWHFTNVFyVzVwTnZ6M3VHQjdyL3JTK3VEL25IditHRFU2Kys4LzQ1dTNDWFNaRHpvUExwVnJaUjJ0dTVMa3Vsa1hHK2ZPVDdjSzFhcTBxOWFxZWQxVGFrczlnLzNTdldsZzg1OVpKUlVoSyt0aUtpc1R3RzgxNFNsNWNWd2xRM016K3VHT3Z4bWdOY0pkaEdCeE12TC9KRlY3QXJvbFVzMFJFSHZaaERJRmFKUnlHSVFacmNiSGNveHltR2tpUXN6L3VPVE1FazJQbllsRi9tUXJXUnJjcWdvL1FkU0VjSW1RTkVpVm1hSlZ3Z3N6eVNjK1dpb3ZhbGliNG9NZmg0WkllWnV4aEhndW5FazlEbXdoNmxKdXVxRUJyenl2UVh6MUpLZkhvZWVKeWNXekROWnorcUU2TEpPWHB1Wks1b0FkUkpIVFk2V0lhUVFIazJYQ2dHb0ppRUdEMUZhWHRHakloT3E2ZnJrbUN2SmNIZUMwUUNDTVpDbTBleWVFUlRVd2hrOVIra0ZZNTExd0pOZUZ3RFkwdVZ1Z2VZc3BEWWpIMjAyTDhwRzlmSjBzVjVkWEZsU1hDNjBsd3ZGNG1Tc0tDcnVIM1FxNVVLbFhLcFVxc1ZpcnJmenNMV3lVbTIwL0ptNXNSaG8zMTVyTkNhVDJmSCtsbFQyeDhJemJWb0d2VzZ1dDl0Y09Wc3BWM1lmM010UHgxbXhXR3V2N1czZnIxUWI5ZmJxZU5EdERYUEhCN3NMNitmLzVLVmZaRGtpbFZYd0pWOUE4cU5nMVhKbFVrTWRXUXA5Wi9SWTM2Unc0dFUxeE1BZWl5bklqTGpGSGt4REhBcEN4eFVVakJpS0U1TkN3S1QwQnhsQWdrOGZzS1RZMnhnYUhVNks1MVZSRjJnZmNDRDVoVmgycGZzRThsSy94cUFCN1JUVDFBRkZVWWZmbm5kUld5OE1RaUhNeFU4ckUvN01aYlNZRVpneEZUTlN1QlNvSWF6TUpSN1pGNzU4R1pnb0ZGbGtkM2ltVlNOK0Vmckl6REtBajRoRE9aM01tK2lmOFI2dnNZNUV4cHJVTHFMdHlpZ050S0JjOG5ndW84SEJoOEdjemMrUUoxWWRKY1NVVGlDRjlqNlZmZzhHbjJCb1phZHBhK21ueXZuSysrKzk5OVF6VjZybFVtNDZhVFRxeDkzZTRWR25QeGdlSEhhR3ZTN3Y5ODkwZTFsc05adlZhbkV5SEJ3ZjZwNzFRSzRTZ0Y2VlNyRmNHWFQyYzFtbHViUStHbzZyQyszalJ3OXV2ZmxTbzczYVdqdXIrTy9zM05XZVhyWjc5NVZ2Rnd1WjFzZ2tYOWc0ZC9HdDc3eFVhN2R1M2Z3MzdMaDBVWkJrODhnUWdJaWhNbGNrTmJPQ1B6cGtESmNwYVlMTzRRMHBGUTRKbGUxbVhWK3hTYks5T0Fpd0VSS2NmQ2pqazQ4NXVRbFhSbE1SU1dGdEhLK1NPczB3QUlJbW1va0d2Q0NlWGN4eGduQXhIa1lBMXd3SVowa3FQK2Z3U1B3TE40M2cwUWlDR1cwK3JIUEh1STQ1UmxOZ0t4R3B3c3ZneFFHMnFzQVJ6dWp1S0xFMVlCblc4QjBBbkhTcitwVXJrRkJnNE5IMFJaT2hwZ3hZaDVLOVR1Nk5TRVFJbW1pZ29xYi9UZzc3VmxkaU13RVI0eG50dHFRUkpBS3BRTGRSME16cDR6QW1STE94YU5tNDJEZndwb2o1TEZZeE8xTXNmdDlnME90czNYdmhvOC9rWnhQdVFVc1ZaZWl4dHJlbDZ1SCs0YkEvS1BJWjRWeXRxQTNSck5aYXJOVnFuYTI3ajk1L1U5dVZZbTJoWEs3cTFsYWQ0MkdmZUN6ckJyWGQ3K3pXbXUzRGgvZTFnOCtYS3N1YkY3VGJrY1diUzJ2NTZiQlpLdzVHVTkzSkRvYkQ5dXBhcDd0ejk5NTNiTm0wakpPa2NyV0ZSMVk3SFFCbFJVU1lZbnNET0pwaDVIWEJYZ2JpbEpweEVZQ25nOEFjcUxHSk1CQm9qeHNFL0xjeERkVDJRS2Q1cjdxZ1ZqUFoyYUYyY3BoQWVPS05IWVNGQVo5V1VRd2huWXZVTUR1aUlKTXNBc3pZVWdVeHJ5RFdpbUZYQTJVVWNaWXN2TXNKZi9CZy9JYzB1RmRubUtYaUp0SG5CaDBSNGlmQ3hDbm16V2MvODVVckRJVkY0R2dwWkZoZ3JDUFFjK1lSU1JnYjlnUWFmVjRBK00xRHpRSUZOUS9rTVJnSjR1d0RrclFRWUtJUytpWmkxMXg5RVYyczZUUUJnZTUrQ0NSZFNBQW1zaHFHZHR0WDgxTDFVMW4xMHM3OWU2dXI2K3RyQ3R5czNtaHFXM0owZktUaCszdUhFejhvOWtmYkpwV3lkdDBWZjdwejBscGVMNVZyVXg2MjFIUDg2OWlpTmpTbFdtTTRtZldPOXJXM3FWVHFoV0twMFY1YXUzanQ4TjZOdzhQOXRYTlh0TDBaVGNmTFo2NGVQTHk1ZHVGSlNUSHBIalFYbDdlM0h6eDg4RWZXUldtR2lDZVJxOWZiVnk2b2tkRjE4QVBvQW1KN2JSVzE4d2FXcWJpREZHdzE0d0N2STdtYjNhaGdoWU9ZRzhsYkk5SlBQSFVRS3dFUVNTUm1iS285UFo0V3NiaXBNazgxYWFRbWgxNk9RTWNRRHk3b2dvL0ZrUHgwd2NYejJuVU9XTDg5ZzhadzlTd2lKMkF0Z2lnWlJJdTJ4QlpUQmxLOGtmRkxGWFFwNXJoQ2dESzNpQXo0YUFLdmVSa3FCS1lYRVIwaVVGcWc3T2UrZWpYQ1J3ZTBUSTNxZ2JTa05FNXFEQThkaFdERWpUQVVTelU5RGxwZWlNZWZDTGlhSUJxa25FR2pmSnpNZ0xsZzRBTlJyYU1IdWZKVUJ2UmloQlhIV0xheThYUE5kZkI0b3Y2WllubnBhUDlvYWJsMVpuV2hYcS80VythVFZyTXRvUlRyNDlHazF6MCtPdGdkOXJ1VDBURGp5andyWllWS285VmNYbC9jdk5qYjIvRXpvSUp1cHFlejZmSGUzc1BYZjcrNXNxYXg1ZnBpdjlldFZTc3JGNStxbFlyZHp1N0M2dG5wYUNESDF4ckxvMkczVWw4Y1RjYWxhbTA4bWIzOTdtK3ptWkZnMk13eFRaSHdNaEpyMVJqRXRqbWpQcmtUdGVvMkQzZVRVblJPSEJ3Y2M5S2RVWFFSQkdIVXhEQUl6Q3BzQ2pzRmxuclpRYk1JSFJkbTZDR1lGeFJ1RUZKRDFPRDdvUk00dXpXL1VJZ21wa004OWpPKzY2Q3BnbDhna0wrWWxOdEFKQWlzcG9Cek1GY05CN3lwdUp5dnFLRDFMQ3JJUDUrTGdjazRNZGFiSENTMzRtZ1hnakVXVnJLcUJtVS8rNVhMREhBQXFWUG1oQVltak1sVTBRazJ2blhoTzFlSVhYdHFkOGNwVFlrc25FbkE1QVVUZUQ2TnRoQnBTTlRXUXJLYm9aQnpZZVpINHFVNkVKNFpKSktmMXBtQ2V1cEZ3OG9QS0Q3SzFmcGlQYmUrMnZKdnFaU2J6ZFprTmh1T1JvUEJVS0V2Q2ZkM2QvY2UzQzNWRzhyakUvNFhUVlhydVZodEZNdTEwVFIzNitVL0xGWHI1WEtweEdmZ1M3cUwxUzZsV2x1WVRFYmowZkRnNFkzeGVMU3d1amtkalk3MnR1cnRsZnhrTWhnT1JLNVkwalZCSVRJWWpkNSs1M2Y4ZlR3WlRlcno0UUhlTThCV2ZIYyt4Q1plZzhRNjhnUlFxZ0h6L0VIbXdZWHlKa2lhNnNWcTltNGdkV2kzWlF0aWxvalVjUHlKaVdoQ0NTTXdNWGxrNENuQ1lUeHZXcURCV1dGbFZYeTVuMUdNNGZvRHJaY3I3MUtDTmVlMGROMFVEU0lpcEJERWdVYmJQVll0QURaeWVOZGQ0a2cvckMwWjNIemhRalU4cms1TUFYTzBFTjRhQlRFRXNMSkJJb0E5ZFhxQW84dDQ5ck5mdlFxcFVLSjBFS3RoQm9MRkdKZklERklVeGJqMXhUWjJEQ1dDMERPVEdxMEwwM0l5RXh1UWZzUkZONHVuSHV0dFUxb2lScWdnSG53ZDlTWlJFK3JISkdERURiWTJEVGExdjBYRndRUkc1VXNmS1diVlVqNjN2SkN0ckN4VnFyVjZyVEhXTnJaUTdIU091cDNqUnFQV1hscFlYVjhUK2ZIUllVVWJtcUpXUjRWSG51V1N6RHdaOUthai9teVMxNWFkbjhjb1ZZcVZ5bGdiLzBLKzFsanM5YnA3dDIvczMzbWoybHFxTEt6bnMyem4xdHZONWJWOG9YUzBjNysrc0RTYmpMVnN5cFhLNjkvNVZlL0R3aDhDc0tCdTB5V3EzYU9YREM5N2s4N3RhV2NOL01xQjEyMUQ4TnI1WUdrZHVCQjZOeDBxMkdadUtOZGhITGNmRjVFSWk2blVwYzR3TUZqUm4zN3E5NWc0T0R0MmZRUTFjUUZ0Rk9kN0JvR2s2UzdCbGtReDdZdUlNU0pMQXNmSFlRQzl1Mkt2SWpnR0FzLzVFL0dhbGdpMnRHR05FTWFZU0JPRWpycTRhakdLNVFvSGdoZE1JZnZacjEzRjBnaEZ4SXN0cm1DY2VWQ1pkd3ludzNSV0tMQlFjT0k3SFpvYm1BSWdGWHk1dE5BMms1U2tqYTdHZUM3NU1Ld0VMeXlTYW85UWd4SFcwRWhXcm5VRUdZUXFxYWtyb1JLbnB0VjJvOXo2b2NsNHFDdlVhcnZlcUplYnJWYVE5dnE5ZTNmdWlFYnhyVENlVGNmMVdrVkxZVEljakVkZFBvWTJuWlpMWmUwbWlMZmN0TG02V2FxVk1ZdFdlMWJXZllFdURaUHBxRlNxVlJ2VmZIMXAvOEZ0M1FGWFc4dVR5ZlJvOTJHOTNhNHVyQlVtZlpHSmg2NFM5KzdkN0hlM2RNMlFIK0x0U2Z3aWNjTTNNbWc4UkhkSmdlS2J5K1I0SFZMYVZ2QTNaTlRGbnA3ZVdZYnBOR1RLZStNMnJVMkpxYWtjRU9xYzIwbkZ4b2RNeUhUbE5ZejFrTW1OaEllTVdST1ZoaVlFd29SSXBIWlBqYkZFR2JHVkpFZVM4RHNZQUUyQUN2WWdTR1BTSjYxQ0hOaElmY2NkRGhabnBXZUdFQVNFcW9lWU04R0RRUWlreUJlRUp3SWdIaHlFaEkwdG04Kys5TFhyV1JyRFREeENvVnNORXp5R0xJZDRhQjQwamk1Qm1oYXhKTGVXU3JCT3J6UWwvT1FrblRCVjhJRmV0RHBBcWFFVHhoTVRTMkkrN29nemVtcVVtZ3dITXRMKzFqaVFKTGxjb2NnVGE0bW82WXJUMG5OWnVkNW8xSnVWd3NweW0wOGR6SEtENGZEaC9RZWR6bkZkMnhLZXhtaWdrdmp4VW51eFhDMVg5RmV1akllampKODB6d2FEUVUyYm5FcXRmN2czblkyN25VNjEyUndOaCtTZE1mbEs4aHc4dkRzNjd1YXljckZhN3gxc0xheHNLUGxuNWRLazM2ODAyNU5CcDFTcFhidjJzVTR2ZDdEN0h1KzhPYXlsQko3RFQ4bER0cFVVbDBCRXN3OXBwTnF1UVVlL3JjaE9ZeDRvT3B4UVNZck84ZG83ZWVPclA4d0xCWGt4YkJhUVpyWEYxR1dQZ1JJcDFDcno1dHpJY3ovZ0tUYzFNc0VzeTBSUHRFRWE5OXdKR1RmWnZ1MUdXcnFNY1doNjlXcUkzQ3BBa1dJTURCMWZCRzY0bFZFV21CMWR4TEU5am53SUNYL2V3TFRBdW1RYXdJQXhDNnVDR2JFekJ2emExNTlFVm1jdWgxUnN6Z1Y3YnFIeEJPSnIxaERIMHdpSHlpcFlUaEpERW9qY0JOMzBKOUlrYTl3WGM1aFcwczR2Tjl5SXM2bFRYMXB5NWlUVlVSeHR3NmllUVdlYVZrQ05NQkJOSm9NbldqbWtwT2RzbkwvZVhqOVhMbWZGZkc1cHFhR082V1M4KzJqcjVzMmIrWHk1MW13b3Uwc2xLVHdaODM4RldzMW1vY2dQQ05RWFdtTituQ0ZYclZXbjQxR21qWGcrUCtyM1J0MU83M0N2TUJsbGhheTZ1TlEvN3ZEcGc5NXdZYUZlcnZQT1ZHOTM2K0RoKzdwSnFOUVhlcDJEd214WXJMZG40MzZ4MHJ4dzRhbEp2cjc5OEhWc1c5Q2NITWlKNDdDR21yaFoxa1lwZXkyRmlKVEhobEhqdHBURitTVXVLWS9SNWxzQ2RZU1pvTWRteEQ4RWRHQll3Z3NvK3NYVGZ5NUdxVkNMQ0FCTXVKbzJQb3h4NXBUNGlWWXJqVlVuYVhsdjNkNVVQbGFIbzVOVlpWYWtYaVpGQ3dMeGhBRFZIdVBOVTRjSWxEakN1UXBMU3g0em1zWnh3YnMyeklBVi9UUmJUZE93VDhHdVlVenpWQ0c3UHdFbDFvV0lEV1Z3eENzUXphZlhHT1l6SlJXMVdRaEdEdUpZY2dzVXBkRE1GN2NJUGtETnI1V0J3WFpVTUVrbFdPZ1BoMklBY0NHQVRxcURJWU94SFh3OEFtazFMNytHd3V4KzUzeVdxeTkrYWpJdGFJdlNLTTBXR2hXR1RTZEs3YnBKclpSckNuMmxld1c2VW55djI1Mk94N1ZHUXlvUFI4TlN0VG9aalpUb3RSSkZOaGowOG5sdDNiVXhHZk8vc0VlalVxV2lPMVZ0VFhhMjdoVXJqWGUrOWJ1U2JLRzkwams2YXF5Y3lXZTE4YUN6c0hxMjN6c3VGUXVqNFhnMjFaNnF0TGwrK2VDbzN6bDgzeCtYUmFsSTZnNTl2T1hIR2hLVHVNZEtYSzlpRFd1bHNyMXhTTEZaeHhpUjVwTlRJaVpPVlZIYjJ0N2RpUzltUzlrZmtPNUVBcFBrQ3RzYzJua1haeE1IUzFDT2VRenVlQlZXL0duaUswaHdoMmlTRmlhTHQzVWx2OThScysrZ0RHN2tWaTkxTmZHcGE1SGhYSFovVWhrSEM4bEZMeG1Fd2E0ZDRqcEY4WXc2T2ZTaEpLbEQ2YldVZmVXcnp5VENmRmJrOTJMRkhXbkVsTmhLZkNWQ2NFTG9qS1NDY2NJSUJ1UU1WbkVLUHBHcmoyeWtQbTVSNklnd0ZSLzh4TkRZRFNSVGl0cVNrbzBlVXlJb0JvbmgxUEFOZTZtRkdieW1aWVg1UWxXTmtMbDhOVmY5ZUZFN2tPTk9mdHB0MWFyYWxJL0hvL3QzN3pkYWk2MW1vOTF1OGZabmhTK2g2dDYwM1c1bkpjVzNwaFE3UHNLaitOYTJmdFFmRERvZDJhSlVxc2dsL1Y1ZndsZXJ6ZDU0OVBMTHI3ejN5amUzM242MXNiU1NHMDExZHp2UnpXbG51N0cwMWxvOU4reDNXdTIxWWIrcnpVei91RmZnQjNiTCs0Y0hPdzllNVRzbm5pV3VwZFlEcjVCdlpCUDFzVnYxTmtDNllFOUhFaDVRd1Fia0pWVXdrWW5VR2NhaE0vRFkwL1JZbGJ5SmhmR0xrVnBQWVhXNVRkem1zRWlBc1RqdFNlRFVTS005QlI0Z2VvUWhESTNEaENLR2tKazR5TzZhQytGRm1YbmJwTGJGUVFhYkdVb0h1dkNPYVh2Y1RQd2d5SmRlNWhlQndwS3h5VXJlL29sWVo1SEJVa2hBcnlzdW00cFRMQnVkRmtrVFpWLzkrck1lb0tEaE0zUU9OZWFEeGdWeFBZRVhLMm96RmgyOEVVSC9wQ1NHQUJiUlhIa1Q2dVZhVGVFOVROMGVEV2YxZW80d3BHL09wU2Y0UUhxZHBCWWNMQ1QyWWt0QXdpT3BxN2JWZkJEeGhWemxvSHUrd20rbXpJYkhSOVZxUVJ1UG82UEQzZTJEMWMyekNxcHlxVEFhRGJSM1lmZVRaZHJGS05QbnBoTTErTURNVkxrL3I4VE9EN255RTdHajBXUWtNY2FEM29qMFgrbnVQaW9jM0Q2OGZlUHc4S2lZbXl5c0x0Y2FpNisrOUsyYnIzeDdjWG0xUDg1UDl1OVZXczNxd3VyZTdlK0taYVd4cUpqZTNMaVl6N1czSDcyTEtiRXhLbkRnWnZrSnJIMGNzUzdaT2RBWGQxanJjQkFJTmFGUGZYQnhsN1ovRGlWeEZBNjc0eE03eXBSaDdtVHM2RTVJVUhHWkFMWUFtbHIrZ0l3R3BJNXAzRUNZc3RYVUZLeFZpNkNpQ28wa2cwTFc0K3dtSTAxR1pDTWFBNWpDVFk2cGFyVlNuS2ptVWF6TklnN3FDYldjdGhYVmpJNTdIa0hLVG1wRStpQ1k0WUFaR0JXVUFJcVlyMzcxT1RhN3RudW0rd1BtVXg5VFFpeHAvWGtNek1GdkNxZ1NRS0NTaHEyZTI5R3JBUmdvT3ZoV051eUNpMU8vTFRmVjlReEdta0pGM2RiUGJOQlY1dlI2Y0U5d1VvRXQ1bVpaNmhCUGIzeXR2RVpyZXdDU3pVeXlUbTVXTGphZXFaU0x0VksxZDdTLzBLZ1ZTNFhkN2IyRjVjMWF2YXd0Q3Q5STByWjZNS3JXZUxhb0VjTkJYMjRhS24rUGg3UFJZTVQvNXlpTWU4ZVQ4VkQzd0xxaEh4d2ZqZ2Y5d2RIMjhlRmU3LzdOaGRXVk04OTk2c0s1dFhQWG4rZVhlWExUNWVXbFVxVzkrLzUzVjFaWEZ0WXU5TzY5WG0wdURPNi9OaXZXZFdFcGxzdXk4NnB1SjJyclcvZThpWmNLY1MwbElIQ3d2S2JJQUMrY2ZTazBpUTNkY2FDTm9TNktRTm5IZU5QRGdoMm9PckE1RlBSREFzTDBZWGFsMHFBaFg4QW8yZG9uTWhHZ1lGa3pFZzNEK1NremlGV0RVU2YyOTFhRVdQUkVOajQ3ZU1PNHhvUFpaRW92d210T25KUmlCc2lDajJoUnhIeGkwK0kxQStCMDVrMmd2QjJtc3owMHdON1hvV0ZhQU1TNm1zNGFNWmR1dmJRZTJDdG1YL3ZhODBJcHhHTWxTUWd4d2xTU2c5MklwS1YydE5tNnRoU0FRMUFTcTVhTnVGK0JQcEJRQUxOWmlUdFg5aTFoT1FXOXd0NGYyNUJXS29uYXJBVG9uUGg3YXFiUWdXeW9sSFQyK2dRVFdqa0NDSFRNcEZXdVpGKzdNcXRjYlZaejlkSzBjN1RiYUZRMXR0NVlYRjVlckpaTDNlT2o3dkZ4b1ZqdWRJNnJsZkpFQVQ0WWFSYkZlbTR5MUNaR1dYL1U2dys3aDRYY1JQZXpXZzNIQjd2YXdOZXI5V3F0VWFtMVNyV2FibS8zYjcrZEh3OXZQanJvOTdxLy9rOS9lYmMzS1JRTDVlRisrOHlGNGFpL2RQNjZBcjNRV0NtV2k5czMzNm1VSnFWcVl6WWREU2F6T3pmL3hBa1FYUWhMOURJQ3k3dU55dmpQaVI4SHBqZ0ltdFJydjV1ZXltN0RHbTVpVWdHeWQvUzRtVkM0eGYyWTJTTUR0TzNWUTE0eUdEM1NQMEQ0eHN3Umk0NG5CaG1KWDZRUmZpSGc3Q3dTRUFtTnJoZ2RKWVIwR3Nack5nSVk4N1FyUGIyWTQ5KzRkT3N5THIvYjJRNEJ0T1dzUCtPRTRVQVFNekVOc0VuSmlkblh2djVSWWIzeDlhSkVTZGRrNzdrZEhJaitpUm51bVRRSnRxSnBXOHFJV05UaXBRSlMzU0tZaUJRS2IrNFpCamVGdmx1bWhBT3dNSWh2WW1SVmxnZmpUVG0yMDc1RXdTRnQyRmVqaG5iY1dBRnpLSzlyczZ2ZHNBQjVRa1laWjFmMk81TnMwajEvWm1WOWZYTnBkVzF2NzdDbEhmcGlvMWJqamFTbHhVV0owVG5xUEhxNHRiNnhjWGg0T05HdDVlR0JZbDFHSGZUN1N2K1RjVi9oT3h3TXgvM2phbXRwMU8xTGhQRlVTM1ZXcWkzdWJPOE1wcVdkdzk1a01ON2YzYTFXS2c5dWI5MSsrNjN2dnZ6Vy9kZGZ5aCs4WDE5c2JML3pVdS9vY0ZZb3Q4OC81Y2RCUzdseHQxbXZ6d3FMZTQ5dTRDSlVSbG5COW4yNFRoYkEyc0lvVXJsVVF4bmtkcUh0WkJ2alNCMXFBZ2pFK1BSTjNRZzREQStvQVhLY2FNUFI0cUJ6U2tYeXNsWVhaTWFhWHJMSTB4QjZpR3FZOEowU0p4bzFtVjBpRWVqTWlEc2l4ZUlJMVhoTlRmRlVMOS80ZzRibEhJckUyckNvOGFUQnJvL2xaRmpjWUpqSXdqd09ZSmZUWko0Q2pNTEFNd0l6Sm1iVWRTVDcrdGMrSGxpaFlwMXBKdTJpWkI0Tnh0emtBU0VkaGVaaFc2aUxRTVl4NmtLK3FPbFNtRExjNXNMTUluSG9peUNlQ3lqQzdjd3dub2NpRmxkMm5RVndGVVVOYmNyUlJBZHBHOE5aTjJvaHVaSzZTVVpSckl0UFdJZmNVSCttTjhoS2srN0dXcnRRcnV6czdZMUcrVnE5VXEzd2lFVjAycm9vbEl0WmFXVjFRNXQ0c1M1bWhjN2VUajQzcVRhYTVVcWxxenZVckpDVktzTUIvODJoV211V0dzM1phSnBsNWF6U1FJdFpzWDl3T0Q3ZVhWaHFuYi8ycExZL2x5NmVlZjZGRDExNzRTT0RYT0hlL2VPVmxZWE5heS91dnZ2dDNRZDNlZ2RicmJWenhVcGxPaG9PZTkzTjgxZDM5M3E5emlOdFBrSkJyQmNHbGdxT2NreEJoTGxMZVBVa1NFNnhNMndsdTFNVkZDUVJtWlhBdFZteFAzUlkzeGxLUVBqQ2xZcjlJUks1SXhJWU02WVVoSTgxdlYzanFXM3pjSTA2TWI0S1VSUTEzaUd3Rk5QT1JIWVRiQlRhOGlPU3hpRU9ZaWNhcEE3VjhDTVRFc3RXK2NUTFJTOGtwakFaRHd5bC9La0MrL2grajJpWTF6RmdoSEtsSjBxOWhlem52L1pKRmt1b3diUDllSTlhM1d4bXBDN1djTXpwYkgyd0c0TVJ5cklTdXFwcDJXTFlCblBwSEhKaElKdkxpODgyMUh6V0orSTFFS1JuaVNmQ2lIVkU1emFVSVpJWWVnVGdZUG5HOHhNdkEyL1o1eFlobDh5S3hlV1BsWXZWTTJzci9MSkFWbHhmYlN1cjYySWpXeWxyRDNyZHp2N3VhRGh1cjZ4VWExV3R3dEZna05kOXFnU1pUTFRJUnBOaHRWcFgxSlRLbFFtM0svd3JzbkgzaVAreVZLOGpTYkcwc0habTljS0ZSVzRHYWd1cjY1ZWYvVkI3YlhQNTdPYTdOKys5K2dlL3YzTHhUTEZRblZicWUzdDdDNVY4WnpCcUxDeVhHa3Y1WWpsZktNa1VsNTU0NGVDdzJ6dDZJRU5KSmRURWJIWU1aazI1eWxnaVNXZE1nSzBBN2Nqd0FhVENLRlpwNEp3SVphY2F6bzUra3l2S2ZWMkZJQzdQWmhoTFFIeUVNT1RFckNuVno3V0ZQNjZjeHRoeGpnZEw1R0JpbXlHTWhGSVhBZXBlNGNIZ0tkR0xVMmhuUFVTamszb1ZDV1I2UEE0SGtpek4rZDRkdERwMEVxQVJETGNZY0lJN2M1a0k1b2pOemljNGVLajRXd3VHWjcvdzFVOGxsbXpLMFowbm80cHZHZEN4R3c2dzlCUk1rUnJnNDRLYndoUU9Hc1NVaWptVHNZb1lMRExTRE55Z1J3TFpGZm1pR1JjZ0FURTJIS3dwVkhPb0pUd3lReC8yTW8yZm5Qb096NGZ3a2tUNkxnNEtGelZEcGN3MzM2cTEydWJtYXF0Unk4OG1FMjI0OS9hT0QvZW5BMzdYcmxRdUtkbU9oLzNacUs4Y3o1dExrekdQYTdKeXRkbW8xaHVGSXYrcVlqb1o1ck15OTVxb091TzNiY3FWVElQenM4YkthbU5wdFY2dFRyTFMvVnR2SCsvdlRuUGw3czcybFNldkwxKzRzcngrdm5QdnpzSGh3Yzdicis3Y2ZhOVl6WmJPWEMxWEYvSVoveENqMFY2Ly9mYTNiU0FyaS9XeEVzVytDR09yejdBdEhwMUdxcEtPTk9rR0lHb2pTYnZRSVppRE1XN2pvVEM5UUxuQnFZc1JXTlpNa09UeGdVbU5sSmhDOE5WVjJyaEozV0pUQ2pMaFZjczhpaXBoSU1iMUpNM3dySmt3VUJOR3VuWGdoY2ZuWVlvYzRFTTdEcEhDMlFoVFdndDNXQ1BvYUxxWGtBZ0JRRU5ERHdkRkZ2OExYL3NCWkJLUlFsd0Y0VFF5Q1JjVDYrS2hka3dhakJCYW1MbFk2dFhOSE1WR0krYm1jWThCRVZCOW90SUZFOWw0cUk4dFdHTk9IZzVjTTNPcVJrcWxCRVFQQllUa085ZitIeW9TbXR5bUZCTDV4bnlRUythS201RDhxSFI1cjFPb2xXYzFSV0d1MEZ4YVhPQ25ZaW82eXVXS0VubXoyVmhhMzlSMG5ZT2R5ZkhSZE5ndHNjdlJUV3pKSHlSYlZHUXJKU3JRSlVtcHBOaldwYUlob05xb0Y0c2wxb051Rm13eVBpdGZyZk52ZVdmNUJ6ZmY3aHp1N055N2QvYmF0ZkhSYnFsV3YvM21LNWRmK0ZqNzRqTmJkeDlremVWaVNYZTVqZnJpc2k0T2s4bmt4anN2SHoyNllXZGhxTENWaTZJa0lHY3lOQXpQMnRVVTZPMEdDRDJRcUlaS3RTKy9hcW9vQTRGM1AzM0ErRmhZNzFEVEVBd09WLzZ4a2h3aHk3b1ZnU1JFcFBBZ3dXVjRGcVRjSVF5VmI3SElXUkxLbDF5UU9GcFF3cmdKVCtKS3RmbDRKbXJUazJOcE1oTXlRMmZaT0V4QVNGcDFFWVpJeHNOQmM4MmJxYlowRnNGTG9KRDloYTkvR3BzSXhIU1JneVVjZlRCa0dMVXd0amdWdGZGSktyNzVlMExtbFdPTFdIL2hrd21vMFpaN3lyQ0llYkpMb1liTU5NRFduRVhFR3VCK25JdVJWNjB2QXZUU3BETVU4NFVSSDJpTmlmT3cvT0hKZUxpMlVCZCtPdFh1bzlSc0tISjE4NmxkK0ZpTHJxUWRSUzQzSFBZSGh3ZVZTcjVVclplcXJkYnlXbVIwRVV4R2c5eUUzNFRKVFNlS1VYNHl5V21xTE1yR1lxV3hVSzd5QzVMVEtaOHdWbWp4VDVESzVmN2h3YWg3c1BQd29SZzg5ZkVmS0ZRV3Z2bDd2Ly93N1ZmeTQ5NExQL0xGYi8vT2IxUUwvZnhNSVY5cExtMzArNzIxdGJQdnZ2WEhZUjBYdENBQXc3d1J4WFlHM25RbGtSS0p1MVRiY2NRMHpRaVdlVGVBVGpJTWpmU3BLOU03MEgzUWxzOWtTenhuUVd6Nm1NcjEzTTdNUTFQM2xEaUVmQlJKUjA0bk4ra1FSeGFMUFlzcnlUN0pSNW9OajFrQllUeVhXOUhMSVhIb29nRWdsRVloV3VMZ0YycFJwRW9nakUvakhCWUpFMHZVWGNMWXh0bWYvOXBuYU5NbzZGNGVTN3FEU3g0Y2NRQzlJQ1c2bG9DbjhRcVpLMCt2S05tQnBjbVkyNkd2RTk1VWFqYXhQZXNsZ1VuVkJXSEVOM21VS1JEWUdBOFVIdjd4cTNnRXRidVlaRTZqT2l1Smh2WEFkU2lmTlM2WEY1OXFWa3JyRzB1RFFhNjlzamdkOUV2WlJObDdNdXIzKzhOK3Qxc284SVBWdWVsMGROd3Bsb3IxOWlxU3h1L1Q4engrcG5pZmpjYXlRcmxTeThvMU1sbVJmMnNuSXY2TGdkYU9qbkl0VTIreG1pOVZ4dVBKc0hmVVd0dlV6VEFoc0xqU244MFdsNWRMazk1bXBUZGFXUC9PcTYrVjYrVitaOUJlWFZuWXVGRFFFcXJXZXQzdTN2YUQ2ZURJamdzalU4S2pqdGNFQUtXbWFza3FZdnRCQUxkWXhMazM1Q0IxVnU0V0tVL0tHWWJGQ1dvN2hyeUlUVlZCSk85clpyclVpZ2JzN1JaTTdSOGxkTDk4TVg5S3htVTJzcnU5Z08vaXdBLzBDbWFYWXVMZ3FCN1NWcUprR3E0TTBRdHpLMlFZU1J4NGFBcEpkRnRnVkFheWVvVFh2QmhoempyclJLSjBhRktCZDFmMkY3LytXYVV0c0JxZ3c1c1pRbE84QVJBSmczR29FTFZHY3BGbHcyMEZiRXNOMU9GUURpVk5sdkF3ajZiQ1YyM1JjSDlwY3pneHlIYXBHVkdPS1NPNDJjVkVNM1RBb01hSHVmbEZmNmJRY0xaUCtXcDUvVFA1eWJDOVdLM1hHOHVyUzVQQm9Ldzd3K21vWGkyTngrT2pveVB0MzZ2bDhuQ2syOWI4NHVwcXJiVkVCdEhXcFpDVmlPTlNxVkxKaXBWU3JTYTJmaStkaDdLYWc5WjByTTJNWWwweVpNWFNkTUx2RGFwTFc0YkpzRDhkOUJxTHkwdWI1d2JqM0hEbjdtSno0ZUp6SDlzOTdyLzdlMys0ZS92ZHJOOS8rcU1mZWZsZi9wTXpaNWR5OWJXZDdZZnlmNmxjTzlpK2hTc3dOQlZuM0pvQWpDN2xIbVA4OGw4VU1wTmJPakFFWFdDSUh6cjh3bWZNb2IyTmgwQXBzNFduc0xuVU1VcEdWdTFnbDNGTDJCeHJHKzgzc04wazBhaU9DL2lKNDNBSGJrMDBrTG1jaW51VEMzYXRsenZoajl4cTZNL3VOTEhPbHRuTjZOVUpadEJHY2FlN3FCTjVRcHBId01FNG4vMmxyMzlPaUJReHRwc041Y2xEM0dRM0NjaVNnSUVBN084VjRxWW94VUhxWVV1YUxBTnBMMkk0YTE5am1wVHBHV0s3RUt6a0FERE1SZE9Ua2xFaTFpbGNPTU44TUtFWFdGNko2QmMzbXBZblYycC92RnhiS2VjbS9kSDQ3Sm1OcFlXNjloWEZMTk8yV3pzWnpUUG9UOXBMN1ZLcDFPMGNWZXZOU3JXbTZDOFZLOG85K2xOZHJBam1zNVBqWVZlclJBckV0VWdSTDZITDVTclRGeXVLVTZWSlNUZWJUZm52Ty9iWlpOUXIxaHFGY3JOM3VKL3JIWmNXRmtlejNNTTc5ODllMm5qdXMxOTh0TnZKOHBOTEgvbStYLzJmL2tubjNqdnJHNXYzM3ZyMjJldlBQN2oxdWdackhsdlNFMGFaUjNDMEJhaUpLekNwZ0hTYnhaK3hMbEJnS0NFQWxlWmxZU2hZRlhhenA4RzBvcFplSkcrbXRiRmxYdGUydHRTMWExSitJYk1JYnhmZ0VSNlR6M3NWOXlhMlV3Z0Y5VkxiL1FibWN6QS9BUUVackJBbUVoeGFXY0lZcEpONEltM0F6QW1adE9IK1QzL21xVjdMcndJaEJRMDg3Y2xoU2s3WlgvcHpuNGVsU01YTFpnbFF2ZlBoMEFXQkxlbnhtZ003eGtURXVvbU5aNEtTUUNNRlJ5WVE4eVN1Ly9tUEFINk4wUFRTaEV3ZmFqTUJzVTRveXhOV0g0UFNpMkkybk9nNXNhamdEemNrejZvWHkrMW5MbTR1cml3dnpncWxjeHZ0VWphcmw0dmR3WmkzeDJaajVXM0UxWVFTc1Z3cWxxclZXazFaV3ZGYTFCVlkwVDNsMzFFNlNuSkszdjVjVjBXYkZuK0lZTXJrdWlLWHRIc3BjNkhEVlBFSW5FYytvOWw0ZjN1cjF4MU9adG9WRmc4ZnZEOGJkN2NlYk91bTRPSDd0K3YxUWxZdXRsZmJiMzNqMzY0c1ZLYVZacU5lT3NvMTYrWHl3ZDRkWFZYRFlyZ0F0cWtFSkhsOHB1QWlyd0ZSQjV6b09ldEFHQUhhbTh1YUFpSzJvK0JHUnNxWUdGVW1sRDdSUVU3aE9xbm94K3pZRktBSXdxQmR3QU1EOWNoWnZwQ2FRVGczSGJJSjY4Y0NwV1NVdWdoT0FVeW1JeUNSSlNRVmVBOEUwT0dPT0Nkd0RsaGpnd3l3MVpBQkt5VmxOVWpvVXpOR1hjai82ai8rVDJReHY2K3YwMVRYd1hnR205NUk5Z2ZWUVlIUUtRZ0U2L0t0TnA5OTBWcWIwMHNPUGpiZ1p3VitRd2tVQWNHUzVPMm41SlZVdVNacTFJdTBvdUxHUng0RFVqZmtPdG5pRmhsTkJYSDFoQjYxMlVqZzVPbWtVTDd3VTVjM1YxYmE5WjJqWVNYTDZoVnBOSkdPdTNzSEdsUXBGU2F6YkRUb3QxclZ4SzlRS2VRVW5NcnZRMCttWFIxUFhOQktVMmphRUZHcGZqUlU2cy9uZEtFbzVrcFY1Ym5KbEsrNzFtck5FWjlBNkU3SG84Rm85T2o5VytQK1lEYnUxUmJidXFMb3p2WFd6WGNudmNQbHRUT05sZlViMy83bTB0cEtmZVB5Ly9PLytLK1hscXRQWDcvNHNSLzdxZjJIRCtvYjY5MnRkLzM0MFBHSVRhVlJQQjlITE5uU3ByUWpkSUN3NVFPRDMwUU1QV2U1QU8rb1I3Y2lkTXU1YW9wV0NnS29Zazl6Y3ZoQmd4L204SWRoeElSYUx6ZmliS3lvR0tPV1hXcEhJRGdzZUF4dEZ0Qm9OcE5aWG8rQzB0RmpiR0FZaWRhaGl6Q0MxTU83WEZwUXNJaVlVUkdGQVR2bk1TQ2NHVWRCcUZnellUaG1OSTBxZ2pEN0szL3VKNGg2RGhZdWZhd1pLejFIZXBYRW9VSzJkcDN3VHZHeDZqVXd1dEtseDhuYlYwQUo0aTRuVmgya2JkS0hDTnpGcXB6UDRzR0JVYTRob3ppRmNOQ2pHekRsSVJLT0JpZ0VtVm5xWksxblZ6WXVyeTdWUjdQczZLaTd2RkRTZmtSOTQ5RllWemRkaDhWck1wM3lyODM1V1R4dFM4ckQ0WEEyVXpvWEl4a21wcGZmQ0JuWlFkbFl0dGNPVHdwb1NRalNybjZXbFVZVHZvOC9IazFHR3A3TFRVWURmcTdEbjBEYWZuZ3ZOeGxLblBiS2FuMTVQVit1Yk8vdDFSdUxsWlhObFRQbjM3MXpaMWFzNkpyeGtVKyt1Rml2dnZmYWE4MWFlWnpMTGp6eGthT0RCOG9LMkI0Ymh2bHhrczc0akhYdFRocmh2R2lsSm5XOE1JbmFZUm5iVlZocnFINnhGcDdDTmZKeFVYQW9KVXRobVl0KzdIeFN3dXlVNENLdWRxVUdrTC9uM0lFQkpITHl1eWYwTWlBa0VobWFXRTVIVGVvMWhnQ0ZHWjFNUXJ3R3NTbFVjeWFnd1RGQUlwZ0JPcWxUT2dtd2JvODExZFRSajFRUytkZi81LytTbFJPcnk3VmZnZUZUalVJcjN5bERhT1g1TjNBVURuUnE0UkVGenZrcWtmZ1ZLU3hxTTFGYnNnVWZSQ1JmTVZ4SUwyNHlCZHJSYlJ4YWFxK01iSWpQMnBmT0FLcHRESjlpNWFxSnl2ekFoaWFjRkdxTnF6OXphWDJoVXExTStVbU5ZYm1rZkQ4cDVNYTZjeHBNSm9Sc0x0L3I5ZXFWVXFtc1MwaldIdzdSYXpLdVZTdXcwYkJCVjM0cGw4cDh1REZYdEEyMHllRkh4bWFURVZyeHk1S0Q4WEJRckRRMHRmYjZzL0ZZUXlYS1lEVHRIbmVtbzNGLy8wR3VYSzQwRmw3OXpzdjM3dHo1azkvOE44c1hMcTJzTEx6MTVudmJ0Mjl2cnJRKyt2eVRsNTU0YXZlb0oxNk5hbTdqSTU4cERLWkxsNi9kZU9sWHBSREtZQkVtaysxa01ZeXBOSWN4T0ZTd2xRM3JUT2d6N3JEWjhSVFhYWXlLbjB3cncvTnhWVm5LN3ZSNlpwYlpKTDRPUldyM3BLcjBzcW5UWG0xdVovVzZ4VmtzY0FxaFRDcGxqdm5USWJsUWgyY1BuNG9KaFRvMGNQRVFNME4wenhsWUthU0dCYlN3WnBxRzg5N09SSUNLRlFaL0lwRmxGUkNVR2tqV2dCY29rOEU5bC84M3YvUmZKYVBBNUtUbXJPckVkdXgyYkcyTnhveVliUUtwSVhvNEpDWlNhREp3bWtrbk80R3ArYzFiY3dhV0xjQ1MycEhMT01KWU9HVUNrUkhtRmpjQXJ3dUhPK1JlQTJpaGlUeHJhZU1IbGxjdkxMWHF5dUwxc2hMd3VGb2szTldyaEtPa3JzU3NOTjhmOUJmcU5VMDlISTFHUXlKVndhL3duNGhVcnArTnN4SUp6cXMyRzQ5SENnaWxQRVU4enlWenl1amp3YWpIbTB2OHp5anV5MHNsM1NJTDN4dDBPNE5lVHdta1VxNE1lZ2VIZDkrOThlb2JiNy85dHE1cjFYcHRZWG5sMWZmdUZVZVRhck42N3N6NitXdFhSN05DczF6b2I3MmZLNVlQajNxZitObS8vT1lydjY3bFoxTmdTdUlvRE9lRUVvR0tLZFdRTzF5N29rUXJTUGpIYjNZSWc2SFdpMDlCMkU1enI1aVh6QWVSbXU3R3JuWUFmc0MwNUVnb0krRWsrNHRJSThOcmRoUUF6QUlJc3dEd0VNOUJJNWpLWjgwQ0ZZTENVcEJSRmtRUXZaNkJNa2ZNQ3lDTVRpajVRMzVXQndLUkxobHZzYnhwUUNvMWFVT3MramQrNlcvQ2l5SXVOcmNyR0dOVlI3azM0cW9aWjFTUXVJaEdjeXJzaEFPTmpTQUYxZ3loc1AyVzFESWEyd2tTc1JVSzRjTUJGdHNXcDRtSkNVRVRwU0xZNDlCUjE1QnBhYkYxK2ZPdFdxbFpxMml2VXFzVUI4TnhWWkEySXRPUkNNZDhFNi9hN3cvNGZ4dVYwbVE0R2srbnJLclpzS0tyZ0haSFZvT1A0R2dybytXdHpGMG9hcjh1ZXQyQ2xrczE3ZGhuNCtuK1VVZW40OE5lWTNGQis2Tis5N2prM1ZtNVVwNU1odDN1Y0RycE41cUxnK1A5dTMvd3I4NWNlL2JXemZlbnBkTE80VUdwM1BqZDMvaXRzNjM2NVdlZmV2M05tOVhwZUdsemRXMngxRjVaMzNxMGQ3aTd2YmgrOXRwekwzU1B0M3JENCtRa214MURoZ0Z0YnF5RDJLbGdOcDI0dW1CVEZaekIyVCtmNFNBM0creGtCd2xTTFZwVDJaMWhXcG9KR1ZGT2hhMXhRZG9PbTQ4Tkw2RVlacEROdGFQL3BCZS9pQmsxcWtoTUM2VXo3Tk0wUG1rUWtaRVFMb0xsQzFPYUZ3UlFwTEdtZ0g0K2lsa2NTakYxcW9XZkE4SlFCWFgrdC83NTMrS01KWm5Kb0tVQTFpbk01VnNnQnRIMnI3MEprQVdGVTVmb3ZSejBJZ1k5alRRM1VlU2N4NnBpS1ZGS1NnWkQ5WmdjeVhqQURZQmZqWTZtR3E0U3lJbGVKSnJtbHo1U1dycFNLZWJQclRYbFkyMHhScE5adlZyaERTUFBJdXBpbHZYNncvRmtXS3VVeWZab3hqK1dxbGJTVG1ZMEhpdlRpeU8zZlNMZTZ4dysybjcxbFZldVAvMTBZNmw1dkgzNHU3LzUyNDJXZG5ldG5ZZTNMbDU5S2l1VzlyYTN6bTR1WFh2eDJhV2xqZHgwMURuWUh4MGZEWWJEcm01YXQrL2N1M256NFR0dnZiTjkrT2l3WHlsVk5pNmV1M2JwL01xWnMyKy8vZTZWODJkdXYvbjZ4Y3ZueXd2TDkyKyswenM0cnBVTDE1OTcvdXoxWnc0R0I0UE9EbVlpOThod1dGWEtvb2JOalFkY0JJQ25TT3FFVVRVSDFRaDNVVG5LcFRUNm1VREZ4Rmh5UGdnMllWMXNUb2Q3Q1grOGxnaURRUDFwb2NEVE1SZnM2SWdRQkE3Znp3dnkvSDhaKzg5b1c1YmtQQXdzWDdYOTNzZWJlNjUzN3o3YjNlaCthRFFjQVlna0RFR0FGRUFTcEVnUUlBRWFrWlQrek5MOEdmMFlyalUvNThmTW10Rm8xaXpOaUpLV0RFVktTeVFBRWlBSWRxUDlhL084dWQ0Y2Y4NzJ1N3laNzR1czJtZWZlMTlEakpPbktqTXlNakl6TWpJeXNxcDJsWkJKQXY5bHBqUUo5TkxRT1RuckVSSlZoQXlGQUNsaHp0d0s1QWVQK0NjSWdoZHBGWWxnSUU0cHEzLzVYL3kvbUZzeUtnRUpzY3JpNzVYZWVYbFFSNzVYa2JNUURRVU4yZ0dubTNGZzJVcld6UnJJaTVrU29SNnIvZ29VZEV3UU1KSWtnVm9MbFRTUkIyazZmWFdaUDVJU0VDSUNLNUl2TWJoWC9xeG11SjI2dGRhcG9RNjRNS21tTituTklCTmVkV1piaG0xWllSekZnZDlxTkxDdGhGSkNRUTB0ZDEwUGxlU1pGc1doNjFwMGZBcHRkRHo3di83bi82ZlI1T1JYL3NNZmZlZjllOHZkbDk1NjY2djkwRzhZK241L21oVDVwZlhsbytNKzZycXd1dktUWC9yU1ozN3VaNXVkRmhaL2JOQ2lJRHp0bjZaeEdnZXpyaFk4UFRoNDc1dmZpTFQ2OXFXTEVOclM4c2E3bjN6U1hWdDk5djF2dXMxTzZFODh5MnpaeGdybVRYY2xucDNzdlBtenM4RWpQWS9RTlhFWDJjbm5SZ2R3bGthV3NxT0tSZ3BneU5TaWlwZ1VWNk1wTWRwOFJzbWVhWlpWQ2lleXBYZ1JVVGFHY1dYbFNhUE9DR3FhUWNsNVNVNnljSlRMY3lVM0Fybkw0RmFBWnFtWlJ0d2NUelZVRjJaa2dndm5LaytwQ2c4TFhGanlyQllBaXFCZDdJbWdtZUNScmhTNTRUUm5DTXhYL3VYL1c4NkNVb2N5VjlXTEl3RXhhblVWWjZNZ1U1UkNOVGpReHBiRkZLaG1LL21nbDlKbXlraDBWRkhTTGdpR1dhTFZNaStZVm1UU2RNeFM1aklxeldlTzhnc1ZuOVRwZHE3OUIxRVVyVFN0NVc0ZGFqMll4cVpSTkYxV0J6TU9tMTczYkt4SkdIclljTG0xcFdkeG5LVXArRGxRY2Y1aXhZRHJVdk5xNFdUNi9yLzkydGYvNkgvN3h2ZStVVGl0L3Nub3QvN2FMN3o3enR0ZisyRC96czNOdHo3YTY3YnFRWnJEWVkrVERNcmRybmxCR0Y1ZVh2ay8vSi8vOGRMMXkvQ0UrdjMrazBjUEh6KzQ5KzdYdm5yN0N6OTgvY0xGSnc4K3JIVzZmRmpIc0E0ZlB4M3VQam80N0QvZTczZWFubWtZTmMvYzNOaTR1TFcrMHZQeThXRDkyc3YyNnJadVJFVWFZZ2RlcnVzVktPRXpJa2RrTVNJa2xGMlpnSU9uRmx1QnlseEpsQWNaRU1VQkI1RXN6QmVBUGdsQ09SamtUcUZET1BEN21LNTBtd1JDajRKTVNsUkdSRVlLSjFURXVoZ2xXcXJnbnlvbWhTU0RFU0trWHlYMXZJK0NLUWtrcWFEVUpyYVJ6Vlh0RklTUXNRVnNBNjA3bTRGOFlVTSs2TUJYZi9mL2d6akV3NDRLVy9DVGlCUm1UQkxxOWZJU1FWcVVHYVdoVUNXQ2NSSld3THBsRDBFT0lnZEdsSnJTR1lJaUwzUU1JSTBFaUV3a0xqMmgyU2VVTFplZVNBQ3dlTjY1M3RwOE9RcVRuWlZhdzdNelRYOTJQTzQySEJoNlRiZG1VV3JxaGVlYUdQTWtTUzNiS1hKZW5jU1FZN09LcmFmbk9aYk4wVTNqWkhZMCtoLytMLy80ZXcvZmpneHJaNlhYWFhidVBkamI2NGV1NHgyUFo1YzIxbTByZVhRNDduYWFqL2FPTjNzdHc3UXU5QnJmK2ZnaEpsQkQwLyt6Lyt6L2VQbTFPeDk4OU1IdzVLaldhbXBwZG5JeVR2UU1PL1QyMGhKY3ZuLzNiLzV0a2t3UEhoOWdFd3hmcTRVZGdWNDBtOTc2U3VmR2xRc2JGM2MrL1BqWmxjMzE3VmUvNERUcTArRlRMS0pvSnpxTWZrSldGQVk3VGFrcFFaVExya2hEcmlDVWNmNkdESGp4NlVzaGkwSUxOWVpDQms4eUswbG13bzlCVGt5ZFlhaFRaOE9pbEY1eTFWSHhWeU5MSU9yY3lBcHc5SWd0bTY4S2xhZVNHRmxncU1ySy8xbnlQRkFQQVdpWlVucFFnUklnY1JVcDFSMmd5ak1QK3ZlYmYrM1BTd1M1aXBKbkpHVnA0R1ZVRUJLcFRwSXQrb2ZsVGlLOHVDbFhjZFcxZHVLWUZKT0FLVy93VWp1SmVQV2RaTHdLS3RkeDJTRGhnd1F2MHpMQ1FBSVZRVmZPYUJTZWRiSWlZbFdyOWVaRjAyM0QrWWFLbzZvd0tZNU94cTZORGF1TkZSMm0zVFlMeDRKZXdhdVJEMzhYdVdVYS9DVTEzQllzcEFETFRsUHQzVC82K2dkLytGKy8vOGxiSHowNThacjFXWnp0OThQQktFR2xyVVlkUFhseWVHeUd5V1EyNjdXWCtvUFR0YWI5WVBjRU85MVpuRFJjODNnYXZQK3R0KzY5OWMwM2YvUkhETXZiMk41YVcxc3ZuQnFXbDQyTmxYYW5BNTRYcmwwWUhvMCsvT0E5MU5xZkJrLzc0LzRBemxVcksrenQxZVgxaloybkQ1NkV3WFI0ZXRDb3RkSUN2Y21vYXRXSXlGbTZyWkljRVdJb0tVWXhZTXduTUpkSVFhaWp5QkFabEMxUEZLYVU1b2lVdVl4ejdTTktqcFM1cE5nT1NiSUkxa2ZTY2lCUWl3UzZjWE0yVllWVkF4WE1NeGlYeXMveUFQTkUyVCtRRTRjZ3NYbFJGaTRqQXFTUkZnb0hSUGpnQW5GeVFLdXJlcVNVK2JmKytsOVEvS2ltWEpLSWwwNElBeVZFcHVCR244MGhxWUFLTFd6S1FNbElxT0lncUNaQVNhTU95TUpaa2p6T3A0SDZKN0VLMGdMa01vQVNLNUFnaVJZQ3RDVEw2NWMxRzl2VW90ZXdUZE55Yk92d1pLb1hjUVBxYnZJU2pldGdlRUFIODJZa2NXendONjIwR1lacHhuRThtd1hoSlB5WC8vZi80cC8reTMveTFlOS85TXMvLzZabkpPL2NQWUxsV1dwNjJPejJHdHFUWjBkZHoxMXFlS1BBajVQazN1N1I1bkpuTko2NTBQTFRjYnZ1WVFIQlZQS3paUGZ3Sk42LzkrRHRkLy9Nbi90eEk1aTR5MnV0VnN0d3RKMExXNnNyNjNxUjdUMzlKRStUNFhDQy9UUmNtVlRQVGtiajRXRHcrUDdEQisrOUN6Wm8wMUt6NXJTV2l5eUxnc3h5S1JRS0FZdWhpRU51OFZTS0pLcFdSbUYxejZRcWcwWTdMSW1TR3NEUkpFMVpTc21Ud2tkRUZGcitoVkxsU0JUMGN4T0dBQVNIZy9uTUZtQjlWVGlEczN4a3FCeFJubm1LeVhtSmhTaHFQTWRJZ2Z4VXBNeFE3Y1FSN2NhQVNveWcyaUNaNEtmdWRTcGdPYW83TTg0d2twQjVJZElzY3dCem1RRksxb0tSQ004cUtKRDRHYlpNOFpvNkVkTGxra3dNQ1NtVURvdVlXVE5US29Oa0Nxb0lPNFdXY2ZDaStwVWsxV3BXVWF0NTZEZjhnOEFQNHlRMkhRcytVNXBtcmcxZHdXYVV0aHp1Q3hZKytQZDVubHVXTlF1aTAybjR2WC8xVDQ5MnYxRmZYbm42N09qOVQvYTNWamNiVnJRM0dDOTMzYzFPelN5TXRaWTNDV2FQRGdjcmpjYVZ6VzZqYnZRbkljei9oVzd0NldDNjJtcWVqaWYxZW0wNmk1dDFKNHdTUC9JNzdaWGYvZWUvODVuWDcvUTJWeDFxU043cHJXNXZYWHp0alMrY0hEMUtrMmpRbjQ0bjRVNjNjL3ZDeXEzTFc1dVhMaFl6ZjN1MXZiN1Z6YkxNdFRndDY2N3JqMlptamU4L1k1RGV5NENJTVFMTTVWQ0pwbHE2SVJuUzRFaWtaQUZLR29WZ05pVmZzYUpWQnljbGJXaTM0QWhsTnM2Q2s2U0FHc3hGaklDcVZBSGJVa2JQbWtGNG9XR0s4bmxlaExOeUtyZnFmQW1sd2toTVViQ3RaYUZGVXFMTTMvcnJ2NFFUMzJLRnpEUE9pbEE4ZWlnTFhBRlNxLzdOVFR2UGMzRnc4YU8wZVArbGtpR09WYWpJcU9kcTRLUjNhTHJLSUxBOHowREtnNmJJcVJyRStjdDhsVko0OFFYdGlidGo2VmE3NFdLYzZ3Ni9INTlueGNsdzVuazF6M0ZRQ1o4YjVnUHFhREE5ZVBhR3Q3ejV5RHI2dHIvbmYrZGYvUzlyR3h0UDl3Njc3YVpwWnM4T2h5aSszRzNGV2YxNEZIcWVjV0c5VzdQMUpkc2NnZk00V0ttNWI3eTBNNTRsZzFuWWEzcEhVNy90ZXBadGpHZkJTc3NkaDNIVHR2N2dqNzUxT2p6KzVGdmYvdWxmK290NlBPQmRxc2pQVHg3MDczMXpjNlZ4YVh1OTVsbVJrWitPZzdjZjdkMTdlbkx2NGU2VG8yRi9QRDA4R1BFRms3YlphamZHQjd1Tlh0Y29zRXA1V3BHcUI3ZVVWaWdWVjFaQnFTLytlV0lPalJTZ1dnMGtsNldJUkx5RTB1d3BQVmFFaUZiaktVODdtdVdJQThtamhET1E0YWd3NUF3bE9TUEE2RWpOWnpTcTlqTUtGVC9YSktyV3VVWXU1Q05MOUxBRTFWRFNVeGRaQzBGWXp2WGtUQWJ6OEszZi8yOVFnZXhxZUkxRkFValZGcUhhN2FqTkFadFNnUlFvYlFrcFNneFlNczJEN0ZZQlBNcTJTUzR6NFh5MitWRFBpWlJRc2VERkNJaStSQ2xnUytsTXpSRUFwbkl6MnZocCtMdmRwbE4zdFEwNE5JNExsWDYwMisrMVllNWgySTA4alIzSDRsTXpwcFdsV1JRR0VCRkU1NWoycytQSi8vUmYvcE83My81dlc2NzM0ZjdvUno1M0p3ekMvYVBUMldUY2NlMVJtRCtkUkhZZWFxbTIxdkZhN1dhaG1aTTR4aDY0YStsaGJqenFUMXpYT1IzNTJCc0VlV0ptbVo3bHBtM1VOWDJZNlMxYk94NU9mL296bi9rcnYvRlhONjl1bnV3OWdHdlVxam02eG11bjMvL2cva2wvY2pJSjd0MjkvKzIzM2wxcU9zT1E4amtKTWlQWFZ6M2o1c1hWZHJ2WjFMTS85K2QvdWFnNWVUcnJibC9rM2J3RkVVQUFTTXNta3NBb0IwNUVLTDRNOXlwS2lNQXVGcFJoVXVXZzYxSk9rQlN6U3NqV2swZ2VTQ3JWcUlJVkNFZUZRVlFlVWlDQ2FUWkdSZWN0THZIOEx6RXFEZ2FLQnYrb2lYRXBwMnBVVkJVc3hnbXFQVERWdk00dU1FYytCNm9LODdkLy9WZGc3bWpvU01aaTZDcWJnQ0pFQU5RVTV4WkE1bzZ5TWN6QUFzaUl6Q3VXeDdTU2xVWVZyR2EvQ2tSd3dSVHJ3ejgyc3N3QWxIR3hJbUtkaEdZT2JHREpGcUF5VUQ1M3VwR3pQZ3VtU1JoMzI0MTJnMC9xMnBZeDh2bWNsbTNUSUtLbllJVVlHNGxwWkJxdTUrVjV1ci9YLzdmL3krK05uMzdsNXFVdE9QWnJUZS9POVZVbjlyZDZ0WFFXeEdrMm5zek1QUCtSbTJ0M0xxK3V0dWtUMVYydlpoaDEyMWxiYXJjNnRQMUxOYWRSdDZkUk1Sak4xcHB1bEdTT3BoLzBaOXRieTM2UVJwbjIrUERveWYxUGJsNit2blgxb2xPcjVWNG5MOHdnamkwenZiQnpzVnYzbmp4Nk91bWZPcGlqbHRkYlhkOVk3emc2Wm9XM3Zycjg1bWR1TGErMFAzem5uZkhlczhHelJ6RDZuZFhOTEtNL1Zpb01JeHc5a1VjNXhwUWxSU2hDcE1qS09JaVVBTVh6QnBBVVk0dWo4aVlsTFdNa0RCSERVWEdBQU1taHFrZzU4dVJjRmhUR012UUExZ2VRQTBYUHVDUXFLT2xMT0orU3RGUlhKdWZBd1N0clpKNzZhUnZpYkM2QVF5dGtWU01CS2o2dkFCSHp0LzdHcjVDUGRJWW40bFVCSEJHQVVFZitNNkV5SzJCRzJSRDZNRXdDK1dKakt4QW1JRk1xWGNLY1pZbFRuUzJybFNvcjRzWEtzWEhON0Y1Z2RLSHJydXR1TFBOOTdYeVBhVkVNSjJFWXgzWGU0c2VXajVPWEQwWENpdVR5ekRxRVpSbmYrWmUvODkvOS8vNXZQLzZsVjhMeDhlSFQzUStmOVc5ZXZkUnJlVW5DYTVmRFVUQUprcVpyM0Q4WVBualNIODJTZHFQaFlhK1VGNGV6Nk5IZWFMVmQ2elZycHpOL3A5YzlIbzEwQTdPTVR5dEFDT01ndkhYMTBwTzlBN2hUY1o2L3ZMUDhMMy9uWDIxNDlZdXZmYjdUYm80bUE1Z2FPR0RUMDBrY1RodHJuUi83NlM4VTNmYkRlN3ZiRGZ1bGxkN3IxN2V1YjdaV2xwc1RQNnUxVjE5Nzg3TjlmK1lQaG5vdzFMSHQxVzE1U0JUT0JvVlNDb3ptZ0NDQ0FUQURpZXBmL0pSS2VPY1Vna2dtRjVIUFVTNGVGWkJyR1oyVGNrajVoK29FcFFoRTlSR0lndDFSYURhdFlvYUdxbWpKVVBMNUw4MWVCSkJWS0o1bGlvS29MSTdtTFJZNDE5b0ZWclR1S0s2eTRYRUlFa2NFWXZpalF5cnpHUmIvejdma3VhU1VuTmNtUmM1UmxJa0Y1R0syMEtNMFZ6TEZCditDTEtuWU1ZbWpZYUZlbnhZdHozWFNvdWcyYlpEQ2lVNnpQRTd5eWNUbkpVamJTbmhKUnJkaG5GbVVwZlVpUDNwMi9MLytQLzd4TzAvM3Z2bTllOXViRzJzOTcrSHU2Yi80NDNkM1QyRFlOYy9Sc3pSM3pieUdDU1NQL1EzOThQN1IrSEFVanFOa211YWpPQnY1WWNPdE5WcTEwOEgwbFN2cmc5RWt6a3pMTWZjSHMrVzZhL0ozSklXRjdYS1Nydlpxc1BydnZQUFJKRXlEVHo2NS9jVWY5UnFOM3NaR2IzMTVhV1B6eHRXTGx5N2Q2RFZXMHpodFJVZTdKNFA5NDlOaEhMLzd3Y0dOSzl1dWtSN3RIci8rK3N2TjdRdDVPTnQ3OG5qU0g4OW1VYk5WdHh6K1ZBV1NFRkZ6bE9aaUVUY0FlQXdxKzg0ek15UkNIQVZSWW5pUWhNTHdyRklFaFZGUU1sZHhPWjREb0o3RENyMEFDMG54NTIwMmtTOWlNUFRFbHJXcmVvRUVxVnFYWk5vZ29kWWthYXVRU0VjWUw0L2tvVlFGUjVBeW1IL24xMzhWcE1BQ2lENXJBTEtoR2NRckp3b0hCdWFYSlBNRXd3dHd6czlhb0t6NHZBaG5KS3B4RWlHY1VaY0ZTMFJjdUZPOTdScG1sTVIxZmpNVk84WjhGdkx6ZHpNL2NTeWpCdjlCYmk5anAycFpGbS8rNm5ya2gxLzUvWDl0YWYzamdYODhtYjczeVpNc1NPV2RNZm5CWlBaay8rVE81ZVZlb3o2WmhsZ05YTWRzdWJhdTVTM0hxTmZzcURCY3g2cGJSbjhjckhacTZ6MFBNdXVmakRmYkRpei9NRFdtWWVyVmFra1VyN1dkS05YOXdGK3BlY05aRkNUcHQ3NzczdGUrOSs1V3M3YlU3U3gxMnk3V0lxZHIxenVCSDMvbHk5LzJnbWRYYjEvVjE2NE9UMCtTSVAvNGNQcnV2U2NmUGpoNFdkYWNTOWV1cjF5NUdCMDlDK1BvOU9nd21BYWRYcy9tMjdveGhrb0pPQVFVQ2c4VW5SSzh4S3FnVkJuL0JDRldsQklES0JXZmEvcjhXQlZWWEtyQlU5bnp3dWVoYkV3RjgyUVpVV1hQUTBYRDQwTHBzOWo1S3NzNFFNVXdqNnRJQ2RCYkZablhidjZkdi9tcnBDcVRpTW4wcUlvb0c2dXluNXZ1Y3lDdmhkWjlLcWhzTnUxL2ovSUhnYXBsc1EySTVXWnpablF0dzBpS1BQVERLSnhOWmo2Zm4yazNXblcramgzcURpVXU4aFN1Rmx5QUxFOHdEUStQQnIvenovL1o3LzNoMTFOTnI3djYxWjdUc3ZNMGpETFR0RDM3V3JkMmNobzZSbmJ2WUxUYXFoVkpWblBNcmZWMjJ6WTNsaHQ1RU1EK04xeXpWN05HczdqajFWWmFqbVVYZStNTUJEY3ZyNFJCZ0xabFduNTdlMlV3bWMxQzNyd2RUWk5PeCt0akl0TE1mNUFNRHpOcitkSzFDK0hvU05mdDhXZ1V6MDZiN2FiVFhqL2FQL3J1MngrR2FYSnhwYjI5MXJ0emZlZC8rM2RmKytTakoxN3NYOTY2Rm1yYXljTkhXcEppL2NyeXZMTzBiRkhqeFZ6VGtuRWNJRjhWWkJqRm14Q2c2T1l5QkxJVTVGeWVSS3VJSEVRTCtNOUl5Vm1ZVnZ6bTFTekNwNkJvbUZsMmptZUVxWE9FQ3NtT1NIVGVLbFVwQUJqMnNjSncxd2hTYWVhYytJeW1wR1RMUVUyOGFvRDVkNkh1cUtGa1NwQUVjZ21WQ0FBc0FGQ0o1K0lxTWdlV1B4L1l4aGZJNW5CV0NZbFo2WXUwTHhZR0pqZXRZYmFFcUd0YWNNK2hzbU0vcXplYlRRODd5eUxoNWFBVXJnNS91c0VMN1dhV3BqTS83ZzhtSDN6M08zZnZmbng0M1AvQ3kxZXVicldTTUJ4RW1WMXoxOXExOVpiaHgxbWVKdnNEUHpQTXcwbmNiYnFiNjB1Ulp0WHI5VjdMYWpyWXRXdXJiYS9UOEk3N3A5aVFYdDlablFUUmszR1lCTW1WYm0xcnRjTUhGb3BpYTZuKzVHUnFadmtrVHBiYnRTZ3JDdFBlNk5iZi9lRFJ2WHYzYmw2NHNQUHFaNGJqMGY3QnM5eWZUSVlqMzArKzk1MzNMQ3Y3c1IvOW9hKys5WjVYSklrL1dsdGFmalFZNys0ZEdNTm5lNCtmVHNhVDhYaWFaMGswSGlkSnZMcDl1UnJ3VWtJdkRNZWlkQW1sRFZ3QXBSd0txcWhTTzRCaUo1cUFvSkNLWnFFZVJPY3BGUmNGVWNDZlJKWlpBTWt0R1p3MXRZd0FJNDJaRTVhMGlwTFlxb2p5M1JIQmFiSDlDaFRsM0xwWERLRHV2L0dYZ1pRTE10Um9aa2krcEVoVUJhTFBtaUwzcTVTdm82ai8vZUhGSXVKMWxjT2c2c0Zaam44eUdKcGhuMlRkZ2w5L3QydTJsaHRHbkJhTk9wUmQ5eng3T2d1U0pLclZYSGp3Y1JUU0M5ZU1LRXFQVDA2SEJ3OVBkM2N2M3RnNk9KNGNuWTdIa1RFSTg3cFQvK3pOaldiRDFhSWt5cEtpTUhZSDR5eExoMU8rVEcvdmVQcm9jSHhodVlIZHNHczVXVjQ0dW5icDBycGJzeWZqcU5tMHNicE1zL3hnSE0ybTRjdlhMNXhPWjIzUHpRdjlKSXh0dS9Bc0p6ZXN3U3hjOXF5amliOVVNMzcvRC80NGUvYXNzM1h0OGt1dmhMUHhKMjk5T3pqYWUvM05WMXRlUFlxeUZTdEVjMy95Q3k4UHg1TTNMcTlkdkxaWlgxclZMUVBiQXo4Q3hOZzJZd25xYmV6WVhwT0RUMWVVdG9KaDBRUUx0a3h3LzFKaGxIUnBUMlc2NEZoU0tlVmhXcUZBTFJSbmJGZ0tjZkdNY1o2alh3VEpsNGFWOFI4RUpZMkNGeWsvQmNOR2xFMW5Db3VJdEpqTnJhQ0tzVDhBTURIL0h0Uzl5bEJTcW9nK3BYa0twUTVuaEFJcS9XSllCQlFudkloSERwdTBtSE9PQlAyU2NtV2tIQkQ0N25ydEpPdkVVWnpueVhxdkdTWEZMT0lQT09RVFk5eW5wbWtHRDk2MitBSVoxQkpGU1JqRFlnNlMvYnNuZTg4MnR6ZWgrZENiYVlnTmFES2MrdWtrblBqRjhTUmNXV3EwYTNiZDRSdWJkTk9hQlB4WTJVZTd3K1dhWTNuT2JKYU5nNWlYaGlLdFpobEpWdXllaG42VUxYVWFXbEZnMzN4d1BMeTJ2WXBOODhoUDJ1M1d4STlyMkZWb3hoZytkNk14aTBMMCtOazR2UHZzOGUvK2I3OXpjMjExKzZWYnJicldiaG5EVTM4MENpYkQ0WU5uSjBzdDc5R3prZU9aZy9IVUtOelhYcjNocm0xOStNbXpuU3RYV3QyRzQ1b3JHeXR1czZlYkxscG84WGRZMUUvVE5OV1R0Q0xyU2xaS25PVzRsMENjNEZVbVRvcTRwSnNUSTRMeU1rS0xBT1psckFLa0dSUklYTEJWdktLWDNEUDl4cGxobmwzQlBGK2RYZ0FXa2paVmRPaTkwcU1LRmtveWlseno3LzNtOCtwZWJURUY5UUp3aDF4R3o0QzFxTXNCQzBGVlhESVRFRVFKenpHUjNPY0Z1Z2dnVUlNeDV3T1JwWVU5TlplaGlIbWFOeHRlR3FkWkFudWFkNXZRTHNPck9kaWE4amZEOGl0aWVEUmorTjF4Y25xd2IrVCtXKy9lVzE1dHplZ1NKSTJhRllaeHo5TzdiaEduOFNSS2s5emNXR2w3T24rWGJmTWhZVjR2T0owRzkwNG1iOTdlcnRkdGZ4WWM5bWRqZU9OcFp0bldzK09SbjRGMzd0bEd3OUl2cmplZkhRM0RER2FYejU2bmh0YnliUGp4cnV0TVp6NW00MkFVbW82OTFLdGhCdTUrL1BiYTJvMmxyWFZ2WmYzQnZVOGVIaDYxMnZXdDdlVTdYM3J6OU9DZ2JlVmhvcTF0cjV5ZStLMWF3MXJxUEh6dzlPbXovbmdDajhrOU9EenN0UnVwVXplMXpMVDRNaHhJaHVaZG5SRTROR0w2S1RKWms4c3NKVVo1S1pWa2w5S1hFaVdVMmwvUkFrRnUvS3NRNTBEbEtrWWxQNlV1RE14Z0tmNlhzMDlsY1VBbE1nOXlsYU9NZzhzOHZuajVRMVdEcmlCR0ZsQ1BzeXFCWnBSWk1GYk1RZ0VlNEx2L0pad1VHeHpuL0VqOWFTQWNTeWhSVWpjYkl4V29Pc29NNFRPSDU3UEtjMGxUSnViSmhTQzhTNEl5UWp6ZjlOQlBtbkJSMENuYjVDWDFPSU54MVpkNHRZWmZDZVlQVVIwcno3SjZyWlpyV2hLbllSd09qNC9lK3Q3N2ovYjI5cDd0TjEzVEtGSUhia0dVZk80S2J5Wmx1VDRLMDBrQ1Z2bkYxYmFtNXczUGh2ZVBTWFBFYXpYYVpCWmYzVmpwTkoxd0ZtTHBxTmRkeDlTUGh1T081ODdDY0wxYlN6TnpNZzV1WFZxMUhKczMvSFJ0czllcVFkcEZQZ21TS00wM2VrdUgvZUhtY3U5S3IvSHU0NU5KbVA3dUgveVJmN0R2NU9aZi9PM2YvTUlYUDMvNzh2clZpK3ZyNjl0T3czdnpKNzdRMjE3eE5UdkprLzdqajJ1QmYvbjY5c2lmRFhneklIcjQ1Tm5sbmJVZzFUNTQ1NzJsNVNYNXNwcVNGcVhFa3dJcUlzZjdISkpRanFlWUVwR3RTZ3U4U0kvRVF2cGNGa0Rsbmkra1lweE9FaXN6MUFuSFJlUWNPSjVzRi9IbjZpOGJ1d2pNbDBtbUVrcXJVUmxQWkRQWE1oQmg2ZnM3Zitzdmd4YWp3c2toZ2NXa3BBTGhVd0pGc2dBS0tkRnpwaDJnc2dDU1lwTEhLdjRjQ0hxeFNIa2ZHZjhxS0NpekZhalpiT3A3RXhzYlNwYmdYT1VUOW1tYzZIcG0ybkJGYk14MTJEeDQ3OWdsNWhMOElQSm53OU9qdytPam80ZFBkZytQQjFtcUxUZWRPeGQ3VnFHTnAyR1U2cUhsREgzNUpWU1VkYm9OY0JsTm8zSEkrMVdPWlIrTVo0T3h2N1hTV1Y5dHNBcE5hL1k2dlpxakplbFN4enM4bmwzZDd1UjUrdmh3dk5HQVAyVmo0L3hrdi8vYWpZMm1xV1BwUUNPUHNhSE9pOXVYMXB3aW5pWlpxK1dlQm9tclovLzAzM3p0TC8zU1g0RHo0OVNjenVhRjlzckdGdnl0blV1M1gzbmpDMjkrOGRYUC8zQ1VKMm4vb0ZmWDYvVjJ1OWN4SEh0OWMvMnJYL2xPT0JydDdlNU5wK0h5Nm5LdDdwVWlVakkvQjlEcVVtVXFyM2Z1d0VCRCtEU1I0QldvSFB5VFNXWFhud2NxVElXWFVaSUVEMmR4NWloSzJ1TXFYb1V6c3VlQ0FIUFBRSGkrQUNSSFcxV1dWRU1qUTRWZktDNDIzdnk3di9tWFMzUUZ5RkUydmlKalZKR2d3Tno4ejBHUkxVS1pzUUJzd0VJUG5nOGwrZ3lFdktLdm9Nd2pJSVZ1NGErWVJNWW9zZmdONnlKMzVCWDQ4R0tESUt1N1ZyUHVZT1ZPc3N3RUhnMkh1dWU1b1puUmVEUThPVDQ4T3B5T1JpZUQvc0hwNFBGKy84SHVJQzdzNFRUdXg0VmxZVHVZd0MzeTR4U2FlUlJsaDVQODFFOHU5RndzQm5DU1I5UHd2WHNIbHk5QjUydUY0eWE1c2IzV25rMm1HNXNySjhQaGRKWnNyeTl0WGR3K1BqellYTzEwNkFzWi9jRzAzZkNhVFhlNTRVN0N1Tjd5OGlnK0dzd1MxOXZaMk54Y1cvWk03YU9uSnoxYnYzbnpNdllIbmMwcm5VYlhhWFZzMC9JYWJhL3UxcHZ0blJzdlR3dnREMy8zNjkvLytCQjdoZjRnTEhUejhwVk5JNS82czFuLzVIanFKOHVyS3czNTRJTFNXeVdzQ2tyWkxRQ0d0SXlwWEZIRUVvVXpVUUpRL2psaGlSSllwQ3B6SlNoUWNZWTVaWmxUSWptSVB3QlVSc20ybXBMcTlEd3dseTB2YTVFaWNxTFNTeWxWajZnN0MxUmF6R3MzWWxxWnlRd0Zxb0JjNjF4QWwyVmVnREo3QVlCRG9QUEJLaVNwaWdzN0tiUUlaYWtYTXdDQzV5QXhoa2x0ZS8zSUM2TEVMQXJiTnFEeDhrcXRvdVphN2JvRjl5YkxzS1ZrdS9NY2s0TFB1aFhSK1BUd0VBby9HZmExa0JjZFhZZGZkTm9kVGZlR3dlRm9Hdmg4TDhmTFc1MGlDc01vekRRdmdXK2tGWmZYT3ZUbUxkMnpORmpwUjN1blR3Nm1iclBlNk5URHFGanR1clpoTmd4dE5JcytmbnkwMXF6L3lBL2ZlZmZlN2l6UjRLOGNUY0tkOWJiR0c2L0dXcWZ1MmM3SjJOL3RqeHVOWnFiWlcydEx4NmY5cVIvQkxmL1dIMzMxRC83MWw5ZmE3U3MzTmgxTDUrdFhuYWJ0dFUzYk1VMDdMdHovNnYvN1g5MjgwUDc0NGY3K2RKRDQ0NDgrZXJ4V2EvWTg3Y3FWSGV3OHBsSGE3bmJxOVpvSWlPT2xoQ2FuWEZtSkVpdkRpU2dTQ0pYMUJtNmVMOUlXS0pNWVFWS2ZBZE5sOUR6SVdNdS8waWpTelNuTENERmwxZzhNNTBDMWpVRXhLNzBTenNYU2pSZFFrV3JxcWxiSXlmejd2L0dYNUNFNkJTQ1VQSW1lWVZsSytRdHpVSW1TMWY4dUtFVlg5S1hmdzlTbmxrVzdTNHJuRmhQcFExbFNwWEdHdFQxSm12eEkzblRrZVI2Nm5vU1JibGsxeis0MlBkTTAvVGpHUGhVR0c5TWdDS0s4eUNOL1dzU2pZSEMwM2JPTlBJbVM3T0phcjk3d0FtaCtvVVVGNzh2Q0FGL28xWnFPWGJOMERiT0JkMnl4U0pqYnEwMkhyeGNUU2VzNi9PZFJrbDNiMldwMDI4MmFBMjdkYmlPWWhuQlJDdHY4em5mdjlsYlhIdTRmOFkwM3BqRVlKNis4ZFBIeGc2T1ZiaDBMelNSSytsR2haYmtmQnRjdVh4d2RuZkJoblR4SEUvZVBqOFBoK0hNLzlJWDIraHEwa0dzVHBHYndnNGxCRk9ZSDl3Nm0rZkxHMnEwTEY1NzJnMzZTM3owOC9YaC8vTW45M1hBNGVlbjJiY3lmVHJmcjJHcUZMNGRQaEVldGdMSUFGcVVKa0NnT1lrY1lteVBQUVVtMUFHWEdpNENza29RUnhzRlpwU3NRcWhKS21nVWdCa1U0Q3hkMHNRSkZUb1VtR1lCcUkzRmtLQldTbmhBa0xycHYvcjNmNEZZVnlUTXRxNEJ4a1kxS3F2dFlpeFNWdFM2VEFGSlhVS0lFVkp0TFVQSVdVSWd5SVlBQlFjUFFHT0NmMC9VeVJtQ2MxUHlWcGVHYnEvM3haRElaQW1FYmZBNFZ5dTBhZXFkZHR5MkQ3eExqb3o5bWxtVnczR0Zwb2x3L1BUaE9aNmR3RkxwMXEybHJMOSs0ZUhGamVSUW1FY3cvdG9UUXpydzRtWVdmdmJ5RzVRQk1NcmVHWTV4bGE1MWF3NEdGMWpFejRsekgrakZKMHYzOVlaenFzMW1pNTRsZDVKNW5aMm5lN1hXZUhwdzgzanU1c3RuTWMzMjUxOGFrbWMzU3dzeXdEWEFOcmRXdUhaMU8rdFBaY3F1ZVdaNnJ4NTNsRlQ4SXJVTEhEdmZaM3Y3N2IzMjNhN2ZxdlpYV1VpT2FESEkyTE8vdlAzN3ArbXA3ZGZ0ay8rREJzMmZoTEwrMjNMNngxdjNNblN2ak1PejdrMmRQbnh3OE8zeDQ3OUhheWxLbjF4WWZCR3NUcFFWNWxib3VFcFRvR1ZBanFzR1J6TkxhQ0tJRUpJQlJVTm52NTJFeGR6RVFPWTlMdWlyd0E4TlprVThCSXBXNkM1Uk1xV2tzeXlQcktLMCtueldIV2VkMWQwVTN6MStFY3dvbmlYTVlPUzZxK3lLVXpWQkEyakxLbnhCWG9EQXFycDVxVmRmTWZoQlBnTkF6V3hWRWI0WmFOd2pTWU9wRFhldTFPZ0FaaGw2MFdvNkYyWk5uTTk5M1hBc3JRQlRIdkdhcGFjZkhKOUhnTUEzR2NSVFloYmJjYWVWSnNyVGNTNHNDVGpiODlxekl3amkvdXRtRmN3Skh4NnA3N1dhclVXODgyenUrZnFsSDdqRVUxL0FzVzdQTUowZjlaM3NIWHF1MkI1ZGxQTDUrWmZQaWhlV3BIL1BOTmptZlgzLzUya2FkYitvcjRpVEZWckxJdFNESmxqMHJ3ODdWc3FjenVPRDYxbHJickxXM1Zydjk0YUJkOS94Q2YzcDArdTF2ZnVQMDBlUFAvNmsvNDlidDBmR2VVZVRUL1FmZi9mSjMzdjNLVitIdHYvM2VnemdMeDFuMjlzZVA4dWx3ZmFsdW0yNlVGQTlPKzN2SHArKysvNUVaNTYxbXE5MXE4TGFtS0xLeU95SzVVdTdFTGtiUFlaUU5mQjRVc3VSVkFzdVZNUUZtL2VDZ0FNcEtYVGdyZWo1ZXNmcFVVSnE0UU11bXFwMndBQjFhV2FxQVlXQ0dXUGUvZ2pOVmJWR1JwU2FlT0NkS0gwaUJsQ0lEZ09La1FMNlRodHBZSzkvMmpVSXNXQkpVVkFMQ1RBeE51VDZvZ0ZyWWY0RTUyL09BRW56Q1hpVkl3MWJxUjJFOTA2M1pjQVNYcGJlOHpCVzhLQnpIb0MvRGQrdWIwMW1jWi9EbWEreGlsb2RoRWtTUmYzeVFCSk00bUhJREc2ZEpucnVlWGErM1BucTBIMkpXUUNBNmFNMVhibXdZT1hjRmJiZ0hkZmZSWHIvakdodkxiZG4xNm5CZG5wNk1qNlloUEpCclcydjFacVBqRkE4ZW55eDNtMjYzalgxa05NTk1URHVPZGZQcTVrcXZaVnVXSDRkTFMwdjFkdXZoazcxYlcwdmpDUE12Tyt3UE1IT3dFQzFoYitvWXZaWFY0WGdTNU5wbzZuL3k0UEhnZUpDY0hHOWZ1UjdNK28vdXZ2MjlkOTY1ZGVkYWFDOTllUGZCV3FlVnpNSk90eFZpMWVEUFhZcEVMNEk0eFhUQ1F2SDQ0UGpodzkzN2R4K3RMNjBzTFhjb0xBUWMwRG1hY3BFZlJVbkZLREZ6WklraVFvTFNENVVQS0xNNGcxVEppbEtXNWs4SjNEdlQrSUlJQTBSU1ZZcWdqZ0N4emd0cHhFaXFORkNwbXdxaUxVckZrU2RiMGpPdFVZcXVXb3hzT1VpTjhzek1jNXIrN3dHcUFPMUZWYjF3UllYZ1Nta0NtRWNNemJiU1k2S1ZEUytCNUFCaFUrYW8rT0lLb0dCUjBSV3dScm5rM2cvdHd2Um1mZ0RQdDlsdDhUVXJTZUk1VmtOKzEyekpMMU5Odmd0UzdxM3krb3cyUERvZURRN2l5UkF1UCtwTllZVlp1MkU3OW9mM2QyY1J0QmNONXlkVWJjMjh1TjZvMlVhbVdiMXUxL2ZEdHgvcy90RE5UZGZTb3poYldtNS83ZDBuVTE3NjFMdnQrbzJyRnpaaG5vK1BuK3lkUGowSmJyMXk1M0J2djJrWjQzSFFxcmxYYjF4ZVdXcFB4N09UWVFCM3k0TGJZeHV6T09OdnJpeTdmekpZWGwyYmhaTTBTQnZ0enVIaEVYK2R3b3M2NXFPSEQ3N3k1VDgrdVBmb3ptZmZXRm5kM3VnMTl4NCtpYWREWjIzMTJZT243WHJOMFBKcjJBK2tFUmcyRzdXYTdWNVk3bTZ2dEdMVDRBWTR6aDg5T2ZESC9yWHJWd3hUYnJqaVh3NGk3eEtxZUNYZGNpZ2tRYUJhUzRSWlpVWUZDcThBQ1FaaXkxQXFhUWtjV1lVaFRoMUx3bk5CUWFuK2xXNHdmZ1lMU25KbTErZFFWbHROQXhBWDV0OHRmZmQvWDhpbHROb1JLM2FLR1ZXUFVTenpvc000bE5XcHI4cWZnY0txVUFGbm96SXhLSVNnT3JZSVorUlZicFhTd3N5T3pWYVNwRUVjT3FZTmZVN2lDRjVHMDdNZDEwYTdmTmp6TE1kZUUxNDEyZ0tucG4rd2UzUjA2Q2JUSkFxS05FdVNFRk9oa0R1dmovWk9Cak1mL0dFNmFyYnorR1M0dGR5K3RyMlVSUUVjN3lBSTJnM3ZENy8yd1k5OS9ucWVKcjFlODE5OSsyN0tPVzZFcytqTjEyNHNyeTFaNGRnMnpiY2U3SzJ2cmM0bTB5c3JUYTFJOW82bVJaSjYyT1FhenRIZXdZZ0xEbHJJa2NRR05FL1RlczE5dUhkZ0dFNGVCWTVUWDl2ZW1vMU91NjJtYmxweGxBejlhUDl3Zi96azBSLys3cGN2WFZvNmVIai9wUi83OGY3UjZMMlBIK1RZWmd4bmo4Zit6c1d0MnhmWHR0cDFyRTFZM1BiMysydnQ5c2FsemNjUG5rWStPcDNhVG52bjhrWDFpaklLVWNsVVpDa0paUk1saDNZVEkzdzJja0wrN3djb1JHN0NWSUtveWp4STNUZ0k3K2Vab2tiYWNtR3dHQVNFZFJtWDhTRmdDb0lDUlpTbllJaWJRVEllQUx3V0J5QVRXdmRQVS9kRlEvc2NxR0xuUU1ncUpNOVNXUDRZVWRQaFR3YVVXTFQ2bndLY0RjOHhLcHRYUktrWjJsM2JjZ2I5b1c3enByRzh4aktuVGRhMU5NK1AreE1ZZUhtV3hnckRhRHllams2UERnNzI2M29jamtiUkRBWWVOZzgraXpFTC9HZUh3LzZNRC9GQ2dxNXJZOU42YjdkdkZrYXo3cmJ0d25LOXI3LzljSnhHVnpkV20rMTJmNUo4NitNOVNsVFh3eWg1NmZMbWhRdWJkVFBWOG13OGlkWjNMdXp1SDcxeWVja3gwQXhqNzJTODJtM0cwUVNPOU43cGNEQ2F3ZWU1dkxNMkRHSi9GalliWHN0elBubTZiMWxlelU0bnc3RmxPdlYySTgwSzdDVmcvbXVlL2Q2RHA4ZVR5Y1dWelozYjE3dGJ0L3E3OTdENUhrZUo0WnE5dGJWaTR0OTl2TGZmRDBKL2RuQThEdklNQzA1YzZBY0hwNmV6Q1phTFIvYyszbHJlMk56dXllMDQrZ0lVbndoUlFNbFRkVjNHVHd5V2FPdHpvdjkwNEt5bndsSVJ6NjNpNTZERTA2aXAyQ0lJcXB3S1pmNGlueGZpWWg0Wngyck1oUUJSUlNOSUFlRG1GZkY1OXoraE15cEhjZmhCWklxck1nUWlLUlpBZDhXbitZRzZybGFKeGZBaUtCenFsYXJQVVNnVUk1b2VwdHJFNk1KeFFaM1lZK3J5M3VvSURra2FZUTh4blViVElMRmdObTJMMWowdlJxUHg4UGlnZjN3eUhRNzBaQnI1UHI4dVhCU3dmL3VuNDd1SGd5Qko1WTRpWDlRT3hVVlA3aDJOdnYvbzZQNno0WWNQRG82bnMrM2wxbktuTVlxMFROUHY3WjVHS2IrSmdBbG1hZHBycjF4dDF5MDlUelREZGVwTitDUDk0OU9YYjI1Q29SMnYxdXJXdW8xNnAxUDNoeE0vaWdyZFBobEVMMS9iTlBYaThiUFRyYldsbXEwZDlFY2QyOVhOT0l4aXE5WVpueDZIYWJHNXNsSTN0Sk5KZ0EzdmR6NzRPQndHdDI1YzJyaDZNMGhtMjIzdkMyL2N1YkM1ZFhqYXY3OS9FaWM1bjdzRWVXRTkyejEyc3FKaFpGdTlSclBYblFUSjA4Y1A4MWwwNmVwbEtyRW9DNFlNcXFuMldTSlhjUnJMNFJTRFdRcGY1b0JnMVVtQkZLU3BGZno4cU9aU3lZZGpKZHJBZURVTkZwa0FxZ0lLenpOVmlOR1NIcUJ5eGFOU3lmSmNJaFVIZ2JJdlFyOW91OHRuWm40UWtKcGt6NE1xckFDeEJSSkdwY2F6VmlwNGJyby9uMzBlbElHcDJNcTVLakN2V2lMZ3l0dW8rN01hRk5TeUxkaHlxQWwwdGVHNWNSVHBwcG5tT253WktEcXZTL0l6cS96SzJQN1RwNEUvL3VEZXc2NVQ1UEUweEZZMVNXWkI5Tkd6MDRQaGpBL2ZRSDZjSVE1WFJrYjVGYzZvMElLSTc4aCs1ZnFGVHNQaDgyTmE3dWY2WVg4RVh4LzlHMDltbjcxMXlYT3RocE1QUjZIWmFOYnJ6dUhKcVd1aWRydlg4QnpQZmUrRDNWZGV2ZWk1cGorZVpKWjc5Mmo4M2llNzIrdnJONjZ1REtaaG1tUTd2ZnFqazM2M1ZndlN6TlN6ZXJNOW00NXl3L1pEZU9FSmZQNW53MGwvTk80L2Zuamo2dlcxbGZibDY5ZVdkNjUwbHBjbjQvRnNFcmFOZUxtSlZjbG8xYXp0MVU2OVlUOGVqazhtMDNVdHYvUDZyZE5wT01WT05zcXZYTCtrYVVrcFcwcVQwMXRFV21IS1NKbXN4SzRJR0pTS3Ezd090MFRPaHJYQ1BBK0NWemtnWm1RQmM0NUJ4UUZWUzlzUVphNmlsTmNKS24rR0JJS1psNjBZSzFJQlJmT0QxVjNxcW5SZHpleXpwcWppeWtLTDR5UjZ0OGllQkdlbFpLS2U0MEF2SHgxRmx5b29yK0lyYThFbzg4bTJyTDJFODdXd21UQU1nN1FXNXpwMFBVdHl3M0thbldhV1JNMW1reTAzclRURlpxTm9ObHpYdGZ3Z1RPSmtPT2dQK2lmOXc4UDNQbjVrNllWckdYR1NmdlJzOE5IZUtYYUgyQUJBNFYyVEp4dHpTSmZYRzFqOGVKbVdaWjE2N2ZyT0JqYUZjQ1I0Z2Q5eTd6MDdZcHNLelRhMS9zbDRaNlBYYmRxbko2TmFyOWR1ZDl1Mi92NG5EeHFtZGZuS2FoUmwvZFBwZE9pdnJMV1hldGo0WmdOd2lWTW9jWDg0M2U3V01rMGJUOU1yUzk3ai9xelRxaWN6SHo1U3U5MmJUVVpaR3VkcFhxdnhJMmJZYlUvQzRIZCsvOHQzTHE2dnI2M3R2UFNaclV0WFZ6ZFd2LytkYjUrY2pLSW9PUWlTNWFYdXM2T2hydHZSZE5veHpZRWZuZzZHRGNQcTlwWmJLMnRiT3pzT25DNE9nR283eGFxc3ZjaVZLU0xrV0E1SEZjNlJsQ0FKRWpKQ2RaTVJoMDdnZUVaVm9zcEJWM2p4N0V1UVhQVzhRb1dSbUxMY2xmNGdMdHdSUFN0YWJXb0pQT05mdVBIbExoVWJPRE8vL3FzOGw3Q28xaXhCa3lVeCtIb29nQlJjSkJFTnlHUzFrUTRwRUpZcUxNSWlaazVRWXBRMHdVbmxWWmdTU3RhcXAweWVaUUZVa3E5WDVkWEYvRFJ5NkpMb0JuejBkcnVlcFhtbjFYQzlScVlaanVNRVlWQ3J3ZjExOGl5YkJsR1k1WS92UDV3TkRrOEhwL2Zoclk5NWhmeDdUMC9pTkt2emEvR1dZZXBRZW1oenU5bnMxS3l0alpWWmxNRTRlNVoyNDhMYStuSWJtL1VzUzJxZTU5YmRKd2Vuc3lqaEY4QTA3ZTd1a2FrWlRaYzN2T0xDWGxsZnhRYWdhNmR3cHJIOHRHcmVhREtOdzhDUGl2WFYxZ1RiNnlpRmlqZGNhNHBOUlpDMm9jMDFweCtrZHBIWnRVWVFKMWVXM1B2OXNPUGtWczNxajhPZDlXVk0yMm1tdTZZeENNUGp3NU5wZi96WnozK3UwKzUyMXplUGp3N2VlL2VEYVpSMWF1NGtUakU4am10QUxQVnVFN1lBYzM2dDVRYis1SlZYUDNQeDBySXVydytDQU5Vb3lCalFjZ21Vb3E1VTRSeFVob3pSODBHc25rVDR6NU53Slk2V1MrRUFaYTZBeENzRXppb3dqbElsSGgwUkJFR2RGbk1CZ2hVYXlTaHhiTCswcDZUa213aGczWkdZQnh3WTRiUmdZeG1rUERTZWNTbEdRbWFWd2lqSmhGSUJLMUNZWE93SHR4SWlPd1JGQTBtcjB2TXpCQVZLRlZjQWIxaE9STEtIbndvb1ZSU2VsZStPckJ6Nmx1ZEpua05mWVpoZHZ1SzlpR0srYmpkTlVrd0syRXZMc21FdlQ0YXpweCs4ZlRJYTlRLzRQdDd0cmplYXhYeDh4alFjM1hROXg2VlZ0enpMNkxRYm43dTVlWEZ6dVhDYmw3WldkMXJtRW54end6QzFQQXhpcis1eDhiSE1rLzRZOWFMQm1IRWZQenZjM1IrOWVYdmp1QjlzWDl3d2JjZEpBZ1BiaVZUYjN1d2tmdFR3ck43MjZvZDM5NTE2STBsaTB6RGpPRnR2d3ltYWhYRngzQisvY2V2QzN1azRLN0xkazJtM1huUGM5T2drZU9YQzZyTlJ1TG5TMitwNkh6L2U4LzFvYmFtdFplbVR3OU4wUFBuY2ozN1JjNzI3OXg5LzU1dmZYbDFkMG0xM05Cd2FXZkgwYUVTdlRPT1BQbDYrc0pyV0cwVnFmT3V0Nzl5NWVMR3oxdVBRUUx6VWVBQXZvYWt3bHpVaVAwRHVud3JsVUJJd0pVUURvUXJWT01xNkxRZWx2Z3BZSTBqRU9Fc1pWYWVxdG94TG9venpVSjdtQVV5Z1lLeE5oUkxCazFwaEFKeko1bS85K3EraHFnWFNNZzR1NmlodFBwdk5LcTVvcEhrcUN5ekxJdk9nOEZJS01FL09jeFdTalVBelJOWnNuOHBRd3FoNEVrUW9Ddk1jY09YUmVCUFVQQTV5ZEJJZURkSkZuc0YzaDFMR1VZeENudWRnSnNCd29qZllqUTJIdzBkM1B4cE93dG5ndU80YXk4dE5LQmJzczJQYlVWYlViYWRWeDJaQVgrL1VYcjI2M1dzNFNacU53d0srZDBQbk43SWRTNCtUTEkwUzA3WGpLR3UzVzhmRE1lL1l3c21nUUlyVDhleDdkNC9pb3Zqc3E3ZnNlaXVhRFdDdFIxQnN5MjE1eGVyV1V1NDBqMmZaNlhEcUdKcnR1cWVqNlhhdnFXZUphMnArRkwvOXliTTNYNzJLK1FPZWs3eFk3M1JPWnpPb3JHN3E0N0ZmYzR3Z2pBNkgwK3NiSzdsZTNIMTJFb3lINy96UlY5LzQ3R2YrNS8vcS83bmRxeVZSTXA2TSs3UFlUOUxsWG1OenVaTlpSWmhueldickpNRFcxZFhpN01IamcxZnUzTEd3ZDZkaWxGSlZvZ1pVVXFiOHkraS9GeWg2aHRLV3E2TkN6b2RkS21LQ1dxTTBwMFFoU2ZYQWJDQk9TcFVCVWkyRHVuRWc4VE1DWWMwZ1dUVEV5czdLY016VjJ6Qi8rMi8rVmFEQUFsam9RYTZlTFlQSElxb3NrM0hPdDZ4TVBDTEpMZkYvUWxCd0RrbjVTbStsaWV5aUJBVVZEZHVEVGlNWFVEV0FNbmd4Z0FVdkpNTDFlREtFN3NOUHgvS2RXRkN2WVovNmg5MWtsS3d0Tit1TzNXM1hNYlZTWG1oUEJ5ZEg0Nm4vNFA0bnJtM2MzbGdPc2l5SCsyK1lreWhhYXRhdlgxamE3TFp2WDFwdHVQWnNGaFJwUG8zUmFjdU1BdHVsUDVmbmFSaEhCWGExdHROcjFaYTdqVFRQSnJQSU5IVFRNck84bUViUndlbm9aMzdrdFU2bmUzclVienBwVkRpWjNSaEd4YU9uUTZmV1JLOU9SNk4yeTJ2VW5jSXd4c1BKcTFjM1JOekdPSXJ2Ny9XdmIvYkNPQS9DMExXZHk3MTZrR2ZZUFdSNU9qd2ROdUdyUlBsS3F6WVkrV0dlMTF6NzRmNyt4OS84NnNzNzlVYTc5dUdEdzJtUU5WeHp0ZFZJNEx6eEduOStzZFV3aS96R2FtTjFjelBLclNMeTF6WXZyNjczc0NSaEhKV2tJVTFsemhhc0wrTHlHNmd6elBOQUI0YmpWY1pWcEFTRng0RjF5T2xja0lJUzVIbGw5UmJJcW9BRU1hbkFvbnArZG9JRlpDMVErc05RMGF0Y0JpNzRHancxNUpLbmFoRnYvK2ptMy9xYi81RVVGamxMQkdOZVFPL0pDeGlzZ1VUT2d5TGp3c1R5QzNoOWtaSTFTVEJra3BXYzJSVHAzTHd6MGhCMUJCRERoaUlxTENvbWtpSVY0bXc4NGlWU0FyQlFhckI5TW9LZXdTWnFLVDhXRS9HN3B6cC9sSlJsdW1QcjNWWWRYazFlRkVtUytXR1ltYlVRQXpuY003WGswc1h0bTVkV3VuVW5TTFNqNFhSbnJiWFphY0h6cWNHTVcrWmtPTVZZekJLTU8yWlN5SlVJS3NrWHhpZDh0YXBqbzJQd1R5NHN0N0FON2k2MWIxL2VlcngzRE5jR2ZlOTY3bkxYZS9Ua2FLMWx3RFZ2TGkzRlNiNS9ORDRlVDVZNzJIRm00TGE1dXRKdzdGaFBCc2V6ejd4NjdjS2xkWDg0akdKc1RiTkprdHVlKzcyN1QyOXRMcTkwUE10MW9KMWhHTmM5NjJRUVdDYmY4R0hiTHNRd0NoUE04L1ZHczl1c2JTNjNkaTR2alllenc4RnNwV1lQb3JTSTBnZkhvNzB4TitwMVBYVWRZMjh3eGZwMTY3V1grVUVjOVFjdTFGWVJ0RkpFUXFYNUhBZVJ0cVFBejJ2MmVUaWZLeU1yWVFHQk5PcUFiaUFHY1VwdWFWN1BndXdWejJOSXlUa2dBUmdtaGJQa3Nsb2swUUJSZlNMWkcxVUs2djdYa2EzdWszSitpSTFuU2JIdXJPd3NVQWFsNHlFWVJhUGUrWEhXaWFwaTZja2NyNDRNcW1OVllHZFVVQk9qckVWV0R4SlE2a3B3MHU1SzltY0JCYVRueURpWjVoTTRFTmlsWmpuTXZBTUhCa2xEYzJ2TkxNMHM2S2JKTndxbWZEUXltQVJocHRmcjA3MEhqeDR2TGExMVhITzlWNTlvN1lQajAvSEkzOFNHa0M5YXloekhDbnc0QmRrc3llSkNzL2xNU2w2ekhleGk0eUF5SEF1ZXVlZEFBaGsvT1dsWXI3LzJtcGZPSGg4TXdwUXYwTHYzNU9EbHl4dmYrK0QrMWJYTzZjbHBiMzNicTNIenNIczBoTloybTk3aFlBSUJKbWxzRzhidmZPTzlvWi9mMkY3RkRIU01BdTRYWmt5elVZZGo5djBIKzdjMjE1b05VSmx3Zmp5ek9KbjY2Q29mdEhSc3o5RDZmcnpkYlR3NkhLQlFyMTI3ZmZQVkt5OWZ3eVprZVdNMVRiWEJaRHBOTWM5amlNeWZCVGN2ckt6dGJQekJIMzlubzlWWjM5bW1UUGtaTGdnWCtRUVpCSkZ0aFJIZDRKQUFJKzYreXBvSDRzdXp5bG9rNE9Db1BBd1VScmJjQjVaeEtoVi90MzdlWXBiNlErTkxyYUEraUE0d3FZNVZVR3BUUmxTTjdBaUxVRE5MdmFMcTZPWnYvc1p2S0Z1dTZudXV5aXFJSUZTdWJxbTNZN1B2S3JEZGlqc0NPNlNDVkQ5WFhNcFBCZFhvaWthSldKcW9DcGFka2JJbFhsV2tpaTkwRlNJbG1acCt6Tk4wZTMrU3lmZTdlQ2ZaZFJ6VHRvY1QzNjNYTWJIek5ITnNEUnZRTE11Q0tJVDdPNTRHMjgzaTJWRS9UQXM5bWZXV2x4NVBOR1R0SForZytFYXZqUzJ2WmVpWVBOaUIra2srOVdPWDMrekpzQW5HbkVuanhEVHRUQ3Vzd2dpQ3lJV3g5UnFGWVVlRFk3NkRZQmJ5YTVWRjhjSGR2WWQ3eDkxV1EwL0NlcXZYVys3QmFjSSs0ZnZ2ZmJMaUZ2eGhoanpMMW5LZDQ5UEJ2ZjNqUC83Ky9mY2U5dzNOZk9QT3p1YnFVczNRZTkyR3BXVlBCdE8yNldEbDBVd0w3bE9RWnFOcG1FVjVyK20wNEk1cmNMZXlzUjlmMkZnN09Cei8zdGUrZjNvUy9zd3YvY3JybjNzbFRmemhhTlMwdGJXR0MwNXJLMHVUMFN5Wmp1eE80OUh1b1pXa216c1hJT201Z2FkU2lyTHlRak1IU0RJRVZCeDVBSFVaR2dYS3VDcEYxQm1vZ2h3NGpwUWFPQmxaYW95S0svVkFLUnBjTmZwUWNlYkt1Q3NNeVRnbE9FOUt0NEkxbG15Vm02NENXOEU5c1NvbDhZb1NCYzNmL0p1L3dUeWxySXBhRkt1TTh4RVloTEp1Q1djWU5mK290V2VCZUttcG9tZE5xa3RWVUhnaGxsVkYra2tNS2xRekI2RnFrbkJRcldkMXFpZUtodHhJQ1Zac3FLNTdWbjdxdzU4eG9pZ0U3NGJqV3E2WDhZa1d6Y1VlTkluaGpMaU8rTzdjME9xRDRhU2YyTzNsMWJVTGw0bzRjTHFiUjJQZmMydEh4MGVIbyttRnRnYy9CZFUwUE0vM0F4Z2hLQWxmYjVHbmRjOEJudE1nMTd4VzA3WDVNbFJvZTZyYnBsMVBnMUduMXpvZXpKRG85RHFub3pGbTRNUGQweXZyN2NKMDFsWlg0SDk3TmZjNzMvLzQrdFpLa1VUaGVQcm02MWV6YWY4MHlOQVJ6N1dPeC82VDAvRmdIUC9ZYTVkdTM3anc0ZE9qbG1PM1hjdXVZZTl0TGJXc21tM3hiZlJhL3RIdThaMmRGZFBHWXBDZWpFS3ZWbk1OYlc4Y0JycXhmM0x5d2ZmZitXdC85YTkyR3RiMitzcm1lcmRsYWpYWDdaK09qNklvbXFWYks5M0xGMWMrM2pzMTRueGo1d0lWbmVySllVQnNycmUwd1pRL296SVc1VmdqeGhJU0wwdEpmREZVdmdETENwTTVKY2RPOUFIbUZVbVFNUWxGcDlrRnZuS1ZsZjNsYWtDTUtDNHhpZ01WSFZuUUlyb3VrcXNtUXlZVFF6alFqcE9QVUpxLzhSdC82MHkzMkI2bGJWV28yaWRCZFp0eGlFQldJZ2JXWFdhVnVaL0dnVXFwTEgxSklQU1Y2cXZBUGhCNVBsRFBWVjJJbHhGVmZENi9RWUJsQjhTNlk1ckRvcDdBZE1jd3JwcGpPNTduRGNjanZtckpOT0lvckhrMlJETGhyVVgrYW1rMEdzNlM0bk92M0RqdWo5czdOMmVEa2UwNUowZW5RUndlRFdZN25acHFWRENMME9HQm54aW1YaVNoQTZ0djZVRVVRd3pOVmdlNExFMHMyNExyWCtzdXhURTJtUDUwUEwxOSt4ckNrNmVIbUZ0QmtwOU1velRONzl5NjZ0VmI4SUhlK3Q3N1RjL2VXc2FFVEZlWE83VzZQWnJsbUZRT2RvWlpGaVpwZitaLzY0Tm40NEhmYVZwLzhOYjlXNWMyNzF6ZGlwTFVxV0cxeXBxdGVzczJsaG9XOXRETnVqc2JCYmxsT1k0YkJNSHgwQ2NteXVCaUhYNTAvOC8vdGY5b2FlZEM3UHQ3VHg1NVd2N1cwLzdFVDVJOFhXdVlxOTNPZm44OENlSzEza3F6MDRMR0UwU3plVkFqUlYzRTZFRENqTXdIQ0JtVXZDajBEd3lpQTVXYnlnSEt4WW9yRGdpZ1VYaE5nOWRRbGlxSlZTaHJVZlRDcDlKc2hRZC9ZTXBKVXE0QWlBaUJxTGhFMEJmbW1yL3htMzliZEVnNkptVVdBLzE0QnVSV05Jd2dDOFJWT0lkaEtXa1oyZ3BOUVUzaUhUR3o1Q21FaXRWelFmSGhVVllWTUJFT3dvMXNKYmRDc2k2RkJ6dUpjQkthUmo3T3ZHbVV4ZjQwQ0daT3ZRRnZaRHFiWWxQYXNOWG5Kdk9hNThCdkgwMm1HWCtTQ2ozTTRjcytlN2IzMHAxWGp3NFBZUGRkcDM2dy95eks4cVArZUwzbHdXbkpzZ1NxYytLbmpsc3JvaG4ydk5nR1pCRjJoNlpYYi9CSnNoUnVzVDZleFc2ampaa1VEckU4UkMvZHZOWnNkcnlHT3pqdHcvdWZodkhSeWZpenQzYnFudGNmRGI3eDNROHdIcDk1YWN2VXpNbG9jdUh5Sm5hV3J1ZlpOcDE3U3pkYzEybzFuUDNoMUI4SFcwdk85Kzd1WGRsY3YzeHBHWE00bk0wTUd4dHJZOGtwL09tazFXcWVEa2R3aytCNFlRN1RSdXE2YSttbncybm9Ed2E3UnovelM3KzZjWEhITnBKbmUwZnczVHV1KzlMbEM2Ky85dEtsYXh0amZ4cFo3ZFdOamQ1U0Z6b2lnOGlSRTIzajZPZHlGSFZYK2tkUmkvQ0pVYlpUMlQ0VlB3dENqS0JHVmd5NUdpL2hMRWNFVG9EbnJvaW9ncFdCZno2d2RlV2dTeWoxb1Zvb0lGVCtJNDZXbHdRVnNmbnJmK3UzU3BWQ0hmd2V5TG1BSVZSOSt3RkJaUW1OZEtrTXhNR0dDcDVYc1pCUUhWYmNGa294TW85TFVLcXY4Q1ZEeFp4NE5CVjRPaS9JeFpRbzZaa3JXYWpUeUpOc21CcHhHSUdBbzg0WHlhU3dxN1p0dHVyOG9FZVBaa3pqSTdIOGkxQWNibld1YVhkdTMvem93dy9yclU1N2FlbmpEejR3Q201UEQwZCtEVlVaV3QzU1RzT01oZ3JXM1FFemZwc3lSOW8wSFF1Vkp2Q3o0SVEwZXN2TmRtdnYvZ1BYY2JzcksyNmpzZFNxWGFvWnp3YmpKR1V0ZVppdU5LM0h1MGQzbngxR1lYcm40bW9IN1lsanI5YWNSR25Oc1RGUGJFNWN6VEhzQzJ1OUR2YW5sblY1clYzSDl2VGsrUGg0M0sxN0xleFFzUXFOK0dxbmkxdTk4Y25vMXBWbHgzSU94ak1MUXkzUERobHgwbTY2VUtaRzNlcWEyck4zdi9Gdi85bS95R2F6TDc1eGJSajQvZjFqQjVOakdtbUZ2Ylc2c2JhOTAyeDMrRG9IYW95b2tkSklBem9ndXpYbGxpZzlVWmFlQWxmQ0x4VTlGOWRYWGZZb2thSkZNdjFBVU9xMDRDVXVSNHdaMVZIRmYwQlFCV216WlQ4OVYxOEpWSWtLV2VKWnF0UzM4c2kxQ3JQMjEzL3o3eEFsN2F0MFR0WEJPR2RDRmFoZXBWWlJlNVgrVmRvbWMzRk9LVWFpOVB1bEVTQmlLVldMb2hjWGhjSmhLQVUwRDZSbjVQbGFHTW9zSXRrVFZaYjFFUU9PbGxuTUlzMlBVOGd2akZNUW9YL1lOWVpKM0t6YnJYb05lZ25OOC9sTDdBeVpVUnIzSHo5ZTMxaUZBL0Q0OFpQbGkxZnE5ZnJKNGRGb2NIUnB2YWRqWTJ2by9XbWttOVp1M3pkczE5VXpPUFg4d1VkV1JHRlVhemJSaWp5alBkNDduZFNiclNRdDdIU0lxV1kzUE0xd0c1NmJUNGZZMmU0UGZaY3ZLOWJ2dkhUcGREQjUrT3dBZWd5cmYzV3pZMXFtNzBlV1Y4UGVlam9ObTgwYTNLVTBpdXZZL2JaYTJHbkVZWExqMHJwWjVNMjZGd2JSSDMvNHRFRC9za2l6ekxwbHI2NTNIS2ZSck9rUDlvWnc3NWRidFdtU2oyZis5bEpyOTNTYyt2RW5INzMvOU5sVHJFWTExM250bGN2Zi8vakphQmI5dTQ4ZmYvL0RKL0ZvdU5Fd0hqOTZ2TEY1MlcyMW9BblZoc3JFMW81SEtpSnN2Q2lKNkFiaWtMbFkzN25KbHduQVhGaHJLcHc2MGtXaGRvbFRRVlpDVEhwazBSaEpyc0p3TkRFNVVaQ0RxWEl4eWhLdmNvRmhBMWhxTVFoL3BaUmNLTGpCQTcyaUJJWkhWYW41Ti83MjN5VUwxUk1WK1pTQTRtZTFVa2VGVjlrbG1YRGlsd05QeFdORTZlSThTTk1YZytMQStjcGNLYnNZempXR1FwY3BJTldWdVNWYkJOVWtnT29JU0Uwb2FHakF2NGF6RWhXNWc1aGg4cTZRcm5tdU81eE9veWdaK3lFZmV5eUtNQXBIcDZkcnE5MjdIM3lvbWRiR3hadWVWek9jNXJ2ZitjWkswOEhLc05weDY2NHp3ZnlBNjIzd01URWJwcGNmWjgyRE1MYTltbFZlcFNoT2htRm1HTkY0c05seHg3UEVkTDFtdXd2UEp4a2RhN2tHbDlrMHpEZHU3V0RLdFJ2TysvZDNNVTBlN1BXL2VHZWJUeHByU1pRYUpsOGxXWGlXRFpQSDU1RFRPSnFOVGs0R24rd09WcHFONjFmV3d5RGZ2ckNFbWZySms2TTNYN3NSajRlcksrM04xYzZ6dzBHdDN0NWFkcDRlRDFjYWRYaFp5MjB2RHVEcUo5Z1puMHlpY0RidE5ad0xGOWE5Um1OeU9sN3Z0Yjd3OHFWblUvL2gvbURTSDJ6MDZpZjlnNlhsZGErOUpGcElpdzdySVZwT05WWGpXQTZmaXF1azZJRENLMzFROFhKb1N0TUh2SXlhRkpSQUl3WGlTa2ZuZ1NBOGhZTlM4UkpmMGxUTVZTc1FCSWxZMlJqR1dTOFVZazRrZFNFT2RmLzdTS2dnZEdXUXg5TG9BZ3AzbWVYc0NaQmtWTktRSFMvdmNPb1FneGxQOVZXTGwyZ3pJbWYwS3FCNnhaWnh1b2FxejdEM0lsYTBsQlVwQWxVanlLUWk2UktiS2dRb3hlc3haeE1BMVZHMlVDa2dEZ04wd2E0M21ubWFKMmtzNzc2RmdtcHcxNDlISTNneWVaYng4b044Z25MaWh4c3QrM3ZmL09ibTVXc3JHeGROeHdHL2h4OTlFTXhHOFBjYnBvWEsweXkzZGFNZnBSNC96OFJ2OTJGUEdjU0o3VmllNTJBTnNFMHpUSEkveVExLzBLMTV4OWdBWmxsbmFSVzVRZjg0U1RJVTMxeHQzTDUrTmRld1lKaUQ4YXcvbkdGTE92VVRiQjQwN0hZTkt3cmpSZ3ViQWY2NGJ6ejFXNDZ4MFhMNDY5cEMrOTc5bzlXRysrb3JWNklnVERPNFgrbmR4OGRmZXVQcVlEQXlOV056YS9uQnM5TXV6TE5wWVFZN2p0bnVkSHB1QWUrdGFXdW5VK3gzNjdNc096b2QxZDM2MUovVTgyUm52ZjF6UC9lalRyMXROcjJUNGNDTzRzbmdwT1cwYW1zYkZEaWZlVllHV3pSR1FqbHFHQ09PeUJtK0RDOGdZZlhCQVR0QXVabXppSkZCSko5ei9LVTZ5UlZkQWtiS1ltVFAxTDBLcEZRUlZrd2FhUUJ4YUNMeG9tWlVJY3daVXNJTy9rZC8rKytEcmdwVVVCVkFLaE5MSlZtWm1qR3F2TENqMXJKWjFEWnlSMUEwcUk4VlMyQi9wQWdDMlpDUHhPa1VVbFBwOHhBcGVHbVRVTEtVZEtma293aGtNaWoraWkzTHFyaU1BYWNsNmpCTU00cnlTYzVyaUdtYStVbmtCd0cyZ00xNjAzWnFydTRnQ1crQkt5RGtaSnBCVW14NThiLzc4bGN2M1g3bDVkZGZubzFuY0dMOXFmL283c2N1bndhbXl5alBJK2hCbE9xTzQ2SFZjSThNRTg0MzdDaGZmU1RmWlllSDBQZURscG5EZ1psTWczRVFYYngrZzI5c0haMWk5d2xydmJQU3NlSEJXUHl5VXBIbER3OVA0ZjQvUEJ6dHJMWmRuVitzbjRhaDU5Vmg3QjNiUEI1TzFydk45WTRiQk5IcWNtTnZNTjA3bmd3SC92cGFkM2MwTGVLY2R3dFMvYlU3bDQ1UCtyYVdyMjEwb2lodGRUdWpLRnhDV3JPN25VWVVwNU13YWJrdS9QaWU1MTIvdExHeHVkeGRXWHUyZTdBLzhFOU9aaGMyMWw5LzlmYlZyYldObm5ua1QvNzFILzY3bm1hdVhMMmhoaDVkVnJZSndxWGtWUUJHZFBIRklLcWlKb2tLTEN0TGhPaVNHaWtadFhLc1N3V2JCNVcxR0hrUlNjTjNyajNTR0NBbHlYcHBDcWtxMGdhYzhjOFN1dm5YZnVzZlVNOHdBN0JQUlJsZ1g5aXdLblZYUVhVZVhLcHVNSmVkS1lNcUlwR3ljV1ZBMzNMWWI2Z0p5M0xDY2JtVUJvbGRSeUFmRWV3NWJtV2pXYnRpTGtnMTk2UkphbVlEeVVrc0JaRU5sK0JrbkVDdmVIMDh5OElZRUdKN1Z4VFpVcThGMVEzREVETWg1VjBwZU1iQnNwTis3V3ZmdW56ajVwVXIxOUlrRE1Ld2Y3Qi9mSFJrNWpIc2J0TzJZWVp6VkpnWG1lazZXdVppSHZBcFEvREk0Y3BqcGNqVGxGY2J4NEdkSnhZNmFlbVRKTi9ZdVppR2dlSER5K0dqT3pDeE5CVVdEaHAycGZmMmp1TTRSUXZlZjNpMDNuSzZEWGU1NDA0RGJvVXhHWTRIc3lMTFhybTEwVDhaYjZ4MXN5QXFpbVFheDFoem5qMDdiZkZ1YTY2amczbHg2Y29HUmplT2s0NWp0VHZZYkhjZ2hYb05UcnQrWVhQSk5JeVRJSDcvMFpGakdLOWUyN1JiN1lQVDA5SHg0ZHBLOThKVzkvTS9kUHZ4N3VIUnlmaXIzL3JvN1E5Mys1UHBzL3VmdkhybG9yTzJBNTYwYUNKa05TSkt2TW9VVWxrbFNZeW9vSXdDajZxVXdxaXlaQ0xGbGVxclVaWUFSNUFUUUFaTmxMQmlLOWFRV1Fqa1FCS0pLMWJDdkt4SWlpaEtwS1Z0WnlvdWJlQStFaGp6MTZqdXFveTBUOFhQMUZyRlZTTVlxUG1LbUlGYWVOWlY4aTBqQ0tvVVVFREtQSmFJNGl3UkVwZDhwSWphb1ZjYjRuTlpqRHcvcWNCQStLaFdnUXpUQm1mbW9qclk3TVBoTkl3VEErcUFVRUJQc3hqK1FwSHpOVWw1RHJPWDhEVkthWnpFc040NERVOFBOZGZkWE50ZTIxajYrSjBQSWJWNnUvUDAvZ2NwbkduYlNtUmZXN05Objk1Und0Y3NtWHFhRjJHU3VLNExYY2R5RmFlRkJUZm1wSTltTmVzMXkvRWFyUTR2MWMvNjBQK1RpZC95YkxkT3p3ZU5nWVdQa3J3Lzl0RUxhUHlEdzlIZThlekdoWlZtMHhzTUpoNS9WKzZaV3I2OTJwMk9wcjIxcFNRSVBFNWYvWldyVzV0cmJWdExqVnB0T0o0ZEhSNXQ5WnBldS8zQi9ZUENkb05adE5TdVFhOVdXdzNZa0FzWE5tM1B2WFZsOCtXWEwvL2VOOTQ3T2gzN2ZuajEwcmJqbWpYWFd1cDJtcloxZVdzWmZzN3gwZkhCT0JpT3AxY3ZYM0VhM3NYYnIySDFnRlJwbUpTY3F5QVltaGhvNUR6M0xNaGtXQmdzRUlnbkxFR051OUl1RlJhbkRWaWRoUVdNNkQzcU90TzBlUzd5WlBUUGdxaTQwaEJKQ29iN0Npemt2L1piLzZoc0NqVlNHaVRLZEE2cDdLNHFLVFZKcFBUVXkxSVN5a2tpalpPV3FKNkRRRlVza1pLR3g3TGJJZzdrbDNnU2s3TVNwYUluazdQQXVjUjJ5alVFOUlSVFN3eUQrSWhFd3RXWStjSHBlRVpYUk10UWQyN29zT2FZVGRpN3dSU0RMa2hUN0VUaGJFUkpEUFBickR1enNiK3kybDNwOVE2T1RnTS92SHpudGJzZjM4MG1nNlpyWXlXSzRFSHIvRXJDYUJiWGJCME9ObG9jK3FGbDhWRVcrQjhoekx0bUhBeUczYnJiOUd6TmRBM1hzdzFUbXc2S0hBNTBXUGVzUnFNRzZmbCsxR3pVNGpCYlhhNFBoalBITm1acGRqaWFZVDk2Y2FYdFdrYkt6MzFqMDFBc05iMFFHK0lhNzk2R3MyQVc1OU1wSDQ1ODg4MlhlcDJ1UHhyMEo1RnRlYlB4eExUdG85TnBtaFNZVko2ZXJXMHVvVmxXcmI2NXZXbHB4dVd0emRtNHY5cnAzYnEwdWJPOTNLa1ZacjBaQkttcFo2MTJzNkduTnkrdnQxYWF4M3VuY1ZMODJWLzVHMVpuU1dtdEdzMXlGTlNJU3h5OWdQNnAzT2YwV3czOVBIRDU1VUh4VVFOSGJlRmdNVjRhUkZDQ2o2aVdCQ2tyNm9jczBRMkZYN3haV2JZRUthRWtNVnVvS0N0dTFEb3ByWnQvK2JmL29XZ3pBekQ0RjFXcnJqVW9KQUY4QmNQRm9neXFzaHhWb3doelN6VmxmVEFNNHVEeFVqOXRQTHVuR2tUVnBISXZ5a1hxRlV4WmZDRlhXWDNHRlYwVmhBbGxnU0RpRnA3c3NHeDVkYU5XcnovZU84aHo3QXNOK05zd3lYQ2I0UXRrZVFKMkViOThZRVJ4a3NDaGdlRlBrbEMzaDRkSERjL2VXTzFxYnNjUC9lWFY5Y2w0Y3ZMMEk1QllNTkxTNjQ3bjdXRjNXUERqbFh5WUpza3lhQi85OFFMNzRNRWttR1ZGenpHYU5kZFBNN3ZSdGh3ckc1NmtlbkV5bWpZOXUrbTUyQTJnTWExYURldlBoZVhheXRvU2ZIcDQyRkVRRGYzd2gyNXVrRk1VMXgwem1veXhic0NuZVBqSms5dXYzT2ozaDNDekxtd3MzWHQyZUcxN3czQzhLOWZXeHlmOS9jTmh1MWxiWCtsMDJ2V25CeWVRQmk5bHVpNG0ydjBIQjE2dFpidjJkRHgyNHRuV2F0TXpVeU1LbXFzYlFSalhHeTdYR2RkNzlQU2swZTBZczdqbEZoR3NRbHBjdnZWR3hqY25sNCtPbFVFSlhNWVJNaFJNaWNmNHFsQlpibEtxY2NkWUFFbVZZQkVoS011U3Z3clFDaGxFMFRRVkpGZnBBQlczdWtVS2R1WG9NNUMrTE1oL2hJVTJTSEZlOGdaR05OUDh5Ny8xbndxRnNGQkVFc29OQjI4cG81aFMzTklQVVFUZ3BFb3BwMFVDa0dValNDTkNVVFNzRmFGMFZLUmhiRUZwTGFpMWlpM3JVb0ZseVJObEtOaHFIYWdxUWdEZ0NMeElSRlJmV0pFdEsrSnJVRzNYZTdwN1lOdU83YnFaUEFITlBXamd4M0M1c3pUWDhpaUJGeE1WZE8rSlM2SW9HaDE5L3ZXWHZ2dldPNWR2M01CK0Q3cTI5K0NUTEFvYkxwWWcxR25BdUdCRkdJWkp4N05zdnRvZ240VUpGaE8wZ0Y2VFpYZDczWk9UMDNiZGdYK2Y4cU9VZWpJOFFTK21BWC9XM2FqeHBYbll2cnEyY3p3TmE1YldhOVVSb2lSN2VqSWFCWEhUc1picVZwU21qcWxoYlRnOEdhK3Z0YVorc0xxMkhJZnh3V0gvK3JVTDhNTU9qd2RIQi8yVjFiV2FsWnQ1MGVsMExOZndiSHVsVy85NGY3QjNPbjIwTzNCTnA5dHJuL2I3a0lTZWhMZXViNjl0YlIyUHc2ZFA5d1pqdmpCek1FdS84KzQ5ek5qcnQ2NnRibTUrOHZEWjl0cjZLN2V2RGlkOWJMU1hMdDJnWFN0bEx1SXRWWmFCQ2dSRTZhaW8wV0VRQmFqR1hSRURqemlYWHd5UVdIUVpMNlcrWlVHMXdrdFFOVlltVW1pRVRBWmE2ZHRjSHhEQVI5cFczaHpnSUdWU0JPUWtvT1V0T1VEZC94Rm5TRGt6cEgwcWo3TkJla2M0eTUwSGtPRWdpbnNHN0wrcTR5eW9wT0NGSnhPY0pNU0x5TWlvWlBocEVTbW9tbFMxcW95WFVnYU5za0JRODFKa3VnbjNCUkxwTkJ0K1ZJekdVM2dHdG0zeFZtc0JKMXNMVTdqaTJIbnk1NXNwSUVzMCt0TzU0ZFgxS1B5UjEyLzh0Ly85UC8zOEYzOGs5NkVvV3BUbGh3L3VvWGQxV0dXUXBhbHIyM21leDFuZXNPSEg4S1B2V1pMVlBCZG13YW5WdDlaV0h1d2VkVHgrZ1RYVWJMWTFHS0o5VVp3Ny9EaXJBeGZDbHNkdWh0T2doaWF6NlhyRHRlNC9PVUwwNmY3d3BlM3VkQWJQQnc2Mm9kdmVvNzNCK3crUGd5anIxcTA0aWpQZHVuSmhLUXI0dGZqamd3UEx0QzVjWEswM2F0UGg5T3ExN2VPVHdXYXZoYmFaZklEWndQOXl0OUhEZk9vMFQwNTQ0V2k1WGZ2c0s1ZXdlNmwzdXE3RFp6bTFLR3cxM09PaDN6OGFqREx0ajc3eXZjL2N1bnl3KzJUdDRtMmp4bytqbEQ2TUdwUjVVQ05ZcnIwTGVya1lsQTV3dUhHc0pzWkNMbnF1VkZ5TnVKQXhjbGFSMURJZjY0b2g3SW9pb0NFV0lDWEtVVDJvMzRpZitRWHpCY3I4MWQvK1Q4NjRDQ01WeUVBZFZKdXErVVNTc2ozU0R0RTJoTVY0R1VyS013NHFLRW9HSkhna2pTUlppQTFGQXlRaVJnVnBLbkVWeW5aTEtKdXE1b3hReWl6QzVsUjBuWmVKV2ZZQUFQLzBTVVJCVk9ha0tMeDYvYWcvVHBNWUdnL09VRzNZWnhoZVdPVTBqYkYrV2JaaldBNE1NeTAzZndtVlhlbnAvOFAvK005LytrLy9iUC9KM2M5OTd1V1RrK0ZvTWsxbkE5T0VVMlJCZHRneVlpMEkwdHppNzFTTk5NK2g4YWFwZTBiUld1NWdLQ1lqMzdZMHp6RDhnaS94MElLeDYxcEJsUEQ2b2p4emp6bzl4emtaaGcwbmh5a2FqV2VPb1UrU3pKK0ZRWllPWitscVhVL2l6TEdnN1hXMzV2M1BYM24vazBkSFgzcGw1K0pXODJUZzM3NTkwY2pTL2lpNGNXM3o4Y085UEloMkxsOW90bEIvV3E4M1ZsYVdQSmVYUnVFU2JheWpQV25UODc3Mm5VOU85dlozVnB0RkZDNnRMQyt0cmNjRkZxM01kcTNOMVo2aEpaUCtjWlFWcjk2NWZ2SEc1WC95My8vT1NxOVRjNzMyemsxdWpkQUZVUjJSY1RsOGNBVTVJdVhZTVlqWlJoTEg1d0tMbGZZYm1sZnBFc2RiU29GbnJxNGNBamlDS3BmNEVpVTBMRWtkZ0pWVU0wUk5FajRYQ1NJT1BkV2ExWldUWVdFTkFRR081cStLZGFkdUtlMEJYZ1dCQ2lsTmtVQksxRjdsRWhib3k3Z0VZVm5SQ0NpcVJReUJ3bEpJYWFJS0lxT1M2d0pQOXBsemhFZjJuWUY5VVpUU05oSUpCK0pBNmJuTzRYRWZHTGpaZkNneWlUQjJOSnJRYkRqeHVvVnRiYmU5NGxwT1hpVGl1K25POU9BclgvL3U3WmRlYnJkcWJiZElkVTkzT3ZmZiszNnQ3bUpONEtzYmJYM3FKOWhmVG1keDNiVXhoallmckE4YjhGelFpSVNQNjFoWjVycjJLT2F6eDBVd2hkYWpVbDZCMUkwR0hDT3NEa1Z4UEkwNk5xL0FEc2JCYkJadHJIVGd6OERIT3BqTW5oNWpqNEU5UU5Ic2RvTTQvY2I3anhOTjN6M3lQL1BTaGZlZTlDOXZyVGcxKzNodnNMbTlnaDNmOFdoVXEyR3IwbGhhYm4vdzBlUHZmdThCSFAzTlpTY09vaUFJWW1pSG9UMisvemdJL0NRdDd0N2ZPendhSFo1T1Buci9RUnlsbTJ1ZDVkWGx5V2gyWVcxcGRYdnQ3ZmNmYmErdTFKZVh2dmZXZTFxV1hubjlDN250UUNwaWQyRlpTZ2RhU2ZqNUlPTW91U29pZzFKaVZPQ1FJS0xHc254R0N4RWk2VHlyNmFFZTgxYVdXNWs1TWM5bHFIZ2ljTFRJVGFvbW5scXVhS29xcEZKRmhnRHIvbytJcjREdXJaQ1h4YWhQeW40cU5DTFVLWlNrK1JTZVFHQmlTZnVBTENlR1VKMlh4YWVGa2tVWnlocUlsam1xOE1vU3FNRDJzTjBVaEFMRllaRkFSVXE4VEhoWTA4bkVoNktibHU1NkRUOE1lUEZmTitETk41b2RqbCtldzNMekFrS1JhSEJPVHZmM251MTN1KzJvZjlSMjBzUnNSSG54OWp2dk8wWUdGNFRQaGFVRlBCenNEUzV2cjhOeEw0cTgxVzRWZGkxTlEwdkw2NFlSMTd2K1pOejJyR2xTZUsxR09oNUI0V3hiNTVkRWJIN0F3N0RnYnBtblE3OWJOMHpMSFBBSFU4WFdjcmZQOTFrbW9NTDJZdUJIbDVZYTdWN3o0Zjd4Ujd0akNCa2EvME92djR6dHhOZS85Y25uWHJzMG5Zd2g1dlp5ejlPTktQSkhvNGx0YWttYytMUGc0NC92N1QzcmR4cjFxeGRYZHk1djExejcycldOTEpnY0hZMWZmK082WmVadlA5eWJ4RnFyMVZ4ZFg5dmJQUXd6STBxMVJEZC81NCsrOWNkZi8vN2g3djV5dytwMnU2UGhjT1BtNnltR1dGU0JGbFFzMFhOQlNmdkZNTmV6akNReXBxVXRsMUtpSytYNGl2NlVRU3c5STF3SHFGM3l4eUR6alZrTHpOazJLWDZtY3FBUnluSnlVaXNrWXY3S2IvMURLQTI3SVExVXgrZUJ6SkVsT2laeFZNM29JcW5nRitGODZneUVTNWtyczJJZXBKTUlrc25XcS9Zc1ZLTWV4cVlTczFja0x2bklVY0c1ZWtXK2pWYmpxRCtBdHhySGllZTZqVnBqT2gxbmVZb05uTzAxZE9DVFZJWUFSU0VvdmNFM1pRekh4NmR4SEd6MDdNN0tXcTNSbm80RzczMThiNlhUZ3ErRWpXbVdScjEyRFR0Z0VQdFJDcDk5WTIzREgvWXhoYnhPRDZvL0dRL3FlaDRhV2h3WGFUU3hlQ2tEemVjNkFQMEdZTmhuY1c3bmlXTTVRWmhHYWI2Q3JZWm5iaTR0elRMK29CYnphaGFrTzB1MVFITWZIUTZ5b3NBZTRjZmV1TjdyTnIvKy9vTmtGcjkrWnpPMm5aTkJ2clhWNGpmQ1RkMGZ6ZGJYbDlzOXJCOVd2ejkwUEM4Sjg0dVhOckFYZjNCL2Q5d2YzYnB6Y2ZmQms0MkwyN3JtVFdZQkwrd24wV2d3TlBqamRxdElzKzJkelEvdVBqNGRUTkl3K0tHWHJ5U20xbDNlMWx0ZFVTQUkra3dwbGFERm9ESXV3NkZtQXBjQ3BkeG5nUlJTVnVKbFVCT0FqSVNiTUpRakV6TDZDZ3ZOWUh5aElKL2NSQzJpME9Yb0szb1ZGamxVR0tvT2RzR2k2NkpHN0krb1BvUDhsTHVNS3hwT3RUa2p0RSsyQWdWMndRWHZLWmE1QkVXa2xxRVhBeXFWcFVERkNhTGlnRG0rN01PTGdaVlNYc3JSSXozTUJnSzI1QXhxUWt0cjJTb0toUkdjYjF5N3pDS0dIVVFSL0ppbDVSWGJhYlNYTjZGNmNMNHhFSEZLSTgwWDc3bGVYRis1ODRVZlM1cTlRRGRTcTNiODRLTjRlTGhWMDlmcVRxZlYzTmpjcUhuZSt0SlNFQlZKbFBweFhIZXN3ckF3WXhMRG1QRURJR2FlSlY2OUdSZEZqUitYaERPaWdUOWF6KzB3Skl6VkJEdUhITlhwVVpvV2Nyc1pUSklraGJzTW4vbjFtMWNhalZxOTV1VzJGYVNha1dhOVpoMnRCL0ZwZndvUmZQYlZhLy9pclFjZjc0Wng2djZycjc1dHUvWHBlSGJ0K2tVK25XRFptOXNiM1pYV25ac1hWcFlidzhuczhjRW8wSzMrRkYyQjYrVDk4STk5d2F0MTlnK09HdGluekVZUDd6MW9ldzY4L0tPajA5T1RrOW5USjcvd00xOHdYWHNZRjAvdlBiaDJjYnYvOEFPT2tCb1hLbWlweC9UcHF4RlU4VkpQU2cxUlF6WWZhSlFpRzBValJwYytOMzkySkZxRWdBaGtxRERxMGdxRHlsb2NYeWdia01JZktvZjJBRWtkZ0RLZ29BckFrSkt0U2lVT3pnam1meWpXblpwVXR1LzVRQU1wazBHQmRCVjR0S0djMDZMYkNDUkgrNUF0ZGM5bi9MbEFjZ0hLcFVvaS9pSW9BdEtjVlg0T3l1YTlBSlFQVG9xbmFxUzh5emRPc3VuVWorTElNYzJhVjROYWVGNDlTb0k0Z2Y5dFRhTUE3ZzBNUENEVnNLelg3VWIzMGZ2dnhGcjl5ZnZmUHpnK2VmLzdiM2Viem9QOTAxNnJ2Ynk2ZEhSNEdrWXhIM2JudzVxd3JabmpOdklrRFlKWnUxNkRwY3pUTEp4TmtEdU5ZU0pwVUR4NDdoZ2NGNXRZZnE0ZE8xRS95S3c4YVRYY0hJNUVtbUt4Z1ZqcnpWcTcwK24wV281bVhMdTQ3bVFwZkorRC9tekN4eGp5blpYdVNxL2RxSHZ2UFQ2OHVybTh2dDc3L3IzZHdlSHd4clhWUi9mM1gzcnQxdEd6ZzNzZlB4MXB6c09uZzVldmJVUHZ2VWI5di90ZnYzd3dDSXdFdm53SWd3NzlXZXRnWDV0c0xDMWZ2Ykw1OFNjUGpTaHUxcTFtcDl1cXUwdU8wZHRhZmZUd0lJMmlHMXZMWnJmWHVIQUx1a0tCcTBHWjZ5S0NxUDQ1akFTSXZvcVhJMVVPcUV3YkdhWnlhT0NvbDV6THVjT3hnMDZyVXFXR01FQTJKQU1venVpR3hGVlZ3cUVLQkRYM0VGZEphWW41RjBYZEZaUjVFaFFOTWVRbklDaXlxNDU4TUpwWVJTSEZWQkVCa2xXQmFpY0Uwa24rcTVWRXRWc2k3SjVNK3JLZkJHN3NwQzdocVNLTVZ4SEdGU3hnRk05NUVHZVJMRHZ0N3NIaHNmeWlPakpoMUcwWDQyN28vQklUQ0R6YmlvQ0gvODV2anRraTd0eW9OZjNkaDd1N2oyZCs5UGhvNEhxVzIrbyszanZhWE9yWnVqNmUrQU0vVms4Q3d4M0MwbEd2MStHeU56eCtXVDR0aWpDT2pUejFYSE9NZmExUjJPS3dtcmFqV3lZYW5tYjVORXpoejN1MkhXc1pyQkRXRjhmRmV1TnFscjI2MUZscU9PMVdJL1luMkd1Ty9maGt5bCtYMUZ6ejhvVmx4N0lmSDQ5N2RXZHp0WmNaTnJhdEh6NDVlZXVqdlVhbnZiM2laa0hrTzg3Ly9QdmZYZXIyWHJxMTQzcjJNYTlORlVtbStVRmkxanJYcjE1QXd4SmQrN2QvL0wzSHU4ZFluVnNONzhyTzF0TmhjdVhTaFNTYXZuWjFjNXdsQndlVGNEcStmZXUydWZVU3VnZmhjbHp3ejlGVU1RQ3ZmaWhKcTFBTnhKa3pveHdiTVQyZ0VHT2tSblplQnVYVndFUGpvYWFrcVBCcW1rbE5RTkNwa2FRaXFXWUZxMThNUXNleStKK3pBdmR5aVZGaERuUExPcDlTRE9BN3A1R21JMWZxazdBQVphVWxwY1FYU0hJdHoyaGd3TGtxaXlCVnNKMkxZUUhLdXFRQmRIVXFtcHl1OUtlc0R5cVhFWUFzYXJwVmJPOXNPVjQ5UzRzeHZ5V1pobEVBb2w2N2c0MHIvT2x1bzFNNE50OWZZUEFaWXR0eGFvMmxrOU45YkI0MVBjRnVkUlRsNit1cmZwTGRlL3pNOFhqZmF1b0hmUHdTVEdwZUdJYW03Y0paaVdKc1dEV0hFNnFHN1NCTWZzOHo4cXp3K1V2VUlnbmhrbVM2eFllS00zZzRCZDlLNEdvNmJENi9EbXRhMHlESThpd05ZbzIzVTdNMGpMTTQ2ZFQ1Y0J1S3YzUHYyUXpiN2lCd0hSdU9DbVNZaHVIdGF4ZmYvTnpMc2E3Lzg5LzdacFJaVjY1dDhoYXZsbi8zL3Y1WHZyLzM3dDJUVlZlL3VlRmR2OUFaanNaZitlTnYvcFAvNWw5KytXc2ZwSDd5QzMvbVI5NTQ0OXJEazluYjl3OHd4dzRIdzY5KzdaMU1kOEpwOEJkKzZuTm0zZXlQb29QNzk2Z0lGTDRvRWdMaTlCWGwyWXovUFVCSjVlNldvSVpQUU9GVndBZ2laQVdEaWxQZkZJMGFSNmlSNkZRNTdxSVBURmVZTWtpcE13NFNZUkI2ODVmL3pqK1NLWGcyRnhuSVJ6cW5MSEhKUytYS1RFWFhHWmM1dzMrWnVDUm1TVmJEWmdBamdtRzBJaFo2Y2hBVWMxbEcxVVVTRUpORVVUT0dPR3VjbHllbFlpK25nbSs1VVhRNDBqaXdUdFdPQ3MyZnQ3QjVXcXZWQ01JNDlFUDJuSmZZc1VSRHdjeG0zU09CWVh0T0RidEVDZ2U4VEt2ZTZ0V2I5ZWJLOXYxUFBvWWJ0TkpwMUd6bi90NStFR2UwMXFZeGd3SFBVc2Znb3pGeGtqaU5KaXk5bnNhdTUvQ3RsQVgyQXBiWFhpNVNUSytZVzFRTWRsRlluc09IdmZSaUZzVHdLUGhsZXAxTkRBdTkxZTVNL2JEZWFLQ2pVUmpCYmc2T1RrSXNQMXErUC9EUkxEOU91bDZ0aVAzOXdTeE44OHRiUzgrT0I1dTlua2ttMnNucCtEc2ZQczNDeUhXOWQrN3RXMFhScWpzWHI5OTg4TkZIUyszMlVzdnNkTHZvTjJ6cmRPYWZuSTd1N28zdTc0NG1zOW5KWkhaNjNFOE04OXNmUGpMamVIQjZkSGxyUzdPMVR4NGV3amZiZnVuMXRONkJTS21wSWxzNWNyVlNJNkZHa0NxaEl2UTBaQWhrakVwZzdoeXA2RGs2YWpqVldDbU1US2NxV1VVRVNUenBKUi8vaW40UldHMmxPQXBJaGhMZ2dMSCtaWFZYVlVBeXprR0ZPYytWN1M0SnFiZ0xtZXBtZ1VvaFVrb0htT2Y0Q3A2Z0xqa3BHbFZYdVg4bmZzNjVKRDdEeUpvbmdZckpHUDR3TFZVMU1qMDRTMGxLWXNvV3pKRXNHdlg2N3U0Qkg3NHlZRDF6R0U3TGh0N3FqdTN3aVVjdGgwYkN1TU1XRklZRGMreDFMN1RXZHI3LzVYL2Q5bHpMTWg0ZDlBdk54TzVuT0FzNkRTK0s0bG5FbjRTYTJBL3hvVjlzQnhyeGRJUlpBVjhGVFFBM3E5VmV1M2pOUHpxRWtxRXBKdWNubGhwKzZHdzBEZEF1MjlSdC9wWWlqM09yMmFyQlpZR3ZCV3NmaFVHYVo3UGhDTXRDTUtQdkVZQnBuaC8wUjVjM3VudkhnNmVIZzlkdlh0ZzluZllhTHJ5ZzFaVk91K0ZONHpnSzR3dXI3ZmNlSHRZYjdzczNkejc0NUdIUGRlNSs4dkhGbll2cmE2M2xYdnZlOGJoYnExL1pYaklNYlJ4bFM3MHU5aGhYVitFNjFiYTJWcjkvLytsa1BEMCtPUDdabi9uU3ZhZTdreUMvOVpuUHA1MVYwVGFLdEpUci9Dd0R4TUNZUXNpUUNaSWxWRnhsQ29FaUJsb2g1NHdrc3dTRmd5OUFaU3YxbjhCWDZhdUNWU2xwRnppU2hpcW5HQzZHQ3NyZGdTcXZRTVhubU1Wa0dhcjZWRE5SZ1FTdU82b0ZjcldFL29Qd1p5aDMxaGhVQmxrdVVFVE5CNVpnbzJUcnpmYUFpV3pBdWNYbXJrcHNCbzRNb3JscWVRTGdLSXBkdWxXSTBCbW5rMWtSQ0EydGpxd2s0Ty9XM0hhM2pSNWtHUi9Id1Jaekd2aHhEc1pZLzNYMHdhMDFMZGN6TFpoc3ZuWU1UWU5ydkxLNnp0dENhVHFlK1d1OVR0MjFQLy9HSy9Cc002a201SU9WYWNPeWdzbWtWVytFU1I3RmZLZ1k4eU1yc3NIeGNiM2RkVDBYTzgwZzRhTTVTUnJ6RTZtWVRJWVdZY2NROGpFMUxQbHBFdFhjR3E5U1FvQnhpdXBCaUoydHhaNWxGNWZyTmJtRzZVZlpWOTdmdTc4LzNEOGRIaCtQSU41bmgvMGtTbXpOdkhKaDdmWGJWOForMnE0NzJCQ0g4blRrOVVzYnkwdk5uWjJWZi9xdnYzRjBQTVgyb2RsYithUDNudTRQd2l1YlM1KzV2cjYxM0h6bDVaZXNUcWZyZVpzdCs1ZmV2UDJqWDN3RFU2ZS9mL0NuZi9SeldSR1BCNmdGY29aeEVpaEhqWU1EVWF0QlY2Q1N4RlJFejBGRnoyeTVTd04yY3N1TjJpb0Job1lxalNGWmNGY0VGRWFLRTVSeEl5TlpOL2pZaU9BQnBVNnFZbXh2eVFHbWxBVXdha28vcEQ0Q0V4VmVCWVdmdTFselROa0lWVEZBNG9BU3N4aFVoM0NvaE1LR01qQk8xWjl6bmdlMis2eWZaVVdLWGgxVnJrcFdOY3dEeGtneHdSSFdONFducXhYWGIxOVArTTRON0F5MVpyT05YTGpnWWNKdm9DS09mOHR5TXJya09vd3NiREU4NVoxWFAyKzZGbC9jb3VYdzdyR3gwNUxnYzdldlpDWWNFK2NVVzFHNDJ6bHNid3p0dFdxMUlJNDllU2dOcmc1YytlbDQwbHJkeUUzYjU0WEx5QStwNFVtZTExMHJoZmVEQ2N6bjE5QVBUbDNNQTNnWC9JRkpGTUhic1EydDd0bG9xMnZxbjdtMnNkVDBsaHJ1WURyRERnRDY5K0R4dmo4YmYvSmtielNab0M0VTdyWWJKMU0veVpOYXpUdzZIV0wvY1dHOU00bVRWNjlmdUx6WitaMnZ2ZnMvL2NGM0h6N2NHNFRSNzM3Ly9qLzdvL2QxZmdQY1dPdlc3cng2NS8yOTQ0N1h3RFJlYVRadnYzUjVQSmx1YnF6ZHViNDltZm1VNFZ5ZUw0QWFCY3A4RGd2SmNvd1VqWUFvU0psUVVUbXlDdUZmcGxCVTBVanQ4OElNaXp4VlVHVUFKUmtLVXozT0JmUFAwM2RIVERqQ0daTTV3eXFsZ25QQTNUUUNZbkpVMDZPYWFveXdWSm1oaWd1SGlxRUVaa0xCVldFeDRkd01TTzAwdjhTcExBTFRaeWtDM1FFU0NpKzEzMEFCbUFoV01nZWhBVzFaSCtNb1V0WUtYNFR2d3JQN3g2ZXdsVUEyNi9VZ2hKYnlnOXJNTm93NERhSG5wT1pDbE1kcDFsalowTUp4ZnpqeGc4Q3lyQ1FNV3JaK2FiMW5HY1greVNoTTBtNnI1dEJwS3FEVHJ1Y2xzeW5VMTRZaDVhKzN6RGpYbHRmVy9kUDlXY1NYVHNaeGJwdHNCamJ0VWNaeHNlVUtLUFlCelZZelNBclU2RGxXanR3ME5kSUl3ellhUjY1alhWcHJyVFJyM2JwN09nbXd3V1ZQK2NKaDY5N2pvNnViUzZnT0xjQ1MrTmI3RDM3azl2YnUwZkJ4ZjdyYWFXOHV0NW8xcjlma0MxUXp6VzQybTQxR0RaT3FYWFB2N1Ivdjd4MDhmSEpZSk9tTnE5dWVaMlBuME5EVEIwOFBzRmZ2TG5VKy9PQnVwMWxiL2R5ZjFsbzkxRmRLdVpUcm1YUTVxT2lIaXA4TDFWQUxvQ01xZWNZS0pPcE01U214MEFjVklaQ1VBLzRjZ0RkS3FpUHlpVkYxS1MxU0lOVXRjak4vOGJmLzRVSytnQkRORzZHU2tsYTRzNWFvenBUWU9UeVhYcUFwR3kxNnFPdzZjcVd0aWlYRm85bzdEeVJZU0lvSVZYRVdRRnp4SjFNcFhoSUlEUW5FNmhOd0pJckV5RzIxV3o3c1k4SzNwOXEyN2RacU1LZzZWQWZlaTZiRHMrRHFDajhiU3EvcENWeDhYZTlzWE5qOThKM1paSndrY2J0VzR4ZE1iV1BRSDZSNURrNTFoOSswcVRubWVCWTJ1NzNSNllsakdVM1BvK09wNjRFZnJsKzgxTjk5WXJtMjNlaldtcDF3TXZKTUF4c0ltaGk0UktaaDZ3WldEOHVyQnpIMkZEUllLSm9udVpiRU91eDlrSGkyMlcwM1czV1hyeHhPczRFZncvK2Z4dm5lNlJpejhFS3ZpWTVaam1VNnp1OS80LzB2WEYzeG8yajN4Tjg5SEd5dExxOXZyWDduZzJkWHRydHB3STlRYnF5dndPVzd1TFpzdXJibWh6YzNtcFB4Y0sxUnk4UEF0ckNMc1Y2L3NUbnk0MWFqZVcvMzBJb1RvN25xN2x5ZmF4SkVxb1JhcGtXNnBkS2RCeEJ5bEZXT1NKNVEwYUh2UEo3VDBCS1FvVXl3U2lpRnJhb1ZtSE5id0JHUW5JY0tFRldETDM3dXA4MUtVYVBua0t4ZnhXRlpVWlpKK2xsVnhjSVVjWWhEdURKSW15RUpBZ2tVelR4SUtiSFo2dTZEMURJUGNzT3NySDJobEFJaHdKR3RVTXVaeWtYdFZISHBGRmxXeEd3VmhjZ2RRcWJwTisvY2tQZEg2MUZlMkJZOEZGZmVPMVBRcGNGbWdIZnUwQzZBYWRDQ0dscXRmdm1sT3h2ckcxcVdqYUZnWS9qOHN5Z0lQVk52MWR6K0dPYVdqOUNuU1JKT1E5T3A1WEJUV0ZJZWlJeUNKQWgwcCtZWlpoakcxMS85RERSNzZrZlRNTVFLdzkrTzhBSmNobG1tYTloSHNOUFk2OFIrQ0U4cDVyMWVpZ2V6SXBYZkdSWnh0dEdxYmJhOTdVNjlnVzBFbkh2Yit2NkRnNFBERTB4Z3JER0daZStmenVEcmQ1dk93Si85L3BlLy9ULytzei84SDM3dmE0TmhmT3RhcjlkdVFSSzNMbSt0TExjK2QyMXI0QWZEV2ZTbE4yNFZXYkN6dmJaVUx4NGRuWWF4OGFVdjNIU2MzTERjU2F3MWtpR2FBR0VxMlVMUWRNQTRLS1Y4T2JxVlpTbHB5amc2Z3owN2hJa0Jva05SRG9RRXVYd0RCS0R5a0dVY2NhQUhKUFJWNEdpck9BU2hBbmVMMWZnQ0ZNOFhnVmFmamduajVpLytIVDRpcHVwY0pGYnNHYWwwaGttSmtTL1BUTEVDTWNDSUNnRXAwRzVWQkZBU2swd2hDTUNvQUZBU205ZWkwRkQwTXVNTXpsaElRUlpRSEJRd0xrWFV0RkdIRWxSYzZGVjdTR3pvUzh0THg0ZkhjSkxoUzBOcm9EWitHc1A1eURLK014V2VEb3FnYjNBcVFJNXpZMjFyYVgzaitPNEhXQW9hbmcyUEcvTTBTOU5PM1R1WmhQV2FpNlhLYzYyajRRdytTUlpIZkJZUzFoa2JzWXcvalhVYjlYUTJHazluVzVldUQvdEh2aDlnV1JqNUVhOXA4bFdyR2x3YTIzTEhRWVRKaDFKcG5EaHVMWTREUG1MSnkzN2EwbEluaVRLdzA3SmtyZFhJOUdKemJYMk1EVUdXRGFmWWZ1UWJTdzA0U0I4OFBHaTc1azYzTmdyVGsxbDZhNk56TUJpQitmRmd1ckhVZW5nMHlwSjhmV1ZKejVNbFIxK3VXYWVqQ2VidjlaMzE0WGhtbWNiTkc5di81cHZ2Zi83em4vZHExczdGelpQWVh1bTFqY3V2OG02Y0V0MlpaSkVVZXdhcExrcTdBdW91RU9lR2NxR3NLaVVNaEcwSkhDTDhDNDU1Q2p1UG8wZ1Z4QlJXU1FWRUttNUF6WXNpUlVyenovLzJmMElYa01YT0JhRXVJL1RMeUU0dUVhb3NNZnc0eVJRbmpsZjlLc2RERldRdU1CSVFCNUtUVk1na2kxMEZsa1hJdkJTTk11Y3NMVkNlQkpDdGtsV1J4VXpFbVNSYlJja1dLQ1FDZjRna1ZISmtjVWJvdXVnRzdLNmZSTEFXME5RTWVwa25jREpTZUJUeU95cFkzQlRTQTNuT3g5UnI3YVc3My8zR2REYUJDKzVxQlJ5TFdSaDFHODR3eUxCYmhiOVJkeXpvMy9yNnhrbS9qMXkycDlEU3JJQ1QwMXRaQzRhbmNOZ05yNEVOd0d3MHhFNDBSbU55RGR0UWpJR0Y5dkJpamhFbnZNeVE4N2ZtM0Z2SG9ZL3UyS2JScXRjdzl4Smdvc1IwckNqSmVwMXVaN2szQzhJNFRZOUg0eGJXanlSNWNES0dIQzkyTE0yckRZSzQ0MW9YTjdwWVBtcXU5Yjk4Njk3N0QvWmZ2N1F5R0U1ZXViSm1hWEhEYzljNzliMlRjYTlkMzlsWm1RVHgzdkY0UE1zY3I3ZTZzN1c4dnZtOWQ5NGRINTZzM3ZwczV0WWhOQ1hIYWl4NFphYVVxUUJVclJTeTBsYkVvUUNpSWlWYXlGV1JVcUdwRjBJcGNSRVlNOEM1WWs1VFQ5S1NOYUhTbjFLUjVzMVFQSDhRUU4xNTNSMmtLS0NhVWYwTGlPNkpzZ3RhblZYdWM5WElzUUxPSC93TFQ0S2lQR3Z0K1RObDlEeUhCYWhLbmVNbTlQTWdTTXdyeGt1ZU9Ba0c0aEFVT3lGQlpxRFFBTjF1dHdhRG9XZlpmc1I3bVk1bFkzZUlQa0hWWVRJMXVOZW1BU09PZ3FacGNTblY5WTBiTjJIWGozWjMrYkFCWmdBMm5ScGZUd0NYd09Pejd6Q3YvRlZVTUp2VmJhUG1lYnk4b0puRDZhVGViSWZqb2V2QWZkSjZxNnZqdzcyczBPSUVDN09HZlc2V1pyYmpRQ2xUVGJPZE9scmdtbWJDdHo5bGFUakQwb01tOFNsS3VDcjhCcmY2WWpLV2c5cjYrc3IyY2djYVA1bWh6bkNqV3pzZSthTnBkSFc5dnQ1Yit1UmcyQjhHUDNKem85ZTBkMVo3VDhmeHlUaTR1YlYwYWFNNUhNNVdWeHJvUkdGaUsrd2ZuSXlidGM3ZHcyRXl4a0tSQmtIdytaLzhlYlBSeEd6NXl0ZS92dHhzdVpkZmhzZ29RNnF2a21CNUxnZWhFaXloRkxzQ0dRQ292Wng0S0FzSVNDSHFPQlBsYVE3bHFLbTRIQ3ZWSjZpNVZTWEJTQkJLRTBRenk1bURUQ0dpYzh3QUl2YUJsYW84VmFBNktXSWNKU21UdFl3ekFxdVBVZWFSRWI0OWhyNEkyQzcyR0tDS2daVzBtQ2srVENaWDB4RkF5dFZBY1ZiMDBuUXFHYk9rb0tpdmFvd3dud2NpcTJhb09MMDhHaCsxS09tTDcvem03VUEwWGpqbjEyL2ZpSXE4VWF2UDRqak1FZ2RPUEx4Q0E5WVZaYzJrTVBpQWpjbDNrL0haU1MyM2wxYTJYdjNNOXVVclU4MStOSmhCb3crbWdXZnBsa0dqNjBlSjY1ckRmci9XYWdaQmxNUUpETG5wR0hYUHVYLy9YZ3pmUE0ybm8yR3owME5uK1I0Tm80aVNWTE5jK1A2VElCcjd2bWNaSm4vMGpSVW1DVU0vaWFNOHpVQ1laRmtzdnlGSHMrQzZqbUpzRmxKZTBvU2wxODNMVzZzdDEreFB3OU54Q0lhRGlmOWtmK3JQeG9PcC8raDBOUFNUbFhhOTd1Z1hsOXZnLzlHamcyN0xpNVBvMjI4L204WEo4VFRlRzBXTmVqUEIxdGl3dm4zMzJVdlh0OWU2M2lmZitNUGUwdXBYdi9tdEw3NzUyWU5QM29PL2hkRXJ4NEpTUnhTQ0xvZWU5d2ZocW5NSUJDMmhCQW9laXpkcDFBaXFVSTZVWEwwdmlYbGxuQnhrZktRV1Fua0NuUEdzWUk1UnFxdThmN0tsZG1GeExxL0hxeHJOWDZRelExSXBCNXFLdFlxd1YrV3BYSTFLaklBMGFKNVNJRHBhVFNtbTBYcWdGSGNWR0FmWjNEbFRIRXFqSy95VkRRWk82TXQ4WnFvMmxIQVdKNU96TE5aWUJmeURMZm9McWFvS3pvQUNCWUZwTkZ1dHc3MERiQ3JETE1lMkQ4WmVSbEtIYjJQd0pnOFptUmFHVzAvbEVSMTBxdFhySFh6MGtXUHdEY2Mxazcra2JqZmR3M0dJcmFOakdmQzhMZHZKMGhqYlg2ZzdDc0NCVDlKME9QVTkwNER0YkM0dEYxZzFFcFRMK1c2OWhtczREbis2YWpzUk5zdDhqTmZFYk1Ya1FiUGpZTVpiVHRpem9tRkppcGI0Y1JyNnZDU2FHb2JqMVREQVVSRDBYTjBQay8waERyd2tYN09NYnMxKys5a3d4ZVkzMHkvM25DTFAvVVI3Y2p3S292VGxTK3NieTgxaEdEM2VIWThDekhhNzNhcjNtcldMbTJzZjdnOTczRHhreXcwcm5renNadTBydi8vVmphMjE1Yy8rQkxSSGhvK0N4UWxESXhaS2hrbVVRUlJVeGxYa1QwT2phRGc2TkRLTFVCYVVzaXFuVWdtV2toekp4WW1sRWFubzUvaHFkczFCa0RpcHN4eXhJRllqWDZxN3drdWJWTVZ6TFJiVlVhMHQxWWlrbkpxSUFndGVVbTYrK3hXMUkzZE9NdVlTS1FWSnpHd0JWVjRGZHFSc3dweGFXQXE5S3NKdVNhT1JGbGtnZzZCS0ZRYnE0UVVNeHBFdG1WQlpSU05ub2xUNU9ZaVVpWE5jTE9qbTZjbXBLejlXaXZYY2dFMkg5MEkvQkQ0MVZnYlllMVJCVTViQjdEdHd0czI5dDc5VHBBbTYzNnpiY0tNZFhVdXhzbUczYWxpdVplU0dIVWNCM3dDUE9yQ2NjRTNScHhFZnNPSFRZSVZWYTdXRFlSLzhVUlp0V1Z2cVpDYWYySWF5eGdsTk9OYVhKRTBhemRaNE9FREQ0TmFZbG9OK3dMU0Q2Mmd5dzFhWXZ6NjBQUkR6OHFpWmRHb09kcks4V3E5ckxkZnByYS9jM2VNcmJ2cWoyZTN0SGphNEdKSjcyS3BtdksxMWRiMjUxbXQ3bmQ1d01tdlh2WTZyWXcxREwzb3JuWHNQOTZGYlhZOVRkWDE5OWU3RCt5M1RYZjZobjBvTjN1R3R0Rk1HUWhRTHlYSThtVUIyR1pDSElNT2g4cEJrZ1JJdnBWUUc4TFJKb2hka1JRejVLM3AxK0JSUXBDK0EwazhFeVM1cG9JM21uMVBxWHRXdEl1aFF5VWRxWVd2bExFZWlTS1BDUE1YdXFZNHBQdnlIMEJXSEY2R2FiODhEaTFVQUNvUVN3d0lNS3JVQW5JUmtCc0ZJMWRKSjFXU0pWb0N0SjVzSFdpaWZ5b01BU0VpMjdVNW5QSjFHdnUvWWZBbHZsTVo4S2xKV1EzWkhwK0pqU3JBRVJKOUFNKzN1Mm1vOEdzUyszMnQ1UlJaaldZaFNiVG9ONnE3VDdYakh3eG1XaTdnd2U3RGNyTWVNK05NT1BZaUNYcU1XcEhsM2VRWHV1MjFhMDRoZlpGMWI2cEpLMDJPKytJYS9CWUYxaHd2bE9ONXNPdGF6Sk14UVA1L0U0QU9icG5FNm5CcDhseFNmdTRRWHhwdTZ3YVR0ZWVoeG1pUzJaYTgwYTF2cnkzdkhRejY1Z0I1bVdkT2lZWHJTbjhWcGR0SWYzN3l3MW5RMHQ5N3drK3p1MDZPYXFmUGFrcWF0ZFRwdW8vbmV4L2V4YTJtNitzYkdsbU1XSDczLzBjcy8rWE8rWFM4bENqbkxtY2xLUVJYOHladkY4M0NtK2lMa2tyZUNjM3pLRVY0TXlrZGx3UmVEQW1vTEM1S1JqSnR1L3NKdi82ZU1rd1BPbGYybWMwdFNHRFFPZ1NnRWMzaVFrMkI0NmFJSzRzL2pEODZaY0VDTWJLbGJaM3g0S0lFZUcra1ZONENxK3ZsQVJpcElNMlFHVlpneWxBQ2VwQkhtUkN0aG9TSkpBZVppa2xLb1gvSVJZK3VnNGZuYTZzcDRPcHROcHE3am9CaHZRUnA2RmtlODlpNnV2MjQ3WUk0VWlrRFI3UFp5dmRXS0RoK1BScE9kemVXMzd4K2FyaHZHU2JOZXMrRnE4LzYzcmxtV1YrU3U1eVNZSTRXR2JTY1dCMVBQMDF4cjk1Wm5vNzZCS29vOFRMSk92V2FKQzVFa0tVd29QQnAwMW9GMTVTUDU4U3pLNDV5dk5xaDdIbG9BcVhJNm9mR0drZkVyYXluSWRMbUtDbFpZQXJCcHRreXQ0WUdUY1R6MjBjOCtkdEwxWnN2TVR2MXNFcWZZK3ZxejdPcG1TOU90YVpKOStQaHc5Mmk4M0t5MTZ1WnNOTzcydWxOL3V0K2ZMamM4UFVzYlMwdlJkTktwMTlPdFd6SytWRFJ4VVNoRGdCb21TWmVqVUFYS1hGSEplSlN3cU1vcUJrd1pFUmFNQ0RNd1FaSldSaEx6VUZhbGlweWhrVHBMS0piQ1VFWlo5SnVBQWl4VEFlaWd2d2hDVEpEU0RORFJFdGdUOEtzQzlQMk1CZGlXbXhKMkExQ1JaWHdLaXdITkI1eHh3MW9HQzRvS1dPTkNxREJWV201WVNKQUtFVGxidVVwS0JaaXh0T0tNS3BwelVDVzVnRW9kQUlqMHpzdDNMTWZFN3Mrd3VPc3lUYWZaYXFmOEtiYUIzU3FmWllMRUxNdkFibFJlMWRTOS90TDFIL3NQdGk1czNOOGJRdTBHNDZsVHE4MkN4SS81Q2o3dUJDeG43QWZzT0grVVJIR2dtQTg3bjZaUkZKdU5OakxnTW1EQ3pjSUlRc0dLNG9qWDdwbDZFa1ZoR0tWSnJOdHVidGNtbVlFSk04UFdsZnZWRkZ1SURIeFRURU5PUmN0eDBCSHNFTEFWY1J4ZXc0SElRai9zMXB3YXRoT1lGWnJ4MW9QRFFWalUrT2w4TGM2MFIvM3gzakFKWitPRWQ1aTFmaEI5K2NPbmt4bVlaZUY0d0lja2RUMDNhNGVIQjlnNFkyMHBUdS9XcVJQYzExQ2VWQUNLamVFNThaNEJjMFhDUXJaQVZ3M29PVkFZcFNGcXdoQWpoZFFRbjRXU21KelJIYTY5QzBGdFdGRWJLQldnMGRDWnVUT3oyQlR3S1k5aW95VlZBY3FUbE5vcXpaRkFRakh5SlcxMVFzV1NRRkE4ejRETmxNNndxS0lSbmhoeUZaaVdHYW1BQkp5ZGdwY0FHZ3FmdFNLTGxDd3VwVlJCaGpJdTFRaE4xUTdtS3FCWXlFSFI2MnNyeTIvLzhWZWF2WldZc3dsT3NvM2RhZ1FhZU92UWVONys1RnlTdTVmSUw2eTFpNlA5by83ZWt3UUtyZk5WWVdFYzFXd1lWeU5MODk3SzB1Q2szMmsxK1BuNUdGdkdBbnZRV1JCYmVtRTdUYmZaQ01aRDhKUVg3Mlc5ZGd0anhYVWcxVnhhY0gwYVJwNXQra0dvMlM0OG5vWU9NNjY1bHAzay9Fd3lSaEQ2YmRXYUZqcHBXa2tVdXR4MUdIbktONlRCemZFczNnNjJMRjduZ1NlVkZQbkJPSmhHZkJRT1RiVk51OHVQbXFXSEkvL2gwUVRyU1Zybys4ZWpyYVVHYW9UajlQQndNdk9qZXFzNU91MFBFOTJDRzNiN0M1SFRwRVpCWkNJZkFBNUtLMkFMWk9BVWxrZjZDU0pka1RCQnRyWXFvU0s4dmdOU1lRQXFVYUpLQVlDUmVjV1ZSQW94QTFrcUFwU3N6QktSUUx3Y0ZiRXd4cG10a2lxME05OTlBWVNvQk5wSTBDbFFOcEpzNWlpaFhpekF1Uzh3NzZFQVNjbzZCWEF1dVNra3drS3Vxb0VtSEJIRlhXVXBTdFVwNmkrdmJ4RmRkVnY2ZVo0VFFSWDdGQ0RsUWp2UkpHako5cFVySDM3bjIrM2VHalNBdXpxTlQ4YWpCb3d2ZG9la2t6clJNc2pSc0IwK1RMeDdGNHQrdStGTy9CQ0cwemEwR3ArbzFHTTBFaVI2NGJudU5BeGhlbU0rQzVEeTI1VHcxemUyUnFmSHNMWnhrZ1ZKMm9JTHdzOHFHZGloV3J6U2o2MUR4Z2NqbzRTdkFMUk1KNC9CellDZWFnYWFGQ1NKWTVtcHptdEgwSEk5ejh3c1JrZmwwb3dXQkRFOGxvWm4xN0ZjR0hrUVpaYnR4QW1RSnYwa1hXOTR6bXF2UGZHalo0UFo2U1FFQjNoYXRtSE9ac0VnU0dxV2VmOXdnT2xUcnpVL2VucUlGc0tFcHJyclhYdXA3TDRhcE9xSUF5UEs5TXBJVUxJcUticXZwRndTeTFISWNKUlJVMEVtQ1dJa2s3aVFDalhqNVpsd0hvMHFWRVRoK1ZmbXFBZ0JNVm8rcFhZQ05Qa2NXRXFEQVZtd1pmTTgyUjB3am9OcWkycXJBa1FVYVpXN0NPUkovMGhxQktoYVJCRHFyeFJFQlRLaHBibktMVkdaSkJQdU9LQXkvTW42eng4SklZaGtHVXJLS2l4Q3lYUUI1bmhTU21lYjdjNW5QditGdlhlL0EyOGFPcHVtbVEzM1F0aERWMDIrY05HUXV6Nlc2ZGFnZnEydG5jaHViTzVzODhzWmZIN1ltSVR4bEY5YTFZTHh0Tm51VHFZek9FaFFYL2d0YVpxYWpnVURtNld4SHdSdW8wT1ZSYlY1TVJ4UDBSQjUraHVheDQwcHNtaW9kUzBLK2JtL1dMZjhLQmJYSTYvVjRLRmdrT1JGOVZuT1QrTG5lWkNtRUN1d21EeFIrUXRhdnFtNGJoaFgxM3N2WDF3RHZhWHBEdHJPejlDaWMxeEV0bnJOWnNOdDFPdHdDY2FZRUZuUm55WGZ1bitTcEhBV2srbmd5SzNWdi83ZWc1TnBZaDUrNElhUmtwV0lueHFCSXdLV0V5b3BRNWtzQSs5dk1JTGhsaU5sVFhPTE1WWEhTcWtBYXF6QmcxVklSRVlHdW1KSVlGcnBVc1dUdVdMN3E3Z2NsYzVTcUhLY3gxazlsVTdhQ1JVVUxTUlFmVlNzOHFXVW1SVXloV1ozbjRNeVl3R0FJbFpOaHFyZ0dRaSs3TVVQQU1XWjdSRXh6ZWxWUzFRdVpwR0VQd2xVUzhxZ0NpMUFsV0FuNGIxdTNyaHg0ZnExdlErK0Ivc09kOEMxM2FibHBITDlEb1VqL0d1bWJUb20vWHVqdHJiZXZIcHJhdFluUVFKZGgwcEZmRXVNQnNWeFRWaC9jenpqcFpJOFRtZDhFUUNjSWl0S3N5anlRN2oxZG0za3g2NXR3b2ZwendLWS9BSkczZEJEdURjYVgwOWcyVlJxNHFBQXpWNXVlMkVjODFkL1dySFVhcUloYVpvbTBQV0VGM05pM3F0S01GV2crMWlRWmlFeVU3UUZudFZTdTg1WFB0VzhKdCtJd0o2MlhEc0pRejdRazZXT2x0KzZlcUhlcU91T0Z5VFpSc3ZUdUc1Z0c1MEZjZFN4NVhkcThJNGFWdlQySC9DanZTSXNFU0sxRldrR1lENXRLRlVtTjJaenZhNkdnQ0RaaTNDR1VXT3R5blBUUUJXWFJiWGtJMGdCNmtVSm9pVFZRRmRCUWVuTUNNK3FEb25JdEpWcVFLU3FmVUZmd1JySGlwY2tLc0NrVWRXVUxSRGRBb0hRVkdlZUdGY3J5UmtuZ1pLaXlnWXdLbmhaSWxTVS9aYXNNMUFaQ2w2TUtCQitKWTZka25aVXdBd1kyTTJyTjdyTFN3OC8rVkEzSE5PcmU3YU5oVDdqYTB5MG11MGtVRDU2eGpSQmNhRTFtcTA4U1daSEI5QmlYcElSZmxiQjN5Sk5wNEhUcU9kSkJGMnZlWjQ0R3RETHpBS0ZZVFE2bmVFeDczREIyWUNHZCtvMWRCZG1Gelplbmw2UTV2SCtNQmNUMTdHend1QldOUXhkeTNBOGUrYkR0SU9OMWZENGdGb1JSMWh0TUNreG5kQU5UTVdXNTZGelhCMmhKSWJWOTRPVnV0MjBiWTkzdzhBN3g1VE5NZzA2M2FvM08rMW16YkhzSWtYVjhMNTBiTWV6R0l0RGdXV3JYcHVPZ3k5ODdwWDA1UEg2alpkblprMXVoRE9Jd0FpY2tpVU9RY21BMkhNaWh1MkhQa0JKT2VRS2o3TU1xQ0k3SHhTdktpNEhVU1VXSUtJY1NLVTZpazd5MVlUZ3ZCWkRRVGIwTHBTcFJwSjFMWURDc0NFbE44NURRSmt0OEZ4eURtV1ZBb3VseU9YVEF2VURjTDROd0JPQXBHbVg1WVVrRlg0Qm1MRUlDelJ6SnVWaGdmK2ZBTUtCQ3JkODRlS2YvdVZmdVhuN0pzeXdENXVwR1RWdVFUVnNSbTJNTnN3aUdNS1gxZ3QzOCtLRlAvWHpiL3lWMzZ5MTZ0amJ3ZEdHV2tlNW5tUTUxQW1UWWpqMkxjZEppZ3d1dUF3Ukw1K1BCME5zaFhXemhrYkxxcTcxaDJOVDR5U0JEeERGS1loaGZFR2FHMW9VUjRnNGpsV1lEcmF1eDVQd3VEK040RTRVL0J4RHdJdjNhQkd2ZFVKbTJPQnlqZ2pvY0xsQkpGL0x3WGp5SnlFNkw0YU9aN3pHeWltRVBXcVdIWjRPc2NOZWJyZThsbndKT1FoZnVYeHhhYlhuV2ZyVW42N1Z2S2Y3KzBHUUhnNUh0K3BHejZNTlZFTkdjYW1JeE04QjVDUHFTRkFVYUFxb1JOTzVZZ05kamhwdFB4bFVsbHNtREEwNWJibUtsM2hTc0NBRC9qaDNGQ2lHNTRIRTRLdVdma3dTY1FtazhLSkRvS29BTHgxaVU3a1FWWlY3SHNBRTRTeFAwWituVlRTY1lDb3RRODQ1QjZqRXhPV2FORlZBTG9PQU9wV1NrWDdKb3haengrb2NxUDNyR1ZBcVplVDhXYlVLUEJCVVhBVUNhQkI0UFg1NzQ4NmRXM0JGK0Ywa3VZTmpXeFkzYmxuT1gwUHg2eUFhdHArYTdYUnV2Yjc2MG1kYmpSYjRSWEJFMEZSc0h3MDlpVUkvVHFHSmNJMFFVRURIZktESGt3eUhmYnRXZ3d2RDd4SVgrZWxraGhVRC9PSEJZQ1VCSDhmaFY4VXdGdGl4c2l3ZmV1QW5ydUFSUVRnV25BUytXeStZUXQrVGhML2Q1bFU1N0dLTEpDMzhPQnY0VVFqZkpzc21ZWWpKNmRYY0lJeVc0YXRvdkpDZllKVkpNdyt6eURRRy9FWTlYNCtNNmVYWk9xeis4Y2xSczg1WHkzY2JkaDVPMFpKKzVFYTFsYnVQZGh2OE1pWkhzWkI3WGVKeFYzS1QzeUtmaytSOFlvZzZVOXFJNFNpalQwMGpGWkdpZFBOWkpEbGxRb0lBejdEYXdwUHFRUmFpbXhMbTlRS3JCcEI3Qis1SUdhb2YyeW80NDFueVI3dm5rNEh6Q1BFRktFblB3NmRqWDRDS0JRL28xaHdXaTFOTE1YcUNWUGp5K0NLY05aeTVrSUc2OHFvQVowWjVLa0hGeTF4S2UxNjZCSlVoRWtjVGlrNnY4OFpuWDE5YldRbWpHT3FDdlpGcE80WnRwOXhIbW81dHcrZ2FPUjhWZnZXWGZ3MjIzM0Vjcjk2WWh0RU1pcGFrTll0dkhvakQySVN4aDBqNUduZ3ZwWDNYRHA0OVRUVTloQ0huaDgwNE9NTXBGcElVZWdtMVN4TnhyZFViV3pYZUxvWHpqZjByM2FwY3QvbE5jTXdNYzZsWm04S3RpVlBzTXRFMStEYXc5VlI4ZVA5NUVjVmdrS044elhMYWplWTQ0Z2FoV2JQUk9VeENQMHBwNDAxOVBCdUZQci9zZ0xveTNXcTQ1bVF5VG9Oa0dCYnd1MkROVjNyTjNkMERiZVhxZzBmM2R5ZXhraHZyb3dpcGRsU1ZTcENMbW9QMUJmRnpvTXkyQUZMOC93RkFsYXZDSXFpVTZNN2M3SjhEMGk4cWxrQTUvemhET00xWU1jMjVzR0ZjRGJpaVVkTnRnVkphaTdPeXRkem15bWI1VThNQ25FMUI0bFUzY0NEREtpNW5wQ3N5MmV5ZldYMEp0Q2hNRWlCc1JCWUtLalNwQURpVHVjSlV3R0ZTY2xRZ2F3VVdSbGtiaFpaWWRrd0NyN3RmdVh6aHdvV0xRWkRNWU9TcFRkeEQ4aW12QXRhV2owdkNJTGU2Sys3eTZ1MC8vWXRmK05XL2xtcUZuNlZqYkMzaHFUdldPS0lCUnU5aFpqQkVLY3VqWC9uUnlURWY2RVVmTkNEemlSL01ncWptT3BiallzTktlODZ2U3VXMmFmcFRYOXdQS0xrOWhSSkQ4aVl2d21SSjFtdlhSOU1aTnA1UWV2N1kwQVFyYkxuUmZsN1VaL2Z6b2xhcmRkb3RQMEV5cjlsWUpQSnB4S2RvMEFOTUl2Zy80Nm1meFRGeVFzd2xtSGV0Z091Q1BibHVHWFhQMnVvMVBuejNyZDdhQlg4eVJGT1ZERVc2ak14bFR2VlJNZUJsck5VU29BWlhtYUZ6WXlWbktsV2wweHl6ODZCR1hObHZ4YnprTE5OTUtKQ21YaW9tS3BmYVVrYkt1bWd6QUJ4dWppNEJFeEg1S3M2T01CRDRPQ1VZQ2FCVXlRQkFPakhEQ0NyK2cwREtVSnZLTmdrU0lCRTFuUmI0bm84dndMeFpjN2xLbzBSVkZVclVuOXdvZTBGUm1hcldmMm9iaVFSV3dsbHVHY01KWmh6TXRyYzN0bmUyd2pEd2d5QUt3eUxucmk2SkVwKy9XY0xtVko5azZVLzhvLy84OXMvK3hSdGYrck8xOWhMY0NUOU5wMUhFRVRFTXV0VmdsL0srS0h5aWtET0ZseVFuc01ieW9nNjBjY2luemFIS2hlMXlZMHFmbmc4YXdNb1hmSjhyM0J2WHF0WGR1TkNER0lPbFl4cU1wdE8xVG1PMTE4SWtoSXVDMHJMWTVJNmh6MmJjeThMSkNVVExJUlJFb0FVdzNqWExuSVJ3L28xWm5HRHhhRmhHZnpUR0RJU2JGR3FhSDhTZVo0TUFWbXpzeDlBbGZpd2hDVFRiVFJvZExReTRlSXBBbFh4NEVzQ2d6Y2ROeVZxY0dlb3NiYndvcU1pYWFsU3FnWXhNV2VZOExOQ3dvTENoQnBmWkFvdmNGa0hJV1JsTENnWXpqNDBUL1M4bnpyd0lJdElOckZLMGIvQjc1cTVQU1ZHQk1KSGxTNllvTUtydWVWQ3dXSXhGR05nYXRyZEVsL0V5dVJBSER3bHFoUlNldk1aYUJsV1BFQW9zUkV1Z1BDb3N5L0ova1FweGxVVEdwNVFHbGd4Z0U3TExPOUQ1RFhnZWZDb3I0Uk9SZGxIQWU0ajRXKzhVSXNKdUZEcmt0bHZkYm8rN1RCWTFZTC9oYnNPZnliSGxMWGh0Rnp0V2VCeW9ERU1IU2NTSktJT214ZkJKNGdRb0dOekN0SFB4UE1sV3B1NWtQSFVzRis3S1Vyc1IwVlJTczAzTG1FeW1uYWE5MFd1R1NRWUZ4eHlBSmNNMkFNM2tiUW4rb2lwTG93aitqeDhuSVcvdlluYUJSQi80UHArU1NOTjJ6Wm54WXo2b0tUVXNPMG56dW10VFJRMXp5TmV4cG1hUjc2eXZRdDY5bDk1TWtnalRsMDR6bTB5SlFVU01MWUFTT1ArbFk5V3l6QVIyUE56MDhEdE5KcDErVE9nU2lLRWdDS1FYRGFHNnlnQlRBb2lJcWpFQVJHcWxQcU04VVJXVTR5Z21uUzJjS3pEbHBtTG5BVWoxRU93OFFINXoyNjlBOFZSUVloQXdRMFNoR1ZmWWlwS2V3VmxsWi9rOFZTMzhRVUFTb1ZHVFJHRXFwT0FobERsSDRqOGRoS1FhS0FIVjJwTExpeUFaUWdJL05MOTEvZXJMdDIraEg2N3JZZFBtV3A1bHdYMTNhUy9Tek1GRXlMSlpHSGEyTHQ3OHpPZDB3NEt6RFB2c1FJZTQvZFJzMjBiMS9MeWRZU1gwZ0hRUDJ3Q0tXVTErdXU5OE1WT1dZOVBLenlXZ1V0NzJoeU5qVFAyWlpWdTFHbllITGwrVm5SZXViYlU4ZHpMelhjMXFOMnBRL2pnem9OWnc2b1VqbGg5cUNrUStDUU9NTTR3ODl0WFVadkN4TEg4V2d3NzdXdmd3QWJiaW5JRTVOQnNiVyt5RHUzVVgyM0NvUExRQUt0bXMxK3JMcS9iU1J1YlUyTkx6RWxQeFJZeUM4NE1CQVlqdXpqV1RQbW1KWWRrS1h4WVNkaXIrSEZzQWRQMVAwRVlaNEhPQUNVUjJJbVdTb3JCY0ZLVTl4eEc5Wkp3T0NCeEZiams0TWRBa1ZVUkFwc1M4R3VtTTBNK3JWNVJsTjg0SUNZSXNHNFdjT1U5eUthTmxmTTZOUi83ZURUNnQwSXR0RUVJQ011Y0ZBZk5TNTBENmlDQjVhR3dWWjBxT1VpY1hmbG92dHB3ODBVMDZmQkF4c29wdXAzMWhjelBnTDVFTTZEcGZPU2JHS2s3U01JaTFKTXJqOE5WZitSdlhmdVlYWWVhTlZnc0N3V1lVM2pUOGQreEVlZlZlN3NzaUFVc014MFBVSGRXeURtdzdremlGNitMWUxuYXBJSlhIZFdqSVpqNzJEZkNKRE04eDNYck5EN0gzNVJ1Rk1TcXpJRVJEK2JzUTZJM2hySzF2OGpFZUErYUZCY0VXMjR3Y25veHB3bmZDQW1McWVkM1JNVFhCbng0UDM5eGtubUtxWVZab0JoOFRLdktXYTlsNmpxMDRwaHNjTGx2TDJqVWIycS9aZkhKQmdScFpEb1VrRlRBdVF6eUg1M0xuU2NxYnd3RFZnN1E1RmtDaXhhWENpT1ZtM21MNUJXRGZYZ0JGaXlvNW5BQUlGWHhnTFJoSEdWRmlvV0UxQ0NDZE41Q05rVEpvaUxUdEhMMEM0YW95U3p4amFyNGlvU1FpK3NRWWs0citIREJkRWFrOEVnbEk2amtnWGkxclFsTFN6TXZPWVRGWDhTL2pDcVNScW9VS251Y2dDUnhLaWZQSXJ3Y1hzS0o4aFhRWVFYM1pFam8zSHZReVRhR3NTUkRBay9HMkxtM2Vldm1ILzlLdnAyNEQ5dHgxSFV3UTdFSjVOWjRlQlowS1U5NVc2WWNSTjYrUWJWNUVTVGFhelRCQTh2SnRCd29wNnM2WGdxQllFQVNDOWx6YndmcVM4WXRvZEFhT2hpUGJNSmRhRFp2UFY0WkxuZVdWOVMzTnhOcWlKWHljdUlpVGVCYjRjSE5HZmt3SEJodGRVMGU5VkFPZEh4aDA0TTNEWjQreDhDVHdLekN2WU5wdFUzYzhQcGtNZzFja3llYndFU3NRUTZEZ25DS2pHZ0djeWxnRlpmWUxRQ1U1RXo3SXlySnF0cFNKaW1hdTNDVlRBWVdoSGdnWktZVU1XY3BTcVRnQWpjWXhxNVNiVnJtS0V4UjNWUUsyYm82WFJyRWs0b3I1SEtPUUNsOWljQkFIUmhYblZCRWlwR1VHbGNwS01oNVpUQkpNczRCQWVZR2s2alpabldYTzRjeWJWMm5Gb1d5aEFFWElsQUpValphcC9CS1F6OElrVTFEU255RWtpUjNkNGNUM3ZJWS85ZjNaTE9Hck9qSTlUYUxKaEErNzgvcDZIa3pIOFhSODdVLy9jckd5OC9xdi9NMFF6Z25hTDdZYzZ3Q3ZQRUwwNVZJSUF3Ni9KWWFCUTcvalBCL1RuWW5nYjd0ZXpZZjZTOVBSRzlNMlR3ZDlTcERYZFV6TmNtY3hyeVJpemt4bkVTeC9vOW1BandPSGZoYk9hdTMyOHNZbU5zcThCMHlya0dGdWduZ1NwL0Nrb1BINDR5WllNNElreHhSd0hYTVNZUDlOM2pOZUZPSlg4Rkd0NTdxVEVKNC9wbkh5N0lPM1htdno1MWhLRkpERlhDNEtLR0hSRkFRVkZ4RktaQUVXRTBKTU1WUnJ0VngyNDBLcXNETFVNazdQd2ZOV1g5VUtDY3BacWxZWjBrNmw3Z29CRUgwb1lhN1pBSkpXWjFWQmhUbURSWXppZ0JQZGRLWUZPOGN2eEJVb0RNaklRUXBDQzg5SW1IT09Yb0VxdEFqU3pVL2p2QURWUWlCY3FVTEVxYlZLVGFTeURFOXEwcWllY1F5WUlvS0Znanc3enFOSC9uRHN6MGFUTWV3aDlGdCtScDFNVGs2blI0YytIQklZeXVFWXN5RFhESHR0NThKUC9rSUtGYzJMR2Z4c3g0SnBoNUI1L3hWMmswK241TEN2OE9QUkp0UkxLMHVkeHJDYmhXVkRLZVdKSGVvbWl2TzJybTE3WGcyZVNXeFk4TGloeEpabGpzWXpyQU9kVGh2bTNwOU8wQ1JNQktmVjVyUEgyQ1JrT1JZbHJCZ2orRUR5b25BNCttZ1JwZ01kTFd4RitMN1Z5SEd3OStZSE1yR1R4aVNHSkdxdUcrY1pERHpzL3QzMzMzRm53KzBtMVl3U1ZLSVNrUzZDRWxXWm1JUENDaXpHbGVEcHhpbnpMRWpGVUtJQ0lGcW9RK0VVdmJMckFOcURNdEFnemtsbGRGbkUvUG5mK29kSWdCaXlseUlsek90QlJLbStPcWg1cTlSRWdTQXEraElQelVDTUtpdU5QeGZLSHFsbW5RZEpDOWtaLzRwR05VSmdzWjNuYklhS2dwQ1Jzd3pRa0NsYnZWaVVJTFJDcmRKeU9pdklmK1pUTkdVUVhycldIMCtPcDlOUkVJVEpiTnp2eDNBd2RDT0w0eUxMbzlrMDU1dWFBcGpPUEk3Z3kvTUI5RGowVnJiVytCVTd5NDlodUhKdUdQbkdnUndiQUxaTEJnWnFDdG5CMWJCMEhYcFpjL2xxanppRDU1RWs4TVN4YVFRTlZGUFhZSEd4dGVBdnRVMHJpeUpzTkdkUkREUFJyR0VXMUVhak1XeDVyZGxDZTJ0ZTQrRDRHQXNPZW90amhQa1dSTjJhMDNRTk1BWnplRkdOdWgxRk1RaE9wLzdXNmxLY3dCM0w0S2xiT3I4N2k4YnF0bDJrTWVzcU1ydDc0ZWFOVzdzeVRhWFZBQmx4TWVKSVFGdzhFWGp4aDRHeUo2V3lsWlJuSmRHS0E0OGtrMXdFVU03SlFFUThVK2M0bkFPaFVZdEJWWCtwZ1V4UVJRdno1LzcyUDJDbTRpUncxbFRWR2ttZlE3SHNHVUs2VTBZSjBtQXBSNUJhSlBidkI1d0pGWCtSSDVLTXkySW5LYzZGeGZyT1FOV0RMYU1xTGFrU1ZOYUxCWjlMczZUNll6Z0RWUndnSEdqNUhoOGVuWVFoM1BIcGJCam42ZWh3MzgwTWZ6cm1iUnJIdm5EbGlqK2ErcU4raHUxaEZKcTZHVWV4Z1QyeDViUXYzbHk1ODhieXpWY0dUeC9tSVZ3R1B2eUw3YXY4ZUlqZnZjRUpocHgzcllxaVhuZjVuSmRsajBjaitQcHdXWGdaVXpmOE9GcFpYYUYza3FVQkhPMG93azQ1NFRWTGlxeFJxOEVUQXI4b3lUdmRKYXdLV0NqNDRyNGtkaXhyRXZBMnE2MGIzWWFkOFBWbTJUUk1WN3NOM3AvU05MajEzVTR6b3JvWDJLUjZOdFlFOUxKb3R0dHhNRVBIVWJ2cHRZeWJiOHo0bE84Y3hGaFc5bXRCek1vNlNGcW1CdDI1ZVc2bDZRSVNaZk1seGZUQ1BLaU9CQkRNYVJZWkNFMmxQd1JGcFdnWXgzYms1Ly8yUDBDRHF1SUM1NVRpTE01V29qSENTWHdkM3VkRXRtS3RRQlVGQnFkRmZBWENvb0tTb1VSNVlEdFlsSWFnakJQUEZhcWtWZm1rSmI0OFZXbUFpa281a1NrT0ZaVTZuUWRXY3laZUFtdm1tVk5tRVZSS1dzTkM4SDArMlgzcVo0VWYrNTVqSmxFMjJOK3Rad1g4aStYVmxlMHJWOVkydGtBS2s3K3l0SEs2dnhlSFBseHdNMC9semg5TWZ3QzN1SHYxVnVQNlM2blgxR3NOWjJtNWlFT1Q1aHNyQWkvSmd6REVITURVY1J6NEd6RVVVMjd2VTZmcGhtdTI3Vml3Ly9DQzBpeVd5NDEwZERRRGl0N3JOT0Y0d0ZxblJWR3J0MkR0c1luMkxJTy93RFcxTU1uREdCWTk2Ylc4RkpEelo2eEwzVmFPcVlQOUJoWVdQc1RNeTQrbXJqbG1FZkwycmI2MnVqSVlEQ0JYcTFaNy9PanB6Ly9abitybmJxTFRlS09wbEkwby9BdUF3VlRxaGx6c3B4WHlIRlJEaWtPcFRJdU1WRzVGY3dibkZWMnNlRm1Wd2pPaUNpS3dMSGpUZHdmRnVaTElCbDZRWllDekl4aDRjYVhuUzBXWHRZYlpVbGs1ejVHbElpOENxNlR2T1hlZUpTeWtLdjV6WnA4Q0lvK3lDaFZUNVFsSUNRZVZ1NWlKTXhpWDZBVmdsalJBcFVvTVk2b1FBU2VHQ3RRMEhNK21xVmJBOEhrMkw1em5ocFVHL2xMTnFua09kS2JWNlVIdnJ0Nis5Vk8vK0V1dHBkVnV1K09aNXVtVGU5RjBHQVZUTFo1NVdWeE0rdEYwM0x0OG8zSG5oOXFmK3dsajgzTFc2MlV1SmtVZDIxTEx0dGt1WFo4R1FjUWZNNldtd3pkcUFJbmE0Zi9ZbGowYWptSStBb0N4d0s3WHBwdVQ4UnE4SHllajZjeTBiRXdCeDlUOHlSUStmYlBlMUMyUDIySGRyUFA1TXkzTXN2NHM1a01mU0pqNi91RVF0aS9QK0dxK3dXZ0NWeDVKVEF6NlhIeVRSOUowbldGbXlsVjUvZU5QN2plRys5ZURoKzAwd0JwMDN1S1ZjbFBBcE5JMER1OFpBS0ZtQVdDdXgwZ2pnMm5HeWx6QVBGWVdGaWhSQWpTN0xLbXVuaTlBUlVWNmlkT1pxU3BnbXBOVmFpeWRMbmFHZjNPZ2ZWTE1BVkpLNkZoTVNnb2VjV1UzcTNhaFFTU1cyNStxZzdLN0VIb1drUW80UFVzK3FsUUpraUFWYWlYRlFtditCSkFlS29Zb1hWcnQ4ekJISVZkc0poeFFWUm5pWlU5VkFDL3hrU2hOczlDT3hxUDdSNE9vMEdLb21tRU05L2VpazhQLzRHZC83cVVmZW5OcGJRMHpvZFhwdUxVYVRETm1IOXdiZnBhczBFZjk0M1Eyd2ZhZG4yV0tacWJuR1V2TGVwSE5wc004bWliVHZtbDR0MTk1cmRab0JLTUJoMVRYNFBuejAyaU9EZHVPZlREMmxXZ0t6RGcyb0hDdlhSdWVQWjh4aGlpaFRFa2NXekRlL0hKWjJtdkRxRHZZUDJERDdOYnJVUDJ4NzNOSXNIand0U0tZTzN6QXVPWllmTzRneXdkVE5GTDk5cnlZQnZGS3F4SENvVW16cHNPWEI2YWF0dG5yUFBWVE8wL3JudnZSMDZQUDNiNjJ1ZHJ1WnJ6bmxlZ3VGcXVGa1QwVExFREZCU215WFFDVkpvRXFXZzM3dkhpWmhpUzRwcXJFSERBV1FERUlCeDdKUS80VUxKWkFjZVJDM2Y5alNUSElnZHJHa3hBUnhhTlNNMTdjcmFwUm9MSUpVaWN6U0ZJQ1kvaEhRQk9rakNxSVk4bEI2Q1VmUVFyS1lYNGlsRzBCaGtoT0pDWUpha3I5Q1ZCbFNzdWZNd2tFNFZVU2tWa0pmQlpDSWp4S2pOM25RV1NxNi9jT0R5TURUbTJpZm9keCt1U1RkREw2VXovK0UrM2xOYS9SZ0w1Q0NYZ3hXOU1keiswdXIrdytlYnk2ZVdFMkhIbTJhMkFER3dWNmx0aWJXMXFyRFM5Y0s1SndRaTkvcGQ1cXQ5dllYd2JURVR6K25PYWNMWEF3YlRRK1BzeVA4NkU0M1VpWVpNT1BZdHZsdHdKcGhKSDBmZGh0Nk80c2lqcU51dXM2RSt4SjQ5aXJOVEUzTEhuSFpjRVhOc0g5MWtNK0ZxbE4rYXVyQWxsK2ttR25hMWk2WStoRFA4WVdHU3NpMXFoV3paSW5tZlcxVG11UTZ5ZW5vM2JOZkhZeWFtQkJxZFhianI1cUoxMytZTndNREJTaHJKNkRQM0dBQ0VKd3J1aThpSXA4MnRqUkdwUlJFSlRSYzBnQUI2czg0NTlaNXMvL0xWaDM4SlBSSkZJZDhhL1NBaHorTWtwaU1YNVNCT3hKUnJRRWxqNEhOSWRBVjBIK2hYUmVTbEFFbk9lYXJNNU1ZcUpJUzFWekZWTG1MNmM4MDRJVzA4dklIR1NDbnVHa1kyVlRBZXlFZEpvVVFzYXJqSklQa1FtTzlDcVhaNm1GTFBWaU9KaytIRTJ3UFkwTkY4YlFINDdDL3FtVHpkWjZ5K3NYcmxBaTRxT2loTVdYK2xwV3ZkWllXb1ovMGo4NHlxTVFya1c5Vm9leU5WOTYzWFIwcjZhblVUQWJIQlYrc3V5Nk5wOEtObHJkcGNsd2lBMG9tTkdLWTYvcTJIeW1OMGxNMm1DMkJtMlpCWUhub0l3TnF4L0Jhdk5hQ3Q4NHlRY0lUTDFaOTdETGhLNWk0WExsczA1aHhLZHh6Q0wxSEhtcFBDK0thdGdiOEFLOGhsVWlUZEtjVnl6aDZzVFlOdkFoaExySDM2bUF4MnFuY2VESEo2Y0RkQTVyZzZkcCs1UGcyZE1EZnpycEh6NnJyMTlQVEp1UEdhQmRsVkpRcENJSEpzcUJLa0ZoU3FnTXM4UVpnVnNpRWorajRtaFI5dlFJWk45WUFyMEdWc2t5S0RWbm9vQmxxRC9ncjBhVjZ2NzM1L21pQUlpalRvV1JlSlVyU0RWOXBLaml6WFlRcDRqWUpzbFJCS0JUVkdmVFRsRUQ1TVRTRlZSUlpwUWNGRlFzNUVSUU1WVlhCY2lHaGk4Z0pEcFBJMHNrK1NsUXRmRThDQ3RVcFBLVVdEQitNS1BmdW50L3doYzd4cWxteElVMTNOMC9mdmQ5TTlPWGx6bzNYbm9GdENCVm5xQ0tvK3BHcytrMTI3VldTek9zMlhqYzdQWE0zcEsydFdYWGJHamUrT1F3aEQ4ekNWWmNONDBpRFZaVjE3dExxMWdsMENrK3JZVlp4UWRmZEQ4TW9ZV3c1WVp1eHJJTGd1bHBONW9wRmd3b1paWjVlakZLY3EvV2dBZkYxeG80OW5RV1FIY3MyNFU3UGcxRFBvR2NwZktndk9GWmZJeHNzOXZ4WENma04reE5UQ2hzYnpFL3NHN0F0OEhVVys1Mlp1Q0FpZ3g3R0tiWXpHSlJZeHV3c2ZaYWsxazBtUGl1YnQ1YWJlelVNc2duMHAyVWo2U2RsNmthdStlR0M3Q0lLWUY0WUVWekpGY29GUjM5ZmVZUnc2VlRrQUExT21XeUtNeXlLSGVZYWdid0lFK2lRZDNGbVpFQzZyUUlWWHVZaTMra2dPR1VramdYUlI0NXRxeWhLcXpzTHVmYmVYWW9XREtwbXFzbytjKzRaTW5FSmtlZUZ4d25KU0FGVWdvb3NSOUNxK2dYdUlFZUJWaW1tZ1RnV2tYUGdCaVorZnc3RDJKRnlrWWhncm9ncjhkSC9YZmV2WnViOWVHVEtacnE4dGRFb2Q1WXRxMzYzck1ua1daaDZ4ZkV5Y1FQcGpNZm5rU1JabWFSWWVPSTBGdGZYYjkwZVduN2dsYXJGV3RyZXQyck56M2tmTzlmL1d1djI3UDlxT3RZOENDU01PU2o2dkF4Ykt2YjdYWmE3YzdTa21GWm84azRDR05lanpldHVNajQrQkw5bWFoZWIwQ3ZNU1ZnbnJVMHlYUnNSNjNBOXozYmJEYnFNejd3cUdFSDdOaE9rTVpZSXVDOW14U3NqcGpMcDMyMGJyZkZXd1Q4VFRvVVd3VEJUMzZucG1uN2FRcWJqM0V6M1E1MkRHZ2Q1Z20ySW1Fd2EvVjZ3OUZvTXZWUCtwTW5EeC9wL3VocXg5bXNtNWlnTWNmT3dFZ3EyY241bkM0d0xSZ1ZBWFdsSzJjanpnRXRJL095UEtzOWxVb0RxT1pFY3lCNWtsUkpMMVJrWHBHYlAwL2Z2Y3c5czhGU3VvekluOHBRT0JYSGNhNCtpcTFFQ1hQdWMwQ05sWDZYR0NaZUlHUC84RTg4WXFxZVQ0RnkyZ0NrSnp3Sk0xNGxZQjlVMmJKeDgwYVNCREhSK2hMeEFpeG1NWVlTOHhiTCtmUjBPSnZPK0xFeHJhRWJGcnlGYURqTHNGbHI5bXJMVzBlVDRON1RaKys4LyswSEI0K2Vqc2QzSHcrKy9jZmYvZGJ2L1l2WDdseDNtKzAwREUzSGFIUjdxOXNYZDZmRFJzZHR0dXJZR2s0R3A2bFJiOFdKZzMxckdtdUcyVnJaNkc1Zmhrc0NyWVgyUS95VzViYWJyVmFyaVNtTlRTdVVOTlg1VEM5MmsraFF1OVdBWngvRHg4NTRNUkllT3k5VlptbW4yZFFOWXpiMW5Wb2RQaEpvZ2loS2FmOG9JdDU0NG5xVjExd1hHOXVtNTBDUHg3TUE3aFFXRFN3VzY3MFdGZ1c0WlBKU1luNmR6WEVkZUY1MXJBWlJjT1hHamRQQktSd3FoUDVnL1BESndlSGVic2RNZTdaV3Q3d0FucDRhR0pFY1IwRkFKUldvQ0VZTVpKVjZxQklLNW9SeklPMDVFbzRuUm9qZFlmRUZCUWFvSlBFcXphM3FiLzREWWlxTkVXQmNxUTRWUkRHVFhOVmNBbzBkNGhnc2xZbFRtWVdFZkxRZGhRVkRUeE5KeGtzK3hNL0RHU3pZZXdicW1XcVZ1S29zcHVxUWZLRWtHcDZ5b0Fnb2k0QnRIRXNLanJRc3hUODFOWVNRc0NoNnhFa3B6Vk5KSGlWZW5Vc3VVV0UrUFRqSXNmSzMyMkVXd0tscDZKcWpXMFdtRzZhYmQxcHh2WlY3OVZsL0hNMW1SVkw0dzJDYWE5Lzk2cmVLOGJQZis2Ly95MGZmZSt1Tm4venAvbVF5emNhdlhOMSs4OXBsWDgrUFI4Tlo3RjFhVzMzbGl6KzFkZnUxYXovMHBlVXJOM1plZnVPbEwvNzRTei95cDVhdTNoeE1aNnVYYjl6NjBrOTBOM2U4N2pLZmh4OFBqUUt1Vkdib3htVG1OMnYxb3NoZzNTRXF3OFRta240NFJyRGRiRUJCSitPSmFVT1RMZmpsbUNIY0E2U3B4OWZWbTZESENHTE90T3FZRDNyRE5hWmh6TEdVVjI0c05ScFl2aUFNejdGSFliemNicUZRSEFhT2ljMXA4aGYvNnQ5ODcrNTdXY2dsWTVaRVFSQWVud3llUGR0cnRyb05MZHhwWXRkcnhMb2xGMjFFaDZnVDVhQ1ZvRlJWTGVoVUdDWCtPVEFOK25rUi90eFVKUlUzUnNpUWc2MFNrb3RpWXZKS21NZVFaZjdjMy83N2MzNW8xbUllb0hKOStDZVJlV0dtMFEvb211cUJWTWpNYWdMZ29DYU1LblptSlNWWENDcFE2c1hLejJoVVhTVlpXWVdrMkVocGpoQUlBdjlDVUhGR0M5Z0lnTkpqRlNlUkRLUktsVkJXTGZIelVGRXFuaVNCcy82MWorLzc0N0dlMnJHWmRUcXVrVUo3c0JYMCtDbSs5VVpTMDVNazFxUEV5T3paMEo3NHV0NnM1ZTFXYUxmZisvbzNJeTJiaE1WR3J4M1dyVmZ1WEx5MXNlSTRicVBtdmIrN2UzeVEvSmt2ZlpHdXp1WldlM2wxZVgyajBldkNKRHVOK3NyV2haZC8rRWN2di9MRzVzM2JsMTc3ekowZi92RTNmKzRYNzMvMFlYLy9LWnhVbU9va1RtaFFET2k1bldzRlREZ01SeHhES1MzNDg2MTZMVWxTR09CYW81bkJGMGxUaU5FMFRZUExBUGNZa0JTS29QMDZOOG1tNTdsaEdQQzdQWGsrOGNQbFJwM1BLV3Y2WU9aM21pMjQ4MUVVTmt3NFhmbG4zdnl4eTYrOTlQNWIzOEZzU2JCMWlCTnNBS0lnM24zeTlQakpBLy93V2NQVzdmWlNZamdZTDZxeWpDSlhabFpLa1paakpCbUxocm5TTmtvZWNlcUZ6QVgrYy9pWkxjemt5QWhIWEVYTEdTVmp4LzhGZ0s3Q3V2L0hDMmdaVjlZQ0N5a1htY3N4RjNZcUxsbkVzYncwRVdtY1ZSdlY5R1A2akt0RW1LMGFLbGRSNXBrRXlaUHorUUQrT0ttT0VSU1Y1T0hBTFBRQU1iTGw1cEFwMGpBdUJGVUJnUko1dm1xQ29sTlNueE9ka1NtWjZJbW1mMzN2Y0twbExjZXVkMXIxbGgyTS9RbFUyUFQwT3Ivb2xkaDUwUGZOTk04dE45SnJSZDExMStxem1XKzVqVGdKK05iSExIYVhWdC8rL3RzLzl3cy9zYmJVME9FYVc0WmhhWjJWalU4K3Z2dloyeTlwT3Q5QkNiSExqVDMrUTlncWlVMEJMTEVnNmJPLzloTS81YlNXcHZEbGc4aXcrU3dBZEZVZWJvRXhOYkFmVFdKK3RROWVqV1hxWHIwMm1Vd2k3REl4SDNqWE5wdjRQbHlqSWszZ3EwQlpVVFpPWXROeHNBZjFQTThQSTJ4WElRbXFlN3NKNXg3U0FCa1dqZ1p2MEJaRkdtUFhkdVh5NVovN2xWLzcxbmUvTVRydXcvUEJ1b0ZwRXlZSi9LWHBMSW9LdTdPOHZsejR5N2FXeXEwd2NCUTFRUjk0OFlkU2xZRDlBbkFpOWhJRGFjdVJlTW5pRUFCUUNyTkZqUWpwcEJTQkNFWlprQ1ZSWWo2LzVzQUJObitPRnlJcDF4SlpxaEN5U0F0c3hZcFFFa2tXb2VLSVE1V0ZKcFRSa3FjUWx3VndraTR0dEtQTUJhblNzS29sT0NLbUpzZ1pvQ0NKcFJDVlFNcEtxc3pFUDBzcUdnUmhWdW11VElkNTR4ZEFJVlVKU2NzQmRRTUtMY24xeC8zSmV5ZW5wM0dnNTJuVGFVTnRKdU13c0EzTnJ1bE9EWll0SEFYeE9NdXNadEh1OFBKM3pYYVhuQ1FZRzBiTjVBZjFUTXpCT1BNYks5N3ExVXR2dkhwMWM2M2JzSnl4bGlkNllkVTdlWlN1TkpkNFBWRDFSSnJOSm9nNFpPaVlWdU12Ui8zQ25aYy8vMmQrNFFzLzkrZS85RXUvK3VQLzRhL3RQN2czUHQ0SEhyck83QnkrUFY5RGlaN0JzNTlPL1R6TG9JdVc0NFErMzFDR29PZVo0MkJEeWVlTmVaVkg0ME5wb0sveENiTUpUUDBzU3Jwd2g5QjRuZGYrUjVPd3Q5eUIveHJNSnFhaDl6cTluL2lGWDJ5MEdsLzc4aDl4cDhCbkVQZ1lRaHFuUVJ6Mys0TkhINzQ3MlhzNE8zZzhQWGhRanlad2ovUm10MUw2TTJEUDBGYWlTdFhoWFJLNURhbnNGd0JkTG5WTlVWUm42aldpeUZBY1JUMllLYldjQithWlB5dTNtYVE2VUlLR000UW5KV1FaYjFWU2RzUWtBZ0JKUEMvTW5BSExjM1RPQWRJS1JaN2laNnZXc1N3N1JXQmFVWkJJTUtDc01pVlhrZkNzZEYzbENVNzUvTUFJVllrVkRvandBTUNBaVkxU3pLU1BURXBjVWFpYUt4YnlmaUt0R01ieG85SHMvdkZrTjRuQ3pDL3lyR00zZEQwZERtZGowOVRjV2dyOUNLTHgwM0dhMVhTM1hqaHVBVjhDVHF0cnhNR3MxblJkcXo2Tkp2ekVwTi8zT3NzYmE3Mi9BdE8rdlo0N2RtaGtwbG1meFB3S3pWcXJQUjJGdkd3dHdsb1FZemwvMVNpb3hnSFVlS0tGTU1ud1AwelB2ZjNGSDczLzlqdWo0d000S2lUZ2I0dWh5WHJBVjNyQTArRm1EQzdIekE5aXVQaDVFVVp4cTFuVFlLc05QWWxUZWltOElWV0RpMC9OeHZRb0NqL0p3S3Z1T1ZCQUlFL0hNN2p2OEhtbXZtOFdtcXRuZi9Hdi80YmJhTHovOGJ0SHp3NTRCNStQNy9QcFQvaE1VWnI0WVhJNEdFK0dvOUhoM3VoZ3Y3RisyVjdia3VFanNFTXljZ293UWtyK0NNaVFQaU5XQ3FKVUdvblBRV1V1anFrVUo5Y3lTNUdWUlJsZzNaVzZxK3FyNFNhSVRvaEpWQ0kvVTQveVFLUUNGVkhITXdZVktBeU9jcEVKVkJnOEhva3R5eEJEUVRDUVhJMng1QUVRVVR5cXM2SlpFQmI3U2FRS0JHU1dLTXlIT1NlQWxEMkhVRVZBakZib1JaUnBENDVHYno4OE9DankzVUVRSk9IUm9BOGJyU1V3Zm5YNHh1TmhkRktZbW1sN1diVHM1cVBFMXJvclZndG0zc1pHVWF1N21tSGtTV0ozbW81dDJDN1ZQMC95WUFodndycDJmZWVOTjI1aGExWjMzRkNIZFk5V0RXZVlwdFkwRG1meWdacUZsc21ZcVhBR1ZVTDFDY2RTQ25CVVh2MkpuNjYxZW9kN1R6VytpUU5tRmdZZU1zYzVhN2dlZis3TkgxemxlcFlCYnhqRm5SdFgvU1RLVTk2bWpYbVZSbjExVGU0SDh4VUdmR0dsSDhVcjNRNXNPZFJnNklmTk9qb0ZIOG5IRGhZNzRML3lhMy9KYVhiRExQejZsNy9NdHl2eEY3bFp5cXVaL0tFV0lNMzBXUmpEeTFxLzlzck9ULzRpdjZqRzlzcndRdVE0U3VNVktKdzZxMlZPTUFKSW9KQWNGWlFkbDZRaUs2Y0VkVmhsY0VBWlVWb2d1ZUxNbExJVDdWQU1LaWdWQnRseUpxYlNTZ1lpNWduV2lpTzlxektIQUhxbWhJOWtNT0NmdDhHckJ1T01JQkdrU2M1Y1JTd01pQ29ERHZ3ZEw1dkJGUEtVcHk0Z1VhQm8xVmtXaDlLODR5QU5ZVVhpSzFLWEVEZ3lCVlM4R0NYeGdSL3R6OElIdytuSk9JQWp3cStNUmRGeE5FbnJiajN4SW11RmovU2VKc2RIb1pjWDF1bWh0NzNSait1YTErSFBwdHZPekkvc2JyTzI3R0NzYld6UCtKU1ZQUXNTR05iME5Na0djVDJMcnV4MG50N2ZmZjNtcFdGY3JGcldtZ3ZEQ1MvQURHZHA1TWRWTnhiZ3JHL2xZTXN3UzAvRW5aTjhCdjZieHZiTmwzN296L3k1bDc3NEU3ZmUvTkhsN1N0MzMvMk96ZXVWT1F3ODlFOSt0OHJpRUFySVI0UGh6L3pVVDN6OHlYMXNhdE1FcnJtR1RXM2RyU0dDRGV1SXJ5UFdwbUhjOW1xZVo1dVdHY05wUy9OT0Mxc1JlT2dCZGdGLzZxZC8ybXo4LytuNkQyaFprdlE4REt5cXpFcWZXZDdldXQ0OC8vcDF2M1pqZWdZekdBZUFBQUdRQUNtQW9JR2hTSW9BU09GUTBPcnNTcVNXaTkxenRFZEhsQ2l1eUNXWFN3TUtBMkpGZ3NUQVQ0L3RucDcycjU5LzE5OWIzcnUwbFZtMTN4OVo5M1VQamhTM2JsVmtaR1JrbU8vLy8rL1BqSXpVMXRlM3YvYjFQN1NHVTlRTjFVRFB3bnJBYkZEbklocU4wUDJIWUhicCtWZWlpb3p6MHJ3ZjFoaU1CbjR4VkJRUHpUMWk5STFmcEJNZXdoYUdnWERJQWgyUGRsRG01ZDRQdjhNWWZpOHlQODJEd1AzQXovM2kwdzBFMHJ0UEQ2RHEwRUV4SWkyb1JGakFSN0wvNzBaWlBueVdLWVF3Nm1LMloxbjMwT0ZBbEhaUmhFNjZ6QjhldkV4bnFRUnRDbUVaMUJuc3MveWhXTGlYWldaUitseWtzOENFaTd4QS9FRHhSTHJqV1gzaURqeTNCNE5yK25YVGJrK3M2ZFRuRnZTZU1Ea2h5MWx0eEY1cE5KN0crZEVpTFpNek9wNTY4V2dzWDlibGZGcmMyQktOZENLZHpCZVR4VW9xbDFiM0x1VXVYMHF2NXFTVmtuNWp2YkN5bGI5eVk3VzRsVXVrRWlmdkhJaTI5ZGtmdWY3cDYrczNydTlWKzcxY05oK3hyZTU0a3RLTWtjZlBScWJuK2grMjRHbGdiUTlISVd4Um1PWHBNRDA5WXBtSFpnTkVaU09STEpZMmJqMjdjZlhXdmRlL3hjL3BLVzlhME1JbkFTR2ZCM25aWmZ1TllnRUp3K0VFS3AxSWlFOGk0ZnN6aVkvNzBaaERieWVtQnpzVldRQjZjUlNjMTJUQ0FOTXpKemlFSytaenVkVjFSWmF0d0xuem5iY0loYXgyME0yb0VHbDZGbEN3NXpoT3B5Ynh2RGRvendhOW1ETVZGWDFPQ3h1ekZsREw2Y00ybDZvTTMxUVc3V1F4Q3RSR2pDWHRZbmsrR2o2NnljcjZFL3NwUlAvQmR4N0hBQVBxQWZRZ25RZ1NpUjBoUW1tVE5pN3VYMUlsMkRkdFlqdjhwUURYZ2hrZytuczZQT3p3N3prcmRqemRKam00MkFnajJNdGtuWExSRHdKSjJqSUpnZTJsYmZwamx5ellMcXJrTWcrMEJRa1lLaEhtcFg5S1owc1hVRHVqL0R3dWlwb29TUkVaZmhvWGM0S0lFOHltUUxzN20vcisxSW5Pb3ZQQk9ETHUrazdmY1pyREgvckMzdlBQRlZ2ZS9MRHVsTEs2WWZBOExkRWFnV1ZHNmNBWGo0ckZGdlFHWWJDQ0tFaHQ5SlNlRW9yUzdmdFl4T3dPdWYzamw2NXRKVE5HL2VCd0paMTZ6NHB1cFBXeUJKVTdtOHk4OFVLc3ZudFgxUE1CQ21PQk91WmlSUENGanFCVWFncmlZYXRZRWh2U3NMZXB0ZUZHdUo5MjRoTWIxczcvMlgvNWkwNjNFZkhuOUZvUmVxY05LVTRRR09UWnlLVXY3NnkvODJEZmQyWXV2WTZiRUtDcENsUTQ2bjVjYll6cGJUbkJWaWxMWHV4aVVSOU10bFpYMGFoZXE0Rm12dkt4bC83MFgvM3JNWjRYTmVrdi9kbWZoSWlnaDlFR3FIYm1ET09iaGlqT1JVVmVsR1FoWVdncmhheVlTdWNxRzRWTHo0cTVvcnE2QTNraU04RHUwTk5Bc3JwUlUraVBiU05RaEhYRlJVQ1VHaG1tVU94UGhyRG4ySkVNdkd5TCs5SXYvRTJHRHJhSnMxQWluVGNzZ21nRnZ0RStrcm13S3luZnhTZk1FLzZFOGtUMVlsRUNIZHZIam1IbGhTbkxrN0E5VkNEdElzTENvdXlmeG9tMncvT0dPOWdtZGpOS3Nzd1Zmc0xxTHovWWpjSnBOajVyYmRqNzZFeDhRM25HWmFsUXl1UktlaklsR1lZb0srSkM0bFU5cnV2UTFNbEVMbDBvWkNyNWRMbVl5dVNTVWpJQlZydVhpVDV6ZmRVWGVNZmhkaXRLUnVGVUh2MjNrSVFZSDQwS3FDQzdqaENPekR6R1hwOFVpUWhCSkI1RVZ1S1JUVDV5UlJPdmJKWXphbHlQenVNcGZSS05uWGJHTzhXRXlORnFxU0RCNDhuOC9xLy9rOHpXNVVoY0NKdUJxb2RkRlA1U3lrV2drMUVIaHZ2RFFISDg0N00weHgvWlVuVGo5dWQvNlBEK2ZidlhCREdIcGhVNGVoY0Rkc09EOVYzWDBHVmRWZHVESWIxa00vRHA0ZFFGeUV3Y0VrenJmOURqVHI0ZXB4azBhT3JFY1JSRlVXWEp0aXlCaTNxdXRiNjVNM0hNZERKN1dqdXJuWnl6eDcyaENwaUNEL3VmbGdpZncwVUFGekp0MTVwTVZENCtOVWNuRCsvMER4L0dGU05SV0tGV0VTaEoyQWdxYkJCcGszM1RnS01waU5FbWF5MzkwTzlIZXlaTXA1Sm9KK3NoMXN5TFhQaU9jbC82MmIvSmlxUHRDL0NGZTJralBEMUNlQmh0czNUU1dxemdaWXp4U0phRFFvaGlsalZLVjhKb0I5dGc1WVJub1JUYVFYVUt0L0JOTGFaODRSY0tabVVTSmFjb09lOHNOZlRpcWNINExQR05INFN3ZVd3UDlUV3BYbkRTZVN5cUpSVWdlS05pUk9MelNKeHpGakdmWGRXZkE2M3NyRXcvUnFHeElyTUE1RlN6ckdRMFVJUHh5N2UyT1YzUUZWNVRPSmx5VWQzb0Flb0lUVnYzMkJsNWxJRHQ2TUswNXZIb1lqMGFLZkRSRkIvTmNSRUZFS2ZySWlTbHFFek5pM1RHM3RWQ2tpYW00OFNndEpPUkd2Ry85dVhmZkhEM3p1V1hYd25oaW5QZ2gxb2RmcUZCWVFleGdIalk1MkZnYWNzRFNQTFpEUlBTSHl5ZHFpZUl6MzcyQzRQaHFMWC9LQmJqWnJNQVBJUWNDeENZeUZ5SVJMeklvajJDa0M3b1B1Z01pRjBJQWszQ2NjRGw2UnBMNEMvbXVrU3ZPblBwOVFweGxWYXA5MFJVZis1SHZVRk1rdDk2NjQxbXJkYXNOWW1zRTk2aFgyZzhjSFo4QXZ6UzY5eEkyWHN6ZW96UXNxeTFaejUxNDdNL21xNnMrdGFFazJSb2Q1YVgvc01tMGNaRklLVkxQY3dTNlJ0V24zSlJLeGtxV2JzcHNPeVVFeUVVSWJyMGliMHNuWEYzMWxkaGRuWWN4VVBzWFJ4STRjTVlRaGhuTmNLNXcwcXdRRDloUVRSbFlsbml4YzZMQ0gySE5XQWpSNE9IakF4NDNHTGhkRHFUWm4xWVBhWW5HL2c0Y1FhZ25HYTBSV2FqZmpBWlY1L2M4d2JkdTEvOTNkcjk5eEpKVFpDMU9CZXI2Q3JHei9KOWdIc1I0ekNZY1VYVWszb3FvVlJXVXVXOHBtalFXSFJ0V2NTSlFkS2pVZHZEK05IS2NqRjRlZXdPcFRjYXZ2dWJ2eld2ZFpSSmYwK1ZkekxxZ2c5Z0UzSXhENExoc2d0enMyQmhBaUR6cURkZnhDTzA0QmEvV09qUlJTb1dLWW1MRWg4ek9BQW9aa2NXcytqQ1dVUTdrWGw3TWEvUFlrZG1kRGgxOWxLcUpQQ2R5U2lDbHJYYWYrOW5mcWIzOFA1czVrb3hidlAySjZCeTJXaXlicUllQ2tlWXdUaE1RL2d3aG4zTG9VVHZzQUVpcUNNSDYvamxEN2E1R0hmdFk1OXNkMXExSjQrZ3FBbkhxRFpITHgveFBOL0JQeUM1aUhvQlhaeGhVdzNRaTlUcGprdVBEY0kxMWVCbGtzVFM4bU9xZ3NyU2xkWkZFUHo1TDM3TWtHTjMzbnY3MFlNRDdJckc2R0Z6SUo3K0NCZk16S0lTQUFOZHFhUVhhRnFPczdWN3ZiUlplZkRPcTRkdmZkUHBEMlU5SVJrcFZPWWpUYU5BTFFsakRLTFVMeGNaTUY3NFJzbVVCLzhzVGhzc0VxYlFIcVlDTHpiQjNWOS94SDdwNExBb1ZrdnFLVHFZM1dwbWtzZDI0MGgyS0NRRzRhT1A1a0ora2Nia2Faa3pMQWZ4aTNPRmhTNEQ2b1FhNDV1ak1xTUwrUHI5bGpNY05BNGVuNy8zZG04SVp5NGI4SHcybitkbE5aazBvQzBjZDNIbm02OG1rN285dGVCN3FiSXNLY0pQL1pXZks1Y3JVWkZMYUtxcXBhWlJZUUNiSy9EQURkaW1CSEF6SEFSQU0zMm9XaUNoOWlKbVV1dW8wekFnTUI5SXRCYlJyb3V4OTN1MTFpMkZKcDg0MkMvS3JpU3ZLMlFGWEdnemV3NnhTR2tZOElnVGljU0JKT29qS0RPb2NFckJLZHhGZEJwRU9wQ0tJREtscDBJWDBkazhHWWxVMUVoQzVRUnU3aTY0b2Irb3hQeHYvSS8vOHdmZit0Yk1ubWlHbmk5V09oRWx1N1hUYXpjKzgrTi9nVmE3SnAwZWRpUHJhTmFydEgwQmZWSW5MRUxKTExhMHNUUytTLzIrL0NZSEk5cXRuZjNMLytaWE9vZUh1aFMzWEpjTGw0aW5heUt4T09JY3ZiRFM4UU5aRkN6VDFNUjRYQlI2VTNOaXVZNDdLeVIxUTFVQjFzSEUzRnhkRWVQOHBOY0M2MTVkeVVGc1AzUDdzdTE1Zi96ZHgwZU5IdGcrdWhycUhCSUVnNGFLaEhWRHhTbFFYYUpRRTV2RlhDcWZVNDFrbEJmaVJpcTdzWFB0QjM0aUlvblVCQWFlaTdaU3dEZTI2Vy81b2UwUXhLdzNXSzZ3cFN3VDlwSlNKMUs3N0lFd2NGLzYrWEFTQWNFWTZRekhkRGlkalVWWktSOGVFRzVTcFNuRzRqaVVGUmx1c2p3c3hnTExkUkZZQWFnZll3VDBBVVM4NFFCSyt1SFhmLy8rcTc5NzlON2JvOXE1N1RtNnBnWEJUT0RqZ1d1YjNiYmQ2L0RPY0hwNjZJM0duVjdQOVZ6UG02RU0wTUtmL3VrL0MrZlJzaHhlMFZSTkZYbWlEcjdJR1NKNmtXYTMwczFEbkF0NkplU1RZQ3RnTWlBNWk2aE5WeEFwLzJ5eEdQdHpsTnYzNXNkTjYvRTd4MnRYTDQxVll4aFJ4MUhaV2NTN0M2NGRMRnpMTDhwQ1ZvNkRuMWpFQVNJejRDTWFtUzRXdzBpa05WOTAvVVhMWDNUOHlOQ1BUSHpJR0kyNEdISFZXR1RWaUNla21CbUxDVkgyeEwrejhBOFBmdk1mL0EvVDhVZzN0QVZZZytOKzVYLzdyYmYrNkN1UDMzaE5WN1dONjdlUUN4L1diZUZnVUdDYlRHbFJVMmdjRUpzdkI1bVNMdklzdjhNSW1jWm9WRTJrQnQzbXVGa2I5QWZRRlQ1Z2lSNEFyMEpPSmtTUWFabUh2cCtwaWtMdnp2Rm5FT01aNlhxQWNLNUtJcjdIbGswUFNrbVNQNS9GWU83aTBqdkhuVy9mT1pnTWg1OTc2Y2FWU241aVc2T3B3K2Fmb2NOUk0vVENCWndJaHpnbjdZQmpZRTlINXJDUDRqbFJXN3Z4dkpFcjBuVXhVb0JMV2FXS1hZU1B0SkFWaHkzVUdCdlVDK0dIemtVNWFPZFNGWHg0UEF2Y0Y5bU1TSGI5ZzA3Q01MOHNtYVhoQ3luMG9hNWRScGNGc1F6WW9xU0xCTnBMaFh5WWt6NHNsYjZJZXkrVG9HOWliLzMydjMzLzkvNXQ5OG5kU2FjZCtITjZjUXFjSmZDWldaREpwT0hKUVdXelJROFgwNm1aRkdPRFRudXRrQjI2TkhFakxzVC95cy8reFc5Ky9UdGYvdlYvODN0LzhBY2J6ejdYSG80K09LM1dMV2ZzemdZak93S25qQzZlTDRKb05LQTN6dEhFVjFURGowSnhMcDlCZ0NTTVBFS243Yyt0cWZYZVd3ZDN2M08wbVZSTGw4cVFKMUVrbk15NUNEK2ZyVWY5cTZvb2NKd05pRWNpazBYRWpVWjY4K2pBWDdUZEJVb0F0K0VpbkIzRWhnNWhCNTRvTVYzSFNRdDhVWmZUSWtBWmpmaWVkVlovNTdkKys0MWYvNWRmLy9LdlozVWxrOVJocGdMZnUzbjd4VWRQbmxoVEUzemcwZHZmdmY3aXkzcXVnQ3FHYW03WmFmaEJsSFZrMkttVWdjV3c1Mm1lNWFndnZ4a2NNTUxzbUZ4bDgvN3JYd1VBUjVPeFFHOFhqb0tvOExUQVpaZ0ZCeStFT0MyWFI0K0V4Q1hMZzdxbjlTdDlQOUJrbXV3RndvTjhocTY1bmdNVi90eXRaeUtwTk5UTmVYZjY5cVBqem5EMCtaZHYzdHBkQTVWckRpYXNDaFFJRkdIdFdBempRSlBiL0NDVEs2NWRmUzVaV1Q5Njh1NDd2LytiYnF0ZXJHeEZKU0pPVkptTHRud29MZ2gwQ1pEVU5pcERSYkpBclNQRkZSNUVnZURHU2tHZ1pKYVorK0xQQXU1c0IzWGMwOERRU1hscEErbnN3NDVrT1pjRnNDaDJoVm5Ed0FUeklrTW9aT3hEcWlQY3hXZ01Ocy9ldS9QZ3E3OU5LT1RvTlJqVEtSd1ljRythb1FyMUFlMk9uTWY3aDRlSEI1b29nbUJiaTFpcFZJaHlRbTgwQm5GQjV0UFRZOXMwUVNVZjMzOTQ4dWplVi83TmIzemwzL3liUC82TlgvL3F2LzVYci82cmYvRzEzL3EzOTc3OTdiZ3N4eE5KTmgwTDZqM3FNZitTank2ZzRBSFFBQlI4Umx3Y1psMFRKTnRkSEgvbm5ULzk1MThKUklrcVQyK2xYaGlPZFZ1UHBhVzRFNDJhaTNsM0Vlc3VJbERob3lEbTBFdmQ2ZjROeEFBdEd2alJHVDBPdDVENXVlZlBaTmRkNTRXVUttdENqSjh2VHQ5NDY3ZiszdC8vWC85dnYvYk83LzlPUVk3V3EvVnlLVCsyaURmTHFuSHA2dVZYdi9yMXlZUW1xOHo5MmJBL2VQRkxQMEpPSG5xQmpXekloY1BoQ0FQdFFYaTZIZVlMRStrMzNLQlBHSkFvcTFxdlV4K2VIc1lGQVJvRWZJYnVIOEZVTW9XSHd6RTBvTjRpWFlpaENmUkpJMms2Rms0TUhSem5ZRENKL2ppMm04OWtUTmVOQnJOUFB2L01qLy9OLzhKVFVndlhCTTF2RGN3UGp1cU5SdXYycFkxbmRsWmQxNW5hYUIrMERUSGZEMnZLZE9vc2lJd25vKzdaNGRuREQ2eDJ5eDFOMnFkSDVtQzRjdWs2SjBsUEVVNDFleHFvUS9DaEtMNm92WWhRVG9yUmdPR1h0WnkrbjhZcDBBWnBkL3FsRWhnMDJWNXNNVUVKTjFtRXVvdFV3SVVMUzRsTGtTQ2hJcDI5VEdlSFVtQjVrQjNib2VxZ1JSNVlLZkNjL1A3d2ovN0YveElMU0ZHRFpJT2V6SU81NjNyUTVkQTNva2lycU1DcDJuLzhoQXY4ZUR4ZWE3UjVRYlM4aFdsWmtpeHF1aDc0UVQ2cE5acGQwN1FLaFJ3WDVhenhkTmp2MFQwVjAzUW0wMkdqVVh2MHBIMzMvbGYrMlQ5LzcydXZEbHB0Yno2RGhZYTlqRHBUd04yTjBzdm4wR29vT1JkZDc4Ky85dHNQZDVQeEt4L2ZrZm1vRnB0SDNka1ZlYkZuY0hPT0d3U0x0aCtNeUVlSjBSdmFxZGtMMkErTzZGUE1EdWFPQ3gwWWtjVUZkamltTFR2ZXBhUlcwU0ZtM015MHYvVXYvdVUzLzhrL0txZVNXeHNiaGlMcHVxWnJ5c3oxbmh5Y05acXRtMXNyZ3BGNi9idnZ3c0dEMC9EWm4veExQL3FMZjRjWEJOYWwxTEUwb213UTJPWXlzRTE4RVR0azJ5eVZaYVErdi9qUUtDeDNVREg1OVowUDN2aUdERVlCSzByTHVRYUNJTUFsQlIwblZ4SDBpK0VNaEEydG16aXVKRW9MZGhHZEhGWlpRbzZCYVZVS0JXOHhuM3Z1WnJuNDJZOWZqUlV1YjMzcWg0MWNMdXFZdnVQV2grWjcrOVZhcS9QYzd2cHpsN2FneHdZbVNCOVZCbVZUVTFoQVIrRmNObnpoZ0M0S0tZcW1aTXN2L09CUGF2bGNGTDR5SDJla2pTcFBiY1EzL2dtb0JEdXdidHBraWVFK0RDVHJwR1U2aGJCL3dnL1R1OXdYZnU2WGtNVGl0Qi8vWVlWUVpBam1aV2I4TDRzSmY1Q0YvVndjUmJ0WmJ6Nk5QeFVaZ2daTFl0QW5hdFk1ZVBMTjMvaFg0OWE1UjY4eDRuSTVXRVBUOTN5VXAycmc0Q3BJWStCNXpkTmpMYUdYU2psUjBlRUpaZk5aVVlnbFU4bG12UUZWVWNqak9DTjhHVFJBYkJncVJyQmNMdWJ6ZVp4TlZlVk1LdjJKVDczeStjOS9mekdUVUJZenUxWjc5VjkvdWZyVzIzLzRMLy9WSC81Ly8rVzliMzZyZTNMcTlqdjJlRFNiVE9PQmQvZU5KOVgzSHZ5cEg3dStray9BRUdTaTh4Mk4xNFhvSkJJZExJS3VDeDhnUW5XTXhObjZjM1JMa0l2Tlo0Qi9zSkRvS2g0Z01xZDM1bmwrT1I2N25JQlppWm0yZC9mVnIzLzUvL3JmV3NlUGg4TkpKcGV0VnF2SlZGcVFaZE9lRGNmbWxjdmIwSm9QSGgyODhlYmIwSVdmK3V6blZGMWIyYnZpejkxTXZoamphZlhxY0JoQ2lybnNkOWJKYklEWWgyMVRFZ0gvYVNwOXdwMFVXQWI4eXJJeWo4WDJYL3VhSUNyQlBBS3Z3ZlZtaWlqWm5rdnprZms0RXdReUp0RHdDcTNNRVpDYTRtSzI2eEU5WkpNQzBvWUJOZ0w5a2xTa25CUms4eXRXYXJXd2QzWG5oVmVTeGZMY3RlY3pyenUxNzUwMGErM08xZlhpODFjdndhL3RqTWFvTStFQURYbXF2ZWxxaisvTlhGWFJrcmw4N2V6KythTzcvVWJkTU5JaUxSVCtQWUY2Z2NDNFBEeUVGWDZRRkdJNGJHL1lNOHNUc0RoWUtXejdVcnV6MVBCSTVDV1lMamVvbkxBUGw1OVF0N09pd3hOUTFxY1oySEhzaTNMUldkbE95c0w1L3ZtZHQ4L3V2MzErNTczWC92MXZSTndwZUlBa0NZb3FkYnA5VVpTZ0JpVkZDbC9yQlM4bnFZcUtJaS9pM0tYTFZ3VkpnTWxQSkxTVXRJalBIVkUyemhzZFFSUjZnL0hVdEdSVmNSd0gzdFZrT2kwV1NpQTU1Vkl4bWFLSDNUekhESHdIR3RoekhWa1dWVTMvMkVzdmQwNVBwTWg4LzkzMzkxLzcxdGtiYjV4ODR4dC85TC84dzIvL2kvK1BjL2NOOS95RFAvYzNma0dNaVJXSmwrT2NINDFZa1VWN05oKzYxTzZ4RzNVanZFc1hXckJKdDhDaDJkMVpCRFpIRnpsM2FHK0lFVzFxYmVoS1VvWmt4OFpudGYveGIvM3lCNy8zSHhRNEVMUVNLbmg1VkJRQXF1aG9PSzZzVnZLRjdNU2NGb3FGK3c4ZlR5Ym05dGI2bGQzS2FySDQxamRlL2FNdi8rdUhiNzFtR0lsc2VaV3VsTEkrWmFORVlZbHFqQlQ5c0lFSWQxNXNocm5Eckd6c2wyS0FBVVNrc0xMNTlqZCtqNk5GTjZCRzZab2h2SDlvRFdESW5kR3FHL0Iyb0ZDZzllRlFnYWNaOEtBQVN1RGJjUVNlQi9SbjNvd1Q0dFowdXZDYzdWTHh5cVgxanNmUEpKVVh4Y0xXcGIyWFBwWGQySnJiNXN3MmgxTjN2OW84YVRUWGNwa1hMdS9CbnhtWkpta0xndEtIQ2hudXdXQXk2cmVhQ294S2xPdlh6dndna3E5c2NQUUdFV1JreldOY0pZeWlGYXpWTWZ6UThXZ1pTUUhMRURhZU1ySEFMb2F5UEJIdVMrU3Fza0FIWHh3WlJpaE95YUVjVXZKRmNVOER5L3ZoTnV0KzJrWjZxTlRoRVhMejZQRmJieno1MnUrTWp1NzJUcDZNR21mdytGQU16OGRzMndrQ3VFRys0OWl5b2hDVHBKZldSbExaVE1KUWVwMmVxS2tBN21RNlNxZVN3SEVRNFdWSjdBK0dXaUxUN2ZYaDFVRU4rVE1QVEZkUndPODVrS0o0WEpSbGFUd2FRWEF5bVJ3WGo3V2JUZENrMFdpS1hXZG54N0ZvVEpTVjZ6ZHU3Tzd1ZWE2dmdCb3BjaUZEVHVOZitDcy9kMlZqUTg5b2NLVkdRYVRuTDdvZ21FUm5GOWJJbWp5dThaT3BZdzdtMHhFL0hNQ3RwcGRPc3RuQzQvYndCY2U4Sk5NclVqbFZuRXp0MS8rM2YvOFBmK2tYT1hkYUxoV3F0VWFoV0lUeFRpUU1ESmxqTzFDai9YWUxkQ0NiU1Rud0FCYVJTaTZOVTgwaG5kYmt4UmVlZi91OTk0ZWQ5cDF2ZnUzdXQ3K21hV3B4YzRjTjUwVlhMMysvNTJlNWx3M0hjZ2ZDVWtIUk9DMFRhSGxUQVZMMHpoLy9SMG1VY1dyWVJnd1ZYWDVCMThSaUdBNTZRVEt0R2tJWFNYQUFSa3NUaFBWY2F1ak9vTm9WUWJCQTNCY0xLUjdIa0swWGM5V3ovYnlxZUhxWkpnNmdpTGlZWGR1OC9QSFBGRFl2dWZiWW1VNGN4enR1OVU0Qituem1wV2R1QUIzOThSakFRb1F3ekFLcUJrc3lISTJUUmlwWktQdUJjL0w0enVyNkhyd3Z3aFBzelpJK1VFNldRaTFDUGRrdmF6ZUxmRFFnSWJ5SVJYdng4OTkvZTUrbDBiSDQreWlVV1dBaXcvN3BoNFNTaWRjeUl6c1h4VVBCWTJla2tsbHhQcjJIYU5wcHZQKzFyNDVQNzgxY0o1ZkxUTWQyczlWSVo5TUp3emc1UGdHcnk2VFQ3SEpFVkZIVmRDbzFHQXd4R0k1akFYNktMSHN1M2VVb2xjcjFXczIwclhRMkM0MEMxRTRtMDE1L2FOck83dlltVk9kNGFubXV2YnBXV2N4cCtXYlRCQUhoaDZOaExwdE9aUkxUc2Ftb0N1eEdORHF6N1ZrcWxYMzg1SEJ0dFRTWmpQaFl2TkZxZ2toWEt1cy85Sk4vNGRvejE3cXdxMWw5R0VSSDRCT1RjZWU4OWY0M3Z0WDQ0RTd6d2QxUmIrQ2FFK2cyYWlESDY4bFVZV05qNC9KZThlYnRsS3ovdGMrOU5JM0d6NmJqcjM3bEs5LzhkLy9PNmZjcWxjSjBNczNtMG9zSVY2KzFVdW4wYk1iZVFTbUxZR3Q4bkhmWnlpKzd1NXZqaWRudmRCOCszaS9sVWl1VmNvUVgvdVB2L0FIZEMwSjc0QjZJMHFVWFh2Nnp2L2hmS0xrQ0JvKzZtZzA3ckRNYnhYQnJHWkN3bEFzMlRzc2tCQm83bHB0OUI1NzdMLzd1M3g3c1AvUUNpSitOVGFoMk9LbEFOdXdzUEhSOFN6d3Rrd05XUXlZM0ZvSC9lbm10L01GcHJUMDJlUjUreFFLMkdNNnJJZkV2N0s3bXlzWENGMy9CTGEzUm5ScWNrckVOMkRqdys1T0hkOTcreW04ZHZ2ZW1OUjc3Z1M5eTBVdHJxNVh5eXFQVHM1TnFqYTZ5MFNFVTJFSGtQVWlDSUNzeVNsbTlkUE5ILzhhdjZxdHJjNmdDMkJ5V04yUXlGSmk0SUJDVlo1QmM3Z29SeVpxK1JIQ1kvTjkvKzRCK3c3REVLZTMrRTRIMThUSkNPY2hDa3F5Rk4zUFpoNldRVW9lNm1OZnVmM0QvbTc4UHg1R255VWRXUHFWSDQyaUFYanMvblpqbXRhdFhEdllQWFJyT0tJeTRyaXRRRS9sc3ZqZnNKeE5KSUg1dGJXWC80QWh3ejJiU3RYcjkwdVZkeDNMQVd4UlplZnZkZDE5NTVjV3owMDYzMDE1ZFc1M1BaNVB4YUhWdEF3S2dhV0ExbnVPNnc4RndNckhnUkdaU0NYQlRWVmE5bVo5TWFLSXE2cG8ySEpoc2NYVCs0WVBINUlMTmc2dlhiLzdpci94cWNiVThjTHhtek8xSHhRZHYzZm4yYjM3NTNyZStObWcyQTllaWkzSjhmTFZTZ2NKRDBTODhmL3U5OXo4WURDRVJQbndNZE1HZi83RWZ1WFRyMXNQVDAyLzgvaDlXc3FsNVpLRkJKMnYweHZkQmZ5akJnb2hLdno4c0ZmUGRiaGRpNlhxd1FqeGNGM05zU2R3OERoRlFOZE94VTdJQVUyQ2swNy83aDEvem1ETUQ2YUxMMUpISTNnc3YvdFZmKzU4RHlCck4vd25IbHRKRHBVT0JLVCtrMDZRbytxRUJEOEY5Z1k5d2kzNUFBcG9uUi8va2IvOWxsUmVnTlZ6YkF0YXhLNEMxblFlb0xqY1BRT2poVFhMczBWWmdIYndkbXVYN2J1emNhd3dlVjVzQ0Z3OFd0T1lNNVBiRjdUVVl1V2QvOENlRW5WdSttdkpsOVFKMUJKZ1kySVEvYjU4ZHZmbjcvKzdoYTE4Yjl6citiQmJuWXV1bEl2amNjYTErMXU2UWJmbXdublFkaW90R0JaNUxwdFBadGUwdi9lVy9VYmh5M1VjREYzUlRqNXJHV28rR0lDWEVMTjFZK2tpZ0RsaEdXV0NIZ016OE1nNEtVNmd6NkhnV1lWVU5QOVNMeU0vNmtHV2hUU0w0OU1zT0l2eEhyRTdyOFJ1dmpzNFBIbjNyMVpQdmZrMmNXelBISEkwR2x5L3RDSUhYSDQ1aUhHZE9Kb20wQWEzUTdmUWR4MDJtZE1kMlVkT3R6VlhUbklMSkFLL1FaNXRiR3cvdlB3SWRuMDRuMld3Vzh0NXN0ZU9DNkRPS0tmQUNPRXc2bWVwMDJrWkNMK1lMTmhRVStKQnR4NkdQNGp6R2JEUWNnU2VVUy9sbXZUa2VReFpNV1JIYnJTNHFEQUVyRm90OGhIdnR0ZGVoSUtGdS85b3Yvdkx1cFkzbWFISml1dDk4OVp2LzhKZi85dS8vby8vcCtNN2IxbWkwbUpObFR5WU5WVll5NmVSa09sbGJXMDluMHI0THEwNDNZT2hPRXNiQTkzN25kMzczK09IRG05Y3VvOExSS0M5SmltbTUyOXRySjhmbmdSOFVTemt3dTM1L2tNdm5ScU14RE4zNWVSM3lER2tiRDZlSFI4Y3dLcVZjQmpvTXBZSy91UzY5UkFrK1NRaFpmUFhxTlZFU05tL2NCb0pZNStORG5KNkY4S0pYT0RiTG4rVXZKZEFmMjB0eGZFSWNHTW1NTS9QTzc3NERUa2hpejZRS2RBYjBCaFlTSEowOWl6Y0hMdWxaRGRnWkVwTFlhWGUwVjhoa2s0bEdmeFNuVnlUNE5raFlGSjQ2NXd5N3dhU2xseTlGWklVUmF6b1J3eWFkSDZ6MDB2TWZmK1pUWDlReTJXRzM2VnBtYnpTdU5WdUdwbTJ2cmtQclc3YTlyQnp4THdJZEtrWHJuam5UNnNQN3BjcG1JbDlBSWlNVHJFUjgwWWN5MHpWbW9tMS9NcEQ4SUI5OTBRWmMxVitpeHRQUjdFeXNjOUZvR0E0aVZwVEV5bVJsaDRFMWhNR2RIUU1waENObU5sdi82Ty84OVh1dnY5cXZIcVprV3VqQjg3eCt0NnZwS2x3NmJ6N1hER01NdXNiRmZNL2hITGZXYkFNUlVJN281S2s1QVduWE5RVmFaZ1NFeGZoR3JRNVBGR2N4UWRodEcvYWZnaWdDdDRvazlkcHRzQ0RZMFhhbmd3cUFsNStkbmVWeStjRmduTTNsWnV6cUNYU3JvZ2dZcHJnb1lwUk15NEZHQWNxQkdFakZ3Y0doYVE1enVZS3FhcHFoL3NSUC9wbFdxL0YzLzg5LzcrdGYrWjMvOFAvK3g0TkduZWxRNmc0TXNLSW8yVnkrVkN5WFYwcFFoT21VY2ZucVpkZnh5cXZyVU5XNnFxVFRtWEs1SE16OGZENUx6MEV3bVd0MWV0ZXY3RDU1ZkZCZXFVQy9HWm84R0F5Z3d5bG9NZ1J5TXA0bTB5bXdIVUdXNEpsQUhxQUNKRldSWktWWmIxbU8vZHp0VzVETXpjMXR5SHdtazAybjAvZmZmdU9sejM0Qi9UMTNwaGdlanVnWndad05DWXZBR3RCV0dLY29EUlVDYlQzOW9ROENtcmV5ZWVuQmUyOHVwbE9QS1hYU2xGRDdCRzVhaFdaQlNwMTNhRVZVVm1pTWZCaU1ZSE04U2N2U2RxWFVIQTNJQU0zcGdtdyttKzcwdXFQdWNQdjdmc1N0UDRrYldUWTdrS3dRVGdSSkF1N3hIVmZrOVNzM2IzLzJoL0k3ZTY1clQ0YmdwT05XdDYxSzBrcXBCRk5NNjV5eDZ1RkEvUHJ6T2MyVk55Y3oyMHBrc2thMmdFUVV5TnFISEtIV3BSaEQ2a2QrUHhMSVAyQjFnSGIvMnhkdU8ybUlzR0hJRVpaQm4vRENEMUlwMDdJZStBTEtaNlBoOFB6WTZUWHZ2UHBIRDc3KysrNjRnOEh5SExvZ0N4UTZOcXo4QWdONUFFcGF5a0t6Z3FoSWtweEo1WThPam1LQU05UTB4Nk0vZEYySFVwY1ZsVjc2WnRxRlFuWThuQ1NTaGlnQzRYUzVBSklqaXVLVVdMc0E4Mm9ZMm1BMFNTUlNydU5vbWc3b0hCeWRJQVAyb3BCS09RZkxXMnUwNlg3TkhEUllTRUpiNm9acG1oQU10QlY4bE9iOXdXTVR4TU9qbzFjKzliRm5ybC81ci8vclgvdmd2WGZkUVFjMkFzYWJneEhuZUJsQmtWZFgxdEtwWExhUTdmZUdoWHdhWWluSWZMM1JhTFo3UVJESlo5SXI1WklvY1VKa2tVcW5KaERFOGRpZHdkOG93ZDVzYjIvRnVXaENsNCtPenl6YmhaMnhiUXMxUlFNVm1DcDY2VkowZGFVTWZjL0hvckttczVmUU96aTM1NEZPdTRWaVBwWFFVNm5NeldkdXhnV3VYQ2kwbmp4NDU0OStaN2gvNy95RHQwMTZWS0pWZlhoM2JrM2pDejh5YzdtNEdLTjFrREJTSVNSQ1RjaFVGdzNpUndPU29vSW9sdmF1UDNqcnRZVm5BOTRBTHRMUmIwQW1zYnhGeEFNVkZDV20rYWtvR0Y2ZkZpbUlEVTFUakVaMjF5djlzU2tMZkVxQmN5UU5KaE5ZQTJ2VW1qYmFSaXJCNnhtQ0hza1FkR3c0RjRZcWhZU1lFQyt1YjkvNjFCY3V2ZnhwbU5kQnV6NFpqVUJsUVo4S3VUeDZEd0ZBRHFzTXNmR2g1RTF6M090bDhtVWpRNElVTmliVTJzc1k0WkkxbXNuRDB4QW1oeWZudnZCemZ3dGIxQ0hMeWxCdEtCZWtuS1Vnc0VMb0VId2pRQ2o0SUhyd25XOS85OTkvdWYzdzd0bTl0KzErUStZRFVaQVNMQ0FIK1RCeFRwWkJlWGxWNE1HVlBkOFhsYmdpS3IwZXBMbWhKOUtUNlJpZ0EyMkZOb1R1VGtBYWtnblFEbDRBSU9PSUEzUVlEOGcyZURBUUQwVVArTUVOamZGc2FoYlZrZFo5SnZJUTR3d2cydERCTU5meTRsb2hmWFRlQVlabWZnQ0pPait2UWtPMzJqM2QwRDF3ZTR0ZTI5NGJqSHI5Z1dVN3Q1KzdHdGpPbC8vdGIyZlNpU3U3MjZvaTUzSlpJQmpjT3BQTHJhMXRSZm00b29od0hselBCZm5HMk1OZGxpVnhiWDFqT3JFKytlbFBmL0RCSFRqWis0Y251ZUlLRitWaDlWRTF1bWNaNDFVVnFJaWlDYndnVm12MUJJQXZTNUJwVVphSFUydk9jNHFxbTdidHplYlpYQmJlOVAzN0QwQ2J5OFY4RkY3dmVYM1FHK3pzYkZVMnRzNU9Eak5KQStQQnh5S1Q0UUJXc1ZPdithUHUyWjIzZzI2dGVmaW8rZURPMFp2ZjdENjVKeXBxRE9EdHR1Umtsc1l0SEVFYTR2QVhYNkg2b3RIRlI0Y09NbEtIYjM2VEFFbHFuU2dOM1FFaW5BTHdVY3QxMFljOEtkcUFwdmpIZWZqUU9KeTlLODI1dEFiRWo0alNlQzVzR2pJZTM3OW5KSXh4NjR6WDAySXl4VnhyRk1uY2F6bzl3U3RnWjhmNGFhbk01ZWMvZHV2N3ZxVGxpb05PY3p6b2pTZGplcGw5SWpHYmVVVG9XWlZ4akFNOU1KM1VqeC9xdXBGZFdXZTFaQzNCZm9aWWlDT2RpYUlmQ2V6bzVUL0IvZWNKN3F3eWRDUU9aQVhRb1lpUUthSmk2UWYvakwwdHVFWDBqLy81UDl0LzQ2dUFjU0tSbkF4SDBMOHI1WUxqMHB1MkFITllhNTZMZ1pwREU0RDlLWnE4czdXZVZ1S2xuSkZNWktIZkRnOFB3V0xjbWJleHNRWTU1cmlvNDg1VXNHTkZSY2ZOZzBBUTQ2N3JpN0k0ODMzUUNYQjZVQmt5bWdKMEtGRzZ5WGpDQzd5c1NLaGtvOW1FcENpcURFM3Z1QTRVZjdzQnQzQkNGNjZpOU5nbEZCYk1oS0hydzM1M3BWaW9WMnYrZkRFRjk1N1BSVUY4ZkhEY0FIa3dMUWdZTEhoL01BQ1VxWHRpY2JvV3dNV2o5SEpza0NLaDNxaVhWZ3FwdEQ2ZGpQV0VibG5tNWF1WHhzUEIvcE1ES0hLZ1kyOTNENXhBRXVOd1RtQ1hVYVhwMUo3Q0ZOc3VqRms2bGJhbTFwV2RqZmZlZm44ZWphVXptY2xvREVzRmNBVStzV1JEVjg1T3FnbERoOW1Ec0ZYckxjTXdpc1gwMmNuSnFOMU9wUkpnTHpEMjhCY3N5MEdCMW1TY3llWWd2TzFteTVwTVlOK0t1ZlRqTjc3MStMV3ZQWHp0MWMyYno0bGFpdHBCNDRpZW9GODI3bXg4NlVPQmkwYUthMXNIVCs0N25SWnFBYlZPWTgwdTlaUHpTc0NJZ2VMamRCTFBXL1FPSEF4SGpCWXppRVpSbC9GMHNsMnAxSVpEbjk0T1NBZ0JHZXYxZTQvdTM3LzlxUitFL1VScHNCY29oZWw0Qml2OEwxRktiQnZwdktLc1gzM205dmYvY0hIdjJuVFlHN1NhY09TZ0FXRmJmWnBEaFFyUjFWN29kd0VESVdqWlloa0N3UnFGWFZSMDJCcjhFT2VpVXpEa0VvTFpHWmVTUVhObWZqbk1IMmFuSE5RakYrR2luTEMzMERWOEpQYnQzL2hmTy92dmcvTnVicTBmUEg0eUQyZ1JaOXV5d0U3QVB1Qys0WlNTTE5ITFJZbVpFK0dETVVwSVVWSFY0V2NPdXgxblJsZTdSVjdBRUk2SFk1Z0FkSFNNRjRmRG9hYkpOR1dkUFRzem53Y2d4OWxzanRuU0NQS2c4T0ZvakpvRDkrZ0w4Q1dFMFhoS1ppVE9hNGFHVGkrV1ZxRXRjV292bUNVVEJ2UTZITm5LYXRteUxURDdMcmppeUd4MXV6RkJTR2hhTnBPQk9QWDdmYkFtOGhhaVlFb0pLQytvV3hBRGNHNllJQ2lTbFZJZVhHTFlIMk9RY1M0MEVQMHdDMmIxODhhRFIvdUZYQTRLcVZETUFPaXZ2L1lheUZVK244Znc0TlNLcEtTek9TQUJ2cklvU2FQUkJMeGMxOVVoNkhnNkRhbUc0Y3BrVXBBcW1JV0RCNDlnREdmelJiM1JxcXl2ekdZQjNVOFFvVTFua2lETmVYcWxCeWdHeW13Mk8rdlpWREdmclZmcjBBanBUQlpPQmV4U1BCWnB0OXEwVEpMamp0dXRWRkw3enIvN2paWHlTbHpWdytjbkdFTFlhRE9OeUlhV0hOL1ZTemZmL2ZydlJrQ2hpTk1BRUpRVGdkUTdzL3hvRGxoZzJqQXMyMlJha05nc1V0M0FuMWptVG5GbE9EVnBmZUVBcmkwM21waUJIMVVrcnJGL041Y3FjS3Eyb0JmOTBSbnBiSVFxWUo4S0NWR0piWFJ5TE03blZ6ZWUvY3dQYkR6enZPZmF2VWJWczIxQUhrWWVTR0NzZ3B0YUUzZlU5aTJyVU5rVU5BMEhRMXFvREZZNkF6ZFZuaVZjdEpGaG1OcE5VOFIrN3BjcEhXZ09wWUR5aEpuQ1FpaUZha1ZuSTdnLyt2cTN2L2IvKzZlN2wvWmNKK2kybXNOQk94cWpOWGVnV2dCR3VydUpubDBzeUsrVVJEUWZSQVdKb05UdG9abEtKS2ZEUVZLS3BmT3JkKzdkWDFrcHpqMWYxRlNvZVFnTThPbzRWcjVRUERnNGtrUWhtd0hibVdLa29YZFJHbWc2TmxkV2dGcW4xK25RbFVSRjczWjdqbW5OQXAvdVU0N0dRQ3hrdzBqcXJqTkxKQXpYY1ZFSGRCYk5peGVwTW1BN2dCY0FQUnBOWWJpdlhkNmxOVWRuWGlhZDRtSkUyT0ZNeDBVSm1oWjJkRHd4b2VhbkkwaWdCb2hicGxtcGxBRlEyQlpEMDF3UHBTWGhvOSs1Y3hjc2FuVzFqQTVTRlJVT0tOaS9rY29ta2hrb2JGV0hWS01IZkhzNjFRM1Z0bHd1dHJoNmRYTXdtS0R6SWJRenowNm1FbWp5NmtvTy9DcGJLcmVxMWRYVkNrMVljR2Z3SGxPNkROL2RBWW4yNTJnRmpOKzRQencrT29iSzlLT1J6ZTBOVFpVTGhaeTBDR2FMeUdqUWg2WGdoWGdzeGxuRFh2WGVPNXhyOWc4Zm1wMVdjWDE5QVptQzFncUhGQUVhaGRDQjN3WDZoVGVTQjI5OUc1d2RvQ0VXQVZDUTgwTjBubERCbGdoV2pBUzBqR3RiWG1RQmdRK1lPb2YyN282R3E3bWM2M3NUbVBUNWdxNnd6YnpxL3NQKytZa3dkN1BydXhGWkpXQ3hNK012eE5xeUhpeitGTE00YWFwUXV2N3h6MTU2NFJPelJkQ3RuOEdKSVorTlpBL2FocHVBUVE3YUVkZk5sTmZpdW9IalFzbEJVUXp4RkVlTTBxbHN4TU1VK3VhKzhMTy9SQ2U5a0Flay9ZbkErb1h5a3VHeHZILzE5LzhyTGhZa0V4a2YxTTBlWWJ4bFRmRXNEOVNpMVdxbDBwblJhSkRMNXRCTnFxb0FsSUNDcXFxK0M2VUFzKzYxdTJON2p1SGprNm1zWTd1eXJwQ3ZzQ0JHR0hMM1REclRiclZjeTdweDR6cmdDK2NTQkQxc0VBd3NkQTk2QktxN1VDZzBteTJvWkhDUGhBNyttVVRWRmNBVEZMbGFTNlpCSEZKUVoxQzYvVzQvblUyRFRlcXFDbE1Bc3VRSE0zQjlOQXJlQlVnWFRVV2pOMjFFTkhiVkJNM0taUFB0VGgvOXF5dVNwcWxvQzF4R01DMWE3WFpxZ2xiaUc5S1JUS1hZYlBWRXB3T21rVHc3UFlkUCtlYWJiKzNzN2p5OC95Q2JTVlZXOHRYemhxeG9Cd2VQWWMxUVE3aXFWNjVkaHBBWFMzbW9ybmE3VXl4bUljbTI3ZmI3STdqRm1WeUtUTGlxUXE5WFZncW9OaFM1bmtpQkxrTmNDOW5NWURoRXF6dmRQaERRNnJSMFdmS0N5TGpWNGVheEtRaUFvaFd6V2NmM0QvWVByMXphSFE1R3hYSjVNaDc1MCtHOXIvL3grZDEzWjZOZXZwaVB3QUtqd2JRQUUwTWJ3MEpsWS9mczdHamFxTUl3SWhXS0JnMUhKOUR3aEhJUmdVVVVWRTFUUkNHQUhnOENVWllrOGlRcFIzczR5U1dTOUxDZng1N1Fqa1JnM1YzSFU2RWd2Rmx1N3daU0NIc2h4T2ljeTVPSGdVN0J6b0ZBK2hhMFBwMjk4dUlyVjEvK1RDd2VIelNxSE93RmV4c2g4cHFtQ1JXU0xtK2xLNnZoczBkTWJGRWNGVW5iVkRKYVJkOWhvZUY1dUMvK2xWK21UR0ZDbVBaaG9JdzRDbTBsQXMzRi92Q2YvZE54NDhEeW5Id3UzMnZYNksxQklpajFITG9CNXdQV2dTSkF6bkZ0ZE5OZzBFZkZNWGJRQzZabFI2SjhmekNhUjNqVGh0UHAybzRYUkRtaTV1eVJMWEJ1bkc1R1YrS1RBQk0wTFZveEdBelJaWmxzaG8vRlIrTWhUUGwwWWdJS2RIRWdGbTAyNnFnZUNEK1VHUlIvTnBzT0ozQWZINTF3SEMrS2NWQVVjTWVaNThMUmhHTUFYZ1FKcEpmYjBTdnllRWhHUWtmZGZEakhvRTd3Z3pWZEJZZ2gybUQxZE9OOERrOFNIdWRVVlJUUUtQYThHMVFxSjB2eW8wY1BhVDVQSkNiUzNTR3hzbHJwOXdZZ1RpaE4xZlROelJXSUg4ZEhZYlZRRThpL3Fxa1l6VUYvNURwMnZ6c0FLR0g1VTJranlndUh4K2ZEOFRTVkxhREM3dFRxZGZ1S29RRFo2SGg2RWJFM2d3M3dYQmQxU01KN3MyM1lidkNXK2N6UEpCT3dQNldWY293RG5yeWhiVGU3ZzkzZFRYdm1nREVpZnpxWEJjMlRRS0VrcWRPQkpqSWNkR0x0K0szZi9lM0JrM3VuNzM5MysrYXpMcGp4ZU1RcEdvMXlOTFo3NDRXM3Z2Mkh2bWxCbWNQZXpoaTNnYjRsSEJFU0luQ3JJSTJsZktiVzZhcFFScDRGalFibWljNkJIaHBadGlJcklMRG9RTXJQTHUycjZSU3NWUG42cyt6UkRZWW8vSk44VVJTL3dEMEQ1SWNCaVVpaHhIbEVOUkk3ejcxODdSUGZMK3ZHdE44RlJKQWZ4R293SHVyeDJOcWw2ekVGMkVOZ2trT0lKLzFNYmdvRE9wMkdxaysvK09lK1NLNHFTUnFGc0E3ZkUzQVVta3VYWStWWS9ELytvLzhoR3ZOMEpjRkhaclJjUnhSd0Y2QUdnQVVBRkpUVXB4bU9QT2dqY0t5cE9yeFZRQmFuQmhDUkNmd0dCTmx4UENPaFpITlpJQzlYS0dKRXdhMUJHSkFCakxQZGJldTZQcDJhZCsvZU5SSkplSit1QjJHbWE0anJtK3RRb3JBaEFzMnJvWUIyd0pXUlpTbkxlTER2KzhBeENod054eGd0S0NjY0NKWkYweGxvL0NBWDNPbEo5ZnlzYnNpQ2dyb0lITmgvU2xkMFdZQVREZGRWMFhVSUczckRjeDBqa1lENTN0dlpndHRFbDAzZ0ZzK2pZQlR3VnFIRDBEV3crTDF1RjNXQUJENTY4UGphMWF1Y0FBT0M3b0NyQWlENTA5RTB4dkgxZXJWWUtraVNBZ0VENTV0TXpGUTZtYzZrb2M3QmRHT1J4YnZ2dmc5Q1VpNW13VWNFTGpycTlFaUpxcHBuMloxR0IrZnROZHV1NndLT3FxRU11b04ydXd1UXpmMkE3bElGL25nd3lHU1NyZTVBVmlVQlRmVWdIUjZrTkYvSU5ScHRkSGlqMGN5eDJ4RUVoc1ZDNU9QRFFTK2xpRWZ2ZlhmLzlWZlAzdnFXcmltSmxVMzRCWFJKcExEMjREdGZoYk5GNHg0RGptYzAvZ1FNd2dqNkhQMnBDVnc2b1VGenYzSnRjNy9XbmtXaWNWcnEza2MrOW40UmpFOGM1QXR3Z3QzeVJrTkp6NVoyZHNWRWtxWWZzVklJNXVTK0lsRFpPQmRLWmhzaEZrTlZqV3dNOTRzSWpPejY5V2R2ZnVwTCtZMXQyNTc2OWdTU2QzYjRLQzNKNWV2UGgrSVJsc3dPcHZCMGhqRDloSVVEN2w5ZzNKMFFUN3ZwZExUNVlhQUUyRHdZaU5OM1Buank1cXV5YkdCSStIZ1VXaEo2VHBKSmthQTg1TFBNS1FDRmV2dnNwZ1VNM1dnMDh1Q1dCb0Z0d1ozbHA2WkpLODN5c0lseVpXMFZuWnNyNU05T1RtR2tVQUl5b0tOOCtDVFJDTFFtL0hKUWRxUVJDekx0ZERvZEYrbnFKSWc3REdtNzFURXRNNTFPd2kwampUS2ZRZXNRQ0dCcWREMWdyeUFsZmk5SlorZm5yaHU0cm0vYmpqVzFWTHJJUlM0T1BBb1E0bHcrVWN3bTlZUXhzWnp4eEJaa2FUUWNnVDZCdWt6SHcyUkNRemtjdXk1RVUxOFdvR0V4QURxZlQ4Y2lzVnExTnAxT3dEemVlZk1kWFRjNmJXQ0xyNUx2U0xkRk5WVjUrUGhnMmg4MkcrQXphamFUQU96b0Z0aGlrVWltdURpdkcvQTkyZ2VQbnZDeUFnKzFXTWlaTUZMdFBnd20xSE92UDJpYzF2ajVIT2dGZEhndjBCT2E1L3VOZWdOR0V0b1g1Y05aMUhUbCtLeHFXV1krblR3N09nTndIWCttYUdxeFhEay9xMkdVZVVFY0RZY2dZTkRCUUNUNGI3NllVd3h0MU8rRHFzbVJ5TTVtNGQ0M3Zwb3A1QWZ0aGovdXJsWldRU3VyOSs0d3cwdmNIUUUyTTBRRFVpRExFVDYra1UyZjl3ZDVUZG5PRzRQUlpBTE95WEVpdlZON01iRnByQVZSZ3VCRFlrakRjckhIYjMvcnhzdmZEODdLVUFnWTArVVRCbElHT0h6akYvOGhWT2tZU2dZbWtVZ2ZRajY0VkR5L3RuWGprNS9idnZXeXBHcHoxNmtmUDltOStYdzhTUmVnUW9INU1JUlZwck9FcGRJcHVDLzgvQzhUME5tKzVjaytER0VkNklIT2VEVDIycGUvYkpzZFNZZ2J1b1FSeGFpSUVoa3lYYWYza2tkZ1V5RUV0QVpWSUNrcVhZN1VGT2lZWWltWHlhWFJUVkRZNEJLeFdBUjlBUTNuV1BialI0K2d0RURRQVVxZ2lvL0hrWjhlSm9oRWdGUXlHZlE2YUsvVElRUXNnc2hvMkRzNU9zSlpwNWF6dnJhR2xxQllaRWFmZ3ZEWXRnMEF3U21FZWdaQzRGekNFR3U2UWZlOGlCZkNEa2ZBb0hMRkhGenEwV2hZWGxzWlQ2ZVpkSkpOU2xrOE9hcmxDL1FlNnVGZ0FHNld6bWJBVy9EWDdYUkFka2VEd1h4T0doM2tQcGZQd20zdDk0Y0lHTlR0elozRzZhbVMwTGQzZG0zSEJYTTdQajFIenBkZWZPSCsrM2R2UFhkcmJXMWxhdEhzaG5hN2ZlUDZGV0Q5NVBSTTA5bjdZVUJhSUV3OFZQVWN4WFpyalFERUQrNStKZzJYSUpPZ1ozQ3orV3dFUXNiOGpMZ2lSLzFGSXBXQ21talZtMUV1S3NZNHNBaEYxUUxIaXdxaWtUU2lYSndld1FWU0Z4RklMOXEyc2xKQ1IwR1hZQ2pydFRwc0VhaWtRNWZKZVpRNUdvOU4wMmtkUG43NDJ0Zk4xdm5STzkveDJzMjkzUzBNQWVnZktTK21nUWdLRE81QVA5QW94dU95Skh4d2RINXJvM1JsQmIyVk9HMzI3SmtQcHlqT3hXd29KTHBjQWNURGNRVlR0WnpwTkpISzVMYjJZRERwSHVSVHBGR3BGLzlQQTlQV29aYkdGL3ZRQnZJdzRZbXFxZXptTXk5Y2YrWHoyOWR2UzNveXFxamZlL3hGY2N0RUl2UFl3TEhjbDM2V3VIdTRkUkhDR05wSDBnV2JBeU1sUktKLzhNLy9jY0tRNW9FRFgrWHM3RXlVNlRJaWREQ2pidURWQVhRejFCUG9CMXd1d0gwMjg1S0djWEN3Zit1NTI4MTZFN0FHYTRhQUFVYXVBNGZRQWFPbHE0ZTZPaHlPZ0licFpJTEJSZ2JvRlJRSGlvSysxbFJvNGdWS2h2MTk4dVNKWWVpaXFHQ3dvTCtUaG00a2s4QXg2TDVsMmNsazByYmd3blB3ZEluZTVHZ3lGb1RJU09qUXFiSWlybTJ1NTNJWm5vOFZpeWxvNjlIVVFYV2E3WDZNRjJSZEx4UUx2Y0VBY3JXNnVtcEJ6WTRuSklFMGF6MEdrL0xvNFJQVHRLSGc2NDJhcGdGUzNLTUhUM1ozZHpMcE5FUVZUQXdjdnQybTFYY1hrWUNQODcwZU9kRGR3U0JZQkZDbHFFTmdlNVBoVUJLaFR4Y1BIejRHNW9oMFFXYjZQWHdaaGdiZnVkbG83ejV6TTVHbHF4L3dUQmNPd1VhTXg2cTFCbHlGODFvZFhWTXNsM3Fqb2E3cDVVcGxOQjJMaW1pQkhXVnplZ0lwWldjMlE0VWxXWFJkRytNSHlSOVB4cEQyc0g5OGRHOGtLcE1hc2pMcEJCRGM2Z3ptRWJZRWNUNExhWnE1M3JEWGd5dHNXVlBBdEZRczcrN3RwTlBaYnJjSGxLTkFRbjBzQm0wQ0oyYWpVR2lQeGgxNDJIejAya1p4YTZQU25waVRpUVZRUVUvTWFMNU5vS2lnaUE2RUQ5Wi8vKzY3VjI2K0pLVXpqTW93UFVvM3MwaWpFOHdJY1F4M1R3TTJMejRzTjlnemd6NlpHdnhHWXdJUG04c3A5TUsyRDhHN0RPR1J5L0padlluUWN6L3c4Nzk4Z2ZTbmgxQ0U4a1lYR0FPb2RvemgvYSs5MmpsOEZ6U20yV3IwZWoyTUtMUlJLcDJDVG9VU3BkblJpd1hpOEl2SXZzc1NyRE1VU0RhZlVTVEZTQmdnMDZBU3dLZGxXbXp1YUFUYUJVTm9HQWEwS1U1bzIxWXVsNFVPd3JuQmVzRno0a0pja2FTRGc0Tk1KZ0VCQXowcTV3dWd5NUFXbEZPckV3TEFaNHJGSWt6RVlEQUNWNEcrbkRrMnlqUXRNRy90NE9BSW1oT2REamFsNnBvRFZlbEFVcHgrYi96dXUvZWhMMUZObUtOZ0J1ZlBIZzlIbkFBQm0ydTZGc3k4MDlPelVya0lCeGQ5QzlDazB5bnlZcjNnN0x3S0d3Mk5kMzV5c3JLMm1rd2xmTitHL1BUNlhjZjJRZVdiemJZc0tlMUdNMThxWlVENTgzazBNS0dEaDh4UW1lMjlTMmVQRC91amdXVmJoaGpmS0JVYVorZlB2WFJib3pYbFpIY3hmK0hsRjA1T1R1Rk02d3B3RGtVNGg5bGNRRUZZZGk2Vk9XODFpK1g4WURTR05uRTllOUR0MTJwMVZVK2hyMEJ5Qm9OQnI5L0RXZktGREV5anFzaHdpK0ZLdzNvbzhIUlRXcjgzQkNmRUxzZTJrcWtVUUlCaHdsNUFDVXJvOVBSODJPdWo1dytPamdiOUFYVEU3ZWR2d2NCbXMxbFpsU0dWNUo3SkJtZ2IraEFxQ1o1UElaVThxTGR6aW14NzlrcFcrOXluUDkzcHR6ckRNUVlVNnAvbUF2aWVhcVJtUHIwckN0cXpmWFowL2VYUHdLQVJ2SjRxMlBDSDhNeGd0L3lpRUVyQzA4MkxFT3BoaXVCUUJ0WmxvRFJHZ0ZocHkrUENaQXBvNWcvOHdpK1RDTEJFUkM3aTVKN1NKckFlaWR6OXd6OTYrM2YvTlF3c2RIeTMxMy8rdVZ1cW9XZXkyZkZnNU0vbXdEcWNNSE02QlNXZ1dhTHNSaWErMjNSMUhEN2x2TjN1d0hiN2dROGJpaTREd1Uwa2pibS9RQVRrdnQxb1FXeUFKd0M2V0N6MStuM1VCSktEa2lFRG1Vd0dRNExCZ09MdkRQb2I2K3N3d0tDOGFHUWhsNE1vUXZaQVRDM0xoZXpDdzlNMEZVTUZsZ1hYRUpBdHI1UTltbUVXdHkzYm5OcW1hZUdNNEV2VVlUQkh2QWdUVkt0VndiSWtXVGs1T0lhNmdjMXBWS3ZQUFBNTVRCRGNYMVRHYzJjUWhoczNiaHp2N3l2UXc2b0tBYTZVeXlocU9KbE9SbkNMaVQrUW4yY2t5dVd5TzNNbXB1WFp6dXBxQlZ5b3VMTGllYlkvanlSU1NlaXpYS1Y4Zm5SeWRIdzZISXdrZ1o1MEJwMG45N0hmejVYTGdLS2tLRnBDYXp4NmVOWm9MVGlvOW5ZcWFjaXFjbHl0UG5mcnBxS3J4OGRuNE83cFpBcStVQUk5bDBrNXJydXp0ZUdQSjBQYmc2dXd2Ym5hYXNOL1RZTW1vbW12dnZvMTFBcmFEZlRTTWgyTU94K05pa0lVdkE2T0xDcVA0VGcrUHMybWsrQ0VwK2ZuQXNldHJhemlGSENzWDN2OXUzQWU5blozTURTNnFrRUZYTHA4Q2IwSy9kMGJqbGFTaWI1dGRZYVROQzE1d3NtaThPS3R5eWs0TU4waDNTV21lV1kwTVVoVmsvUmFrVVhVbVF4YzE5cTY4U0s3VVBrVWhoU1dZQTBEaTVJTkNMRkxVUVpNOXFGMDRKT2hsRkxvUUhiVGlrWFFURllVUXovN0FPU1VEYkZGbFB2aW4vdHBUcFJpRUcvYVI0WUN2L2pHSm4xSG9zZmZmZlA5UC9oTlE0VWZ3c1BvNyt6dW1TWTlMYUVvS3RBRGY5THppQ2pQRjNOME9xQ3ZxTEpBNndqTW9RQTY3UzQwSzVnOXVENXdFbzlIeWYyVVJKZzJtRTVrb2JsUTBPV1NCQTNkNi9aTXl3SzA0ZkpDZzFxMkRkb05nV0UzWmFHUUhMQjI2Qlh3cFh3dUs0bWk0NUtPZ1QwQnVVUjl3S3BIbzZtc1NwQ3JWQ3B0bWxNdXl0bTJtVXdZT0FYTmFKZ0ZVSDRxNkd6RWwzanVZUDhnWDh5SWNYaWxzdS9UcTAraGhFRFB3ak1LOUIwUU5XcDNZWTVRYTFnbnNnK3VNeGpDaFUwMDI2Mk5uYTFTc1hSK2VpN0tFcmdxUkJvOGVHcE8wWFBOVm5kamN4TjJ6N0lzVkppVzkzY2QrTEtPYmZmYTdiVmk2Y3JWeTN5VUx2ajNSOVBLU3ZHZDkrNEVzZWphYXVXUGZ2OFA3OTI1MXppdlJ5VnBPRFpuamcvM0xwUFFlYlRGY1hmM052WVBqKzdkZjJ5TmFZNGtTRWlTdlJ6UHMwMUQ1R2lXamhBZmprZkZRaDdVU3dCemt1UjJ0M3Y0NUdDbFhJUUZBSDJDdWtHN1lPVlMwcUpSYTNZRzAwSXhQL05jbEFZWnhyR2JteFcwdDk1b2ZPeGpMMEZmTkJvdGpPL2h3V0U2UmNGeXpPKysrUmJrNGVyMWEwWXlkVjZ0SmxXMU5UWmgzVHRvaUNGbHlwVmcybm4rOWpNbjFicFBMNm9qYkRxdURSVUJCUU0yQzN0MC9ZVlhPTGd1cEpoSk5UTXNQdjFHSUdpU1dtYzdXYlpsWUJDbmdHS1g2U0g0S2NLK0tiQVlBM3I0WWY4VThNc1Z4Ym5ubU5uVlRicWJBMTVFMnBrSURNbkliUGJrVzk5NDlNM2Z5YVJWUUEydXBFbHZIYmZoOU5CTWh2a0NmQkVhR3FVRW5nZTZ6VzVNY3ZSYUlPQStGdHZlMllHamlTNkhjb0tmQ0RWL2ZsYkRnTFhiZlhUY0RCQ1llZlNVUGwyeVZIR1Vua2lvNFBIOVhqNmZSOWZqakZESnFEa2d4bkh4YkRZVHpBTGJkdW51S3g4RDRZRnJuRXFtZkpwYU1BZVlnSGRVQ1h3bW1jN01ncmxsMnZSOGhhcW1NbW5YODFFZ3pBTFVmenFoUVBmTzVuNDZtNGFOVmpWNHQrUXNBSXVhU3JPMFFXYlN1Y3lNWnFUUlRMTHRuUzFSVm1sWmpXaVVYblZFU3pYeE9GMi9Od0NMNVFRUmpKbVB4dDUrNjExVlN6VHJEYUFxbVVpMUcrMUlGRmczd2FRZ0c3YnRpV0ljaU5HaEpCTEdRcFFoTzhmSGgwZTFwcEtBUWNnTHNiaXNHeEhQSzJlU1VMZnJBUDVheVRmdFVtVkZVWEJvZkRKMWFOVlNrTWw2MDVzRlY2NWNxWlNMYy9UQ2pEQ3pRR1Mrd09Cd0hBOTlqMkZGWDBLRGRKdXREOTYvaDY3ZjIxaXJOOXVqMGJoVUx0bldGQ1JXTXRMc2llc1kyZ0xkSlNrUytEM0l4L0hCVWJHVUI5dkdxYnU5YnF2WldhbXN0T0RpOUh2Mzd0M1hOZVhsajczOHdRY2ZDTEVvS0g0cUNYZmE2SXlHemM1SUVRVjY5NWpBdzFMQ0NjZ2FSdDZRRzZQSkhNNEJ6YTV4d2RlZ2xQMlpPMjdWc3l2clVpcjlVV2d5SFVzUlNtVFl4SjZuUUVlZzdXVXlSWmlLWnhINnBSamo3OUQ2b1ZDUU5XQloyRTBqa2gvYXkxMjd2TnZhZjF4L2ZLZis1UDdEYjMvVkdqUVc4SkttNHlldmYrdnJ2LzVQcTQvZTh4MzN5WlBIcWdvdm4xWUdSQlZ3TkRpWmE4L21jeDlFQTdReW9QdkdOQnRPRXNRbkI0Y3JLMlhRZDl1eW9Famc0c0JxaXhRa3VIVEpaRnBWTmJDRlJNb0FwR0FmUU1FTHhlSjROT24xdXNQaEVDUTdMc0JWY3NBTlFLYzRQdDV0ZDlBU1FBZmY0T1YwWVJsdVhMQ1FGQmxDT1hOOUtOUzE5VFhBUHB0TlR5WVlUUlA5QzMwUGpRNzlDaHBRS21aZEYrMGdjZy9qazYrVVRBeXlPNk5KTERSTEIwSXJGb29aeU9Rc0V1MTF1cmwwQWxqSjVITG9QWkM2czdQelVpRVBQWTNhUXJwZ1JrQ3hZQk1BYnRqM2d5Y1AwMWxzNml1YjYwVFBCbVBiQkROT3JxeVVhdWZWMWZVS3RXNDhoTVFtVXhuVlVDZFRpNjZIbU5OS01VL1BPR2xLZE9hbGtvcWFoQVBRVCtVeWtrNnVjRHFwaVlya0JCQy9oRE8xMHJsc3A5TVZGZ3RGa0ZmVzFtRDlPcDIySUN1bVk2bGlQQ2x5K2ZXMU1SeHN5NFRyWHowNnJWWnJ4OGNuTUtPcFhHRjdlNmV5dFRXWlRKTEpGTHdkQ0lNUUYxcU5acmxjZ3UxRlM0SHlnNGY3MW1RRU1wT0QwNXBQb3l1NE9EZWFUT3YxZXVEUGhxTXhGRWNjV09hNTg3UFRtemV1UDd6M1lPNUJhWGhwbk0vUW1yMWVOUEFuanIrYUZMT2x0V0dubHFIMUNLeVAzNzcrOExUcXpnSlprRncyWlJLeU9lelVCL1hHbFk5L1A1cytBMHdpQUtPRVRZSmttSUJBR3VZamdiYVhlZkM5VEF1RmhIM0NIQ3lSNVZnRzhpcnhFMG9PdDVKTWp3YURsQ2JhM1Y2dldtMGY3NTkvOEg3OTNudnRvOGRKSFQwcGdGM0FKVDQ1UHFmSHFHZkJvTjh2RkxKeERsNmRING5PZFZXZldnNlpLbFlnVUs3S0NtQUVtZzZvb1lOY3lMWGo5UWM5OG1pNUtDL0FLSU9ZV0hBUVc2MDI0QVFpMkdnMjZVYTM3NmVUU2JBZ1EwK2docFBKS0dGbzhGWlZXZTkwdTRhaHgvbTRibWl1WStmelJTRk8xeG1CZTVnYXFNOWNxUkRuaGZGNERBR0RCUWYzaFp6Qkp3TkdPNTNPWkV3RWc2NVU2alJtam1YWDZtMGNDM21vckpjaDNYUnh5VEtQUUJRT2pzYWowWlZyVnlSWkFLZENlM3ZRNHBGWXBWS0Nib01QQ2huZTN0MEM4a0RtSXNGODk5TFdaR2pDZjRYQm1kRzk1TVg1U1IxR0EyN2NzTjBCZXpaU0NVbVEzbnYzenVwcTBmVTgyQVAwZGl3R0pUY2I5L3U2QVIrR0Zqbkk1MUl3ZFBBUSt0MHh2Q1A0TjhWaWJnSnUzaC9Dc0lxR3VvaUMrM0txSkhrWXVTaDVVSlgxRGMrMkdtZTErU0txeUhxejNYNzN2VHNZQzBVRXRhUjVDRkUveUNTUzhIMUJuOGJUU2ZYOFBKTkt3bnMwSkxIZmFSWkxaZFFIS3N6M2ZFbVNlLzNCWkR4MGJSdEFuOUNGZEhNMk1WZFdpc3pBTG1EVFlFRGgyTURaV0FUelpxTlpNTkRyZWdRdWRTRVA5ZVFIaTJhbkp3dnhuQ3Bqd09IWGVaUEJiTUh4Yy8vUC9aay85ZWFqQTJ0aVF3ZEI5MEhzRjdTcVBuLzV1WTl6ZE5tTktBVjlFejZmWXBUZ0czNkkxb1RKK0E2bmx5MDNubjZJMjdCRUZqN0M4c050OXIwTTNHYXhnRjVVMFBGR0VrdzZrVWhoa01BSjBHSFExeUxNdnhCWEV4cThMcHFZQ2g5ZjFZeEVvdFZvbnh3REdXTXVMa0M4QVY5b0NHU0Yxb2RaQkVzbTJZQnZ5dlFyVlA3QjRRRkdyVlpyM0x0N0g2eWpXbTFBVHhUekJUL3d3T1c3N1Q3b01pZ2pxQVhVcWVmVFpHQmQxOUQxMEx0UVNDcTk1R1FPaTlSc3RvdkZBaTFmRkYwWVJnTGVKMFJyT0pwMHV4M1BBUlNuMFB5Z05PUFJFQU1KdE1BSmpndjBBREVzYnlhZEhZOUhwVXJKY1VCVVBMZ0tPM1NWTFFsWmV2ZWQ5MkNqams3UHRyZTI0Q2tpUS9XOFlSZ0t2RFNNRFZwRVUrZG42QlZZSzFwWEVXZGh2VGYzWENlVlNGeTdlYzB4Unllblo4bWtBZVc5c3JKeWZueU03RndjMWdQTXpyNzkzTE5CUkVCM2dBcEJrQUo2SlVhVXJwLzRNNXhvTmwrMGVnTlZsNkgxbFJoM2NsWTlPRHg2NVpWUFQwZGplT0ZBdG1PYW1XSStvV20wT0tsdGcxd3hoOFM3Zi85Uk9ac0NwVFFTNnY3K0lTcUgwYmwrNndib0g2UlJUMnFGUXU3bzVHUnNXalRaTXhLaFZ3a0lvajFocjk2YnoxdTE2bkE4U1NYVGg0Y0hEbnhZMjRZQWc5ZzhlYnd2eDJMVlZodmM4UFRzUEd1a3hwTUpiRm9reG5VSGc5WDFGZGplVnJjbmNMeVcwRzFRVXMrRDhZRXpFNDl4RTlzc0c1S2VLZ3k3OVlTZWJQWUhhanp5d21jKzlkV3Z2VUYzTWFJWVJhS2M4TVVFeVNoZnVUWW5OQkxjNlhlcHZiLzNnNjlsSkV3QnVDbkN0RGh0L2g4RUNBRFVRaWdKSDJiam5ybDZ2YmkyZHZ6b1VFdHJjSXlncERIR2tGY1VaK2dxY2svTk1SdzFuby9LQWdkVng0dHhtdVU1RHpMNVhEcWRJVURnbUVVTVVyR2dwWGlBQUpvTDNlLzE4S096QUpMdE9rNnhVRWhDZWZ1Ulpxc1pZZ2pLeWJZdGVIZWVEM2JPMDdYbldNeWdsWHhWbkFDOUtDdktZREQyUEllZWhxT2Jnb0Z1cU5EYThCUm9QbmhjbW5rK2ZFckhNV2Z1Yk5DRHhxWEpWU0tvb3pjRDhZRDRUVTBiK1FFU3lDU3R5ZWM0NC9HazFlam1nQjVEUjZjTitvTmNOdHM0UFlOWmgyQWtrZ1pJY0w1WXBJc3Q4NEF1Mi9sekVDMVZVM1JOUlg2NDV0RFFvQUVRdkdyMURQMlN6aVJRdldydHJOZWJ3bDVkdnJReDkvMTJwMXRaMjREVktwVUxyV1p6UEJtTSt6MklIUS9jQ1h5dFZzMWxNakJmNk1uajArcDZaV1hxdUhURmRCRlRaQUYwNHJ4YXYzZnZYcTgvU3FkMHVNSzFWc2UwSGJDTWs5TnFaVzB0blRQT1RzL0J0MFZKUGpnKzZRMzZ6aFJxM2QzZDNpbXRyc1RndjJyeFJEYlhiWGZWWkxJL25FTEl5VnBPcDV1N20wTUFWeEVYM09MK3ZjZVpRaDRna3RCbmhqRnF0alJKUk0vUFBTK2JTc2RocnpXdFB4aDVybmYxK2g0dnlYQmJ5VGp6SEhyanVSczNVUnJnQ3d2NTZQQ3dYcThGY0lKNW5sMUhqeFZWb1Ruc1E1ZEYvYW1SeWpWYm5kdFhONS8wQnZXekpqb0swQVBxWVZoeXBmV1Z5OWVqZ2tUUUJEQVpmQW1oTU1UcytpTW9mNWlJYjBJNFJRaXloSFNrTEJVNnk4QWk0VVhMY0NQa0xtRUsyNmFBR1BmeXh6K2hnRFNBaEdvR1BPZGV0M044ZW9UUlRhWFM0TGNnR09CMndEU1VBYnBwTXJVaDRuT2ZDREc0TlVCL2RucVd6YVhSYkQrWVFYOURHYU5jU1JTQWJIUU5NQWsvQ1gyQVhZaHpITkJNRi9MUWNSaHBlRC9JQWxkU1ZmVFJFQ1NpVDdlaWdnQmtPazR2STQzMmUvMXVkekNkVHJ1OWRqYVRoc0xHZVNSSmdaYUZ1WnhBNTR6SEVEQ1lnc2x3VWw2dHdPbUVLdlZwWFMvZ0tvNnpRTzNSU3F0aUhCMEVhUUdJcDVQcHpzNG1iQWliRTBtVEltM1gzZHJaU2lZVG9OSGdTS0RGYUJ5b0xWaCsrRkVWRmJ3ZEZBdytNcXdXdWdVYU9wTk5ueHlkUTZYdDd1M09JK0MzQVVyR3NhUFJOREtQYmU1dWo4Ymp3UGQ3bmZZQWd0anRBa3VGWWhtOXdYSHpSTUt3YlZOWFZDaVY0V2k0dDdzem5acUJiV21HV20xM0pwYjFwVS9kbnZRbkVZRUhtVlprQ1pqekxKZm5RUTE4MEo3eGNJTEJUcVFTdlhvOXJXc3dhcy9ldW9XaFZSSzZJUEtPT1g3dytHQnJiOC9RRldncnlEL01Xc1J4NDdJQzZpaEtZbTg0UXZkQ2tvZmpLVVpCTjNSMFRXVHVKMG1lNFRLTGNsSWZEQ2VlYThYbWkxeXArUG9iNy9TN3ZZU0NjcElRTFl5ME9aMmdKaWlxMW1nSzhUZzgrbjYvbjg1a3djY0VqbXQwZTJ0cFdPZDBOREExV1hRV2ZLOTIvdU0vK2VOZi9zb2ZSUHdZS0FPNkJWQm9WNCtQN3I1ei9jWFBSRVdlY01tQUdzS1RyZ25TNWhLemxJN0FnRXYvWWFBa2x2bzBpWTdFSnhRTmxqMjhraG1XUUY4UjdzWGJMeDQ4Zkx6ZzVuRDZGQ0Z5MXVpUFJrTnphcDZjbllJdXp4Y0FYd0trQlZJN0dKb0JMZlpCS25acmF4MjZFbFlNSkFoMGtCYURwU2Y4SjBBRFlBdVdURGVlZ25sY2dDVEgvTGwvZG5LV1NobVc3YUNQaW9VY3BBaHVLem9JdkFnd29xbFRrcEJNcFFBc2RxbDcvdWpSUHRRelZEam9UU2FkQXRHSDNLVXlxWk9UY3hnS2VKa1FFa0FrbVVqU05VcDZnd3JkcElUTGFOc2Vkazh0azE3Y0c0dUNxNkFWVUpsZ0k0NEZQOExmM3Q0WURBY1FURmloMDVPVGJDNTFkSENDL2kyVml2QzE3OXk1Q3l6Q0xBQlBvOUVFWFlYaWtGS3ZOeUhlNTlWR0xBcE5SeStuenVZU3BWSnVQRGF6dVN5d0RuRUFRUUR4MExVMERCUVVwMk5aYUh5M0NYbllnVUVZanNkOG5GZFVXb2xvT0J5TG90b2ZEQ0NTdXFKVXEvVkJ2d3Mzamk2WXlGcTMxWVh2UEowNlVVbktaS0UxeUNCM08zM1kvTkZnbU5HMFZyMEp4UUh0RWN4ODFBWU1tNHZPenh2TkI0LzJvZG9QanFEdlRRL0svdklsYUJrSUorU3dVRm5EMlJudm1NbXllbngwL09qeEU2Z01SZFBhN1dhalZzc1lPZ1JQVHlTZ3pzQzF3RFltcHQzdTlpNWZ1N3hXS2FRU3FUam9FTVorRVJrTVI0c2dvTmRuejRJa3JRUHN3VFNoaWpSUEFSd0F0WXBFVncybDJ1ckNJczd0Y1RaZk9tOTBDcHAwOWZidGI3NzJ4dWJ1YzRFZ2drM0NOTVVXOGIwWFBoR0htZjBlVEY2RUM2UWlNQWlIQ3Z4cEhzYlJHZDZacG1ld3AwUHd2d1Q3OHZ1cFdNQkp2M2J0bWpXZUNMS2MwS1ZpS2pXY0FpMDI3S29zeUdmblp4QkVhQ2xEVDlMN0hTS2doZ29PUWtjRDBEZ2NLaCtOL001M3Z1TUh2cTRaOUtDTnJBeUhRM015UlkvQjZhZExFRjA0WG5SdER0ME42cS9xRXZDS2RMb3RKd3JBR1RoRFBwZUFJU2MzUVJTSHd6Nkx3M2RRWUJDZ3ZJRVBXWkhZN1Q5NlZocWVKVDF4c0lqQVVJd24wMWdrQm5LZmdHNVdaWkI0S045Wk1OTmx5Ykt0Zkw3QXcxeUFIMWZQVUJSUU94cVBUTk5FdldIOFlSeHcxR1JreVpLR05yT3JLeExNUWdyK25PZURaNEdHcWFvQ2cxNnFGRE9aYkwzZVZuV3Rzcm95R2svZzVXWXlLZlRNMnRyYTZmRTVTS21rcUhGSldsdGZWVlU5bUhzU1JqMElIMi96NEYxdzVCUVpRQjZHSnAzSnhTTGtTd0JxcUVtbW1Idm56bDJJQ0Z3OUFZWXJHcXMxVzBxQ250TmRxYXlva2hDTGNFWXljMzVlWGNRVzVYUitPQmlpekRONCtkNGM5THJhYW1VTUl5cUt1M3Q3TUZiTldtTmtPcFZ5Q1hRZW8rTzZzOGx3TUxWc0hKNHdERW1WYXJXNkNOVWlTZmw4cWRQcnRCcU5UcXMxN1BadVhycGtCelQvakpiRWthWEJjQXpOMVlGMWJiZGN1c3djUEhseWtCUUYyNXZabmdmb3kySWM1REFxaU0zUmtBRXBDdlZuSkpJd0lCaTI4M1lucThTVG1lSlpvNTdUNG5LcWNINXc4UDJmL2pnZmp6MDhPUDVQL3M1L2QzaDhmOXJyUWxNOXZ2UEdsUmMrdzhsQ1NEd3dzSVRZa0ttd3BBdkFzeER1WGdZQ0FidEFFaDRhcHJCL2hHVkttTXJTMkJlM3M3MkRabS90N0p5Zk5qUTRxZk5ZdjkrMVRBditEM2lGUC9OcGVpRHhsamt0YzBoUFV2UGdGYlBBejJSeWNBNmhweFZSQWZsR0Q0QitZRnhCdlRKcFE1VkZIT0w3QWIyRE9RNWZFWFNDQ0ViVWQ4M3gyQUpwZDBDUWFMR29PZVEweG9NaVMySzgzZTZXeXl0Z2h6VHZGTks3bUlPdW1PWUU2RUM1ZEVGVEVuVkRBNEVHK0NHVENTTUJSaVJKRW1vMm05R2xHR2cxU1l6bEN6bFFaSTZuWnhSQW1HM1RZMk9NSkFHc0YvSUd0M2c4SE4rNDhZeHRXcnVYZGdlRFlZeVAySTZkU2ljOHowWjdLNVdTRUpkQTdlSnhzYnhhZ20xSjZIcjF2RllwNTREQy9VZjdwWElKcmhoVU9GaFJ1OU1EbFpxT3pFR3ZUek4vYUtaVXROY2JtbkNab1N3TW1BdVJhaUlJNVVKbWM2c0NyQ2NTS1NOcDlOdXQybW45L3NQSHNBOHZQUDhjMnRYcjlqYzJWcUdpUE1kcmR6cnBYQnBGblJ5ZVZOdmRkQ290eW1LVWk2YUVDRnhWV01Tald2WG1wVDA1a1dnM21tZG5aK051LytyZXJxNG5yanh6cmRmdkoxTnAyREc0UXNmSHAwQUV4RGdJWmpocmxJdnRIeHlNQmozMFE3ZmRnWG9HRG5nK0J0YlhIazNhWFZwR2JYMTlaUjZObHN0bGZ4NDA2dTFlcXd0a0FmV1FHYWlxamJWS3Nid1JLUHB3UElSUkpSZWVadFFRdGtCREFMSTRIeXNsMWVOR042WWxZcTZsNlZLbk4vWnQ4ek5mK0d3NlBvc0tpZWQrL09lcVp3ZmpaczJkakxpWXVIYjlGZzVqc01YUGd0MGpaVmhkZ3BjRnhPa1VMTTlGV0NwdFNvU280RUNXOHVIRm1UQWdza3pocnUxZE9qODlpM0J6dUZ5ZTdjbm84VTRQSHRoc0hnQ0Z4VklSSkJXTVpUQVlRSnVDeG9yMGZveW9xc21Bc01kZWVBSU9BSU5RS0JRYzIwbWxVOVBwV0ZiaThIWkFJa0JJTUVKUTFQQ3FTTGZSOHJqMDhEYW9kaXFkcG12cTNSNE1aRHd1cVJxSlJ4eEJFR3F3cllYY2JPWnJ1Z1kvRW0ySDh3QURrczVrM24zbmZaQlJlcFVLclEwTGpXS0NHS0RISjFNVG9BZFZXQ3dDdWpmQVp0aWpSWkFya0NpY2doZWdRVVR3VHZnUTRJOFFsWHcraDIrTVBRdzhCdnRnLzJBeW50S2Rwa1VFYkJoVXZsWnY2Z21qMittUkRmZm5zQ0ZRalN1VkNtcjExcHZmWFYxZlI1TnIxWG91bHh6MlI2Qms3UlprdFloNndxVjQ4N3R2OFpGNUxxbjFobE1JVHphYmc0Q2hEN041dXAyK2lJQ0RpSzFXOCswMzNsSU1yVnFyYjI2c2xWZEtHSkZHdmRWdXQrSFd4eVZCMDVSQnUyTzc4elJNZzZhREs2RDNrNkJuMGNuVW1vOG0xaXdTczJhellpNG54TG1rcGljemFTZ1NDSjZvMEp4SEtLYnB4UFpjQjlpNWN2VUtPdXJHelJ2Mzc5K0RDOWhydFNWQnhJblFhY1E4T1I1dExKWUxsWEk1bDZGbjU5OTc3MjRtbHdWN2hLSUJPd0xTd1BJRkkxZTY5dUxwL3VOVWZ2MUxmKzFYcjN6bUI1VlU3dVQrMnhHeTVEUmRGSVlVQlFvWS9saWszdTJqVmpmM2RyL3k1Z2NiT214bXB0WHJsM0s1N1oxZDFlOU9renM3TDMybWVuNHdhVlhuM3V6cUs1K2ZjelM1ZFludjBPMmtMY0k0UzZJcE41UVNTdFZId2pJSGhvMmhIajkvSWdzMm1BeFE0SjUvOXRta2tYQXNEODdxeEpvSzlNVEtmSFYzbzVETHpVRkpiUXNZZ2lxVkpkbGYwRVFBMEQrY0FLQ0hRd0dOWlRzT0hDeElRclBSS3BhTElEOU1td083SHMwQVN5VGh2MmNMcVN1WHQrdTFObXJzMDR0YW9uTmdONXVGOWNCNVU2a0VIeGZvUHJOQ0YreWhGTWszWkkvaHdhalY0STJsMDJDVE5DZG5FYVNTNlN3cU5wL0xpZ1kyQWk5d0FiODB4c0U5QUJXR1pDWU10ZE5zZ1FwQm5ZOUhBOWlUUlRBZmpJYmdIdjFPWDVERVlZL1daMHVrVXRDNFI0ZUg4QVhKRlovUjlCaFVZRElhTjVwdFJkRWdZNmdlUkF2cUNyNzE2ZEh4L3Y1QnJkWlFkYlhUNlk1cFRkWWtwRUxnRjVLdW9KbmowYlJReWg4Zm5VRzhZV0cyZDNmaWdnUmxyNlhTaXFvYlNWcU5IbTJSUklXUFM1NC9BNnhyb0xTMUJoK2w1VzRxYStWRUt2M3d3YVA1UE9MNTBYWi9JT3NHck0zbTVobzBpenVlbXFOUmpPZDgyNW5aZG9iMys3T1lsc25EVTRRZHppZU42WGpxQmdIODBHS2xIT040OUJnMHJtVzdsZFV5VGQ1ODlCQW90S3hwcTlXU0ZsR285alFzVmIyQjRVTkFKOVBTUmJQQUJhS2prWHdaVXB3WGVQNjk5OTRmRElmbjFScG8xNC8vdFYvZHV2WHhIL3VWLzh1dEwvN1E1WTkvN21NLzlwOXdtWlNvYVpWTDEyWXg3dmp1V3hHYTZFRnJvUVpCQVBFRzNjVG1wVkx1NGRFcGV0Z2NUOVpMeVdSaDQvRGd5WldiTjBSK2JnOTZzOHoyMXEyUDFXdW41dy9ldmZiQ1orTEo1Sng0TnpRN0VJSVBReXBwN0RBV2ZnUElTNlpET2gyQm5td0tjYjc4VUpiL25RRHRUb0hiMnR3cXJsVXMxNUhqL0R0dnZ5ZUs5SXFTc2Vud0lnZXJ5dk5pczlHUUpCazRBMjNRTlhhWHA1QUI5MVZWdGQ4YkFKbmdHemdMeGhzYU54YUpnbUhQSXo1UVB2Y1gwNmtMZkFPWHJYWUw2Z1NrRTdRQjZNcG1zL0JyZ3dWZG80RDdDQW1UcFVpOTNrbGxERGhxRmx0MGdVeG5NcG5OWkJ4NlFOU0NLNG1tQjNRdGhZaHZwOVViajhjUVFvN2VIek4vK09qeDFMVHAydkJpTG9nZzduYXhoRk9NeDhOUk9tT0U5N0hCK0UzTHp1UXlneEU5WW9zZXlHWnlaNmRWOUk4TzcxdUQwWUIybHhTMEZoNENyVGtCQjdHTGowNFhaOFM5M1YzSEJ0Zzg3TXJuc3RpYnp1aXhSU0NKNHVXcmwwWkRvckN5S2dONVVDSzI3VjY2dkh0NGVKUk9aMEgzdSsxMnE5bGVXMS92OVh2Z05vUEJCTlFpbDgwb2lnVG4rK3ExbmVGZ2ZPLytneGF0SXFiRHBZRmRsVVVPbW5ZeWRSWUJlek1lelFUbVRWZ3JjNGd1bVBIS2JEN0hXY3J3bDlQSlZyOWZ4eGxhblpWU3NkWHNRRkFoejU3bjJMYWxKL1IrcjNmMFpKOHVudmwrdDlHd1hhY3o2TU40UXV4REVJUiswWGd5YVlBVW5WYlh5Z1ZWVTg0YnJXNnZCMy8wTXoveVU1LzhtWjlmdVhZeklzU2g4aFRnRWg0WEhVY3cyOWk3bmwvZDI3LzNwbStaU0VJNjdCaUNDbkkvZ1U4b2JCWUtmL1RlbzZ1bEZFMnNpdkt4bVZQWTJqV0Nuc2NadHBMZXV2WFMrZkZqMy9ZcTEyNStGT2hoQUhLWDdCeUJmVEVzZndqb3A3Tm9LQ0JHNGtKUmZIMEU5N1NEeENZYTRaUTQzeHYwSWpQZkhJNjJOMWFOWkRvQVpOQXgvc0kwN1h3eDMybDJJQVAwS0VBc0NoUk94eVl3QnhWT2ozaHlTS0dMR0NnN1RieWZUa1hUM0JNNmROWVlBeDlid1BpNnpneVNNSjJZTGkxTTVNWEJQa0V3NXJUdU03ZzRxQTdzTy94WXVJWmc5R0JIOEFneC9NQXVMYkVVajhYNXVLS3A4SGRSWTRnWmJKN3J1aEJ5cUNSVmxaS0dldi9lQXppb0VueGJVUzRVYzVDTmdON1piMkU3bVRUUWRsWFJiUWVNSlE2M0xKdlBhSXFSeTZ5QTVpT1BwcWtnK2k0Y1NsSFFEYjFSYTRDQTdlN3RBb1dPNjJxcWZQWDZGZGZ4d1pQT3o4KzNMMStaak0xMEt2bnc0U1BJSGhDWkxhVHRxZFZ1dGlFUCsvdW5NOWM3T1RtQmNvVmxFMFY1WjN1NzBXcGlseld4c3RuMGNEU0VJTWx3NXlVSnJ2T2Q5OTZqZVp0Nm90Y2JqSHRES05wU3FReXdvS3FhTEFKejE2N3ZKcFA2azhmSForZW5POXViSHIxRU0rQTR3UWxpaHFLY25KeDVNQmx6SHp3YlRPYko0YkVneXJDeGU1ZjJMTWUrZi9kZU9wSEIyU2JERVJ6aW1lZWF0ZzJxNW5qT2NHS0MzY0pDRWhEWW5jNVFZV0w0QUh0c29sdmdMZy82SSt5R212aTV2L3YvWENnS1VBR2VzS0FwS0FTcThBdnhHTWNWTjdmVEsrc1AzL2o2WWdZRkh3VjBnQk9VaHNHOWxFL2ZQejR0NWpPUFQ1dHJLYWxRS3A5VXErVjhRVklVd1c0UHBjcGNFUFp1ZllLTFN6cFlLMHFGZTA5RjAyZDVrakJRTWlXd3MxTnRMNUtKNXJQNlhCd1F4a0tzVXdZS0xBZjlRSVVVUjRQaDFJRmJuWmdNNGFORDl3MUJiNEpJWk5DZndBZk5wTk94V0FUOUNzRERCSU5yUWpQUzVVaE5uMDRuVUlyTTE0eTVqb2NPQWRiUllMcG5GeUFPOTRYdUQxbWtkeFhVRWYwS3B6NHVpb1BoQ05XQkNNRmIwaEk2SCtOTWN3Z0ZnNXpJaGs0M2pLUmwwd3VhWGNmQ3FXRUttcldHTlRYSk5ZeEdadTVNTTdSRVFoNE9oK3NiNjQ3anE2cWNSOGlCM29PbGNEaGRNSStrVXFsT3B3OVNZU1NVUkRKMWRuSyt0Ym0ydnJFNTdROC84Y25QREVaOXFEdm9JZE0wallRZWk4YU9IeDJEQUtNYUVFb29hV0FkTkwzZjdheHZiNkxuTXVuc2UrKyt0MDR6a0JlRC90QklwSUtBM3VObFcxT28vTDJybHc3Mno0Z21HUVprVDRmRUFpNnhPWGg1TXBsa1QzVVZqby9QQUFKRDE4blptSmh3azlCUkhCeVhhTXkwcHBldjdFSHh6eng0aEU0Qi9wSktVMStncWlmZXJOWm9KMUpKQTU1QXAxZGNYWUcwcDVMSncrTXpHQmt3VHloZ2dMN2FhTUlYeXVXeU1BRGxTcGs4SDAyWitTN3RuQy9BaStESFE4cEdrd202SGNNa0E0elExclNDRlQxY1Q2Q2ZMekJZaHFKQnQ5RWo2Qnd2eG9YblB2SDl6LzNJVC9va0VNUXNtRnlFZW5ZSkxXQUk2Y1hLWmt4U1QrNThCMElFT0tJMFVWYkFlOUh3UkVJcmF0cTNIaHh2cFBXbzd4alpsVTZ6dHI1OW1WOVlRTlZJekVXRnVBNC9paFhKZ0h6eCtXZ0lFWHNSR0pvWmpwZmZJZWpEbzlnL0U1RGxJZkJjbDNrajNKV2RyVUt1c0g5NENuOERvS2tVQy9sc1hvNkw3b0plM2pEei9Ja0paMHVpNnpPcVBCd01WVmwyYUczUmdqZWJpWUlRbzBmRnFGQlJGS3ZuMVVReWdTNFJKSmpqMkF3bWd0YkpRSFBpbHVPZy94UlpBckZHMTh1aUFwTU5RRThuc0FEUlpJSmVWUURLZ2pyUnhIRjZrU0VQUlQ2UFJleXBEWnFFL29OT2pIRXhqYTRYelNlMnhjY1dkUDNkQzZEVGp3N1BZRzB3MG9IdmhSZEpWVTBmRFVkUEh1OUQ1V01VNGY0Q2tYUTlKeTQ4dXZ0QUZ1UE5YaE9BYURRYWxkVUtLQWU2eTdYZG4vb0xQOVh0OW5rcEJneWhLK0I0d2VIRCtLR3FJUGVnY0EvdTNhZTdzQm05WGdPMnBIYTNuVTVxZ0ZGQ1M1aVcyeHRPZkRDR09ZaGNESTQ0N0VhMzAyNjF1bkUrWWlSaHEvVHh5RlEwdWQxdXBwSUptQTVTcW1EcWpwUE8wSUo3ZEVsa3NhRFg4Q2xTTnBkeFI2UHhZRnd1RkdlMkNUOGRuQ3JtenM0YURTanZ3S2QzKzZxcUJzVmtHSHE1a0h2bjNvTmlvVndxNVByajBYaGl3cmhCZVEzNnZXNjdHNGxGaCtNSmZERG9lSkFUYUJEbzg2MjF0VTYvQnhYcjB4Q1JLU2Q4c0d2bjYrdVZhMWYyTW9rVVljQ2ZZV2h2ZnZvekM1NmVxQXl4UXprcHNnekVyaG1Td0dyY3VWOTdlQmRhRFhESGNLUDhnN1BxczdzYkI5VjJQcVc5ZTFEYks5SmRSajBQRGR0WldkLzF1azhDdFdUR0NFSmhtY0FvblliQXVZd2hrZlpkcEZPbUVMcVVkUWxqNk51TEhUU1JOMHhqWC9RT3piQmtTb1N4RW5uQm52dUdxcGJMSmNqSTJ0b0t1Q2s5dWtZdjVZRWZFL1djZVZ5SXduOEJjWVRTQm1oOGFBNFZNSk9IZmVCL29CS2hod2g0T0JXQUZZL0g2WDNSOUtnMW9yUXVBSGt3UHFreGRLaGptdVdWRXRDUXorVkJqRGMydDZZalUwdHFsL1l1MWV2bnNtSjRucTBiaEhlWURzYUNETkRpZHJzdGFxb0gxdWw2dFNZUjRjZ2lnSXVaU01ETjVjRjVpc1dpSVBHMkJZTWcwOHhCVWVpMWU5RE9XMXNiblY0UDdBSVMyMmswaVFCWUxsb2hheGhORGxMUjcvVHl4UUlYNVVEMER3NzNCMk42WmtkUjZSb09XZ0tKTGE4VVJKSGpZOUZPc3c1UCt0N2RCOTFPZisvcTFWd3VLVXZLY05oUEdJbXJ0MjVzWFhzR09rU0lBK3J3QythU0pLWXlhVEEzYkJjTDJjbkl2SGYvL3NiV3VtUFJndDN3T2pLcDFIZ3lmZmpvWVNhYlBUazloUW91RkV0bzZlcHFlVElhK2piTkc0UHhjUVAzeWpOWGk3bWtEL1VUalp6VTY5bGNDcFczaG5hNzE0ZG93UnNCeTZ5M08yQUJRTmgwU2t2WDgwUU9ORzg4aFZQQkpyRkdENS9zQTRRV1BYNCtUUmtKVUhQNEE3VFlNZ3RMTkxERjNXR2w2ZUgwU0d6NzhrNDJhZkRSK1hmLytCdTNmK2hIbnhMOUVIc2ZCaHdaWGk2SlJuWnV2T0M0VnZYeEI5QVh3QU1jL2Y1b2lpSFRFNXJCYzArYXZZVWZWRkl5R1B6TVh3QkNocTRFZytaWVg1K2hsTEEwcGpzL2NpVVJuMUNkTGdQT3ROeGl2OHN0ZkllYlQ3TXlsTFBuTlpZSllRYnUrNy92RS8zdWNHMTk1ZmpzZEhOOUF3aWJUQ2Z3N2hjMGNMSFp6STFIb3IxMks4b3RSSUh1WnZPaUFBa2Q5UG9nK0o0M2c5SjFYUnRxRzZBSGhZQjNBbTdxdVRPQUZaWkJwRXMwYy9DUUtTMVN3R1V6YVVXVmRFTkdkNXlkVjNINllqRVAxdytNcUpqUHczQ0Rwa05sSzVJQ0ZnRkxDTVkvWU5NR0o2UHBZTkNIZFcyMSt2TTVMVHdwU3lMVUtna2JUVW1naS91V09RR1ZoeFhDbU9YeW1VSXBoNDRHTC9KblhyMEpieHRsODNvaW1jbW1VZGZxZVF2TnBLbnQyUnhUVUpGT3AwVXpmRTB6VnloNEpxd1JtZ0FlRllueFVaUU1CQTBIZEVIZG1rNnUzM3ptL096TTk4bEZ3U2RYb09kZjMzajk3WTJ0RmZnRk5Ia1F2bXloL09ZYmI3aTJuYzdsUUlLaEc5cXR6dTdlTmxnSHZBcW84M2ZlZVI5Y0MxNDFUUVdkQmJlZXZRSEhCNUtqU0VJcWt3TFF4N2J6aFIvKy9NbmpvM3doRllzRWkxZ1U2YWVudGVwNXphZUhDK2FCNnpVNzBCY2JVREhuMWVvblAvVXA1RGs5T1lIN0RzVXY4TFNVaUtiSnBZVEt3YUZhd09nNVY2OWNnVWR4L2ZwVjhNbHV0d2VPRGpHRE1nSVFJT1NRUUhxMGtkd3JuNHZIRWtsak1ZK2VucDFkZitaMitmbVBMUWsrd1ljZ1IvZ0tmd2xXREZQZ1A3SG96czBYVUx2VEIrLzdiTzRKVU5IdURUZkw1Y1pnbE5QbGQ0OWJ4WVFxUmdNdG1SMzIrNFhTaWpzOEJhQkdVcElwZUlJcmt4MEdVNnBYaUdOVy92SWJnZVNMMHRuSlExZ1QyUXFyUVlGMmhSeUdiZEJYaUg5T0UrSkpWWU5YQ2tpdGI0T1l4cm00a0N2bWpWUUNXaHlGeVR5L21NMXBBZlZDcHRjZHhnVW9iem9jalFQT3d2dWphQnBVSnRBUHhPTW8xNlZiRDVJa280dmdYaG1hZk9QR3JXcTFCbGpqT0xDSTBYaDZjbklLRCtIZTNYdWFJYjk0Ky9iamgvczRjRGdhZTM0QVEwL3ZMT2Q5ZkkxR0ZvWVR1RVEzOEp5TURHQTM2V3lxWE1vQjFyYnJRN1RRWk1nYTNRbVdhVzVaS2d2ZWI1THdLWEtNbm9ya0dUbFJVV0ZWaVJ2d1BXaU5FQ2VYeitxNmdVSWVQMzZVeldZZ0o1RGJlcTBPWlpuT1pmV0UwV3EyVWFWbXZhbnJhcWxjUnZQV043ZThtZGZwOWRHVktCNDJiV3RudmRub0xPWXo5SnVoY0o1dnA1SVpYWU92a0VnbEV2MWUvOUdqeDY5ODZoWE5TSnlmbmROVUlzT3d6V2t5QlE5QlVIVWRiTkMyWEl3TGpBOXEyMmhBU1VmNmd4SDhnWHF6QjlrbzVET3FKcG93Vzk1c1ozdXIzV2pEWlNxVWlwUHhGQWpGV0hCY3JOZnJ4amdKcEFSVXUxYXZyWmJMTkFIYm0rVUxlVW1SM1dCdVRpZVNuc1JSVUJCbHVHSzVWTVQzc3BrTXZiWjZhbUtNWUJBMGhSYTFBOVBIMEdKQWtWNG9aREhDSzJzVmFQcXRsNzl2UnFQTy9zUGhYOFl2d2dYVW9seU1Wc0xRRWtmMzNnWlBZOU1PSW9CSE1nMmhqVXhzNTk1NWU3dVVBVU9seHlkaThXeXhNT3NkemhLYlRrd2tUSVlQYXk4cENTR2FjUHRobE00UUppeFRXUWpoVFhLQ0h3Z0oyWnZRUGp3TjRiNEk5N2xYUHQxcGQwdWxJb1E2bmMzU3JaL0J3SFRvOWYrT1k5TXQrdEVFUkxEWDZRdXk0S0x6d0ZSc0oxZ3NGR0NYblR0a2J4Z0F1dWNYalUyaElITzV1Q0NDKzZKSk5IbHF2dmprNXo0VmRXY2prMHh0d0s2VUQ3ckQwa3FwM3g1b2h2cmNyVnNySzJ0MEg0cmp6T2tZOU02Zm80L29OYlkwY1cxQlQzS0FxOUJ6UFFLczZ5S2hHNzB1VVJTWWNsQU9LRjFCcG1kSGVyMFJyY2tveW9QZUFQcSswK3VndXpIR2NCYWhZdU1pTHl2cTZjazVlc1pJcHozSEJVdUdMZ01SaDJ4VXE5WDFqUTNiOGEvZnZJN2VJdXMwbThPazVQSjVjSUJHcmJHNXZRTDNZakFhSTZWZWI1SVdwRFVvNDNTL1RaUWVQM2gwOWNhMVRxUGQ2WXhielRwTmJnR0g2UTlxMWZyWW5MNzg4WS8xZXowd1B5aVIvYVBUMWRVVjlOdkIvZ21JVDQ2dHlhcnJpVTZudDdXOUFiV2F6dEJDOGx2YjI0UEJaRFpmZEhxVE9UMVV5YmM3dlFaa1Q5VkJSWWFqS1Fadk1wMUMzOUQwamtVVXJJOUhDK05jdjllQkl3UzdDbzBIb3hUaDZEM0puWFpiRmdYUUk4OXlIai9lUHo4NlV4T0ozV3VYSGo1NEdBSUhhaDVtR2Jna1pMQmxuRk9RMmhSTmxWRUwyL2xyejRiYW5VR2NBZWZEUUZzaG1KYVNBQWZnOHMzeTd2WDk5OTZZT1RZWGpWbmVySnpQRFUxTGsvZ2UzVkwzUm9QK3psclo4U1BGOG9vMWJtaUwrVmlyQkZRSVZZZWRnaFZJWCtEZnBPd1pZS0hId3hOZG5QS0M3Tk9IOWkvallRZ3pMbzlrZ2R2ZVdpK3RyeXFhbGsybFFVVmdnUlNORmx3UG5CbGRvNEkyaTNoMEsxV1NnVFZBRFVyNjB0VkxmWHFDazA5RFExajBSQ2s2SFJvVU1rbXJOSXBpTXFuQXRaSmwwYUhIb21uWnNLOS85ZXQ1WWhkMFIwZFdOVmoyMWZVMStKU0ZjaEhFN3ZyTm00QlVqSXZBQTV2UkV0bHpqbHRvaGdFY0hJQjB6dW1PSmhlajUwZnBjU0Y2TWlnQ3hVT1hVRndYS2tyWE5UaGJHK3RiNStmTlVqbURWblZhM1dxMVhpem1oTGc0R2sxQkhtQlZKMk5yRVFuR3d4SG8rQ0tnMThvSkFwZlE0ZkJOVzgzVzl1NDJSaFFXWWI0SVZsYno3UVpkZnRVMXRWR3ZvZVdsY2dXYWxlZWpFSGdvclVxbHJHc1N5QURPV0trVUlWU290NlFsU3BXMXltcko4eUtOUnIxVGI2aDhYQlZFMkRTMm1CODlYTGUvZjVSTkp1RC9vRkd5QXFOcVZqRHFyZ3Nqa0Vqb0hsdEozVGJOUXJuQ3NlbXZZSlE0dXQ4ZFdOTnBycGpjM05xWVd2WmdNQ3JrYVoxSGs2M01nVzU4L29VWFRHdWlTa0t6WHVOcG5lNFpCQlg5UHgwTmRGb1NncFlwMVRXRmo4VkthK1ZVS25uOTJSdWVQM3Z0MjYvUHZNV3RseitkS2xRVVBWTmEzLzFUUC84MzEzZHZRbTRmdlArT0pzdXdCSW0xNjgvK21iL2c4VXM4aFdwM0NYdTZkN09FRkV2RUJsUmZtQkFwcm03bzJmemgyOTljME5TaEtBaFN1VmhjMEd4Q3Z6dWlLL1JaSWJKV3FRU0xhTG15TmpoNVY4dHNqdU1HbTBKOGNTTDhVTUVVUXZhQ2Z6ckhNc0xJeWtYR2o4U1dIQWFCSlYvRVdhVzV2SkdGZzMvbG1SdTI3Y0lVcVlZMjZ2WmxWWXpMYW0vUWgwVWU5U2NKQTB4QWdINFNZdlMwLzkwUDdzWjRUcEJFcUU0aXhMb0IxZ0VGTE1zMDR4UWVmaXpHd3pnb0JKMm9wdW1TSWtMMXdyeUNJQUw5SUpHTmFtTjdkd2R5TXBsTXFxZW53OUVJcHJuZDdnejZQWC9tVE1aanNIWTRPbWNuNTRCRnZkYndNS296TUlzWjZEVTBLNXhSd0hjOEhxRkFuQkFHSjFmSVE1TGcrc0FpTmV1dHphM1YwWERTYW5WM2R0WXhBZ21OZS9UdzZNcVZIVEMxYnFjSFJ4a01HTFlGYm9CSTFtWmV5QmJoTmJMSjNBTkpFbHIxRm5RdGZEeHdEUFFYT0JKNks1MHlQTWQ3OE9nSm5GcTQ5WnFoNTlJNkhGNFFQajBoNWZLbGgvZWVpREFmbXBCSTB2UGRnaUMvOS83N25LU3NyQlczZHRlQjkyNjdCejZEVG9iMjRLTFIvWU9qQ0ZwWGhTa1lKT211RUYwN0FvZERrNmVUNmN5elcyMElHT2RhVm5rRi9BUU9ydWw2Q3pBTmEycmoyOUJWV0Jnd1BkZjJJQnV1WllNYldWTXJYOHhaazhrcm4vN1VuUS91cnhXSzQwNHZpTXpIcG9uZVBxdWVMNExaZERLNjkvNmoyMS84czVtMXZTLys1TS84MkgvK2YzcnVCMzcwRXovKzU1LzV3ZzhsVnJmWGJ0MWV2WG5yL002N3FwSC94RS85OWMzdisxekFYZ2RDQXh1aWpINElSVXU4ZlNRd1dJVzRJcHRmWE4vcHRHcWo2Z2xhQkZXU1N5ZWhUYlg0WW1nNkE0dWVKOWtxYUlKcUNLSkNzeis2SjBGNjI0bWhmMUEwUWZjakVBKy93Z2pVTzl1N1RLSXYxSWlTV0FaRUwzQitBZlJsbkhaem4vdjBLN3FSZ3NhQ2FSNE5ScnhJaitxaE56bEJoQndOeCtORWdnanhQSWhBS3JaMk5va2YrOEhVZGNBYU1mekpjUG9ybkI3MmZEdjBIR3dpaUFUQU92T0FRN3BHRDZVQ3BPS29HQmVGRHJNdCs4Yk5HekFDY0NLaHYybUFmWDh3Nk5GSzZqNU5vSC8rK2VjUER3NVJvU0NnYVkrUDk0K0I4M1E2NDFnMlhON056UzBvOWIyOVBjL3pEY09BbEtFbzJPNXVwd1B5RFk0dVNNS1RoL3NPM0lOcUxaTlBRMHJBYTdPNUFzMnNsTlhwY0FUdUVlZjRxTy9IQlI0a0J3ejdpNS8vNHN5YWx5cmxTcTd5K25mZWdLTktOMzJEQmNRcG55K0FsY0dVOVFkRHdOR2NtanRiYTVsYzVqLzgrOS9ORnpLcUlnZXpXYnM5UVBsZzM1bDhidWFBL2k2NEJZaTkzK2tORXluOTl1MGJrY2k4V20yeG16WXhNS3RDTVF2eU1CcE4ySDNyMk9IUjZTSXl0MXk3a001TUJrTkJsV0ZtVTJrRHZRN2ZtdWVGbmIzTEcydVYybm5WOGZ5a0lsWFdLN0M2YTZ2bGhLR2ZuSjZpODRHdkNTMXRPZDlZS1dQazg5bXN0d2pnYU5ITnFjZzhaZWljRVBjc1V4SUVEREdNdzhkLzVDKy85QmQvZHZPRmx4TWIyeTdkckFyQU9HY1lZOWdnREZtVWUrYjdmK0QyRC94cElWdGc1Q0gwUi9HSFgrSVZ0SEh4ODcyQjBvRThnaGF4Nk5qYTVXY2V2Zk8xeU5TQ3JZSml4Nmt5eVJRcWJNL21mZE8xSm5ZcHA0SkFsc3VWWHYxSldsYUhXcG10M3ZTaGhsNmVpbTB1TFFmYlpOVmhKMktiUkdwQ2F4T21zTEFFK3RMSHBueGNwVnlTRE0zelBSNkduNHYxK3dPWEZuMk44aUxORVkvSHVGR3ZCOTBhaVhPYXFrUWxjY0hGa3BsMHU5M09aTktTTEVQQkUxT2ttNk1ZZWlVdXhuR3k0WEFvMHZLREM2aXhlcjIydFpvY2pjekoxSkhwUmNIeFFyR2swaE9Od0JEZG9vT1UwM1V4eDRyVDlkY0lKSDFCUytkQ1RCWWcwQ2hjNE9Qd1VQT0ZITmlGS3N2Zy9kQWNjQ2hCWjhGaHdMOHoyU3lRQVRvMG5VN244MWtzd2h1NkRrSU42alFlalhYbzRXVGFEMmJRclAzK0VHNTBMcDhwVnlvemNMQllkTFd5QlFaWFdTOWF0dnZCblR1Ly9DdS81RXptblY1TFV6VkpwQ2RUNmY2QVpTVU5VSFFlWUVYODZvMnJvS2ZkVHYvSi9tRXluWVppanZQeDlZM0t3NGVQVzYxT29WZzRPVDdlUHppdXJLOHJzanFmUnpaMzFsSDV3eWNuNlRRdENBTzdOUnFQMXRiV21zMTJvWmduY3hEblZVV0x4dmpMbDdiaFVkeTUrMERYOVV3bVJScUxMc2prMzM3bnpjMzF6ZXJ4R2Z5cmplMGRTRGZFSEVVRmkvbmRCMCtncHhDUWlIRmRXYTNjdVh2LzVyTTM0V2RydWlyRW80NXI3NStjOGFLeVVpbWZIeC9ORnRHUC85Z3Z2UEtYZmc3Z0ppK1NzUStDQTAyeXdIRGdRMm8xeXNWOWhodGdCSnVVZ2FMMElTd3hHQ0VuVUxuVXdRUTMvSkNmeURKVDNiRmZWTlJNWmZmSmQvNklBeU9GT25SZFRVc2tOQVgrRFBxL081a0lSQ0NsSk9obUttRTJIaXFablVsY0k4MU54WVZhbktJQTh2TE15d2o5aDF5SzFaTFZnUWtKOHJQZEZPaFFGbWNGVUVidTQ3ZWZGK0pTSEJ4M1lnbzhuRGtGMmtrM0V0RDNvcXBnYk5vZ3dTdVZKMCtlcks2djNQM2d3ZFF5b2V4aGpOZFdLNFArZ0Z6UGdGWkI4andYeFJLWlFjZjVjR1hwVnF0bFdxcWlEc1pqeDFuUVJXaDZ2a2xVTkhHK2lQUUc1bkE4VUJRdFFqUGE0OUNqa0M0Z0Uyb2VCYUlhRWlUSDkrNC9ldkxKVDc4c0NVb2tpRUF4WlV1RmJxOExaeXZ3L2JXMTFWaVVtNW9XdXdIMEtKL1BRc3pBb0d4ckFnTUR2a3BMZE1kb3dpUFVNNndMNkZhYzV5RVYvVjQzeHNkc3h3WWhYdDBBNDYrKys5WjcwVGdIa3JDeHVWNHVscTdzUFBQZzBiMWdNZE1OSFZvYTlnUE96SlhyVzlPcEhmSG5KbHU2S0tFbkRvNU9nSlR4YU9yUDNJU1J1SFBuSGpxaFZDejZybnU0ZjZBbGsxZXVYWlpVY1RFUFlDa0Q5aXdpWEIzZlgzaWVrOG5RMGdiVDhRUTFnMlhsQlE0MWg0T3J5c3FnTi96azkzM2FTQ3FGbFZVZWpMOC9lSGoza1JBalgzRjdaMmYvK0dqWTdjMU14d3ZjeC9jZWVSQjBJSElSM2RwY25aZ2dRU2FrNk5hdEsrM09NTTdGQWE5aGI3Uyt2WTBjOW1UWUhreCsrRC85cjU3N2laK2tGUnd2d01Dd1RtZ2dvRERjNGk5VWlBaE1ITUtzREVYMHU0UVViVkVDU3cvamJJdmk0VkZzTTF1b3pCYnorcVAzMlJZdE5iZTF0dFlkRHNqbUxpSWdyak15Ty9GQ3JtQk5oNkxWOC9KWC9DaXQ1a0xaTDBxbXNsaTUrQW90RE9Ka2VhSjBJMm1aNFNLRUdlbkR6RktZRnY1d3o3OXdHMlFERkJDNEFRTGk0Q0dhQ3ZwTHhFUFhIdDU3a0V5b3hkVktZTTBzenlGclRKTmhBMFZUb0YzSnFVUi9nUHg0SGhodDRNMFVWUkhwT2RjWUVNYWF6TkhVMEFVdmdwV3lGK25QWjhIcjMzbXREL1hQM2pCaGFOcmhnd2NBSC94WGtIdW9LTWMyWlJsMWdMeGhzRHg0dm5DQzR3SzN0VnI4NE42amcvMkRScjBCeDZHWXk5Kzc5OUJJYXVCT2NJV1RDWDA4b3N2YnRtMkN1TXRTWE5GVlBnWWg0bEVOMzV1REJjRm5vT3V0RTNNeU5qMC9xS3l1RGdiams2UGpkQ2E1dXJaNmVYZjdwMy9xcC8vaC8vU1AvN05mL0t1Zi90d24zL3oyK3hPekEzMEVpNUZOSnpFMmFFeTczdG03ZW5VeG45Vk9XNVdOOWZyWk9kVHFkQXAzb2p1ZWp1QUdRRDJuYzhVbkg5ejE1OUhWalkxNUpPaDNPM0EyN3Q2NUgrSDRiTDdjYlhWZzJlN2R2Zi81SC9naStCTHdqcjEwSjNaT2J6cVl6V1liNnl2QklvYXp0QnFkNnVFeFhPZmVjTXhGT1QyUkNBSlBFeGF2ZmVlZFoyODlreThWbmh3Y0I3WXJhZEFta3doZFY1R2FqWFovTUlacjJPc04wVzk3bDNidTNiMjNzckVHRy9Yd3dRUFR0RDd4Z3ovejRrLy9EUHhXd3NFU0NBU05VTDhUakpaUmhCQXg5RVd4aThDeVU0UnA3NlV1aDRpQXQ0UmtHaDlHZDFnMndpWEoxZHJ1MWRiNTRiaHhEcG1kQlFGbFhnUm9sRGNMUEg4T2hiSXd4N2wwdXJ4YTZkWWVaN1RzU0NzeGE4SHFFd1oyWHZwbEpaTWFKOXhUQ2tzTWYranNWQzlXcXpCT05ZWEpZai9ZNEM1ZHZzeHprWlA5SjNRSDFQVVhYTVMySERpQW5tUEN3YytBTWJQRkhQM1piRzFyKzYyMzNrNG1EUXhNN2J3ZVFBbEhJc1BCR0F5WXJrS3FjaTZmaGRqQWZ6S25VNTllRFFoM1NvT3hKaGR6YXZMeE9MaXZJc210UmcvMkY3WlYxZlJPbzkxcnRTYjlmcjNWeU9YeVlQUEpaQUo4K3ZEZ2FIMTdhendjQjNPdjN4c2xrM295a1hRbjlQWVcyM0Z1UG5NZHJtQ1RIcFducS90d2Yrdm41NFdWQXVnSzZyYTV2VFlkVzNTM3k1dWgyY0FRZk9oR3M0Rm1vMmRUcVNUYWxTdmtRS1hhclRhOUNrK1JrUFBvNkFnSGZ2REJnODkrLzZmUm9uZmZmNmRXcTZIQ3NEenV6RDA4UElHTktCVXprUmdINk1zOFo1cU9UTmY5NkdIY2Nya01TSzF2YmNCWW9hcHdXVUFld084TlhScDBoL1ZxY3pBMGFSQWlDMUMxeWxxbDN4M2R1Zk5CSXFuRGh0KzVjOThQZkZtU2RWV0YrcWllbmovMzNFMDliV0I0M25qdE84ZlY2clBQUFJmbHVGVEtnSWs2Zm53QStwNHQ1alJaZnZzN2IrOXViM2Y3L2RGNEFzVmZ6QmVnVFh4Nm5pQ0dYZy9tL3NuSnFXMmlIOFRIanc5KzRHZCtxWHo5WTYvOHhiODhvMFZSeVFqUFE5NkN3SkR5RkRwUHczSVBRdzBoaVlVbHpWZ0tCYjRvQWFoRVhqSUxZVGF5RFVqSE5qRWRaSURTV2J2eTNORzlOK2FXU2ZPeHpRa0dVUkpnNUdudThTSllRRE5GQTN0OWZZdXUzSFdPcGZKVk02Nnc4NFFudWdqTXNFRFMySWsvREdFTnFRcElaVUpDcHlXQVU0eit3bU9nZlY5NDRmYWcwMWMwSGNvbWxVZ2M3aC9KbWd3Rm1Fbm5wNmFaU1dyVHdTQzNXbzVHb0QrRWs3UHpWRHJaN1E3QW9Xa1dJYUVCc0d1TnhtUExuQUpKOUdRZFBiUUxoazF5TGRGeWVUUHF0MFVFZGdQZ2FEVGJWMjllS3hieWp1ZG9Pa2gxQnFEZlhDM2N2UHhjczlzRnZzSHBYZHVubFZzRVZKeURVc2FCRnJTeWJSbEpBeW1iVzl1ajRZUTlyeVFWQ2xuSUd4OEhZd21HZ3o3TmNKU2t6bURVcURlUGowK0pQTmowQW94c0lZdWVCeTZoN2dYMlRsTjBOMFFPOGduWEU1UUhJQjZQeC8veFAzNUZvTVVsNWYvN3IvMTM5ckFqcVFhVWF6NmZobDg0TVIwMnVkd0dLYUpxRUUrelk3SEllTkNmeDJMQTYwc3Z2dkRnNFdOb0x6anNyVTUzd2FZWVFhY0lBcit4c1hsMGNMeDNhUXRrNmRLVkhmako4TXplZWZQZFpEcVZ6ZVVhOVRwMHltUTZMWlVMcVBCb2FuZmFMVjNSOWorNGkyNGIyMjcxOU5RYzlTdXJLeXNyV1JoRTZCMDA5c3FOSzNNUDd1Z2NQbzVEeXk2WWxtUHQ3RzdYYXcwdXp2ZjZQU2dndW9BekF5ZU4vTUt2L2I5dS9QQ1BydHg0SmxnKzQwOGpqd2dES0RDQWYxS1hCSndRSU96ek5JVDVvUmt2dEdxb1Y2UHdLUm1vMldFRUxrcGtDamxNUTJEbHNJK29LTVd0YTlYN2I4NWRGNGZCOElLTTZldzlzcUEwcnUrWFUvcjI5blorYmF2ZDcyUVdscGZhZE9tMUxuUXNzTW9pck1Ud2x5cnhZV0NtSVB4ak1aWWovQkMzcGtxRk9hTGM1ZDBkTUhSb0JTaG1JMlVrRXVsT3UrUGFkaTZmbXJ2VWo3QTlybVdmSHAwTFV1VCt2ZjFzSmhWWjBJdjE0TlNLY1FHYUFqVEdkdUNCYWRETlFEUlVJODJzRHVBS3pXcU51dWM2UUgrbjNWN2ZBTldtOTZSV3o4L3poVHlrQWZrVlNRQ2hINDZuaGJVeTJCUjROc2dQV0d5NzNUdXZWUzlkdXFTb2VyZlRXVit2UUJMbUhOUUJ2WDZZNTNsVWJEZ2VwWlAwaWdHTUJ6MzRNK2pEWWlocUFrUjh0VktDczBWdm9sUnBFUUZVaFNkV3cwM0dreWliRVFUV1BwNU1RTmc4ZHdZM1lYMXQ1L2o0bkY2R01mZmJuVGI2MTdJbVdzS29WSXFLcXRhcnRjRndqSjVFdDZIVW1lMWV2bllGblhmL3dVUFlvbm13MEZRZFNoWmFmM3VqMHFxM0VWbmYyZXAxaHNWQ0Zsd0lqTVZ6NklvaHg4Zmc5RDk4OEFqaWRmUFdNekE3alVZemtVaWNucDd3Z3JSU3pISU1OSVZzQWVCNDlPRGhhR0t0VmlxNVZESVdWM3hyd2t1OHFPdWI4QzFXUzJmVldtV2wyS3QzNFAraEo5MlpEemNwbGFSTHBib0tERmtZOEdJK0o2blovL0pmL3dkamE1czVVNHNRb0lRSkFpNkREckhiRHpIeWZ4QytaejlpUy9kMEdaQkVnQ09OenJROEV5WEt3SVNERGtFaWRoalpRcTY4TmpoNU1IY3NsRUxxTmdvbEtLRHljRCtDbVo5UGFaWDF5dHJWMi92di9WRk96MHkwbFRuQmxmR21zQ0FXMkVtL0oxRGFoeldrbE5EVVVCTCtTVnJEcndpM3Q3ZUhZUkRGT0R3NVJHaEdOUytXU3ZsK20xYnpxYmU3RC9jUENrbk5NWjBJejIxVzFnaGs5RTQ4dTFnb3ppMjMxZStra2ltTjNwYVlkV2daQWhnSk01R2t0OTdoRE8rLytYYTczYkpzQzZmTzVYTlFlT2dxejNadjNYNjIyKzVxbWdwMmdRcEJvVFliOWRGb1NKY1U0L1RFZThKSXNjdlNRYnREZDAvQm9jRTY3bnh3MzBnWUtFclJsY3JLeXNON2orS0tHSmxINjdXcUVCY09qMDdvUlh5dWxjdm5ZVEVNSS9IR2Q5Nk1CRUd6MFlRVExNcmdXam1nT1p0S29aNk9aOU1OeTNZUFJDVXlqMVZyMVh5NUVIak82ZkVwcFBUMDlCUW5zaDJyZFhadXBPamVMUWhES3BuSTU1TEQ0WFQzOHU1MFBHNjNPakFJWFppK1FnblVZR3Q3ZFhPallvOG5oV0ltbTh0LzhNRUhBSDFjRXVyblZUREg4a3BsN3M5MnJ1NjVsaFhuQlBUUDNidDMwYWhpdWFpSTBzSCtNWlFEZkFtY3FOdnRycXl2d0ZmQjBJQXNHaWtkdk92eGt5ZTI2eVdTMllTaDZpbVMvMW5nQ3JJNjduVEdjQzJTeWVaZ0FBUkRteno3ek0yZDdWV29UTThYcm4veUIzL2lWLzl1UEkvcWtVckF5Tk0zRFQ5VGx3d1hJVGdZV3Rndisza2FLSjFTQ0hCUHMzeVlpOFZEQVdKcWZabENwUlBjNkF1Q0hRSU4yUUg2UkdHMXRMVTNicDhFMW9TTHhWM2l5UXFjYlMrWXc2TVFveEZSaUcxdGJNajV5dWpSdDdUTXVpVWxhVG9BQ2x6Vzl1blBoNEdxeUQ1MFpvcXdVNU5xb3NxRXRhT2RMSEEzcmw2RHZnVFI3bmY3MXBoZTZBVWVOZXgxYmw2N3RQQWpqdXMyT3AxTUtyRmFMSTFINDVFMTdmYjZmSnhIR1RBSTJXUmlNalZkVUh6ZDZEUmJjWm5XRHdoOGY5QWZ3RldpVlhNdDE1cVlNQVcyVFRORFVIR3c5MFF5Q1JwUXlHYzc3YTZxMCtwMjhDZ0JRYlNjdllZMUlvb0N6RFQ0ZDM4OExPWHl5WFNXNHlJZzZNZUhKLzFlMS9OY3NLYVRrM05BQkczYTJGaUZmYzhWOHVnK1NCM1BjUURUb0RkR0N5VkJ5QmdhTFBXY1JLTGU3clJ1M3J3QjZnTHBhclhwRFZCd0xlSXhEcElCRlp3dzZOZzRyVWpzZGZ0RDJ6UmI5ZVo0YlBZSGc3VzFGWE04eldWcDBYUzR1WVZpYmt4TGQ0REkwZnNmV2MzcGx2T3cxOHRsYy8xNmV6Z2FuVlJyc0VpR3BMWHFyVUtsdkhOcGJ6RHNIRDdlTDViSzREZW81OW5aR1N4Z0twWCs1amUvbGM3a1RNc0VTcDQ4ZnBKSUpHRzRJRTZxVG12dnBIVDlnL2Z2Z25SQjNzNU96aUNtT0RXTWJiUFdLcTZ2d1prZmp1SFEwQXVCL01VY0luTDk1c2ZhcHJENzB1ZC83di94RDY1ODluTzhSZ3Z0WXF5WGVHZi9oQUNHQnZvUWVCZ2NhQmZoSXd3TUtvenlVbUNBWThJU0hoVCtncTRpT2N4SmtRczVZditzTklvUjJwSE1EcWJENUV4aDlkSnRxM215Y0tjMFQ4bnowcnFPK2tmbkM5ZHo1RWdrbGM4VjE2K09SazF0ZU9hbGRseGVDZzlGV0o3bVQ0U3diZmlsczdINjRKZWRQS3hPV0JVU2VYZ1JOMjdjR0UvcGhjdHdzOHlKQ1d5QWtBQjVrVVZ3Zmw2SHNuSDkyZUY1VGRhVVJxUFY3dmJHcGttbzRqbFJsQkdING16V20vbGlWcWVuY3ZxQUlLZzJGSnR0MjVsYzZ2WUxMM2JPbXhFdTB1djM2U2JJeG9adUpPakdrQkNIb28zRmVMQVQ5dGcxVVIvRUpVM2xJMUhJRlZTVkF3UndzV3doVXloa0RnOFBGRmxwdFZxREFSR25Xclc2dmJNSnc1MHZGb0FEbm84REVHRGptVXdxblU2NXRubjkraDQwWEVLVFVybU12MWlrMDhudDdhMTZ2VFVlOVRPNWRJU0w1WEtGMnVrcFZHYXVrSVhzZ1QxalVFK09EdUZLcHpJcGNCNjR2T0JkbDNiM1RxdTFSRUtGaXRVTU9jclJteGJaak5FWTNlVmxzNUhoS3BmS09iUUNyazVoZFNVV2wrcTEyc3A2cFQ4WTNYN3g1dXJXUnF2UkdRMzdEdlE2eUJNSFRiR0Ezd0FUZDNaV1hTbURkRVhEeCtweUZETEQ0YUNReTBGaXA1WUxOcExPSmg0OGVMQmFXWW1Ed01XNFdxTmRQYStCaTBuMDh0Zkl3ZkhwNXM1R2IwQ0xUOEZDcis2OStLVy85U3UzZi93bktzL2Nna2NLaW9BUlhtS0JrTUFnZ0pTTEcvV2tEU2xwK1dFWmdPendRNGVFaWNzditxVVNFTUxpQU9NTE9XQmJKRU00a2hXejVDQXNKLzFRRVFBYzIxN0VkV1B0eXZNcVBTM2hnK3RDdlNxeVNrOTVSbU1LSDdVbncwakV2L1h5Ri9ZLytHTWp3azNUbTNRWUsvZ2kwUFl5aWhncm42b1Jub2pXNVdNSitLWlRMczhlN3VNdVg3NE1tRUxWZ1ljSXNqaVpUTUdsNkFaTnM3Ti9lS1RLYW04OGlYRFI4MnFONWdid1hDcVJSR3ZBV0lncGVyU3krMGE1Y25CMEJOZVRYbTRLdjd2WEE2TXA1dk8wMkNjZjNiNjAyKy9RK3dWd1R0aDdqbGFMOWp1OVRyNVFoRkJ4VWNFMkhhREhzcWJ4ZUJ4TUNHU0dGK0pzVnFEVEd3NnNxWGw0ZEFBb2QxcU5mQzRES2c5YmxFMm40ZERDVUxqZVRGUGtVWC9BQ2J4SHR6RG9lVDlWa1NWYTdtYk04d0pzRVdvTmx4cCtna2tMOUkxOWYyWm85SUE1U1VZNkNjNEFOK09sbDU5LzgrdHZyS3l0bngyZm9pM3dPUE8wdEV3ZUIxYXJWVWppMmNsNXQ5dUhaekdkMmxEbndUd0NMeGFFQjkycHl5TE9vdENMd1Rnb2xLbHRKWFgxalRmZXdua1hBVGsvNkM2NEc2MTJIekxaYWpaYzlLL3ZRNCswbXUyZDNRMWFaY1NEYWc2MmQ3ZlB6MnF3bklWaWdlYmhPaDd5TkZzZEFFY1dKUnNHeUhIaDZlcXFjbm9HUDByVUUzcTFXZ2RRTk0xWUxaZC84ai8vKzEvOHBWOEN6d05KbzZ2RFN6QWdRbEc0empUZ2JPQVplcGpsWjBvWFd4ZnBsQ01NVHhQcEU0b01tdnFSWXArR3NBU214Si91Sm1TeEtPMUJaQTRQbVFrRGd5VTdSRmJUTzlkVzlwN05KRk8rTTVWMUE5SXhud2RUZTZyR29uQ3o0cUpVMmIxZWYrOFB0Y3lPbzZUcGVGWTcxSkYrTHM2TGdHK3lNbUh6aU02RWFaU1JuUlc3UHBSS2JtTnJLNTB3UURTZ1l1a0JQUFpza1RteE1wa01mTXAwTmczZmNXdHpYWkdVZHJmdkFEU1dSWXY4UmVaUVF0RGlJd0FvTXF1VUs2cEc0Rk0wSlp2TmNUR2FmQklYK1dReVpUdXpGMTU2d1JwUFlJaFZUVVZwQWg5L2RQOUJPcDh6a3VsME51WFJTcnowQkJ6TitjV1I4VGlBQy9jeGs4M1NyRjI2WGhZWkRRZVpiRVpTNk5Ha3k1ZDNkQVZzcEpYTVpNNVB6aGQ4Vk9lRjRhQVBMWTV5NEk2eFMrd1dzQWoxZkg1ZWhTU2pZS2lTT1Z5aWVhVFJicHVUQ2JRNFVBdExDb0VFZ1hJOWUvdlNKajJlTFV1bDBvb0FaMWprd2JMZ1RVSitWaXRyRWg4ZmpNWWNGNU5wZlM4NGdsRXdKU09aUVA1V3RRYjhEa2IwTHFlRUxsdTlYcVBWYS9jSEs2dVZjcm1ZeWVWUFRtdndkMEdjdXEzdXJkdlBvZE9iSjlYRHd4UEl6ZmJ1VHJjejJOblpvamxCcmlkSzlNRGI1dTdteWVFWkxCTGtFR3BsWmFVb2lCS3FPckVjWUtLU1RRV21GOHptVHc2UFVtbXdvZHhnTlBCblFhcTBrNzU4blJsMk51UkxWQ0FnUmhlZTJaQXpZc0ZDdUkrMkdETG9seDF6Y1JpRUFtWFJoNlVzd2lMb01pYkxHbXJ4OEVNNEppeXhVcGhhWjF2ME9Ed3JrREl4d05OV21CRWZlcFdBbGtodjdPVzNieWpwUEQycHdFdG1FQjMwdXNXMHprWG5sYzNMUTNzWTcrd0grUnN6WHZpSU5MSmZRalk3SDRxNjJIRVJQdHhGTVRvZlM0SjJ6K2Z5SXQxOVhEaDBSV2pCYzFHWmkyWjBwWDVlODEwdkpncVh0cllOUXk0VkM5WUl3d3dacDdjZVlBenkyWnpqMG1KL1BDZDBPbDNvVGh3T0RqQmZCSlB4Q0syam0xRHphSzZZemVReW1xTHpzVVdNRng0K2ZEaVArdXNyRlZyNEhoanFkb2VEWWF2VDJ0emE2UGNISUJFd2tETFVzd1E0U1RBek9rbVJNK2lQQzRYc0hJTGxRdDdNbGRVOFZDbkVaZ1RQd1RSblFVQjJVTkhIazRtbTBVSXgzVGF0c1VFUGkxaVdUTTdRQXBSRFpvdGFLcklHRHhXRUJMMmlxbHEzMzdkTWVqaXcxK21mbnRmQm1FR3YwS0ptcTQzbUFDaWdXQkFMV1JMUkl2Z1lzaXpCRmNhdVZGSWY5WHFTd0owMzJwM1JDR3lrMnh1dUZiSXdaWnpJOVViVFVqRmJLS1JuQVdkWkZzOUhORU92MTFyNVFxN1Q2aVJ5K1VRNlZhODNKU0crZDJVM21VcDk5enR2YWttREUySndJY3lwQlRRUGFRWHdHY1QvNVBTMFVpd3Vnb0NUNE9oSENxVU1QWGliaHhTZHdlc1FaWHJ3S2lhVXZ2Q2YvczBvVytZM0RFdnZsSTB4RzN0Q0xtMCt4Y3hIUXBpRURDRXN3a0Q1MlRhbFlJTjFCN0JNdnl4YzdMLzRXWjRwM0kxSXFGUFpoL0xRRHhrSStxV3NyTWpJZ3VQamlWU2lzcVhsVjFldXZiajdzUy9jZi9CVzgreGtkN1VrS2VMVjU3L3ZmUCtOcENoUEUyc2tKMkVJQy94d213SXJkQmtRb2FvdW93amhxWWpDY1ovNzlDZVRjYTdhb1VVdlJJN1BhaEw4MC9FRW1sZ0JYTVdFTVIwT3M5blV1RC8wQXI4L0djTjBEb1lEei9WU3lkUjBPcTJBclVaam1XeTZlbGFGUVFlQStyMEJaQUJHZ0dZZXpXZFFucFBKaUo0Q2NUMlFwWHdtOS9ycmJ4UkxCZHVhNmJvU2pjU0hvOTZNSG9VZUF1aUJ2NEFua0NzVTBGbU9aVWRqdkcxNTU2Zm5IQi81MUtjL3Jtc2FuTWtCdkxQSmRIT3pRcFBqYVIzcWVZSHVHUUVZc2RPVHMxS3BBTWRnWTJNZG9yYndBOU9tU1dPYXJtZHpkRUZHNGpsNmVZRW9MWUlGcURZRWtsNlFKQW1Hb1lOY3VUWXRuZzUzRllWYjB4SDA2NU1uaDlEbGlxYUJiTURoQnU0aGhMQmc5KzdlaDdXWlRxYm9scFNoZHZzVHVrRHBPdFZhczV6UGMzSzgyeHRsTW1rUzBYbWszKy9OZzhYWmVRMjhhK2Z5NWZHZ3I2cGlNcW5IT0JGNklaZFBQYmo3OE9ZejExLy96cHVqYnUvU3BjczRoSzI5RXowOXJkNisvVXl0MnRRTkdkUzIyZW1CNnVieVJSRU1VcEVTQmowSk1PNzBMbi9pUjMvcTcvK2FUMWluMFVVaURTK2lCS253bHdJREFLR1BNZmZsaDNhelNCaUFTUnlMd0I3VVcyNlJZbDRXZElIMWkwUHdIZWIvOEtvOElFVTVtRFpuZStnVEhrdkhVQVp5bkVQSWhqd0ptV05SS1pHU01oa2xrMW05L054N3I3LzY2TkdqeTV0cks1WFZoYXJPYW5lNHhMWXRxTWpNVEFjWkdqcU92bGlBRW41YUUvemdROW1XOVZ5bXMyTzR0ZlYxTGk2Q2pFWmp0TzdYcEQvS3JWWW1kRjlubWltbU1maUR3VEJmTHRSUEdrOU9qMjNQQmNyQmdCMlhGcVJGK3lSVk51bHRocFAxalhVZmhKcXVjTWNsVllsQmh5L21wbW5CLytwVUczQnFMKzFlYWRYcStVS20zZWlOekVrcW1VMm1EWHBodEM1Z2dLQTRhVFlZMUxvZ3c2TWJEWWVKVEFxOVBwcE9MKzNzalFmanFXV3hDUXRnTExRZWR5S2xnbXNJY1pEVkpOd0dtRWI0ckIvNytBdGc3WWY3QjJCS2cyNC9GaGQwdUt2UThqd3RFMEljU2RlSG81RWZ6R2hhdml5bk0xbFpFQlZWZnZhNVM1MXVMNWxPeldhZXJodnp5R3d4Q3lycmxkcDVBd3dJM2dLTXlhRGZkMkhPRmd2NEZ1bGt4clNKeFo5VTY0WWtCTkVZK0l3Tm1oZmxpaXZGWnJjTHh3T0VDcWg5Y085eHNaRFRFOGJaMGVsNE9ybDg0MGF2MTJuWG11N0U3dlY3NVpVVmNMeDJ1d2Q0RGJvOXVra0xMdWY1czdtTCtrTnRCOEVza1NDK2h6SHpaNUZnNXBWWGltTnpBcVdReWFiUVN4Lzd2aC84MUgvMks3TjVqQzJNUWFDazBiMEFBb05mdU1YWUI2VXNGVC9oSU15TWVQaHpFWjVtSU5nekpZcHlrTVJLWXhoYVJzSW9oVkIzNGcrUVFFNkMyakpRY3ZpaFl5N0twZExvUTh5YXRpbHBXUWt0bWE3czNIai91MTk3OVJ2ZmpDNW0xNTU5L3NuOWQ4cFMxRTV1enlCVXdFQ1lqLzFDaGxoQ21QYTBlQVJVZ1pwOGtabk9UVEM3ZWVzR2FNekVOTk5aQS9vMVZ5cWh0M3VOcHNCejV0Z2FkL3YwL3U4Rm5DM2g0UGpNOVQxb05LQUhoM2Q3R0tRNU5MVHZ6cnpaYkREb0ZndkZYcThIM1E4T0RZVUtXd3cxMUc2MVJWSDAzRmx4cFpSSXAzdjBZTWM2SE5BZitwRWZncGYyNmgrOHlpMzhiMzdqMjRWU1FSQ0l4ZVFMV1RhcHkzZk5LVHcybXBrb2M2bFU2bmovMUhNOHk2RzNKTkNWVGRQcXRvZThDSTNyMEJPeDlHWlFXc0lPVkNkZktJQ1owTE1kSXEyK3JTbWlwdEtDWlAzK0VCMEFIZzhRY1h3TXhDYnczT0ZvWEZuTlpkTTZ5REhJUFZ5SFJxMTVkbFROVjhwblJ3MU5UNmFUU2RpSmNyRzBzcktpQ1hLdjM4OFY4b0lZaHlhT2NyRmd2aGhPcDVsc3J0M3BZbXlCMW5hM04rZ05mRnBHYTk3cERqUk5reVM2b1R6cWRRK09UMWRXeXJCRDRZMDJTR0N2MjAxbk0rMVdKNVhTSlpvRkZsTTAvZnowNU9Ub0NEME1Bd3ZQV0NISmxPZ2RrWWtFek1KZzBMdDhhUS9weDRlSHB1VmMvZVFQNWE3ZXBGbGlhQ3JwT0Ria0FBRzJhWVRERk1RWThHZ252aGtNMlgrNHdkUXkyOGNDeFpiZ28rTVJhQzlsWVQvNE1Ca0lyUVRUdE5qQmZBSldJTXRKVUVQNmhiQlFLbk1qYWNmRjlVcmFoUzA2aE1Vb1A2RjNZV1FMNWUyYkovZmVmdjNicjcvOTNUZk9UODV1YnBaMFZaM0krVkN4MHo4MWtCM3pGTkpVWjRxekhHd2ZpNkF2c0JGbTR0Ylgxb0Z5dW5vNEN4cm5MWGh1Z2lSWlk0dUxMVGhKekdWeVJrS2o1YURvK2ZuSjJESnhIRDNxenRIa1cwQXRuMC9KQ3IyTzdPUzgzaDhNNlFsUlZlZTRxQ0lKMEhZdVBjTTZuMHluQ2QwWTludXlLaVZ6YVRZSE9EZVBCSlBKZUdWbDlaMzM3cno0L0l0d1ZPQUh3Nzg4UDZ1NXJnV1BMWjFKRXI0dDJ6VE5SU3hXTEpYOVlBRUxNQm9QWDN6cE9VVVVwOU1KbkJzNGVhRHVNMzkyOCtiVnhubDdOdk5sVWZBOE94Nm42NkhSUlZETXBZSVpQVmxDYjhXejZCMFY2Q0JSRkd4d0d6YkxZSXAwY3lKTHl0YnVwbW5aenozemJDWlhOTTNwMUtTWEZYTWlueVV4SHNDb0N5SnYyemJZVHZpZ2t4czQ2RWtqbVVvYUtyZytxSnNraVdnZHhOVklKTUMxQUlrNXJZMnNEM3Y5d0tWN1ZXbE5TZVF6azlIVUJUMmYrMEk4Tmh5TSsvMCtMYWJITFM1ZjJZVmZVY2psZEMxSnQ4Sm1zNmxsRndyNVRxdTl0N1cxdGJOaGpxWkJoTllXUHRnL1FJdXlwZXMvL0t2L0ZiM0paRG5vR0ZaQ0VodFpCTnE4K05DNFA0MGpoQ3Fjd1JISHM0UERRRHN2NHBTZElaZ08rNU1GQTBSTUdnQmVZdlFmN2wzR0tOT0hZaENtUEMyUm1Rc2s0RHY4SUxCSStCZEo1SXJyMTU0L1A3alhQYTJpcTBRK3NwbVRJbHJGaXN1VWVTa2o0VUhoNzBXRUJXelFhVWgyaUgyRkthVGRWd3A1ZEJ3cUJmNnRhbXJ6N0J4b3ptVlRNOGRONXJPMHBPMllKdGxGWWh6ODBhbmwwQzFZZW80SnZoUHNaeVNUekRRNm5XZWV2UW5Cckt4V0lMa1FZT3lTUlFtMEI4WjlOdmNyS3hYd0FYRFpYcWZIOHdMUUQrbHF0L29RQnN1WmJtOXZHYWswaHBCa1l6R1g0K0xweWJtcWFkMXV6ekFTTGppQlpjSjUyTnJlT2p3NHp1VXlzT3l4aUEvZm1wY1ZQWldDU3dBdHZiVzlpbFpVNkczb2FCYjh6aDdzQU1nVjZMV2lDSkRlR0FlTWlwSWlKdzBEOGdPRDRMSjFnTkh3UWpIZmFyWnUzTHdzQ2p3Y2NjdHlIdHk5WjF2MmVEUWFUVVpuSjZkUVM1VktxZE5zMjVZSktEOTZ1TjlzdE9aUk9MSEJjQUNabmR5NGVRMCtBT0RKbHR5UVBjY3BsUXN6U0I3TlBBNlNldEtrMlpxR3JPa3I2eXY5VHE5MmZJSVJRQysxT3ozNEE2aFhPcVZQcGxaa3djTjF6NVh5NVVyaGd6dDM1OUVZWGV5Q3orRE1KRDUyZkh5MFVpN3ZIeHhOSFJQYTU1bnYrek4vN3IvNXRSbWIvUitPTVF0c2hFbVZVaUJjRWFpV09jSmxSVEZDaUxQOXBHdEpTYk5BMkNXSTREODhqaDBaUnRnZWRsaTQ5V0Znc0tYZmorNUNXbGptVXFwWUlHTDBkR09aakcvS2krOFk2V0JLREl0QlpqV2RLZTFldi8vYTc4M2QrWGcwdnJxenBuTHptYkVCOFE1em9XdzY0Q05BcHdRbWdtRUlZK0U1d2t6Y2VxbE1MNVlCOVhSZE9HU2dIRURKZURnU2RZMlB4UWlDVWQ0Y1RneE5pVWRqMEY3RENTMW5CL3VPekR5OExkaHBTUVFJb0FoNy9RRjRqdWU1NFVRcktPWkxsL1k2elU2MzN3Yzd5UmR6NXRUT3IrVG5ydGRzTnZrNDMycTJVK2trRGh4Mk9sQjE4SFFCZC9EWFZEb05Pak1hVG5FNlZMbmJCbllCdm5HeFVKaU14OUN5Ky9jZmNZdUZyQ2NmMzNzQVF3K0hiemdjWndzWkRMSTdjM2xPQUNtSC9vT0NMNVJMc3FvNThDRzZ2WEJwWUdoeVJkRTlQd0Fnd0swaEpNN1VmTHgvb210eUxwOXB0cnJUNFNDcEorS3lyTVQ0aDQvM2dWbXdua2F6bVdhdkNvVGdyNitVZ0FuYnRTRXpoVUpwTXBuUUs5azByWHJla0RRTkJBdzk2OEFUQitzUDVrS2NvNldtUEcvanh2WDc5eC9zNzhNRE9rMW5NdWczMTUvQjc2ODMyNUlvZ0JOQ2ttL2Nmdkgrdlh1eHhkdzJuVmE3RFVha1NOSkdlU1VTTEF4RGc3bXhKK1p6THp6bldiTjBPcDNLcjI5OC9KT2tpU2dRd2xtRWdJWXZTZzNCUUVrWEE4OStRb0NHZ0E0QkU4YVhZYWwyUTd6U0VTUWV5TERFKzU4TXkwVDJ3dzZoc055OFNMOEliTmV5TG1IQXVmQkJDak16VEdTZUNnamllaUxsVGtmTncwZEk5V2ZlamN0cmk1aHVTYWtsenIrM3JEQXdFYVkyL0lsenNRdXBFZTdXamVzUk4rQ2pFVjRRUkZtaytUQ2pxUzd4R09hWVA0ZXkxRE5KWFJRY2srNlNLdEZZQXk0Z2NCT0pycFZMeFh4UzFnejRjR2tvNDE1dk9yR20xZ1NHRFV5QW5TOEczSytzVkdiT2JBeTBqa2ZReFBWcVE1TWxjSjU2dlFsdVVDd1ZvWGVuNDBrMEhsTmtaVFNDTEduQm5GWlBMcFh5Z2UrMzJ6VHhpNHZ4ZEUwOUVpbVVjMC91UCs0TWhxS2lEd2I5M2QxdE9KZFA5ZzloRGRBOGxBK05teTJrSVRtdTZZQm5hN28ySG93S2xUSzhpRGtINzBCYytITmFHb0c5Z0hjNEhCMGZuNlRUZE45K0hvbGR2L0dzSEVsMVdnMDRJOGkxdXJVQnAyUk1qNDNTbEdabzRzMk5OZHZ4UnFQcFNybFFQYStDL2pWcFBsbk1NUFJMbDNaT1RzOVJMaTE5aXdPOEdiQ09Wc0FuemtKUVZMbDJkdEp1TmREdFNPLzBlZ2xhYVBMeHhzYUdaWnJGUWhhZVF5YVhIblRhcnUyQTZXWHpHUWhMbzlGTWEvcjY1anJQYzZQKzRLUmV4UWluTUJyd2lMcnRSRGE5OS9IUDBzdW9xYXR4cXFkNHBBZ05MZzAzL1JObUx6Q0lEMDBVWTZENEVGamhnUi9CR1FzZjJXUkpGK2tVb1RqTHozZy90a25ZRUZzZXcrTGhIaUlUTEN6VHcyT1htK0ZPaXJIclA4dWpsMEtJLzFoc2JlL1dwTjhZMXM4andUeWJUcXhrMUVESjIxR2V4QnhuUUU1R2JIQmlLaWdzQ3k1d2pNd2JLNE5Ta1llS0I5eGZldWtGVmFkVkdrR3lPWjZEODVUTXByRUhIaVRBTVI0UjNZVWVSUldzeVRTWFRNTHk3cCtmNnduTnNUMUFPRmpNNFpWaXREUmQyVnBkZS96a1FKSWtuQ09SMEgzMmlza3hyVmNmMVZRbG1Vd3gvc0FQUjBPQUtaRklIeDRjeUtwTUQxdXc5d2tQaHdPWlhuUVJwV2Q4Wmk0NEZXb09QbE03cnhVclJaaCtzQXNvTTJ0czdsMjVwR3ZHcEQ4R3VHdm5EUmkrWnJOMTZmSk9MQXFDSTd1MjY5Z3U3QXc4UnpRYjNCZGtiZXE0WUJibXhJWm5VcXZYZ1hXVUQwa281clAxYWowUzR3MDlrVENVYkQ3OTFodHZYTHQyT2ZDODl6NjQ1MWhXUHBlRGRZS0lncU5Ea1ZjcVpUaW1zRGJnRmNQQkVENzNBQjczZURMbzkvZ1lEMmFEbnA3N2N5NFdneHlpSDhDL2JXdWFORFJVRzRlZy9LU1JnQThOVlkyNkRZZkRWREl0eG5ueXFoZXhZamxIVFpEaXdEZFk0dEhSQ1h4aTJ6RmJ6VVpDbGNkRHN6MGNDUUlNRW14YjBLeWVQLy81SDF5SUNrQVJVbVFhNkRDRXNkQTNwTUZubzc0a09QaGxFVVpxdy9BVTkyR2d3MEo0MExVd0hBbDVDVE9BRFRIc0xBTkZVRDVTbVFWZ2FlSEp3MzBzUXZIdktUODhLZ3pMOUZCS2NKcnZ6VXlSV0p5dkFQSHQwN2s1QXJPOWR1T3FJdkpEemdoWUdVL0xvZ1BacWNNdStONEdJVkRaMk0xQkU0cTZDc09xMG5xY015TnBkSnV0R0JSd0lqVWVEakdFYWpxdEpmV1l4RWY4QlhUa2VpRU4wTlI3QTBVV0RGM0hlYnlacnh2YVpEZzJFbnBDMGFxdGx1ZXpCWFYxbzFSYWlmcVJack1CQmkveWNYY0d5RTZnK3g4K2VyS3l0aEtMOEkxbUErcFdFdUhoY2E3clFHWW1kSHVTeitleTlQb05qdDdaaExFZkR5ZXlwclFiclhRbVZTaXRRSTdnSDJieStkSkt3UjZiN2U3QTgyZUNDTEdDNGVHSldFR0JSNk9XN2FaVEtkZXlmSHFnMW9ha1FWb0dvL0ZwdFlwaWtYbDlZN1ZjS1NaMUphSHBsMjljZlhqL3NUbnBYcjkyYXppMWFxZG5rS0pNT2ptZ1daWmV2bENZZVc2d29HZlBnbUNHbm9YRG1rMmxZUU0xUlFNYktaY0wvUkhSZDhnWWlDZWI1ZTlqNUlBWElKNjRIOXlWYnUrOFdzc1ZzbkUrZm5wYVplNysvTm5yVjFSUmlpSXBMdExWZ21yTDhSdzRyd2VIUjYxV0c4UlM1UG5lWURDWm10ZWZ1VmF0Vjhmak1ZWnpNQmlJY2ZtbFAvM1RFU0Y4elF2OUE4OHcyVXpoc2xGbmwva0FiUnBvOXFFME51cjRzRjhHa1dVcUM0UU03RVd0R1pDWVlTQXdMcDYrMFRROEc0V2xCV0ZmeU1CeWhudklINkE5N0ZBNmhKMHN4SEVvTFI5aW1ucG9HWG1haHhLWGdVcm5KV24xOG0xdk9veTRFMGtRTnpmWFpndCtFaEVqNkZaMlNuYXFDN2l6cmJBTG5uNlFGT2JoTG05dFFxZENaMGNGV2hYRG1mbGsyZWUrNTlncXp5ZHphWThlWVk2MXptc0xQcVp6L0p0dnZmbkt5OWU1aFJqRW96TUhBTlZjNHZxRFVxbUlQbGtFUG56SVRyK25xakpZTEpRV2pqV241aUs2cUJUTHc4bGtiVzExMGg5TnBuYTlVZi8wWjE2eWg5TlVOcm0rdmdhZkRnUWJsQlExb1VWa0FOczQ5Qmo1YzNFa2dZckE1MHNtQUFoYXdENVlPSUFkbkFjSWhDQTRqamVaVE5HZXRmV3Rack82bUVjZ2Z2QVJGWGlwOUlSZ0RDUWVQeGhOc0tONm8yTW82dDdPbm1OUFZWVTZPenNOWmdIY1dBT2V3TU1uMjd2YmNaa3ZGSXVPYVZrVHM5NXFnbWUzMnIzdDdYV01CQVlZOVVrWkdsQUZ4eGRHeExiZHRTMjQ0dVh6ODNxNzNTVWx3aEEyRDRCMWRubVFEY2dVSXVmUFFMMUFjbEJWM1RCZ2ppQithRm0yUUxZaXlrSERpRWgvLzczM0R3K1BUaytxOEVhZy9tRXFhV21rYUhSaVRrK3JaeEk4SHZqY2NWNFNwZUxPTlNtcDJYQnF6bzZUNVZVMm5DSENnUlZXRFRiNGlDNjM4U0VPUTBxZk1nSExsQmppNENtOEtMQWpsaWtoaEdnalRBZ0xDZ1B5VVp4bG9ZTENIWFFzVGsyT2FiaWZJbVJBd3QxUjlteHRxTTdEQ0tVVHZnbjRGL0duQWJ0UjdnSWRrZCs4cW9reU4zZVQyV3hHbDRkKzNLSHpmSGdhcWc5eWgwZWprS2Zub0ZNdlU3bFBmUHc1WG95N0pxMDQ2d1lXRjQwVjhnV0I0eFZkaThVV0lDMktic3lDR2NqOTBlR0piS2pYazFLRzNwZ1ZiYlg2YWxJclp0TzJhVUhYamNmbVBFcnZiNmlzbFJ2TnJ1LzdzQXhnRTVvc2swNGREdFdrNFZvZVhVcW5OZWhLbGZMcS92N0IzdDR1TDhTblUwdFU2QkllOUNqUWNIcHlsaXZtYVgzR0NJZE5WTFBiN2dJWjNXN1hjMmVRYUM0ZVR5UVM4UGJBWXZzOVd0ZXozNmRWTVRZM054YkJBaDE2ZkhMODVPQ3cwMmxuTWprb2Zucnl6WnNOT2wwam5RQTV6dVZTSU4rNVROcXh6VzU3VUd0MmtobGd6alFNcFZtdlRVY1dTRjJFb3pXTlhZdFdHb09wYUxiYlVPVHBqQTRIZEhWdHhUTEI0UjJjc1RjY0hoK2Y4eHd0cDlQcDlJZ1FzbXREOE5kaGFVUmFGdzZ5UzI4NmdXQk1Ka000OXJaTmQ2RFlxNm5ta01sMnA2TnBHdWhMdjl1bDlTSWRONXRJb2dMd0hxQzhmRnJzbDk3OURTY2VvMXJJWmpjM05nQUFTRUczVmIzNzdWY2JkOTVNNTh1Y0FxbkF1TTZtclZOSlRVWWcyMng0a1pPUWZSRVBFd2hnN0k4RlFodUxML09FbVNFU1RFRVM5SlpGc1cva3VNaU9EMW9hM2tPbE1sa1NoVER6OHFSME1rQ2ZObWtIa0lkczdJdHRVcDVRbzdPdkVKWVg0S1E4bEl0S3daOFFsM01WUFpGQlQyU1Roc2hIdTE2VTFEczdHUldJUE96QThDaEUyY21Yc2hCdVFMdXZ4MFJCVnBSaGI3aS9menlkam9FWExhRlBSNllYK09BazVtZ01MOEV3QUZhcjJtZ1hNOG00TEQ0OE9DMG0wMEJTVG9zNnRnOHpQNXBPWkZHcHQ5b2ptcmlpUXU5Qlk0SHNybTl0dXE2YlNtVzZQWm9TQ0loQ3ZjQ1BTNllUc3FnMWFnMDlsVVJkQUNCNkxwWnUxc2JwOVpFemdHTUtsZ24wT0pZTnN3V2xjUC91dmQwcmwxZFdWaUJGOUY0LzErWGkvUEhoOGZwR09aVktvYm05VmhNQ29BTjZtdDdyRDlJcGVxMEFHNEVGdmNTbTFUazhPZ0ZlQVRWVlZjUzRBTi9EU0JuZDduQjNaM3ZZNi9UYm5ZU1c4S09MQjNmdndnS0FPblBSUlNHZmdSbWhsNDdNdkJ5OEducHJyQ1RHNDR1QVhrVkV6NWlMVXEvWFIrdmczOEtNUUttajAwRk40QnVnK3FnM2xIMHVsd09Dc1oxUWRaSGpjVlNvN0hoQlFBYTROSWFxd2srWWpFYUZmTEZZeUkvZ3ZRUTBDU095bUF1Q0FOZElsZVVYbnJ1Tjl1TFQ2ZlpjejgxQ1JFMVRVNVRUdzRjUHZ2WjdyLy8yYjN6dysvL3U5SzNYOXA3N0dLOGxNZGdNZVFRSEZzZloyRCtMMFRiVDlLSGVZOGltL2V3QUZtUG9XS1lDTVhRWWZWSGF4VGROSkdiUjVlY2lMUE9HKzFnNnpjajlNQXVsRStCcEwzWERNaFBWQmVIaS9QUmhleWduQXpMTWVpem1DMm9ncWhqK29pSGI4OWg0Umcya1RQUk5SMUdoRktPQXhySFVEd1AzVENIWHFqV0RTR0JQbld3bUM4L3I5UFJjMW1RRlJFUUNWaUlZVlZHS3cyWkduU0JmTHNEbk96enJkbXczdTVFMm03Mng1M3JSaU8xNm1xb09SeU1NQjdnMlVBNkNCRFUyYzkyVDAxUGY5NkQvb0ovQU1lYUxBR3JTZGh5Wmk2WVNHajFpT1I1UHB0TWN2WXNZcWxRMkREaVJISVlaN0Z3U0pMaW5ZTjcwVGl4SnpHYnpra0x2cWRRMUZWYmVjaHl3bW5yMXZIMWVlM0o4RE5VT0NnWnRtQy9sNFFKdWJrTE1ISndYZ2plSGVtNTFUODVweGVwc0puVitYa3NiZWpxVGhoSVQ0dEVuQjZlcUxvSHVnR1ZIWlJHK3FXTTcrVXE1ZVY2N2VlTjZvWnhmWDkrNGQrOFJGRElZUlRCZkNCS2ZMK1RCekh0ZGVtRU9xcy94aEhLYTBjbnpvUGlnWW5Od2Q5S1J3QlNvU0FUc0V5Q3VONW93Q0pjMk4yZk9iR0xac1NpbkdEcmdEb3VxS3JUR0pkU09BN29UelBKbHVqL3RlUTRLOEgxZmlndlhybHlKeTlKb1BKUWxaVHlaTkZ0dElCN3RRdWZVems3bEdOK29uaFV6S1F6dytjSGpHNS82L0R4QzErTkQ5VWJEajRKbzZHbjBROFpEZUdZelcwS0VNTlNFVUFzRHBaSVB1dHlpNnpsc0Z4MGJmck84ZEFSRjJKbkNWTXJBZHRHSDl1SHp0Qmc2T0l5dzZvVDdQL3hlSHNaaTdKc2xYT0FYdjBFMDZpNDRieDVUdUhsT2srczJQUkcwRE45NzROT0E3YWRKM0tkMk5zQklaakd4WEtsVUc0M1ZyZFZjSW5OeWNqS3hUU2dreTV5czVmUCtvQi84Lzh2NjBpYkhqZlJNNGlKdUFyekpJdXZ1cXU0YXFYVzVOZEpvZDJMR3V6TVJuZzllTyt6WS9lWXY5bjdiQ0VmNGgvbFhPR0pqZHkzTmpLVHBsalJkM1hXUnhac0VpWXNnQUhLZk40R3Fsc0paTENEenpST1pUNzc1dkNDWWtPV0ZDMEppdVE1dHF5S0o4cmN2TDk4N2FyOTZmUmVHY1JCdEVtNWJyMVpoQlVBbG8vUG9XZkR0Rm1zM2JZcmt1aXR2Q1o3ak9zc3BHTVpvQkxYVTYvYzNjWEN3M3psdE5mL3ZsMy93d29DK0ZmSURtTXVMbVFPOUNNeEo5QzFtZ0NHRlBzWGt3ZVY0bm9zQ3NmUkRRNk56dCt0TlM1VkxRc0V3eTdBSGJTd1pkbmt4bndOd2dlOFZ3ZHhwcXpNc0E4bmV3ZEdmWG41ZnE1V0FrRnFsRHR4Y1gxMlBKdVB6aS9NL2Z2V3l1ZGNzMnphWkxzRzYzcXBIZmdqVjVjR0c0UXFTdVB2amwxK1hxNVdEL1c1UlZvYURDWWk0SUF1ZGczYm9CbUFZbi8vRlI1aXZzOWtDTXhtOEJhREJ2QlhGSXJROEtrWlhRd2Y2bnVmUXN4WDArRFNtZXJ0UlF5RzB1eXdTWWZCM3U3MTJjekNlME41TXIxNWljTDc3NFhWSUNkS2lUQThVN1hlN21ONjREbnJsV0Jnb0t0bEY3WGFUZHVMM1BKZ1RzRklZWExqYmZ0OFpENUhsNktOUE1RcnNUa29HTDNaZ2FZalVVMnJpMDB6QVNBbUxaTWZjeXpKUmtBZ3k4MlJGc0VRQUhqTFRNVTlQQ2JJd0N6QVpLWFh5czF4WnZrZEhoYkhGSVU5TlRDUXZQNHNrQnkrVjkzQmtqbmtqanZNMnU0WmVYTUdLaXpNeHNnTVJWQlpUNmZSUHRKSWkzem5odi96eUY2a29EaWFMYUJNT2V3TnZFM2IyOTdRQ1BhNExhOHR6L012cnQxcFJUS0p0c0ZydkJBRlE2TFFiaHFwYjRQV1d2bzZTRlVaRktkYUFDTjF3aGhPUWdRSzl2NEQyamtQRldKTkJQTUlJSnRvS1FsWFZhamE0cVhoKy92VHE2dmI2dG1mdnRZODYzZm5kS09Fd0g1eHlvMlpaSlZBQk5MaC9ONFR5T3pnNUFGc0FGMWl2UTFWUlladGlRcWVGTFhROEYwZHIxNFhGQUhYb3JtRXh1NUlpUU1XcnVyWnlsa204QWFzQnFnQXlaSWUraE9XTWEwYUxZUE4xRGc1RVVZSEZjbko4OVBxSE4ra21sc1RpK1h2bnZkdDcxZENnK3lkRGV0cUhMd3A3emVwaXVuU0MxWDUzanlzSW51c08ra1BmZDVNa1hXK2lTazIzTkdXYmNGNFlZWWFENFFqUTdsdmFSUnAxWVFvbGJBOTFBTHRpMjJ0Z0ZvdGRnaWxYMWxRWmFFWTdRZGlnSFd6VnVMMjdXL2tCMkNCR09rNWloU3g5cVdTWWU2MjJwaHB2Mzc0NTJOOFBveEE4cDlsc3pwMUYyUzVuL1V4UG9tb0dycVZhdGhlTDVhLy83bi9hKzBjNThwZ0Q4L2dSaXVpVHlSa3NFR1Nvb0tpSFUrN1AwTUxTcytJWXVrbmJNaEUrdVp5VlRxU0ZKRGl3eUR6Sm8yNW5qbVlZeFZBaHVVT1M3TWdBVC8rNXl6MVowb3ppazJNcG94MjNqTGJKanFmbjF2T2tMQ2ZMbitXazQ3dHM1SVFrcEovNTFHV3hHRVZXbys3NW01M3YxanZOY3AwV1gxVVVKK1BGM3RIK01nNVBucDBKc21UWkJsbE5ncUNVNU9GbzFodE9wc3RsdW9OUmEzcFlFT2c3MFhJQWlySU93YWVobnpSTnIxWnJxREtLTnA5Ky9rSVdpbnhSYkhlNnE5VVNOcXVJWVlqREpGamJqYklpd2ZRay9JSGJsR3RsS0hWTlYwRk8wT1E0am9GQ0RIKzlXVS9vVzZLMGdscENYNUhCdjkyNUYwRjVkdzY2OUpRS3ZldEdwVVZGNEQ3NCtQbHM1b0FCKyt3SkdOcVlHang0SGZtQlgydldIZEF6ampOMEU5WUVnRjZyVjBIcmZjZUJYZG5yM1cyNTNlZGZ2QmlQNW51dG11OHVYNy90VFdkTHZrQWdWdFFpU2xPVjR0blovbUc3RHVzYmZQcmkrYzhtNHpucmNHb3RadW5EeUcxaE4ySU9JR05LejhsUUNUN01YRW1palJnTXMxYXJnSjZCdDBCbHdQeWxkaGJwaGJVMVFIbTdmWFo2cXNxeVlaWWtXUXFEZGJwTE1mTnR5d0p2UlA4Y0hCeU9Sc09xWGI3cjkwOVBUelJWQldkNy90R252LzZuL3hVemFESUZ6QnlEQUtNM3Uxd0habURNTkN3bGV3RGFRdzZvcWt4ZmsrSmttaXNMc3hTTWUyZHBrWXN1bFdHVkZVZGE5cWNPUXFSa09Tajl3NWxpZnVRb2tOZVF5NmtpQ3BHVXlYL2l1R2hiMkxCN2tRL0ZvQWxBTjBJUEplY1JkSUlZRnk1VWpYSzRjb3Q4ZXZMc2Fib1QybzAyS0FjbkNEZkRrZSs1RXYxUVdqbytQZmorNWFXdVNxUCtuYnR5ekxLMW5NMDBSV3MyMmtxOHV4a09vb1IrakxOY2VZUEpkREtiZ29xZ0FrV1dJL3FsMGpvTXdPMWhidEV1ekFlSEI3NGYxS3BWRVl4RUZFdVdYbEoxV3hLM0M0Y1RzUGlLSGoxblpnTHlBUFRTV1lLNXdGQ2V6aGJkZ3k1d1hLM1g1dE81WFM3VGN5K3k3UHBodWRHR1NWMXBWQXhUNi9jSDdYWjl6VjcwUjFZZy9iNEoxY1pwc29VV0JDTUNvNkQ3TFZFRWRSdEhzQ3pXaXdXOUs3UFh1MGRQOGJ5SWhJcWgzTnpjWWtHUVZRbTYyQ3FiTURuc2N0V1pMeXRsRXlRYlBLVGRhbzVuTXloZ1V5ODZZQ2R4aWs0TDEyR2E3aEo2dVFNNERFd2V1aGVKam9kMmtEVU55d3NXT3RvNmsrZGh4eHdlSHBRc3pOZ1FNMkV5bmhRRWZqZ2NzVzJPWTdCQmpKY2s4VWYwWWdMa2dDazhXM2xlMWFhN3RHQnlXRUhzU25rMkdNa0NiK3I2Y0RKcE5Sb1c3Wml3M2ovb3RpOCs2Mzc2Qy9hVkx0d0RHREx0emo2RTMzZmdZWGhpYUNLWTVKcVVPUkt4RUlHSDRNeVVMeVI1RW9ZcCtqQVBUdmtDa3NmU2pHQVZQcVpoNTh6L2tJb2NGZmNZekExVzh2eEkraFBIOEl3VGF3Yk5hV28rNnM0S3B0V0RWWk1sQS9weFpwR1VXUGlyTDE1SUpWMnAxY1plQk82cEdiS0U0Vml2M2FVRGJkcHQxbmxSeEpEb3NncVdzdmFUOFdUbWp1YXJsVmVJNC81Z2dOVzJJQWhZbmFIVVFWdzJhV3BvcGlEUnZVVU1hNlZjQnFZM01iMmlLNmIzZks3cFptSkNEd01HWHJpRUd2ZjhORmh2d3dBTTlIWTQ2ZC9meTBVSjYzV24yL2JkUUZWbEFTTnFHWUF2R0E3UDhhQVFRSlVvd0xEa3N0OHIwWE84OUZaQUhpekI4ejJFMW1Ib0I2RlpNakhUY0ptTlJnTWpBWTNMY1NBVkluckpvcGQyeENJUFppOEJGc0NsTEd1d0pZcEZORnlZamNkYnVydlBMeDBYRFVZL2pVYUxkcmU5bWt4ZGYvWHM0a1FWRkQ3ZFJ1djR1TnVHWXI3OGN3OExpRTVid0hLTHBRT0RGUmRMUFUzZGozNm1EUWtoeE1JVkJmU2xNc1lERjBJMFNlQU5YVVBmekJjT21nM0pMdDNXeWpib2Y3Q09zVHdkSGgraGgwRC9zSnJhZHRXcVZLclZDbTBOZ3JVampuaGlPOFhDZG5jN0dDaXFKb25LL21HM3FHcS8vc2Qvd2N3bVZESnNzbEZta0NLWGVlbkRGQzUwSVIxekVrMUJ4TEY4RU9mcEtSVmRSMTRlU2VqZVUrNW9DakJFNGZ3VHBVNUY1bDZXbTF5V0xKTlF4aXptWFZsMFFDVzBNREtZc29JeklmdkxYSDVtWmVHZk1Ta0taRWZXREJTVnRabWtXV3V6YXhUMmo0L3ZKNDRvU3MxNkNUTmxmbjNuT3RQMWRtZWJwZDB1QVZOZXhORm9OZ1dxZG1GMDhmNUZ2Vm16RmJWaVYwdVZTc3J4MWIxR0FveW5TYkpObXEwNjNiSXNnNkdHVUprd0xxTW9sQVRScFkwLzZkMXVJTHVzQ2J6dmVycXBXeVV6OU55eWFVUkpBZnhINGdSRFZXOUdvNm9pODZIejJ5OCsrUHJWVmJqWktJcmE2WFJIZzFHeEtBNEd3MXExaHFrRDlZeEplUDMyV2xGQWtYY2hlMHVaQ05iTWkxWGFWcmRFZDc0TDZlSHhJU2JQSnRrMEdxMXR1c1Z5YjVaS3RCRUNiWUt3bGVrRjlpckErdjZINzY4V3JzaHptSUtnY0hhMXJNdGdGSnVEbzMzSDhaNDhPUjMxZW5iZGNoWXJRZU1qWEZnUTc4UnR2YUUybXBYanM1UFZhRzdyNW5MbEM5QVhPdTE3Q28zT3ZqVEZITVAxZ3RMRDFpaWdzb1M5L3dmOXZzSGszNnlESUhBY2VxTXFMZ2RFcTFtdkFZU3FvaFcyVzZCZlo1dmlZMW5FcklhU1g4ZWIyN2R2dTUyTzR6cFNZZnYwL0d6c09QVkdjN0p3dXZ0ZGc1enBPL096di96cndnUGMyZkF6VEpBUDliSjdKOVFBMG9nMEZpd3VhMUlteWVIT3hFZ0ZFV1doOU5sOUhFcVRzWEZLU0lWU2JPYkpFRTlCcEdNZVNGbHQ5S0Z5czFia0VpcUlQR3orVTdHVWdTVmxjdkptRWhaaTRseU9FMFA1VDZaWTFpcUlIZ3BDZlk5OWdBQlZLSFRLNWFwbDhKRS91dTVQUXI5c0ZnMllQWmJ0SjRWLyt6Ly83c1ZoVGRDdWUvZS8rczFmR2tYTmF0V01ja1V2NlV2Zlc2NkNZQnZnQW1iamlhbktWM2Y5ZUpjU2FVa1MxL1diclFiWUFrRFBDVnljd0E0ayt4bHd4QkdqVzdMc1h2KyszKzlqTUdIV3RTbzIyblh4Wk45U3hjblVXd1IrbWhZc0xSVzBXcWxhcGkvZ1ZiblJhSzY4QUR6SDgxek1xT1hDd2JLVHhpa1lMYTRGQzFySnNnSXZLQWowZlNlR2FibjBwU0wvNnV2ZnI5ZE9yZGFtbCtnYUJxb0dneGZFZ2lEeW85SDR2bmV2R2ZydHpaMnFpYzE2L2U3MjF2RmNlaENnd0l0RndiQ01YbTh3bnp1Vm1ubHlkamlpRnllbFAvejVyaWdyb0J2eE9yMi9tMVJxOXJmZnZKSjFUVlNLQUVLOVhwN09GNVpsWFZ5Yyt6NzkyQnl6RHFZR2xEckgwKzZ3MU5Uc2JneFhtTlBQbytpMkViQU9heFY2SFRHcndIZFdxOE85UGF5QUJtM0NRNWFBYnBtNllRWnVzTmZ0dXY0NmdvNG9XMG1hbUpqVjBjWXNXYTdyQXFhS0loOC8vN3o1NHBkb0Nmb3owMm9Nbm9RVDVxY1llTmd2VG1uNDJZZHNNU0NEVWpCSmZxQXpDYk1BR2s1SktRUEx4REJLc012dnZqK3lpVHd2elJpSTh5elpoNlZqRTRGVjlqQUJIaXJKTTdOc2xPaHh6bEI2NW1ISGg1WXlHZnQvY0ZrQnVSU3BIcXJPTEFvcVZ2amRpMDlTVmRtNS9tRGl2TDNxZzRadXRydjVaQmFGYmtQVkFWSllqVTkvZGpaMzNZS2lRQ2VCdi9hdWJwTHRkam1hQUN1YmFBM3RMb2c3VXpmdkIyTjZIakNpQndJRGFQZ3d0R3hUVnhTTWRBQldRTzhIbHRCVy9JRm1ITzN2N3paeHExVkhkUXZQTjFROWpGYlBUK29mSHJhdmIrZVdyVjYrbWY3MmwrZjM4K2k3UDN4YlZNWHBkR1paOUZ3WGFYQXVGWXN5RmcwUUcrQUFaTGZkYnF5V3krbGticFJVVFZjYXJSclA3Nzc1NnZkYWNUZWR1cWRQenpEcG9XUHI5ZnB5UHZ2K3UrK1R6YWFrRzFhcGROdnJBU1g5M2owQWlmbnBMaHhGTEtxNm9tdmE0SDRJd3MwSi9HUXkrZUdIUzlmMUJKNSt4bFZJWUdKd2h3Y0hoaUdXNjhabm4zM3kzYmR2b3pENTdQUFAvLzMzWDhNbUdVL21kMzBVV3dUdGh2bUxYc2ZTaUh6b2NaQ1c3TzRORmloQUhJZ2hUR045aVpQem84UHBZZ0hZd2RxUWVVN1NWRkdXNXJQcGNiZXJHaFpBM3Q3djNON2VMSmVMcW1sTW5FV24xYnA4L2ViSms1TlZHSDd3MFljd05yWlIyRHg5V3J2NGhHQ1U0Um91SC9Nc1JCb3hBekhKNExJcHdaSmtna2ZjNXk0REZZdW5Ed0dRZ0U2TUFVSW1venVaTEJHVGtTMU1CYks2RVAwanBESzltd2R6RDVYL0NIZ21wVk9XaEQ0WkIwRVFpakxYMjNsczVxY0d3ckc2S0o2K0s0QVgyUjR1TXZ2Z256ekMzLzdxUlpXUHB1T2xvR25QTysyYjRSaTZyeEFuWXJTcDYzSnNhTjFLMVYzNXI3NjduRHB6dEE3MGR6b1k2WWJjN25TSGc4bHdNQVlEd1NBZUh4eUVVUXlhcmVzYWpTTlFLWWp6eFJ5dFVEVU5veDZ0UXhwZzlBVTdwdHNZYUZOMFZSUmwrRzFKcXBmTXlXZ0JwZ0FGSm5DY1pxajlQczJvOC8xdTcrcXFWS3VBNlk5SEkyaEgzL012djM5OWMzdGJLaG4xZGt0U1pGZ2FJQU9TTElJYjNGN2ZEUHE5MlBVeGNQM0o1SDQ0SC9mNnk5V3EzcXpEVm83WFlkbXlWRjJqTjNEVDdTTjY3L0ZrTk51czEzL3h5Y2ZMeGJMYjdhdzNRYTFSVGJaUTh4ek0zOUNQUEM4eVRiMXEyUnQ2UjdIV2FGVnJWUU9UNFlmWDExSGd0L2VhUmFnTVZDOG9ieTh2MGJtYWJrQjVZeFN3c3FtS0F1ME5IUUFrb2ZGa1JUQWZQQnRJSTlvWkZEenQ3UFQwelp1clN0a3VGb3QyeFlwaTJpc3o4SHhkMVlDdTlTYWRUU1l3OGQzNW5EYnQ0ZWxXTEpyNmg1ZmZhcVhTMnpkdkpGQjVWZW1jWEpTZmZZeVJwbEhQSElFbTl6SnM1TStyTUVUU1hSckVRd0NpZ2laQjlDNHRnMkorWm80eXM5bVFUeWRFRXV3SWhDd3F5L3RvSExKSU90RUJpZkxuWTlnSGYwai96dEdjeWNRc05RV1lZeEVQbElYQVI0dEpuanlMWS9PQlhRWmJiUEppczdabG00VXdBWVh3TDZoYThlLy8rKzlTSnpCajc1TkQ1ZWYxMHBmOWhXblNOM3liTkJGMXRXT0k5V1pGTld0Zi92NlBqVmJGVU16WmJMNTNzQ2VxS3BRVjhGMXZOVS9Qbit6aTFGMHNiL3A5dTJ4RHY0Ty9nblp1dDdUcGJoRDRiTXRzdXU4QUt3dDE2N3F1eUNBRkN0Q2c2MnJnZ25zSG96NjRxSGMxY1piUWlNSU81a0JSTjd3b0FwK29ObHF6eWRnUFhFd2J6QlZZbG1Dcjg4azBpdFpTZGtkUDBUMC9tRVBwemVnSDFEQmk5NC8yUkxvRlNLK2xoZ0dnS2ZLclA3M2FKYWtHclN1SVgzNzFSM2Zsd2VBbUhyVk5QdnY0QTQ2VGprNE94ek1uakRlWU9MQmJ4cU1aQ0FrVXN3Q3JzZHVCWVZ0dmd2aVpnOUVVOElYcHZGd0V1MVNTSmVuSjB6Tk1OY2Z6Q3R1NEVFUjJ5WVNlUnYvR0VUMzRndnBKamZNOGZRVUJ2Z0x1Z042bllBcUVvWkcyWldIRnVycTVRUnJiTHRHK0RGNm9xeW91YmJkTmw1N2JialNDZGFLcHl2M2Q3ZEh4U1lnWklvdWFLdmNHV005V3NDVkFsaTdPVHdSSmthejIzb2Vmb29JY3FZVEJmTHpoSHZDV1FaMk83SjhsL1E5WXp3NE1VbytZQVdwWjhFY091VmtsSkFmUFlHaWpmQ1NqbFp3U1ovOTAzUWdqSVdyTkVsSWljcG1IeXFFeld6bXlBa2xLdnF3STRQa3hndmFVWng5TUFBSXlaYWRaU0prUm9Bd1VwQXdndU5Sd2tnZ2ZuWjRXbk12Zi9QWUx0dytrdVlmdkgvM3dlbEU3NkJRTFNVSGllNzJSdjlsME9rMHcxOUY0NHEwampJRnE2RmpXRnd2WVdHbUZ2V2JvemR0TDBkU2I3V3BWczN3L2tIaGVLZERMQzJERW9qYW9NV2d4VEFNTWNNUmVKSTAxSFFzNk9JOG9FcHMzREVXTTQ2cEdCdFkyaXJTU0RtYWxpSnhTbEVGMUtwVUsvVUl0NXJDWStJRW5pV0t0MGZLV00xbWdSeThsNk00ZEZoQjYzZ0hFWURxWktMS0lwcXFTMk84Tk1OTzZlL1hRVzg4WERsVGowZUUrdXF6V2Jtb0YzakpBamJqVHN4TzdacVZjWW1ncTJudDlkWU1XRmlVaDlDSk5OU0kvRERDbE5wdnBmRDZaek4xZ0pjaGl0VmE1dXJxRHVicmw0bmdYL3V6RjJXTHVEbnJEMTY5K1FMTG56NStxVUNHWXladEUxMVRZbWhoWlhEK1FnRm1FSlEvWHk0dHN4NkVkUFFvRVU3NjcxKzczaDFnTXdmRm96NThDRDlLMVdNNWhCbWhheVRRc3NDSk9LSzU5Nytqa3hBc0NyU2lnOHpDVFRqdWRBRXRxUks4VDlNS1FWK1NENTUvYlR5N1lHTlBvMHRobjkxWG9uMVFzTzBQR2dFQUhwdXdaMURLWEorQUltemw0V1ZPUmprV3hQT1JoY2tyUFRqOTFrRENzMFg2bU9MSnRVUW1OQkZpeUZGaW1IK2ZML0ZsTmVmZ2hPc011aWVtY1NaaVFCSVJ1Tko2YWxrbnpGRmtwTEF1VDBabVNDdi9wc3hkZUlMejkwK1hrM3A5NDR2VWlxWW83Zzl2OTcxZHZGRkhSdWUxbkg3KzM0UVRIdzBpSXl5REUyTWd5M2YrcU5HcXZMMjl3T1ZFUWM1eVNjb1hSYUZKdjF3VkZTZUxZTUxScWhYNWJ2ZlQ5ZXEybXlIS2MwQk5VRVh2ckx4eEd1dDFzQmlzUGltL3RlaGNISFJsbGJRdTZ4Q2ViSFNkSzdtYno0dGxSeWhleFVteDJXOXUyc2VBc0Z5dk1wVlozejF2NmdlTU1hSU1rcjJRWUFOQUN1dDJabGN3U3RGMTN2NjN3SE5Zby9HMjU3ZE1uUjhQeGJQK29NeG5QZkhvcGlOL3E3cStXM3JZUSsrdjFZdVgzZThOTkVvTkl5QVVPYmZZQ3Y5RnVsT3pTKys5ZFNIeEJrT1J5dVV4M1YzYUYrejZtMGh5MjVYZzhCZW02dmg1OTlmOWU5ZnVnV0x0ZHVoV2xJaFJ1cmROQXlJTzkzbXl3RzdEMFRSbDFPNGdnM2RWTmRJTmVNWWx1YURZYUlHYUJIK3kxMjh2bEVxdGlEZXJkTUllVENiUit5YlNmUGozZmJHTVZSbmFhd21SeDNWV2oyUWJBVzVZT0t4ZnFBNFYzRHZkaERmaFlUbDMvVi8vd3o1SmxvVEtHVkdwVVB1eE1DYU1KVEpMRlpUSGtxRzA1VUhJSGZPWEFvUVA1OC9RRTJ2eURiSFNnWWltSStFY2hDMUd4N0p5RnNqQkxDM0VtZVhCWkhuSjVkbFlpL2FQNHg2VHdaQzBoQ2NQNVl6NVdLaXM3eTBVaEZzaUM3RU1KaEl2alk5T3lWOXVpVWRLbGt1NkdtM2E5T25QY0Q1K2N2TitwUER0cENVSjhQNTBWZEZzMnJVcTFESmFwYUhxMFNmdTkvbXJwRkVYWk1MWHIyQWFqQUFBRklVbEVRVlQyWVdkNGQ0OU9MMWVyeTVWYlk5dTg3SFZiM1dyVkM4SUJ2U1NqNUs5OE5nekFPZlVRRm5WM3RSS0x4WkpWVWtSNU1wMUlxb3Jsd0U4d3JwZ3lVaGlubkFnZHd4VjFTU3J3dnVkVjl2YmFod2Z0L1QzYTN0RXkxSkorOHVRTUJNRlpPb29xQTI1N25ZNUdMeEd4c1Z5MHVxMSt2eS9EdEUxcEUzZlRMTm4xQ2xpU3QzQWxTUUc3Mk8rMmIyNTZpcWFGYmxBVWVOaktzOGxNdHpRMERQcDhPQnJQWnd2WFdkNzFCNldLZFh0N0N4c1VDSU1kdVY1dmFKdUFUWkxHV0tOU1FOOXh3S2lYZ2lodWQ3RGE1VDk5ODkxMEN2TTd1Qi9jWjgrMDBEVmprSGlPZnFvTmpFYjBkSmNzeXpCUzZRbzVMdGxFc2xURVV1aUhhL3JsVjdrU2IzZDFXelYxRXlweE1CeHVvclZBVDl0enRXYmx6eSsva1lXQ0pvcTd0Q0RJMnRmZnZFeTNpZWY3NzMvMlh6LzhtLytCRXJjRWtwOENLbmNQd29mWURCRk1HeklOQ1Q5RlpSLzZaM0NEaUlKd0JMQ0hUeWFpTE9SblJJUDgrVG1MZ2FOQ1VBeWxvWEl5VnNGbVRlNGU1MlRtV0N4T2VUc1FwS1FzKzdzOHBCamZ1U3gvaG0vR2ZXZ09VajNzUTNKRzZ4RXRISFQzOWs2YVM4ZHpBbDh1S1FsZlZNU3Q1N2ovK3VVZk1KQmYzdzNTVk92UFBidW1ROE81bzNsRVArRFkzZDMxeC9US3F3OHFGVHNJdzk3ZEhWVHAwZm1wWGpLNUhkUlFYRzQycEtJRXF1M1Nyc0o4UUQ5VmpzVWl2ZmdYU3c5b08xb0FkZmpGSngvQmpoUUxzWTdCNXZtS2JVcWlmRGNleWFZQ2JJMm5TOGdUTjJ5Ym5DcHVCd3R3R2ZZcVRPb3V0b3Vxb3RScTllbDRLZ283Tk9QNjZ0cWdCNVg5YXNONjlmVjMwOGtTbldhV3kvdm5KK3MwSFU2bVlSQ2NQenVienFhd1JLSE9XKzFLNTZEUjdUWjEzYkxMcGNQajF1WHJ0MUNURjZkSHA4ZUhxcUlkSFIxRVVmTDk2MHNvMFV5YkFyam9XSGd3WVlvU2ZlMktJTmlqYVpycE5nVUx4M1MyN1VxeGlQWUg3SHN1Y3VBd0tqM1hGWUs2STBnY2hqMVJnNkhHMG81MVQ1R0twNmNuSEM5R213VEZzdmRYSmtXT0cvV0hkcms2bkMzQ2xTZUl2R0xxUG1qOU5tbTEybU5uS1NxS0d3Ym5wNGR6WjRVV3Z2anRmMnU4L3hFcUlDaGtFSGpuRU01RVJDMllraWNKUnpZdDRaQmhqa2tvVlphU3NNNmdobUNHSURqbXh6L0xuRG1XaHNHZkl2TFlCNWRGc3VPUDVLeVVQQVE5alNCS2U0ek5YSGFQRTBtekdQclBXd2N2UHVSRjMyY3h6TEhmdTFLUXdNMGtqeDdtd09KLy90NkpPM0JIeStYRjA4NTlmK1g2cmxiWWpWZStMTW03ZExmZmJqMzU0S3hhcnM5dmVsOTkvVkl5MUFEcTJ2ZTFvdFJxTjZEWFZ5djM1czFWR0s3dnhzTzE1K21HcUpnYXg0bXZYbjJmN01CWXR4elcvZEVFMVlLMDBNc2pxYXUzWjUxMjltdWR2Yks2Q1QwMHNsMjJCbzY3aG5HSE5oVjRtSjhWdzFCVnBWUXFWVXJtYWdtOUdnVmJ2a2p2b1UvWDY3UmtHWU83SGk4V29qZ3AyOVo4TnZZOGYrbjQ3c0s1SDQ0MTJJOUpvV1NYaTZwbUdzWWNISDlFMzhURHlKWkVmclYwMDhLMmZ6OWNKOEZ5NVlFNFdaYUJ5Zm5keSsrQnZvdG5QN09yWlFjTVR4S2dtNkhKcDdNRnlCSUFBU3JDK0lnQXd3TzlCMVdmZlUwTGdBRnRBREhzWUZqZ004ZkJqQUpMd1FWbVpCMVJTVUsvTnllekN0Mk9EcUppeENKOUxjWnY0bGpUOWNQakk5Q3c0KzVlbU1UandiQlRxNGQrMkdvM2VWMFRSS25WcWtORG9vZURhTjNhNzhBbUJ3Mkx0M0haTUFSK0M3UGJDOWIvK2UvL29kUTlRSHZRenhrWVVSSE9WR1VHQXVaaE00NWhoYzZVTGt0TGZvQUZPZklFTkZTWko0YzZIRUh6SWZxZEJDN2JPWVBDZEhpTS9hbDdoSGhlSUNzc2d6c0VEM1ZranRxZU5ZODVTa2x6TXN1WGhSOXFlU3dXRGo0S1VNTEh2QSt1VVBqLzEwNFpEUVJydG5vQUFBQUFTVVZPUks1Q1lJST1cIjsiLCJpbXBvcnQgeyBRdWV1ZSB9IGZyb20gXCIuL1F1ZXVlXCI7XHJcbmltcG9ydCB7IFJhdGlvbmFsTnVtYmVyIH0gZnJvbSBcIi4vUmF0aW9uYWxOdW1iZXJcIjtcclxuaW1wb3J0IHsgU3RhY2sgfSBmcm9tIFwiLi9TdGFja1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFyaXRobWV0aWNFdmFsdWF0b3Ige1xyXG5cdHB1YmxpYyBzdGF0aWMgdG9SZXZlcnNlUG9saXNoTm90YXRpb24oY29kZTogc3RyaW5nKTogc3RyaW5nW10ge1xyXG5cdFx0Y29uc3QgdG9rZW5zOiBzdHJpbmdbXSA9IGNvZGUubWF0Y2goL1xcKHxcXCl8XFxkKyhcXC5cXGQrKT98XFx3K3xbXFwrXFwtXFwqXFwvXFxeXS9nKTtcclxuXHRcdGxldCBpOiBudW1iZXIgPSAwO1xyXG5cdFx0Y29uc3Qgb3V0cHV0UXVldWU6IFF1ZXVlPHN0cmluZz4gPSBuZXcgUXVldWU8c3RyaW5nPigpO1xyXG5cdFx0Y29uc3Qgb3BlcmF0b3JTdGFjazogU3RhY2s8c3RyaW5nPiA9IG5ldyBTdGFjazxzdHJpbmc+KCk7XHJcblx0XHR3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHtcclxuXHRcdFx0aWYgKHRoaXMuaXNOdW1iZXIodG9rZW5zW2ldKSkge1xyXG5cdFx0XHRcdG91dHB1dFF1ZXVlLmVucXVldWUodG9rZW5zW2ldKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmlzT3BlcmF0b3IodG9rZW5zW2ldKSkge1xyXG5cdFx0XHRcdGxldCBvcDE6IHN0cmluZyA9IHRva2Vuc1tpXTtcclxuXHRcdFx0XHR3aGlsZSAoIW9wZXJhdG9yU3RhY2suaXNFbXB0eSgpICYmIHRoaXMuaXNPcGVyYXRvcihvcGVyYXRvclN0YWNrLnBlZWsoKSkpIHtcclxuXHRcdFx0XHRcdGlmICgodGhpcy5pc0xlZnRBc3NvY2lhdGl2ZU9wZXJhdG9yKG9wMSkgJiYgKHRoaXMucHJlY2VkZW5jZShvcDEpIDw9IHRoaXMucHJlY2VkZW5jZShvcGVyYXRvclN0YWNrLnBlZWsoKSkpKSB8fFxyXG5cdFx0XHRcdFx0XHQodGhpcy5pc1JpZ2h0QXNzb2NpYXRpdmVPcGVyYXRvcihvcDEpICYmICh0aGlzLnByZWNlZGVuY2Uob3AxKSA8IHRoaXMucHJlY2VkZW5jZShvcGVyYXRvclN0YWNrLnBlZWsoKSkpKSkge1xyXG5cdFx0XHRcdFx0XHRvdXRwdXRRdWV1ZS5lbnF1ZXVlKG9wZXJhdG9yU3RhY2sucG9wKCkpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG9wZXJhdG9yU3RhY2sucHVzaChvcDEpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2Vuc1tpXSA9PT0gXCIoXCIpIHtcclxuXHRcdFx0XHRvcGVyYXRvclN0YWNrLnB1c2godG9rZW5zW2ldKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0b2tlbnNbaV0gPT09IFwiKVwiKSB7XHJcblx0XHRcdFx0d2hpbGUgKCFvcGVyYXRvclN0YWNrLmlzRW1wdHkoKSAmJiBvcGVyYXRvclN0YWNrLnBlZWsoKSAhPT0gXCIoXCIpIHtcclxuXHRcdFx0XHRcdG91dHB1dFF1ZXVlLmVucXVldWUob3BlcmF0b3JTdGFjay5wb3AoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghb3BlcmF0b3JTdGFjay5pc0VtcHR5KCkgJiYgb3BlcmF0b3JTdGFjay5wZWVrKCkgPT09IFwiKFwiKSB7XHJcblx0XHRcdFx0XHRvcGVyYXRvclN0YWNrLnBvcCgpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIHBhcmVudGhlc2VzLlwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aSsrO1xyXG5cdFx0fVxyXG5cdFx0d2hpbGUgKCFvcGVyYXRvclN0YWNrLmlzRW1wdHkoKSkge1xyXG5cdFx0XHRpZiAob3BlcmF0b3JTdGFjay5wZWVrKCkgPT09IFwiKFwiKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBwYXJlbnRoZXNlcy5cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3V0cHV0UXVldWUuZW5xdWV1ZShvcGVyYXRvclN0YWNrLnBvcCgpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG91dHB1dFF1ZXVlLnRvQXJyYXkoKTtcclxuXHR9XHJcblx0cHVibGljIHN0YXRpYyBldmFsdWF0ZUZyb21SUE4odG9rZW5zOiBzdHJpbmdbXSk6IG51bWJlciB7XHJcblx0XHRjb25zdCBzdGFjazogU3RhY2s8bnVtYmVyPiA9IG5ldyBTdGFjazxudW1iZXI+KCk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICghdGhpcy5pc09wZXJhdG9yKHRva2Vuc1tpXSkpIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKHBhcnNlRmxvYXQodG9rZW5zW2ldKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IG9wMTogbnVtYmVyID0gc3RhY2sucG9wKCk7XHJcblx0XHRcdFx0bGV0IG9wMjogbnVtYmVyID0gc3RhY2sucG9wKCk7XHJcblx0XHRcdFx0c3dpdGNoICh0b2tlbnNbaV0pIHtcclxuXHRcdFx0XHRcdGNhc2UgXCIrXCI6IHN0YWNrLnB1c2gob3AyICsgb3AxKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIFwiLVwiOiBzdGFjay5wdXNoKG9wMiAtIG9wMSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBcIipcIjogc3RhY2sucHVzaChvcDIgKiBvcDEpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgXCIvXCI6IHN0YWNrLnB1c2gob3AyIC8gb3AxKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIFwiXlwiOiBzdGFjay5wdXNoKG9wMiAqKiBvcDEpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBzdGFjay5wb3AoKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgaXNOdW1iZXIoY29kZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gL15cXGQvLnRlc3QoY29kZSk7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIGlzT3BlcmF0b3IoY29kZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gL1tcXCtcXC1cXCpcXC9cXF5dLy50ZXN0KGNvZGUpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBpc0xlZnRBc3NvY2lhdGl2ZU9wZXJhdG9yKG9wZXJhdG9yOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAvW1xcK1xcLVxcKlxcL10vLnRlc3Qob3BlcmF0b3IpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBpc1JpZ2h0QXNzb2NpYXRpdmVPcGVyYXRvcihvcGVyYXRvcjogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gL1tcXF5dLy50ZXN0KG9wZXJhdG9yKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgcHJlY2VkZW5jZShvcGVyYXRvcjogc3RyaW5nKTogbnVtYmVyIHtcclxuXHRcdGlmICgvW1xcK1xcLV0vLnRlc3Qob3BlcmF0b3IpKSB7XHJcblx0XHRcdCByZXR1cm4gMTtcclxuXHRcdH1cclxuXHRcdGlmICgvW1xcKlxcL10vLnRlc3Qob3BlcmF0b3IpKSB7XHJcblx0XHRcdCByZXR1cm4gMjtcclxuXHRcdH1cclxuXHRcdGlmICgvW1xcXl0vLnRlc3Qob3BlcmF0b3IpKSB7XHJcblx0XHRcdCByZXR1cm4gMztcclxuXHRcdH1cclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IuXCIpO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGVudW0gVG9rZW5UeXBlIHsgUGx1cywgTWludXMsIE11bHRpcGx5LCBEaXZpZGUsIEV4cG9uZW50LCBOdW1iZXIsIExQYXJlbiwgUlBhcmVuLCBFbmQsIFVua25vd24gfVxyXG5leHBvcnQgY2xhc3MgVG9rZW4ge1xyXG5cdHB1YmxpYyB0eXBlOiBUb2tlblR5cGU7XHJcblx0cHVibGljIHZhbHVlOiBudW1iZXI7XHJcblx0Y29uc3RydWN0b3IodHlwZTogVG9rZW5UeXBlLCB2YWx1ZT86IG51bWJlcikge1xyXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcclxuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHR9XHJcbn1cclxuZXhwb3J0IGNsYXNzIExleGVyIHtcclxuXHRwcml2YXRlIHRva2Vuczogc3RyaW5nW107XHJcblx0cHJpdmF0ZSB0b2tlbkluZGV4OiBudW1iZXI7XHJcblx0Y29uc3RydWN0b3IoaW5wdXQ6IHN0cmluZykge1xyXG5cdFx0dGhpcy50b2tlbnMgPSBpbnB1dC5yZXBsYWNlKFwiIFwiLCBcIlwiKS5tYXRjaCgvXFwofFxcKXxcXGQrKFxcLlxcZCspP3xbXFwrXFwtXFwqXFwvXFxeXS9nKTtcclxuXHRcdHRoaXMudG9rZW5JbmRleCA9IDA7XHJcblx0fVxyXG5cdHB1YmxpYyBnZXROZXh0VG9rZW4oKTogVG9rZW4ge1xyXG5cdFx0aWYgKHRoaXMudG9rZW5zLmxlbmd0aCA9PT0gdGhpcy50b2tlbkluZGV4KSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLkVuZCk7XHJcblx0XHR9XHJcblx0XHRsZXQgaW5wdXQ6IHN0cmluZyA9IHRoaXMudG9rZW5zW3RoaXMudG9rZW5JbmRleCsrXTtcclxuXHRcdHJldHVybiB0aGlzLmdldFRva2VuKGlucHV0KTtcclxuXHR9XHJcblx0cHVibGljIGdldEN1cnJlbnRUb2tlbigpOiBUb2tlbiB7XHJcblx0XHRpZiAodGhpcy50b2tlbnMubGVuZ3RoIC0gMSA9PT0gdGhpcy50b2tlbkluZGV4KSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLkVuZCk7XHJcblx0XHR9XHJcblx0XHRsZXQgaW5wdXQ6IHN0cmluZyA9IHRoaXMudG9rZW5zW3RoaXMudG9rZW5JbmRleF07XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRUb2tlbihpbnB1dCk7XHJcblx0fVxyXG5cdHB1YmxpYyByZXZlcnQoKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy50b2tlbkluZGV4IDw9IDApIHsgdGhyb3cgRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7IH1cclxuXHRcdHRoaXMudG9rZW5JbmRleC0tO1xyXG5cdH1cclxuXHRwcml2YXRlIGdldFRva2VuKGlucHV0OiBzdHJpbmcpOiBUb2tlbiB7XHJcblx0XHRpZiAoL1xcKy8udGVzdChpbnB1dCkpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuUGx1cyk7XHJcblx0XHR9XHJcblx0XHRpZiAoL1xcLS8udGVzdChpbnB1dCkpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuTWludXMpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9cXCovLnRlc3QoaW5wdXQpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLk11bHRpcGx5KTtcclxuXHRcdH1cclxuXHRcdGlmICgvXFwvLy50ZXN0KGlucHV0KSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRva2VuKFRva2VuVHlwZS5EaXZpZGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9cXF4vLnRlc3QoaW5wdXQpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLkV4cG9uZW50KTtcclxuXHRcdH1cclxuXHRcdGlmICgvXFxkKyhcXC5cXGQrKT8vLnRlc3QoaW5wdXQpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLk51bWJlciwgcGFyc2VGbG9hdChpbnB1dCkpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9cXCgvLnRlc3QoaW5wdXQpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLkxQYXJlbik7XHJcblx0XHR9XHJcblx0XHRpZiAoL1xcKS8udGVzdChpbnB1dCkpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuUlBhcmVuKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLlVua25vd24pO1xyXG5cdH1cclxufVxyXG5leHBvcnQgY2xhc3MgUGFyc2VyIHtcclxuXHRwcml2YXRlIGxleDogTGV4ZXI7XHJcblx0cHVibGljIHBhcnNlKGNvZGU6IHN0cmluZyk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdHRoaXMubGV4ID0gbmV3IExleGVyKGNvZGUpO1xyXG5cdFx0Y29uc3QgZXhwcmVzc2lvbjogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLmZvdXJ0aE9yZGVyT3BlcmF0b3JzKCk7XHJcblx0XHRjb25zdCB0b2tlbjogVG9rZW4gPSB0aGlzLmxleC5nZXRDdXJyZW50VG9rZW4oKTsgLy8gaXMgYWxyZWFkeSBhZHZhbmNlZCBiZWNhdXNlIG9mIG51bWJlcigpXHJcblx0XHRpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLkVuZCkge1xyXG5cdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcclxuXHRcdH1cclxuXHRcdHRocm93IEVycm9yKFwiRW5kIGV4cGVjdGVkXCIpO1xyXG5cdH1cclxuXHQvLyBhZGRpdGlvbiBhbmQgc3Vic3RyYWN0aW9uXHJcblx0cHJpdmF0ZSBmb3VydGhPcmRlck9wZXJhdG9ycygpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRsZXQgY29tcG9uZW50MTogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLnRoaXJkT3JkZXJPcGVyYXRvcnMoKTtcclxuXHRcdGxldCB0b2tlbjogVG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdHdoaWxlICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuUGx1cyB8fCB0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTWludXMpIHtcclxuXHRcdFx0bGV0IGNvbXBvbmVudDI6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy50aGlyZE9yZGVyT3BlcmF0b3JzKCk7XHJcblx0XHRcdGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuUGx1cykge1xyXG5cdFx0XHRcdGNvbXBvbmVudDEgPSBjb21wb25lbnQxLmFkZChjb21wb25lbnQyKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTWludXMpIHtcclxuXHRcdFx0XHRjb21wb25lbnQxID0gY29tcG9uZW50MS5zdWIoY29tcG9uZW50Mik7XHJcblx0XHRcdH1cclxuXHRcdFx0dG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdH1cclxuXHRcdHRoaXMubGV4LnJldmVydCgpO1xyXG5cdFx0cmV0dXJuIGNvbXBvbmVudDE7XHJcblx0fVxyXG5cdC8vIG11bHRpcGxpY2F0aW9uIGFuZCBkaXZpc2lvblxyXG5cdHByaXZhdGUgdGhpcmRPcmRlck9wZXJhdG9ycygpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRsZXQgZmFjdG9yMTogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLnNlY29uZE9yZGVyT3BlcmF0b3JzKCk7XHJcblx0XHRsZXQgdG9rZW46IFRva2VuID0gdGhpcy5sZXguZ2V0TmV4dFRva2VuKCk7XHJcblx0XHR3aGlsZSAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk11bHRpcGx5IHx8IHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5EaXZpZGUpIHtcclxuXHRcdFx0bGV0IGZhY3RvcjI6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5zZWNvbmRPcmRlck9wZXJhdG9ycygpO1xyXG5cdFx0XHRpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk11bHRpcGx5KSB7XHJcblx0XHRcdFx0ZmFjdG9yMSA9IGZhY3RvcjEubXVsdChmYWN0b3IyKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuRGl2aWRlKSB7XHJcblx0XHRcdFx0ZmFjdG9yMSA9IGZhY3RvcjEuZGl2KGZhY3RvcjIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRva2VuID0gdGhpcy5sZXguZ2V0TmV4dFRva2VuKCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmxleC5yZXZlcnQoKTtcclxuXHRcdHJldHVybiBmYWN0b3IxO1xyXG5cdH1cclxuXHQvLyBleHBvbmVudHMgYW5kIHJvb3RzXHJcblx0cHJpdmF0ZSBzZWNvbmRPcmRlck9wZXJhdG9ycygpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRsZXQgZmFjdG9yMTogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLmZpcnN0T3JkZXJPcGVyYXRvcnMoKTtcclxuXHRcdGxldCB0b2tlbjogVG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdHdoaWxlICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuRXhwb25lbnQpIHtcclxuXHRcdFx0bGV0IGZhY3RvcjI6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5maXJzdE9yZGVyT3BlcmF0b3JzKCk7XHJcblx0XHRcdGZhY3RvcjEgPSBmYWN0b3IxLmV4cChmYWN0b3IyKTtcclxuXHRcdFx0dG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdH1cclxuXHRcdHRoaXMubGV4LnJldmVydCgpO1xyXG5cdFx0cmV0dXJuIGZhY3RvcjE7XHJcblx0fVxyXG5cdC8vIG51bWJlcnMgYW5kIHBhcmFudGhlc2VzXHJcblx0cHJpdmF0ZSBmaXJzdE9yZGVyT3BlcmF0b3JzKCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGxldCB2YWx1ZTogUmF0aW9uYWxOdW1iZXIgPSBuZXcgUmF0aW9uYWxOdW1iZXIoMSk7XHJcblx0XHRsZXQgdG9rZW46IFRva2VuID0gdGhpcy5sZXguZ2V0TmV4dFRva2VuKCk7XHJcblx0XHRpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLlBsdXMgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk1pbnVzKSB7XHJcblx0XHRcdGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTWludXMpIHtcclxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLm11bHQoLTEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRva2VuID0gdGhpcy5sZXguZ2V0TmV4dFRva2VuKCk7XHJcblx0XHR9XHJcblx0XHRpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLkxQYXJlbikge1xyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLm11bHQodGhpcy5mb3VydGhPcmRlck9wZXJhdG9ycygpKTtcclxuXHRcdFx0dG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdFx0aWYgKHRva2VuLnR5cGUgIT09IFRva2VuVHlwZS5SUGFyZW4pIHtcclxuXHRcdFx0XHR0aHJvdyBFcnJvcihcIlVuYmFsYW5jZWQgcGFyZW50aGVzaXNcIik7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTnVtYmVyKSB7XHJcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5tdWx0KHRva2VuLnZhbHVlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBFcnJvcihcIk5vdCBhIG51bWJlclwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH1cclxufVxyXG5cclxuLypcclxuXHRwdWJsaWMgc3RhdGljIGV2YWx1YXRlKGV4cHJlc2lvbjogc3RyaW5nKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdHZhciBkaWdpdFBhdHRlcm4gPSBuZXcgUmVnRXhwKCcwIHwgMSB8IDIgfCAzIHwgNCB8IDUgfCA2IHwgNyB8IDggfCA5Jyk7XHJcblx0dmFyIHNpZ25QYXR0ZXJuID0gbmV3IFJlZ0V4cCgnXFwrfFxcLScpO1xyXG5cdHZhciBudW1iZXJQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnWycgKyBzaWduUGF0dGVybiArICddJyArICd7JyArIGRpZ2l0UGF0dGVybiArICd9Jyk7XHJcblx0dmFyIGZhY3RvclBhdHRlcm4gPSBuZXcgUmVnRXhwKG51bWJlclBhdHRlcm4gKyAnfFxcKCcgKyBleHByZXNzaW9uUGF0dGVybiArICdcXCknKTtcclxuXHR2YXIgY29tcG9uZW50UGF0dGVybiA9IG5ldyBSZWdFeHAoZmFjdG9yUGF0dGVybiArICdbeyggXFwqIHwgXFwvICknICsgZmFjdG9yUGF0dGVybiArICd9XScpO1xyXG5cdHZhciBleHByZXNzaW9uUGF0dGVybiA9IG5ldyBSZWdFeHAoY29tcG9uZW50UGF0dGVybiArICdbeyggXFwrIHwgXFwtKScgKyBjb21wb25lbnRQYXR0ZXJuICsgJ31dJyk7XHJcbn0qL1xyXG5cclxuLypcclxuZXhwcnI6IDR0aE9SREVSKztcclxuNHRoT1JERVI6IGNvbXBvbmVudDE9M3JkT1JERVIgKChQTFVTfE1JTlVTKSBjb21wb25lbnQyPTNyZE9SREVSKSs7XHJcbjNyZE9SREVSOiBmYWN0b3IxPTJORE9SREVSICgoTVVMVElQTFl8RElWSURFKSBmYWN0b3IxPTJuZE9SREVSKStcclxuMm5kT1JERVI6IGZhY3RvcjE9MXN0T1JERVIgKEVYUE9ORU5UIGZhY3RvcjI9MXN0T1JERVIpK1xyXG4xc3RPUkRFUjogKFBMVVN8TUlOVVN8ZW1wdHkpIChMUEFSRU4gdmFsdWU9NHRoT1JERVIgUlBBUkVOfCBOVU1CRVIpXHJcbiovIiwiaW1wb3J0IHsgUmF0aW9uYWxOdW1iZXIgfSBmcm9tIFwiLi9SYXRpb25hbE51bWJlclwiO1xyXG5pbXBvcnQgeyBDb2x1bW5WZWN0b3IsIFZlY3RvciB9IGZyb20gXCIuL1ZlY3RvclwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIE1hdHJpeCB7XHJcblx0cHVibGljIHN0YXRpYyBhdWdtZW50KEE6IE1hdHJpeCwgQjogTWF0cml4IHwgVmVjdG9yKTogTWF0cml4IHtcclxuXHRcdGlmIChBLm0gIT09IEIubSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdHdvIG1hdHJpY2VzICh2ZWN0b3IpIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygcm93cyAoZWxlbWVudHMpLlwiKTsgfVxyXG5cdFx0bGV0IHJldDogTWF0cml4ID0gbnVsbDtcclxuXHRcdGlmIChCIGluc3RhbmNlb2YgTWF0cml4KSB7XHJcblx0XHRcdHJldCA9IG5ldyBNYXRyaXgoQS5tLCBCLm4gKyBBLm4pO1xyXG5cdFx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgQS5tOyBpKyspIHtcclxuXHRcdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgQS5uOyBqKyspIHtcclxuXHRcdFx0XHRcdHJldC5lbGVtZW50c1tpXVtqXSA9IEEuZWxlbWVudHNbaV1bal07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBCLm07IGkrKykge1xyXG5cdFx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBCLm47IGorKykge1xyXG5cdFx0XHRcdFx0cmV0LmVsZW1lbnRzW2ldW0EubiArIGpdID0gQi5lbGVtZW50c1tpXVtqXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChCIGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcblx0XHRcdFx0cmV0ID0gbmV3IE1hdHJpeChBLm0sIEEubiArIDEpO1xyXG5cdFx0XHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBBLm07IGkrKykge1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IEEubjsgaisrKSB7XHJcblx0XHRcdFx0XHRcdHJldC5lbGVtZW50c1tpXVtqXSA9IEEuZWxlbWVudHNbaV1bal07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBCLm07IGorKykge1xyXG5cdFx0XHRcdFx0cmV0LmVsZW1lbnRzW2pdW0Eubl0gPSBCLmVsZW1lbnRzW2pdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9XHJcblx0Ly8gcm93LW11bHRpcGx5aW5nIHRyYW5zZm9ybWF0aW9uc1xyXG5cdHB1YmxpYyBzdGF0aWMgbXVsdGlwbGljYXRpb24objogbnVtYmVyLCByb3cxOiBudW1iZXIsIHJvdzI6IG51bWJlciwgbXVsdDogbnVtYmVyKTogTWF0cml4IHtcclxuXHRcdGlmIChuIDwgcm93MSB8fCBuIDwgcm93MikgeyB0aHJvdyBuZXcgRXJyb3IoXCJDb2x1bW4gaW5kZXggbXVzdCBiZSBsZXNzIG9yIGVxdWFsdCB0aGFuIG1hdHJpeCBzaXplLlwiKTsgfVxyXG5cdFx0Y29uc3QgbWF0cml4OiBNYXRyaXggPSBuZXcgTWF0cml4SWRlbnRpdHkobik7XHJcblx0XHRtYXRyaXguZWxlbWVudHNbcm93MV1bcm93Ml0gPSBuZXcgUmF0aW9uYWxOdW1iZXIobXVsdCk7XHJcblx0XHRyZXR1cm4gbWF0cml4O1xyXG5cdH1cclxuXHRwdWJsaWMgc3RhdGljIHJhbmRvbVNxdWFyZSgpOiBNYXRyaXgge1xyXG5cdFx0Y29uc3QgbWF0cml4OiBNYXRyaXggPSBuZXcgTWF0cml4KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpICsgMywgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCkgKyAzKTsgLy8gbWluaW11bSBzaXplIDN4MyBtYXRyaXhcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBtYXRyaXgubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBtYXRyaXgubjsgaisrKSB7XHJcblx0XHRcdFx0bWF0cml4LmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCAtIDUwKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBtYXRyaXg7XHJcblx0fVxyXG5cdHB1YmxpYyBzdGF0aWMgcmFuZG9tMigpOiBNYXRyaXgge1xyXG5cdFx0Y29uc3QgbnVtYmVyT2ZVbmtub3duczogbnVtYmVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCArIDMpOyAvLyBiZXR3ZWVuIDMgYW5kIDcgdW5rbm9ud3NcclxuXHRcdGNvbnN0IHVua25vd25zOiBudW1iZXJbXSA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IG51bWJlck9mVW5rbm93bnM7IGkrKykge1xyXG5cdFx0XHR1bmtub3duc1tpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwIC0gMTApO1xyXG5cdFx0fVxyXG5cdFx0Ly8gdG9kbzogY2hhbmdlIGJlbG93XHJcblx0XHRjb25zdCBtYXRyaXg6IE1hdHJpeCA9IG5ldyBNYXRyaXgoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCkgKyAzLCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KSArIDMpO1xyXG5cdFx0cmV0dXJuIG1hdHJpeDtcclxuXHR9XHJcblx0cHVibGljIG06IG51bWJlcjsgLy8gcm93c1xyXG5cdHB1YmxpYyBuOiBudW1iZXI7IC8vIGNvbHVtbnNcclxuXHRwdWJsaWMgZWxlbWVudHM6IFJhdGlvbmFsTnVtYmVyW11bXTtcclxuXHRjb25zdHJ1Y3RvcihtOiBudW1iZXIsIG46IG51bWJlcikge1xyXG5cdFx0dGhpcy5tID0gbTtcclxuXHRcdHRoaXMubiA9IG47XHJcblx0XHR0aGlzLmVsZW1lbnRzID0gW107XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50c1tpXSA9IFtdO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgZXF1YWxzKE06IE1hdHJpeCk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKHRoaXMubSAhPT0gTS5tIHx8IHRoaXMubiAhPT0gTS5uKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbaV1bal0uZXF1YWxzKE0uZWxlbWVudHNbaV1bal0pKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0cHVibGljIGFkZCh4OiBNYXRyaXgpOiBNYXRyaXgge1xyXG5cdFx0aWYgKHRoaXMubSAhPT0geC5tIHx8IHRoaXMubiAhPT0geC5uKSB7IHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgZGltZW5zaW9ucy5cIik7IH1cclxuXHRcdGNvbnN0IHJlczogTWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLm0sIHRoaXMubik7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgcmVzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgcmVzLm47IGorKykge1xyXG5cdFx0XHRcdHJlcy5lbGVtZW50c1tpXVtqXSA9IHRoaXMuZWxlbWVudHNbaV1bal0uYWRkKHguZWxlbWVudHNbaV1bal0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHRwdWJsaWMgc3ViKHg6IE1hdHJpeCk6IE1hdHJpeCB7XHJcblx0XHRpZiAodGhpcy5tICE9PSB4Lm0gfHwgdGhpcy5uICE9PSB4Lm4pIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBkaW1lbnNpb25zLlwiKTsgfVxyXG5cdFx0Y29uc3QgcmVzOiBNYXRyaXggPSBuZXcgTWF0cml4KHRoaXMubSwgdGhpcy5uKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCByZXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCByZXMubjsgaisrKSB7XHJcblx0XHRcdFx0cmVzLmVsZW1lbnRzW2ldW2pdID0gdGhpcy5lbGVtZW50c1tpXVtqXS5zdWIoeC5lbGVtZW50c1tpXVtqXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cdHB1YmxpYyBtdWx0KHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyIHwgTWF0cml4KTogTWF0cml4IHtcclxuXHRcdGxldCByZXM6IE1hdHJpeCA9IG51bGw7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmVzID0gbmV3IE1hdHJpeCh0aGlzLm0sIHRoaXMubik7XHJcblx0XHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCByZXMubTsgaSsrKSB7XHJcblx0XHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHJlcy5uOyBqKyspIHtcclxuXHRcdFx0XHRcdHJlcy5lbGVtZW50c1tpXVtqXSA9IHRoaXMuZWxlbWVudHNbaV1bal0ubXVsdCh4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoeCBpbnN0YW5jZW9mIFJhdGlvbmFsTnVtYmVyKSB7XHJcblx0XHRcdHJlcyA9IG5ldyBNYXRyaXgodGhpcy5tLCB0aGlzLm4pO1xyXG5cdFx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgcmVzLm07IGkrKykge1xyXG5cdFx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCByZXMubjsgaisrKSB7XHJcblx0XHRcdFx0XHRyZXMuZWxlbWVudHNbaV1bal0gPSB0aGlzLmVsZW1lbnRzW2ldW2pdLm11bHQoeCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoeCBpbnN0YW5jZW9mIE1hdHJpeCkge1xyXG5cdFx0XHRcdGlmICh0aGlzLm4gIT09IHgubSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGRpbWVuc2lvbnMuXCIpOyB9XHJcblx0XHRcdFx0cmVzID0gbmV3IE1hdHJpeCh0aGlzLm0sIHgubik7XHJcblx0XHRcdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHJlcy5tOyBpKyspIHtcclxuXHRcdFx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCByZXMubjsgaisrKSB7XHJcblx0XHRcdFx0XHRcdGxldCBzdW06IFJhdGlvbmFsTnVtYmVyID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBrOiBudW1iZXIgPSAwOyBrIDwgdGhpcy5uOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRzdW0gPSBzdW0uYWRkKHRoaXMuZWxlbWVudHNbaV1ba10ubXVsdCh4LmVsZW1lbnRzW2tdW2pdKSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cmVzLmVsZW1lbnRzW2ldW2pdID0gc3VtO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblx0cHVibGljIHZlY3RvclByb2R1Y3QodjogQ29sdW1uVmVjdG9yKTogQ29sdW1uVmVjdG9yIHtcclxuXHRcdGlmICh0aGlzLm4gIT09IHYubSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGRpbWVuc2lvbnMuXCIpOyB9XHJcblx0XHRjb25zdCByZXM6IENvbHVtblZlY3RvciA9IG5ldyBDb2x1bW5WZWN0b3Iodi5tKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRsZXQgc3VtOiBSYXRpb25hbE51bWJlciA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdFx0c3VtID0gc3VtLmFkZCh0aGlzLmVsZW1lbnRzW2ldW2pdLm11bHQodi5lbGVtZW50c1tqXSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJlcy5lbGVtZW50c1tpXSA9IHN1bTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cdHB1YmxpYyB0cmFuc3Bvc2UoKTogTWF0cml4IHtcclxuXHRcdGNvbnN0IHJldDogTWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLm4sIHRoaXMubSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdFx0cmV0LmVsZW1lbnRzW2pdW2ldID0gdGhpcy5lbGVtZW50c1tpXVtqXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9XHJcblx0cHVibGljIGRlZXBDb3B5KCk6IE1hdHJpeCB7XHJcblx0XHRjb25zdCByZXQ6IE1hdHJpeCA9IG5ldyBNYXRyaXgodGhpcy5tLCB0aGlzLm4pO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm47IGorKykge1xyXG5cdFx0XHRcdHJldC5lbGVtZW50c1tpXVtqXSA9IHRoaXMuZWxlbWVudHNbaV1bal07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG5cdHB1YmxpYyBzd2l0Y2hSb3dzKGlkeDE6IG51bWJlciwgaWR4MjogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5tIDwgaWR4MSB8fCB0aGlzLm0gPCBpZHgyKSB7IHJldHVybjsgfVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubjsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IHRtcDogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLmVsZW1lbnRzW2lkeDFdW2ldO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzW2lkeDFdW2ldID0gdGhpcy5lbGVtZW50c1tpZHgyXVtpXTtcclxuXHRcdFx0dGhpcy5lbGVtZW50c1tpZHgyXVtpXSA9IHRtcDtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIG11bHRpcGx5Um93KGlkeDogbnVtYmVyLCBzY2FsYXI6IFJhdGlvbmFsTnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5tIDwgaWR4KSB7IHJldHVybjsgfVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbaWR4XVtpXSA9IHRoaXMuZWxlbWVudHNbaWR4XVtpXS5tdWx0KHNjYWxhcikuc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGFkZFJvd3MoaWR4MTogbnVtYmVyLCBpZHgyOiBudW1iZXIsIHNjYWxhcjogUmF0aW9uYWxOdW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLm0gPCBpZHgxIHx8IHRoaXMubSA8IGlkeDIpIHsgcmV0dXJuOyB9XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5uOyBpKyspIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50c1tpZHgxXVtpXSA9IHRoaXMuZWxlbWVudHNbaWR4Ml1baV0ubXVsdChzY2FsYXIpLmFkZCh0aGlzLmVsZW1lbnRzW2lkeDFdW2ldKS5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgYWRkUm93MVRvUm93MihpZHgxOiBudW1iZXIsIHNjYWxhcjE6IFJhdGlvbmFsTnVtYmVyLCBpZHgyOiBudW1iZXIsIHNjYWxhcjI6IFJhdGlvbmFsTnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5tIDwgaWR4MSB8fCB0aGlzLm0gPCBpZHgyKSB7IHJldHVybjsgfVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbaWR4Ml1baV0gPSB0aGlzLmVsZW1lbnRzW2lkeDJdW2ldLm11bHQoc2NhbGFyMikuYWRkKHRoaXMuZWxlbWVudHNbaWR4MV1baV0ubXVsdChzY2FsYXIxKSkuc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gYSBzcXVhcmUgbWF0cml4IGlzIGEgbWF0cml4IHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnNcclxuXHRwdWJsaWMgaXNTcXVhcmUoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5tID09PSB0aGlzLm47XHJcblx0fVxyXG5cdC8vIGEgZGlhZ29uYWwgbWF0cml4IGlzIGEgbWF0cml4IGluIHdoaWNoIHRoZSBlbnRyaWVzIG91dHNpZGUgdGhlIG1haW4gZGlhZ29uYWwgYXJlIGFsbCB6ZXJvXHJcblx0cHVibGljIGlzRGlhZ29uYWwoKTogYm9vbGVhbiB7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGkgPT09IGopIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbaV1bal0uZXF1YWxzKG5ldyBSYXRpb25hbE51bWJlcigwKSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHQvLyB0aGUgaWRlbnRpdHkgbWF0cml4IG9mIHNpemUgbiBpcyB0aGUgbiDDlyBuIHNxdWFyZSBtYXRyaXggd2l0aCBvbmVzIG9uIHRoZSBtYWluIGRpYWdvbmFsIGFuZCB6ZXJvcyBlbHNld2hlcmVcclxuXHQvLyBbQUxJQVNFU106IHVuaXQgbWF0cml4XHJcblx0cHVibGljIGlzSWRlbnRpdHkoKTogYm9vbGVhbiB7XHJcblx0XHRpZiAodGhpcy5tICE9PSB0aGlzLm4pIHsgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgc3F1YXJlIG1hdHJpeC5cIik7IH1cclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoaSA9PT0gaikge1xyXG5cdFx0XHRcdFx0aWYgKCF0aGlzLmVsZW1lbnRzW2ldW2pdLmVxdWFscyhuZXcgUmF0aW9uYWxOdW1iZXIoMSkpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tpXVtqXS5lcXVhbHMobmV3IFJhdGlvbmFsTnVtYmVyKDApKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdC8vIGEgbWF0cml4IGlzIG5vcm1hbCBpZiBpdCBjb21tdXRlcyB3aXRoIGl0cyBjb25qdWdhdGUgdHJhbnNwb3NlXHJcblx0cHVibGljIGlzTm9ybWFsKCk6IGJvb2xlYW4ge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xyXG5cdH1cclxuXHQvLyB0aGUgY29uanVnYXRlIHRyYW5zcG9zZSBvZiBhbiBtLWJ5LW4gbWF0cml4IEEgd2l0aCBjb21wbGV4IGVudHJpZXMgaXMgdGhlIG4tYnktbSBtYXRyaXggQeKIlyBvYnRhaW5lZCBmcm9tIEFcclxuXHQvLyBieSB0YWtpbmcgdGhlIHRyYW5zcG9zZSBhbmQgdGhlbiB0YWtpbmcgdGhlIGNvbXBsZXggY29uanVnYXRlIG9mIGVhY2ggZW50cnlcclxuXHQvLyBbQUxJQVNFU106IEhlcm1pdGlhbiB0cmFuc3Bvc2VcclxuXHRwdWJsaWMgdG9Db25qdWdhdGVUcmFuc3Bvc2UoKTogTWF0cml4IHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcclxuXHR9XHJcblx0cHVibGljIGlzVXBwZXJUcmlhbmd1bGFyKCk6IGJvb2xlYW4ge1xyXG5cdFx0Ly8gdG9kbzogY2hlY2sgaWYgZGVmaW5pdGlvbiBpcyB2YWxpZCBmb3IgYSBub24gc3F1YXJlIG1hdHJpeFxyXG5cdFx0Ly8gaWYgKHRoaXMubSAhPT0gdGhpcy5uKSB7IHRocm93IG5ldyBFcnJvcihcIk5vdCBhIHNxdWFyZSBtYXRyaXguXCIpOyB9XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAxOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IGk7IGorKykge1xyXG5cdFx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tpXVtqXS5lcXVhbHMobmV3IFJhdGlvbmFsTnVtYmVyKDApKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHB1YmxpYyBpc0xvd2VyVHJpYW5ndWxhcigpOiBib29sZWFuIHtcclxuXHRcdC8vIHRvZG86IGNoZWNrIGlmIGRlZmluaXRpb24gaXMgdmFsaWQgZm9yIGEgbm9uIHNxdWFyZSBtYXRyaXhcclxuXHRcdC8vIGlmICh0aGlzLm0gIT09IHRoaXMubikgeyB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBzcXVhcmUgbWF0cml4LlwiKTsgfVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IGkgKyAxOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbaV1bal0uZXF1YWxzKG5ldyBSYXRpb25hbE51bWJlcigwKSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHQvLyBhIHN5bW1ldHJpYyBtYXRyaXggaXMgYSBzcXVhcmUgbWF0cml4IHRoYXQgaXMgZXF1YWwgdG8gaXRzIHRyYW5zcG9zZVxyXG5cdHB1YmxpYyBpc1N5bW1ldHJpYygpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzLm0gIT09IHRoaXMubikgeyB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBzcXVhcmUgbWF0cml4LlwiKTsgfVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm47IGorKykge1xyXG5cdFx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tpXVtqXS5lcXVhbHModGhpcy5lbGVtZW50c1tqXVtpXSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHQvLyBhbiBvcnRob2dvbmFsIG1hdHJpeCBpcyBhIHNxdWFyZSBtYXRyaXggd2l0aCByZWFsIGVudHJpZXMgd2hvc2UgY29sdW1ucyBhbmQgcm93cyBhcmUgb3J0aG9nb25hbCB1bml0IHZlY3RvcnNcclxuXHQvLyBbQUxJQVNFU106IHJlYWwgb3J0aG9nb25hbCBtYXRyaXhcclxuXHRwdWJsaWMgaXNPcnRob2dvbmFsKCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgTVQ6IE1hdHJpeCA9IHRoaXMudHJhbnNwb3NlKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0KE1UKS5pc0lkZW50aXR5KCk7XHJcblx0fVxyXG5cdHB1YmxpYyBpc1Jvd0VjaGVsb25Gb3JtKCk6IGJvb2xlYW4ge1xyXG5cdFx0bGV0IGZvdW5kWmVyb1JvdzogYm9vbGVhbiA9IGZhbHNlO1xyXG5cdFx0Ly8gYWxsIG5vbnplcm8gcm93cyAocm93cyB3aXRoIGF0IGxlYXN0IG9uZSBub256ZXJvIGVsZW1lbnQpIGFyZSBhYm92ZSBhbnkgcm93cyBvZiBhbGwgemVyb2VzXHJcblx0XHQvLyAoYWxsIHplcm8gcm93cywgaWYgYW55LCBiZWxvbmcgYXQgdGhlIGJvdHRvbSBvZiB0aGUgbWF0cml4KVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLmlzWmVyb1JvdyhpKSkge1xyXG5cdFx0XHRcdGZvdW5kWmVyb1JvdyA9IHRydWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKGZvdW5kWmVyb1JvdykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0fS8vIGlmIGN1cnJlbnQgcm93IGlzIG5vdCB6ZXJvLCBidXQgYSBwcmV2aW91cyByb3cgaXMgemVybywgdGhlbiBtYXRyaXggaXMgbm90IGluIHJvdyBlY2hlbG9uIGZvcm1cclxuXHRcdH1cclxuXHRcdC8vIHRoZSBsZWFkaW5nIGNvZWZmaWNpZW50ICh0aGUgZmlyc3Qgbm9uemVybyBudW1iZXIgZnJvbSB0aGUgbGVmdCwgYWxzbyBjYWxsZWQgdGhlIHBpdm90KSBvZiBhIG5vbnplcm8gcm93XHJcblx0XHQvLyBpcyBhbHdheXMgc3RyaWN0bHkgdG8gdGhlIHJpZ2h0IG9mIHRoZSBsZWFkaW5nIGNvZWZmaWNpZW50IG9mIHRoZSByb3cgYWJvdmUgaXRcclxuXHRcdGxldCBwcmV2aW91c0lkeDogbnVtYmVyID0gLTE7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Y29uc3QgY3VycmVudFBpdm90SWR4OiBudW1iZXIgPSB0aGlzLnJvd1Bpdm90UG9zaXRpb24oaSk7XHJcblx0XHRcdGlmICgwID4gY3VycmVudFBpdm90SWR4KSB7IGNvbnRpbnVlOyB9Ly8gdGhpcyBpcyBhIHplcm8gcm93LCBubyBwaXZvdFxyXG5cdFx0XHQvLyBsZWFkaW5nIGNvZWZmaWNpZW50IG11c3QgYmUgMVxyXG5cdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbaV1bY3VycmVudFBpdm90SWR4XS5lcXVhbHMobmV3IFJhdGlvbmFsTnVtYmVyKDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0aWYgKHByZXZpb3VzSWR4IDwgY3VycmVudFBpdm90SWR4KSB7XHJcblx0XHRcdFx0cHJldmlvdXNJZHggPSBjdXJyZW50UGl2b3RJZHg7XHJcblx0XHRcdH0gZWxzZSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHB1YmxpYyBpc1JlZHVjZWRSb3dFY2hlbG9uRm9ybSgpOiBib29sZWFuIHtcclxuXHRcdGlmICghdGhpcy5pc1Jvd0VjaGVsb25Gb3JtKCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHQvLyBlYWNoIGxlYWRpbmcgY29lZmZpY2llbnQgaXMgdGhlIG9ubHkgbm9uemVybyBlbnRyeSBpbiBpdHMgY29sdW1uXHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Y29uc3QgcGl2b3RQb3NpdGlvbjogbnVtYmVyID0gdGhpcy5yb3dQaXZvdFBvc2l0aW9uKGkpO1xyXG5cdFx0XHRpZiAoMSA8IHRoaXMubnVtYmVyT2ZOb25aZXJvRWxlbWVudEZvckNvbHVtbihwaXZvdFBvc2l0aW9uKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRwdWJsaWMgdG9SZWR1Y2VkUm93RWNoZWxvbkZvcm0oKTogTWF0cml4IHtcclxuXHRcdGNvbnN0IHJlczogTWF0cml4ID0gdGhpcy5kZWVwQ29weSgpO1xyXG5cdFx0bGV0IGxlYWQ6IG51bWJlciA9IDA7XHJcblx0XHRmb3IgKGxldCByOiBudW1iZXIgPSAwOyByIDwgcmVzLm07IHIrKykge1xyXG5cdFx0XHRpZiAocmVzLm4gPD0gbGVhZCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBpOiBudW1iZXIgPSByO1xyXG5cdFx0XHR3aGlsZSAocmVzLmVsZW1lbnRzW2ldW2xlYWRdLmVxdWFscygwKSkge1xyXG5cdFx0XHRcdGkrKztcclxuXHRcdFx0XHRpZiAocmVzLm0gPT09IGkpIHtcclxuXHRcdFx0XHRcdGkgPSByO1xyXG5cdFx0XHRcdFx0bGVhZCsrO1xyXG5cdFx0XHRcdFx0aWYgKHJlcy5uID09PSBsZWFkKSB7XHJcblx0XHRcdFx0XHRcdGxlYWQtLTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJlcy5zd2l0Y2hSb3dzKGksIHIpO1xyXG5cdFx0XHRpZiAoIXJlcy5lbGVtZW50c1tyXVtsZWFkXS5lcXVhbHMoMCkpIHtcclxuXHRcdFx0XHRyZXMubXVsdGlwbHlSb3cociwgcmVzLmVsZW1lbnRzW3JdW2xlYWRdLnJlY2lwcm9jYWwoKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHJlcy5tOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoaiAhPT0gcikge1xyXG5cdFx0XHRcdFx0cmVzLmFkZFJvd3MoaiwgciwgcmVzLmVsZW1lbnRzW2pdW2xlYWRdLm9wcG9zaXRlKCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRsZWFkKys7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHRwdWJsaWMgZGV0ZXJtaW5hbnQoKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0Ly8gdG9kbzogaW1wbGVtZW50IGFuIG9wdGltaXplZCB2ZXJzaW9uLCBsaWtlIEE9UExVXHJcblx0XHRpZiAodGhpcy5tICE9PSB0aGlzLm4pIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRGV0ZXJtaW5hbnQgY2FuIG9ubHkgYmUgY2FsY3VsYXRlZCBvbiBhIHNxdWFyZSBtYXRyaXhcIik7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5tID09PSAxKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnRzWzBdWzBdO1xyXG5cdFx0fVxyXG5cdFx0bGV0IHJldDogUmF0aW9uYWxOdW1iZXIgPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5uOyBpKyspIHtcclxuXHRcdFx0Y29uc3QgbWlub3I6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5lbGVtZW50c1swXVtpXS5tdWx0KHRoaXMuY29mYWN0b3IoMCwgaSkuZGV0ZXJtaW5hbnQoKSk7XHJcblx0XHRcdHJldCA9IHJldC5hZGQobWlub3IubXVsdCgoLTEpICoqIGkpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG5cdHB1YmxpYyBjb252b2x1dGUoa2VybmVsOiBNYXRyaXgpOiBNYXRyaXgge1xyXG5cdFx0aWYgKGtlcm5lbC5tICE9PSBrZXJuZWwubikgeyB0aHJvdyBuZXcgRXJyb3IoXCJLZXJuZWwgbXVzdCBiZSBhIHNxdWFyZSBtYXRyaXghXCIpOyB9XHJcblx0XHRpZiAoa2VybmVsLm0gJSAyID09PSAwKSB7IHRocm93IG5ldyBFcnJvcihcIktlcm5lbCBtdXN0IGJlIGFuIG9kZCBzaXplIVwiKTsgfVxyXG5cdFx0Ly8gdG9kbzogcmVmYWN0b3IgZm9yIGFueSBzaXplIGtlcm5lbCwgbm90IGp1c3QgMyB4IDNcclxuXHRcdGNvbnN0IHJlczogTWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLm0sIHRoaXMubik7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdFx0cmVzLmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0XHRcdGZvciAobGV0IHRpOiBudW1iZXIgPSAwOyB0aSA8IGtlcm5lbC5tOyB0aSsrKSB7XHJcblx0XHRcdFx0XHRmb3IgKGxldCB0ajogbnVtYmVyID0gMDsgdGogPCBrZXJuZWwubjsgdGorKykge1xyXG5cdFx0XHRcdFx0XHRpZiAoaSAtIHRpIDwgMCB8fCBqIC0gdGogPCAwKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cmVzLmVsZW1lbnRzW2ldW2pdID0gcmVzLmVsZW1lbnRzW2ldW2pdLmFkZCh0aGlzLmVsZW1lbnRzW2kgLSB0aV1baiAtIHRqXS5tdWx0KGtlcm5lbC5lbGVtZW50c1t0aV1bdGpdKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBpc1plcm9Sb3cocm93SWQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tyb3dJZF1bal0uZXF1YWxzKG5ldyBSYXRpb25hbE51bWJlcigwKSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0cHJpdmF0ZSByb3dQaXZvdFBvc2l0aW9uKHJvd0lkOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tyb3dJZF1bal0uZXF1YWxzKG5ldyBSYXRpb25hbE51bWJlcigwKSkpIHsgcmV0dXJuIGo7IH1cclxuXHRcdH1cclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcblx0cHJpdmF0ZSBudW1iZXJPZk5vblplcm9FbGVtZW50Rm9yQ29sdW1uKGNvbHVtbklkOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0bGV0IGFjYzogbnVtYmVyID0gMDtcclxuXHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm07IGorKykge1xyXG5cdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbal1bY29sdW1uSWRdLmVxdWFscyhuZXcgUmF0aW9uYWxOdW1iZXIoMCkpKSB7IGFjYysrOyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYWNjO1xyXG5cdH1cclxuXHRwcml2YXRlIGNvZmFjdG9yKHJvd0lkOiBudW1iZXIsIGNvbHVtbklkOiBudW1iZXIpOiBNYXRyaXgge1xyXG5cdFx0Y29uc3QgcmV0OiBNYXRyaXggPSBuZXcgTWF0cml4KHRoaXMubSAtIDEsIHRoaXMubiAtIDEpO1xyXG5cdFx0bGV0IHJvd09mZnNldDogbnVtYmVyID0gMDtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm0gLSAxOyBpKyspIHtcclxuXHRcdFx0aWYgKGkgPT09IHJvd0lkKSB7XHJcblx0XHRcdFx0cm93T2Zmc2V0ID0gMTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgY29sdW1uT2Zmc2V0OiBudW1iZXIgPSAwO1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uIC0gMTsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGogPT09IGNvbHVtbklkKSB7XHJcblx0XHRcdFx0XHRjb2x1bW5PZmZzZXQgPSAxO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXQuZWxlbWVudHNbaV1bal0gPSB0aGlzLmVsZW1lbnRzW2kgKyByb3dPZmZzZXRdW2ogKyBjb2x1bW5PZmZzZXRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE1hdHJpeElkZW50aXR5IGV4dGVuZHMgTWF0cml4IHtcclxuXHRjb25zdHJ1Y3RvcihtOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKG0sIG0pO1xyXG5cdFx0dGhpcy5lbGVtZW50cyA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbaV0gPSBbXTtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubTsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGkgPT09IGopIHtcclxuXHRcdFx0XHRcdHRoaXMuZWxlbWVudHNbaV1bal0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMSk7XHJcblx0XHRcdFx0fSBlbHNlIHsgdGhpcy5lbGVtZW50c1tpXVtqXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBlbGltaW5hdGlvbiAtIG11bHRpcGx5IG9uIHRoZSBsZWZ0IChFKkEpOyBSb3ctYWRkaXRpb24gdHJhbnNmb3JtYXRpb25zXHJcbi8vIHRvIG11bHQqKHJvdzIgb2YgTWF0cml4IEEpIGFkZCAocm93MSBvZiBNYXRyaXggQSlcclxuZXhwb3J0IGNsYXNzIE1hdHJpeEVsaW1pbmF0aW9uIGV4dGVuZHMgTWF0cml4IHtcclxuXHRwdWJsaWMgcm93MTogbnVtYmVyO1xyXG5cdHB1YmxpYyByb3cyOiBudW1iZXI7XHJcblx0Y29uc3RydWN0b3IobTogbnVtYmVyLCByMTogbnVtYmVyLCByMjogbnVtYmVyLCBtdWx0OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcikge1xyXG5cdFx0aWYgKG0gPCByMSB8fCBtIDwgcjIpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ29sdW1uIGluZGV4IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBtYXRyaXggc2l6ZS5cIik7IH1cclxuXHRcdHN1cGVyKG0sIG0pO1xyXG5cdFx0dGhpcy5yb3cxID0gcjE7XHJcblx0XHR0aGlzLnJvdzIgPSByMjtcclxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzW2ldID0gW107XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm07IGorKykge1xyXG5cdFx0XHRcdGlmIChpID09PSBqKSB7XHJcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDEpO1xyXG5cdFx0XHRcdH0gZWxzZSB7IHRoaXMuZWxlbWVudHNbaV1bal0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHR5cGVvZiBtdWx0ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbcjFdW3IyXSA9IG5ldyBSYXRpb25hbE51bWJlcihtdWx0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChtdWx0IGluc3RhbmNlb2YgUmF0aW9uYWxOdW1iZXIpIHsgdGhpcy5lbGVtZW50c1tyMV1bcjJdID0gbXVsdDsgfVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gcGVybXV0YXRpb24gLSBtdWx0aXBseSBvbiB0aGUgcmlnaHQgKEEqUCk7IFJvdy1zd2l0Y2hpbmcgdHJhbnNmb3JtYXRpb25zXHJcbmV4cG9ydCBjbGFzcyBNYXRyaXhQZXJtdXRhdGlvbiBleHRlbmRzIE1hdHJpeCB7XHJcblx0Y29uc3RydWN0b3IobTogbnVtYmVyLCByb3cxOiBudW1iZXIsIHJvdzI6IG51bWJlcikge1xyXG5cdFx0aWYgKG0gPCByb3cxIHx8IG0gPCByb3cyKSB7IHRocm93IG5ldyBFcnJvcihcIkNvbHVtbiBpbmRleCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbWF0cml4IHNpemUuXCIpOyB9XHJcblx0XHRzdXBlcihtLCBtKTtcclxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzW2ldID0gW107XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm07IGorKykge1xyXG5cdFx0XHRcdGlmIChpID09PSBqKSB7XHJcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDEpO1xyXG5cdFx0XHRcdH0gZWxzZSB7IHRoaXMuZWxlbWVudHNbaV1bal0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5lbGVtZW50c1tyb3cxXVtyb3cxXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdHRoaXMuZWxlbWVudHNbcm93MV1bcm93Ml0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMSk7XHJcblx0XHR0aGlzLmVsZW1lbnRzW3JvdzJdW3JvdzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0dGhpcy5lbGVtZW50c1tyb3cyXVtyb3cxXSA9IG5ldyBSYXRpb25hbE51bWJlcigxKTtcclxuXHR9XHJcbn0iLCJleHBvcnQgY2xhc3MgUXVldWU8VD4ge1xyXG5cdHByaXZhdGUgcXVldWU6IFRbXTtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHRoaXMucXVldWUgPSBbXTtcclxuXHR9XHJcblx0cHVibGljIGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZS5sZW5ndGggPT09IDA7XHJcblx0fVxyXG5cdHB1YmxpYyBlbnF1ZXVlKGVsZW1lbnQ6IFQpOiB2b2lkIHtcclxuXHRcdHRoaXMucXVldWUucHVzaChlbGVtZW50KTtcclxuXHR9XHJcblx0cHVibGljIGRlcXVldWUoKTogVCB7XHJcblx0XHRpZiAodGhpcy5pc0VtcHR5KCkpIHsgdGhyb3cgbmV3IEVycm9yKFwiUXVldWUgaXMgZW1wdHlcIik7IH1cclxuXHRcdHJldHVybiB0aGlzLnF1ZXVlLnNoaWZ0KCk7XHJcblx0fVxyXG5cdHB1YmxpYyBwZWVrKCk6IFQge1xyXG5cdFx0aWYgKHRoaXMuaXNFbXB0eSgpKSB7IHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGlzIGVtcHR5XCIpOyB9XHJcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZVswXTtcclxuXHR9XHJcblx0cHVibGljIHRvQXJyYXkoKTogVFtdIHtcclxuXHRcdHJldHVybiB0aGlzLnF1ZXVlO1xyXG5cdH1cclxufSIsImltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuL0FyaXRobWV0aWNFdmFsdWF0b3JcIjtcclxuaW1wb3J0IHsgUXVldWUgfSBmcm9tIFwiLi9RdWV1ZVwiO1xyXG5pbXBvcnQgeyBTdGFjayB9IGZyb20gXCIuL1N0YWNrXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgUmF0aW9uYWxOdW1iZXIge1xyXG5cdHB1YmxpYyBzdGF0aWMgdG9SZXZlcnNlUG9saXNoTm90YXRpb24oY29kZTogc3RyaW5nKTogc3RyaW5nW10ge1xyXG5cdFx0Y29uc3QgdG9rZW5zOiBzdHJpbmdbXSA9IGNvZGUubWF0Y2goL1xcKHxcXCl8XFxkKyhcXC5cXGQrKT98XFx3K3xbXFwrXFwtXFwqXFwvXFxeXS9nKTtcclxuXHRcdGxldCBpOiBudW1iZXIgPSAwO1xyXG5cdFx0Y29uc3Qgb3V0cHV0UXVldWU6IFF1ZXVlPHN0cmluZz4gPSBuZXcgUXVldWU8c3RyaW5nPigpO1xyXG5cdFx0Y29uc3Qgb3BlcmF0b3JTdGFjazogU3RhY2s8c3RyaW5nPiA9IG5ldyBTdGFjazxzdHJpbmc+KCk7XHJcblx0XHR3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHtcclxuXHRcdFx0aWYgKHRoaXMuaXNOdW1iZXIodG9rZW5zW2ldKSkge1xyXG5cdFx0XHRcdG91dHB1dFF1ZXVlLmVucXVldWUodG9rZW5zW2ldKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmlzT3BlcmF0b3IodG9rZW5zW2ldKSkge1xyXG5cdFx0XHRcdGNvbnN0IG9wMTogc3RyaW5nID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRcdHdoaWxlICghb3BlcmF0b3JTdGFjay5pc0VtcHR5KCkgJiYgdGhpcy5pc09wZXJhdG9yKG9wZXJhdG9yU3RhY2sucGVlaygpKSkge1xyXG5cdFx0XHRcdFx0aWYgKCh0aGlzLmlzTGVmdEFzc29jaWF0aXZlT3BlcmF0b3Iob3AxKSAmJiAodGhpcy5wcmVjZWRlbmNlKG9wMSkgPD0gdGhpcy5wcmVjZWRlbmNlKG9wZXJhdG9yU3RhY2sucGVlaygpKSkpIHx8XHJcblx0XHRcdFx0XHRcdCh0aGlzLmlzUmlnaHRBc3NvY2lhdGl2ZU9wZXJhdG9yKG9wMSkgJiYgKHRoaXMucHJlY2VkZW5jZShvcDEpIDwgdGhpcy5wcmVjZWRlbmNlKG9wZXJhdG9yU3RhY2sucGVlaygpKSkpKSB7XHJcblx0XHRcdFx0XHRcdG91dHB1dFF1ZXVlLmVucXVldWUob3BlcmF0b3JTdGFjay5wb3AoKSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0b3BlcmF0b3JTdGFjay5wdXNoKG9wMSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW5zW2ldID09PSBcIihcIikge1xyXG5cdFx0XHRcdG9wZXJhdG9yU3RhY2sucHVzaCh0b2tlbnNbaV0pO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2Vuc1tpXSA9PT0gXCIpXCIpIHtcclxuXHRcdFx0XHR3aGlsZSAoIW9wZXJhdG9yU3RhY2suaXNFbXB0eSgpICYmIG9wZXJhdG9yU3RhY2sucGVlaygpICE9PSBcIihcIikge1xyXG5cdFx0XHRcdFx0b3V0cHV0UXVldWUuZW5xdWV1ZShvcGVyYXRvclN0YWNrLnBvcCgpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCFvcGVyYXRvclN0YWNrLmlzRW1wdHkoKSAmJiBvcGVyYXRvclN0YWNrLnBlZWsoKSA9PT0gXCIoXCIpIHtcclxuXHRcdFx0XHRcdG9wZXJhdG9yU3RhY2sucG9wKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgcGFyZW50aGVzZXMuXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpKys7XHJcblx0XHR9XHJcblx0XHR3aGlsZSAoIW9wZXJhdG9yU3RhY2suaXNFbXB0eSgpKSB7XHJcblx0XHRcdGlmIChvcGVyYXRvclN0YWNrLnBlZWsoKSA9PT0gXCIoXCIpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIHBhcmVudGhlc2VzLlwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvdXRwdXRRdWV1ZS5lbnF1ZXVlKG9wZXJhdG9yU3RhY2sucG9wKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb3V0cHV0UXVldWUudG9BcnJheSgpO1xyXG5cdH1cclxuXHRwdWJsaWMgc3RhdGljIGZyb21TdHJpbmcoY29kZTogc3RyaW5nKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0Y29uc3QgcDogUGFyc2VyID0gbmV3IFBhcnNlcigpO1xyXG5cdFx0cmV0dXJuIHAucGFyc2UoY29kZSk7XHJcblx0fVxyXG5cdHB1YmxpYyBzdGF0aWMgZ3JlYXRlc3RDb21tb25EaXZpc29yKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBiID8gUmF0aW9uYWxOdW1iZXIuZ3JlYXRlc3RDb21tb25EaXZpc29yKGIsIGEgJSBiKSA6IGE7XHJcblx0fVxyXG5cdHB1YmxpYyBzdGF0aWMgbGVhc3RDb21tb25NdWx0aXBsZShhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoYSAqIGIgLyBSYXRpb25hbE51bWJlci5ncmVhdGVzdENvbW1vbkRpdmlzb3IoYSwgYikpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBpc051bWJlcihjb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAvXlxcZC8udGVzdChjb2RlKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgaXNPcGVyYXRvcihjb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAvW1xcK1xcLVxcKlxcL1xcXl0vLnRlc3QoY29kZSk7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIGlzTGVmdEFzc29jaWF0aXZlT3BlcmF0b3Iob3BlcmF0b3I6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIC9bXFwrXFwtXFwqXFwvXS8udGVzdChvcGVyYXRvcik7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIGlzUmlnaHRBc3NvY2lhdGl2ZU9wZXJhdG9yKG9wZXJhdG9yOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAvW1xcXl0vLnRlc3Qob3BlcmF0b3IpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBwcmVjZWRlbmNlKG9wZXJhdG9yOiBzdHJpbmcpOiBudW1iZXIge1xyXG5cdFx0aWYgKC9bXFwrXFwtXS8udGVzdChvcGVyYXRvcikpIHtcclxuXHRcdFx0cmV0dXJuIDE7XHJcblx0XHR9XHJcblx0XHRpZiAoL1tcXCpcXC9dLy50ZXN0KG9wZXJhdG9yKSkge1xyXG5cdFx0XHRyZXR1cm4gMjtcclxuXHRcdH1cclxuXHRcdGlmICgvW1xcXl0vLnRlc3Qob3BlcmF0b3IpKSB7XHJcblx0XHRcdHJldHVybiAzO1xyXG5cdFx0fVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvci5cIik7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIGV2YWx1YXRlRnJvbVJQTih0b2tlbnM6IHN0cmluZ1tdKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0Y29uc3Qgc3RhY2s6IFN0YWNrPFJhdGlvbmFsTnVtYmVyPiA9IG5ldyBTdGFjazxSYXRpb25hbE51bWJlcj4oKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLmlzT3BlcmF0b3IodG9rZW5zW2ldKSkge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2gobmV3IFJhdGlvbmFsTnVtYmVyKHBhcnNlRmxvYXQodG9rZW5zW2ldKSkpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnN0IG9wMTogUmF0aW9uYWxOdW1iZXIgPSBzdGFjay5wb3AoKTtcclxuXHRcdFx0XHRjb25zdCBvcDI6IFJhdGlvbmFsTnVtYmVyID0gc3RhY2sucG9wKCk7XHJcblx0XHRcdFx0c3dpdGNoICh0b2tlbnNbaV0pIHtcclxuXHRcdFx0XHRcdGNhc2UgXCIrXCI6IHN0YWNrLnB1c2gob3AyLmFkZChvcDEpKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIFwiLVwiOiBzdGFjay5wdXNoKG9wMi5zdWIob3AxKSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBcIipcIjogc3RhY2sucHVzaChvcDIubXVsdChvcDEpKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIFwiL1wiOiBzdGFjay5wdXNoKG9wMi5kaXYob3AxKSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBcIl5cIjogc3RhY2sucHVzaChvcDIuZXhwKG9wMS50b051bWJlcigpKSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0YWNrLnBvcCgpLnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0fVxyXG5cdHB1YmxpYyBudW1lcmF0b3I6IG51bWJlcjtcclxuXHRwdWJsaWMgZGVub21pbmF0b3I6IG51bWJlcjtcclxuXHRjb25zdHJ1Y3RvcihuOiBudW1iZXIsIGQ6IG51bWJlciA9IDEpIHtcclxuXHRcdGlmIChkID09PSAwKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkRpdmlzaW9uIGJ5IHplcm8hXCIpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gdG9kbzogcG90ZW50aWFsIGZvciBvdmVyZmxvdy4gV2hlbiBNYXRoLnNpZ24gYmVjb21lcyBhdmFpbGFibGUgaW4gVHlwZVNjcmlwdCB1c2UgaXQgaW5zdGVhZCBvZiB0aGUgbXVsdGlwbGljYXRpb25cclxuXHRcdGNvbnN0IHNpZ246IG51bWJlciA9IG4gKiBkID49IDAgPyAxIDogLTE7XHJcblx0XHR0aGlzLm51bWVyYXRvciA9IHNpZ24gKiBNYXRoLmFicyhuKTtcclxuXHRcdHRoaXMuZGVub21pbmF0b3IgPSBNYXRoLmFicyhkKTtcclxuXHR9XHJcblx0cHVibGljIHNpbXBsaWZpZWRGb3JtKCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGNvbnN0IGdjZDogbnVtYmVyID0gUmF0aW9uYWxOdW1iZXIuZ3JlYXRlc3RDb21tb25EaXZpc29yKHRoaXMubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yKTtcclxuXHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIodGhpcy5udW1lcmF0b3IgLyBnY2QsIHRoaXMuZGVub21pbmF0b3IgLyBnY2QpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGVxdWFscyh4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3Qgcm4xOiBSYXRpb25hbE51bWJlciA9IHRoaXMuc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gcm4xLm51bWVyYXRvciA9PT0geCAmJiBybjEuZGVub21pbmF0b3IgPT09IDE7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBybjI6IFJhdGlvbmFsTnVtYmVyID0geC5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0XHRyZXR1cm4gcm4xLm51bWVyYXRvciA9PT0gcm4yLm51bWVyYXRvciAmJiBybjEuZGVub21pbmF0b3IgPT09IHJuMi5kZW5vbWluYXRvcjtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGx0KHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBybjE6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yIDwgeCAqIHJuMS5kZW5vbWluYXRvcjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IHJuMjogUmF0aW9uYWxOdW1iZXIgPSB4LnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yICogcm4yLmRlbm9taW5hdG9yIDwgcm4yLm51bWVyYXRvciAqIHJuMS5kZW5vbWluYXRvcjtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGxlKHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBybjE6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yIDw9IHggKiBybjEuZGVub21pbmF0b3I7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBybjI6IFJhdGlvbmFsTnVtYmVyID0geC5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0XHRyZXR1cm4gcm4xLm51bWVyYXRvciAqIHJuMi5kZW5vbWluYXRvciA8PSBybjIubnVtZXJhdG9yICogcm4xLmRlbm9taW5hdG9yO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgZ3QoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IHJuMTogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIHJuMS5udW1lcmF0b3IgPiB4ICogcm4xLmRlbm9taW5hdG9yO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3Qgcm4yOiBSYXRpb25hbE51bWJlciA9IHguc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdFx0cmV0dXJuIHJuMS5udW1lcmF0b3IgKiBybjIuZGVub21pbmF0b3IgPiBybjIubnVtZXJhdG9yICogcm4xLmRlbm9taW5hdG9yO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgZ2UoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IHJuMTogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIHJuMS5udW1lcmF0b3IgPj0geCAqIHJuMS5kZW5vbWluYXRvcjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IHJuMjogUmF0aW9uYWxOdW1iZXIgPSB4LnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yICogcm4yLmRlbm9taW5hdG9yID49IHJuMi5udW1lcmF0b3IgKiBybjEuZGVub21pbmF0b3I7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlXHJcblx0cHVibGljIHJlY2lwcm9jYWwoKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0aWYgKHRoaXMuZGVub21pbmF0b3IgPT09IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiRGl2aXNpb24gYnkgemVybyFcIik7IH1cclxuXHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIodGhpcy5kZW5vbWluYXRvciwgdGhpcy5udW1lcmF0b3IpO1xyXG5cdH1cclxuXHQvLyBhZGRpdGl2ZSBpbnZlcnNlXHJcblx0cHVibGljIG9wcG9zaXRlKCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIodGhpcy5udW1lcmF0b3IgKiAoLTEpLCB0aGlzLmRlbm9taW5hdG9yKTtcclxuXHR9XHJcblx0cHVibGljIGFkZCh4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKCh0aGlzLm51bWVyYXRvciArIHggKiB0aGlzLmRlbm9taW5hdG9yKSwgdGhpcy5kZW5vbWluYXRvcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBsY206IG51bWJlciA9IFJhdGlvbmFsTnVtYmVyLmxlYXN0Q29tbW9uTXVsdGlwbGUodGhpcy5kZW5vbWluYXRvciwgeC5kZW5vbWluYXRvcik7XHJcblx0XHRcdGNvbnN0IG4xOiBudW1iZXIgPSB0aGlzLm51bWVyYXRvciAqIGxjbSAvIHRoaXMuZGVub21pbmF0b3I7XHJcblx0XHRcdGNvbnN0IG4yOiBudW1iZXIgPSB4Lm51bWVyYXRvciAqIGxjbSAvIHguZGVub21pbmF0b3I7XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIobjEgKyBuMiwgbGNtKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIHN1Yih4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKCh0aGlzLm51bWVyYXRvciAtIHggKiB0aGlzLmRlbm9taW5hdG9yKSwgdGhpcy5kZW5vbWluYXRvcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBsY206IG51bWJlciA9IFJhdGlvbmFsTnVtYmVyLmxlYXN0Q29tbW9uTXVsdGlwbGUodGhpcy5kZW5vbWluYXRvciwgeC5kZW5vbWluYXRvcik7XHJcblx0XHRcdGNvbnN0IG4xOiBudW1iZXIgPSB0aGlzLm51bWVyYXRvciAqIGxjbSAvIHRoaXMuZGVub21pbmF0b3I7XHJcblx0XHRcdGNvbnN0IG4yOiBudW1iZXIgPSB4Lm51bWVyYXRvciAqIGxjbSAvIHguZGVub21pbmF0b3I7XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIobjEgLSBuMiwgbGNtKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIG11bHQoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcigodGhpcy5udW1lcmF0b3IgKiB4KSwgdGhpcy5kZW5vbWluYXRvcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKCh0aGlzLm51bWVyYXRvciAqIHgubnVtZXJhdG9yKSwgeC5kZW5vbWluYXRvciAqIHRoaXMuZGVub21pbmF0b3IpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgZGl2KHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIoKHRoaXMubnVtZXJhdG9yKSwgdGhpcy5kZW5vbWluYXRvciAqIHgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcigodGhpcy5udW1lcmF0b3IgKiB4LmRlbm9taW5hdG9yKSwgeC5udW1lcmF0b3IgKiB0aGlzLmRlbm9taW5hdG9yKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGV4cCh4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKHRoaXMubnVtZXJhdG9yICoqIHgsIHRoaXMuZGVub21pbmF0b3IgKiogeCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAodGhpcy5kZW5vbWluYXRvciAhPT0gMSkgeyB0aHJvdyBFcnJvcihcIkV4cG9uZW50aWF0aW9uIHdpdGggcmF0aW9uYWwgcG93ZXJzIG5vdCBzdXBwb3J0ZWQuXCIpOyB9XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIodGhpcy5udW1lcmF0b3IgKiogeC5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IgKiogeC5udW1lcmF0b3IpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgdG9OdW1iZXIoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLm51bWVyYXRvciAvIHRoaXMuZGVub21pbmF0b3I7XHJcblx0fVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMubnVtZXJhdG9yLnRvU3RyaW5nKCkgKyAoMSA9PT0gdGhpcy5kZW5vbWluYXRvciA/IFwiXCIgOiBcIi9cIiArIHRoaXMuZGVub21pbmF0b3IudG9TdHJpbmcoKSk7XHJcblx0fVxyXG5cdHB1YmxpYyBkZWVwQ29weSgpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKHRoaXMubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yKTtcclxuXHR9XHJcbn0iLCJleHBvcnQgY2xhc3MgU3RhY2s8VD4ge1xyXG5cdHByaXZhdGUgc3RhY2s6IFRbXTtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHRoaXMuc3RhY2sgPSBbXTtcclxuXHR9XHJcblx0cHVibGljIGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGFjay5sZW5ndGggPT09IDA7XHJcblx0fVxyXG5cdHB1YmxpYyBwdXNoKGVsZW1lbnQ6IFQpOiB2b2lkIHtcclxuXHRcdHRoaXMuc3RhY2sucHVzaChlbGVtZW50KTtcclxuXHR9XHJcblx0cHVibGljIHBvcCgpOiBUIHtcclxuXHRcdGlmICh0aGlzLmlzRW1wdHkoKSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJTdGFjayBpcyBlbXB0eVwiKTsgfVxyXG5cdFx0cmV0dXJuIHRoaXMuc3RhY2sucG9wKCk7XHJcblx0fVxyXG5cdHB1YmxpYyBwZWVrKCk6IFQge1xyXG5cdFx0aWYgKHRoaXMuaXNFbXB0eSgpKSB7IHRocm93IG5ldyBFcnJvcihcIlN0YWNrIGlzIGVtcHR5XCIpOyB9XHJcblx0XHRyZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG5cdH1cclxuXHRwdWJsaWMgdG9BcnJheSgpOiBUW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhY2s7XHJcblx0fVxyXG59IiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4vTWF0cml4XCI7XHJcbmltcG9ydCB7IFJhdGlvbmFsTnVtYmVyIH0gZnJvbSBcIi4vUmF0aW9uYWxOdW1iZXJcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWZWN0b3Ige1xyXG5cdHB1YmxpYyBzdGF0aWMgYXJlTGluZWFybHlJbmRlcGVuZGVudCh2ZWN0b3JzOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgbTogbnVtYmVyID0gdmVjdG9ycy5sZW5ndGg7XHJcblx0XHRpZiAoMCA9PT0gbSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0Y29uc3QgbjogbnVtYmVyID0gdmVjdG9yc1swXS5tO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMTsgaSA8IHZlY3RvcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKG4gIT09IHZlY3RvcnNbaV0ubSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGRpbWVuc2lvbnMuXCIpOyB9XHJcblx0XHR9XHJcblx0XHRpZiAobSA+IG4pIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xyXG5cdH1cclxuXHRwdWJsaWMgbTogbnVtYmVyO1xyXG5cdHB1YmxpYyBlbGVtZW50czogUmF0aW9uYWxOdW1iZXJbXTtcclxuXHRjb25zdHJ1Y3RvcihuOiBudW1iZXIgfCBudW1iZXJbXSk7XHJcblx0Y29uc3RydWN0b3IobjogYW55KSB7XHJcblx0XHRpZiAodHlwZW9mIG4gPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0dGhpcy5tID0gbjtcclxuXHRcdFx0dGhpcy5lbGVtZW50cyA9IFtdO1xyXG5cdFx0fSBlbHNlIGlmIChuIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuXHRcdFx0dGhpcy5tID0gbi5sZW5ndGg7XHJcblx0XHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcclxuXHRcdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5lbGVtZW50c1tpXSA9IG5ldyBSYXRpb25hbE51bWJlcihuW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgYWRkKHg6IFZlY3Rvcik6IFZlY3RvciB7XHJcblx0XHRpZiAodGhpcy5tICE9PSB4Lm0pIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBkaW1lbnNpb25zLlwiKTsgfVxyXG5cdFx0Y29uc3QgcmVzOiBWZWN0b3IgPSBuZXcgVmVjdG9yKHRoaXMubSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgcmVzLm07IGkrKykge1xyXG5cdFx0XHRyZXMuZWxlbWVudHNbaV0gPSB0aGlzLmVsZW1lbnRzW2ldLmFkZCh4LmVsZW1lbnRzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cdHB1YmxpYyBzdWIoeDogVmVjdG9yKTogVmVjdG9yIHtcclxuXHRcdGlmICh0aGlzLm0gIT09IHgubSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGRpbWVuc2lvbnMuXCIpOyB9XHJcblx0XHRjb25zdCByZXM6IFZlY3RvciA9IG5ldyBWZWN0b3IodGhpcy5tKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCByZXMubTsgaSsrKSB7XHJcblx0XHRcdHJlcy5lbGVtZW50c1tpXSA9IHRoaXMuZWxlbWVudHNbaV0uc3ViKHguZWxlbWVudHNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblx0cHVibGljIG11bHQoeDogUmF0aW9uYWxOdW1iZXIpOiBWZWN0b3Ige1xyXG5cdFx0Y29uc3QgcmVzOiBWZWN0b3IgPSBuZXcgVmVjdG9yKHRoaXMubSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgcmVzLm07IGkrKykge1xyXG5cdFx0XHRyZXMuZWxlbWVudHNbaV0gPSB0aGlzLmVsZW1lbnRzW2ldLm11bHQoeCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHQvLyBbQUxJQVNFU106IGlubmVyUHJvZHVjdCwgcHJvamVjdGlvblByb2R1Y3QsIHNjYWxhclByb2R1Y3RcclxuXHRwdWJsaWMgZG90UHJvZHVjdCh4OiBWZWN0b3IpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRpZiAodGhpcy5tICE9PSB4Lm0pIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBkaW1lbnNpb25zLlwiKTsgfVxyXG5cdFx0bGV0IHJlczogUmF0aW9uYWxOdW1iZXIgPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgeC5tOyBpKyspIHtcclxuXHRcdFx0cmVzID0gcmVzLmFkZCh0aGlzLmVsZW1lbnRzW2ldLm11bHQoeC5lbGVtZW50c1tpXSkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblx0Ly8gW0FMSUFTRVNdOiBkaXJlY3RlZEFyZWFQcm9kdWN0LCB2ZWN0b3JQcm9kdWN0XHJcblx0cHVibGljIGNyb3NzUHJvZHVjdCh4OiBWZWN0b3IpOiBWZWN0b3Ige1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcclxuXHR9XHJcblx0Ly8gW0FMSUFTRVNdOiBtYWduaXR1ZGUsIG5vcm1cclxuXHRwdWJsaWMgbGVuZ3RoKCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGNvbnN0IGxlbmd0aDogUmF0aW9uYWxOdW1iZXIgPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0bGVuZ3RoLmFkZCh0aGlzLmVsZW1lbnRzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBsZW5ndGg7XHJcblx0fVxyXG5cdHB1YmxpYyBkZWVwQ29weSgpOiBWZWN0b3Ige1xyXG5cdFx0Y29uc3QgcmV0OiBWZWN0b3IgPSBuZXcgVmVjdG9yKHRoaXMubSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0cmV0LmVsZW1lbnRzW2ldID0gdGhpcy5lbGVtZW50c1tpXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG5cdHB1YmxpYyB0b01hdHJpeCgpOiBNYXRyaXgge1xyXG5cdFx0Y29uc3QgcmV0OiBNYXRyaXggPSBuZXcgTWF0cml4KHRoaXMubSwgMSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0cmV0LmVsZW1lbnRzW2ldWzBdID0gdGhpcy5lbGVtZW50c1tpXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG59XHJcbmV4cG9ydCBjbGFzcyBDb2x1bW5WZWN0b3IgZXh0ZW5kcyBWZWN0b3Ige1xyXG59XHJcbmV4cG9ydCBjbGFzcyBSb3dWZWN0b3IgZXh0ZW5kcyBWZWN0b3Ige1xyXG5cdHB1YmxpYyBtYXRyaXhQcm9kdWN0KG06IE1hdHJpeCk6IFJvd1ZlY3RvciB7XHJcblx0XHRpZiAodGhpcy5tICE9PSBtLm4pIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBkaW1lbnNpb25zLlwiKTsgfVxyXG5cdFx0Y29uc3QgcmVzOiBSb3dWZWN0b3IgPSBuZXcgUm93VmVjdG9yKHRoaXMubSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0bGV0IHN1bTogUmF0aW9uYWxOdW1iZXIgPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBtLm47IGorKykge1xyXG5cdFx0XHRcdHN1bSA9IHN1bS5hZGQobS5lbGVtZW50c1tpXVtqXS5tdWx0KHRoaXMuZWxlbWVudHNbaV0pKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXMuZWxlbWVudHNbaV0gPSBzdW07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxufSJdLCJzb3VyY2VSb290IjoiIn0=