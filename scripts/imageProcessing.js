/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/exercises/imageProcessing.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./src/exercises/imageProcessing.ts":
/*!******************************************!*\
  !*** ./src/exercises/imageProcessing.ts ***!
  \******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../structures/Matrix */ "./src/structures/Matrix.ts");
/* harmony import */ var _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../structures/RationalNumber */ "./src/structures/RationalNumber.ts");


function imageDataToRGBA(imageData) {
    const imgR = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
    const imgG = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
    const imgB = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
    const imgA = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
    let idx = 0;
    for (let x = 0; x < imageData.width; x++) {
        imgR[x] = [];
        imgG[x] = [];
        imgB[x] = [];
        imgA[x] = [];
        for (let y = 0; y < imageData.height; y++) {
            imgR.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
            imgG.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
            imgB.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
            imgA.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
        }
    }
    return [imgR, imgG, imgB, imgA];
}
function imageDataFromRGBA(rgba) {
    const imgR = rgba[0];
    const imgG = rgba[1];
    const imgB = rgba[2];
    const imgA = rgba[3];
    const width = imgR.m;
    const height = imgR.n;
    const imageData = new ImageData(width, height);
    let idx = 0;
    for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
            imageData.data[idx++] = imgR.elements[x][y].toNumber();
            imageData.data[idx++] = imgG.elements[x][y].toNumber();
            imageData.data[idx++] = imgB.elements[x][y].toNumber();
            imageData.data[idx++] = imgA.elements[x][y].toNumber();
        }
    }
    return imageData;
}
$(document).ready(() => {
    const canvas1 = $("#canvas1")[0];
    const ctx1 = canvas1.getContext("2d");
    const image = new Image();
    image.onload = () => {
        canvas1.height = image.height;
        canvas1.width = image.width;
        ctx1.drawImage(image, 0, 0);
        const imgData1 = ctx1.getImageData(0, 0, image.width, image.height);
        const rgba = imageDataToRGBA(imgData1);
        // duplicate
        const imgData2 = imageDataFromRGBA(rgba);
        const canvas2 = $("#canvas2")[0];
        const ctx2 = canvas2.getContext("2d");
        canvas2.height = imgData2.height;
        canvas2.width = imgData2.width;
        ctx2.putImageData(imgData2, 0, 0);
        // convolute
        const canvas3 = $("#canvas3")[0];
        const ctx3 = canvas3.getContext("2d");
        const kernel = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](3, 3);
        /*
        kernel.elements[0][0] = new RationalNumber(0);
        kernel.elements[0][1] = new RationalNumber(-1);
        kernel.elements[0][2] = new RationalNumber(0);
        kernel.elements[1][0] = new RationalNumber(-1);
        kernel.elements[1][1] = new RationalNumber(5);
        kernel.elements[1][2] = new RationalNumber(-1);
        kernel.elements[2][0] = new RationalNumber(0);
        kernel.elements[2][1] = new RationalNumber(-1);
        kernel.elements[2][2] = new RationalNumber(0);
        */
        /*
        kernel.elements[0][0] = new RationalNumber(-1);
        kernel.elements[0][1] = new RationalNumber(-1);
        kernel.elements[0][2] = new RationalNumber(-1);
        kernel.elements[1][0] = new RationalNumber(-1);
        kernel.elements[1][1] = new RationalNumber(8);
        kernel.elements[1][2] = new RationalNumber(-1);
        kernel.elements[2][0] = new RationalNumber(-1);
        kernel.elements[2][1] = new RationalNumber(-1);
        kernel.elements[2][2] = new RationalNumber(-1);
        */
        /*
        kernel.elements[0][0] = new RationalNumber(0);
        kernel.elements[0][1] = new RationalNumber(0);
        kernel.elements[0][2] = new RationalNumber(0);
        kernel.elements[1][0] = new RationalNumber(0);
        kernel.elements[1][1] = new RationalNumber(1);
        kernel.elements[1][2] = new RationalNumber(0);
        kernel.elements[2][0] = new RationalNumber(0);
        kernel.elements[2][1] = new RationalNumber(0);
        kernel.elements[2][2] = new RationalNumber(0);
        //*/
        //*
        kernel.elements[0][0] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        kernel.elements[0][1] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](-1);
        kernel.elements[0][2] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        kernel.elements[1][0] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](-1);
        kernel.elements[1][1] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](4);
        kernel.elements[1][2] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](-1);
        kernel.elements[2][0] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        kernel.elements[2][1] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](-1);
        kernel.elements[2][2] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        //*/
        // const newRgba: [Matrix, Matrix, Matrix, Matrix] = [rgba[0].convolute(kernel), rgba[1].convolute(kernel), rgba[2].convolute(kernel), rgba[3].convolute(kernel)];
        for (let i = 0; i < rgba[0].m; i++) {
            for (let j = 0; j < rgba[0].n; j++) {
                rgba[0].elements[i][j] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
                rgba[2].elements[i][j] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
            }
        }
        const newRgba = [rgba[0], rgba[1].convolute(kernel), rgba[2], rgba[3]];
        const imgData3 = imageDataFromRGBA(newRgba);
        canvas3.height = imgData3.height;
        canvas3.width = imgData3.width;
        ctx3.putImageData(imgData3, 0, 0);
    };
    image.src = "data:image/png;base64," + encodedImg;
    // Other ways of doing it
    const imgSrc = $("#imgSource").attr("src").replace("data:image/png;base64,", "");
    const binSrc = atob(imgSrc);
    const img = Uint8Array.from(binSrc, (c) => c.charCodeAt(0));
    // reverse
    let binDest = "";
    for (const i of img) {
        binDest += String.fromCharCode(i);
    }
    // String.fromCharCode.apply(null, img); // throww "Maximum call stack size exceeded"
    const imgDest = btoa(binDest);
    $("#imgDestination").attr("src", "data:image/png;base64," + imgDest);
});
const encodedImg = "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";

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./src/structures/ArithmeticEvaluator.ts":
/*!***********************************************!*\
  !*** ./src/structures/ArithmeticEvaluator.ts ***!
  \***********************************************/
/*! exports provided: ArithmeticEvaluator, TokenType, Token, Lexer, Parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArithmeticEvaluator", function() { return ArithmeticEvaluator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenType", function() { return TokenType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lexer", function() { return Lexer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony import */ var _Queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Queue */ "./src/structures/Queue.ts");
/* harmony import */ var _RationalNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RationalNumber */ "./src/structures/RationalNumber.ts");
/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Stack */ "./src/structures/Stack.ts");



class ArithmeticEvaluator {
    static toReversePolishNotation(code) {
        const tokens = code.match(/\(|\)|\d+(\.\d+)?|\w+|[\+\-\*\/\^]/g);
        let i = 0;
        const outputQueue = new _Queue__WEBPACK_IMPORTED_MODULE_0__["Queue"]();
        const operatorStack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();
        while (i < tokens.length) {
            if (this.isNumber(tokens[i])) {
                outputQueue.enqueue(tokens[i]);
            }
            else if (this.isOperator(tokens[i])) {
                let op1 = tokens[i];
                while (!operatorStack.isEmpty() && this.isOperator(operatorStack.peek())) {
                    if ((this.isLeftAssociativeOperator(op1) && (this.precedence(op1) <= this.precedence(operatorStack.peek()))) ||
                        (this.isRightAssociativeOperator(op1) && (this.precedence(op1) < this.precedence(operatorStack.peek())))) {
                        outputQueue.enqueue(operatorStack.pop());
                    }
                    else {
                        break;
                    }
                }
                operatorStack.push(op1);
            }
            else if (tokens[i] === "(") {
                operatorStack.push(tokens[i]);
            }
            else if (tokens[i] === ")") {
                while (!operatorStack.isEmpty() && operatorStack.peek() !== "(") {
                    outputQueue.enqueue(operatorStack.pop());
                }
                if (!operatorStack.isEmpty() && operatorStack.peek() === "(") {
                    operatorStack.pop();
                }
                else {
                    throw new Error("Mismatched parentheses.");
                }
            }
            i++;
        }
        while (!operatorStack.isEmpty()) {
            if (operatorStack.peek() === "(") {
                throw new Error("Mismatched parentheses.");
            }
            else {
                outputQueue.enqueue(operatorStack.pop());
            }
        }
        return outputQueue.toArray();
    }
    static evaluateFromRPN(tokens) {
        const stack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();
        for (let i = 0; i < tokens.length; i++) {
            if (!this.isOperator(tokens[i])) {
                stack.push(parseFloat(tokens[i]));
            }
            else {
                let op1 = stack.pop();
                let op2 = stack.pop();
                switch (tokens[i]) {
                    case "+":
                        stack.push(op2 + op1);
                        break;
                    case "-":
                        stack.push(op2 - op1);
                        break;
                    case "*":
                        stack.push(op2 * op1);
                        break;
                    case "/":
                        stack.push(op2 / op1);
                        break;
                    case "^":
                        stack.push(op2 ** op1);
                        break;
                }
            }
        }
        return stack.pop();
    }
    static isNumber(code) {
        return /^\d/.test(code);
    }
    static isOperator(code) {
        return /[\+\-\*\/\^]/.test(code);
    }
    static isLeftAssociativeOperator(operator) {
        return /[\+\-\*\/]/.test(operator);
    }
    static isRightAssociativeOperator(operator) {
        return /[\^]/.test(operator);
    }
    static precedence(operator) {
        if (/[\+\-]/.test(operator)) {
            return 1;
        }
        if (/[\*\/]/.test(operator)) {
            return 2;
        }
        if (/[\^]/.test(operator)) {
            return 3;
        }
        throw new Error("Unknown operator.");
    }
}
var TokenType;
(function (TokenType) {
    TokenType[TokenType["Plus"] = 0] = "Plus";
    TokenType[TokenType["Minus"] = 1] = "Minus";
    TokenType[TokenType["Multiply"] = 2] = "Multiply";
    TokenType[TokenType["Divide"] = 3] = "Divide";
    TokenType[TokenType["Exponent"] = 4] = "Exponent";
    TokenType[TokenType["Number"] = 5] = "Number";
    TokenType[TokenType["LParen"] = 6] = "LParen";
    TokenType[TokenType["RParen"] = 7] = "RParen";
    TokenType[TokenType["End"] = 8] = "End";
    TokenType[TokenType["Unknown"] = 9] = "Unknown";
})(TokenType || (TokenType = {}));
class Token {
    constructor(type, value) {
        this.type = type;
        this.value = value;
    }
}
class Lexer {
    constructor(input) {
        this.tokens = input.replace(" ", "").match(/\(|\)|\d+(\.\d+)?|[\+\-\*\/\^]/g);
        this.tokenIndex = 0;
    }
    getNextToken() {
        if (this.tokens.length === this.tokenIndex) {
            return new Token(TokenType.End);
        }
        let input = this.tokens[this.tokenIndex++];
        return this.getToken(input);
    }
    getCurrentToken() {
        if (this.tokens.length - 1 === this.tokenIndex) {
            return new Token(TokenType.End);
        }
        let input = this.tokens[this.tokenIndex];
        return this.getToken(input);
    }
    revert() {
        if (this.tokenIndex <= 0) {
            throw Error("Index out of range");
        }
        this.tokenIndex--;
    }
    getToken(input) {
        if (/\+/.test(input)) {
            return new Token(TokenType.Plus);
        }
        if (/\-/.test(input)) {
            return new Token(TokenType.Minus);
        }
        if (/\*/.test(input)) {
            return new Token(TokenType.Multiply);
        }
        if (/\//.test(input)) {
            return new Token(TokenType.Divide);
        }
        if (/\^/.test(input)) {
            return new Token(TokenType.Exponent);
        }
        if (/\d+(\.\d+)?/.test(input)) {
            return new Token(TokenType.Number, parseFloat(input));
        }
        if (/\(/.test(input)) {
            return new Token(TokenType.LParen);
        }
        if (/\)/.test(input)) {
            return new Token(TokenType.RParen);
        }
        return new Token(TokenType.Unknown);
    }
}
class Parser {
    parse(code) {
        this.lex = new Lexer(code);
        const expression = this.fourthOrderOperators();
        const token = this.lex.getCurrentToken(); // is already advanced because of number()
        if (token.type === TokenType.End) {
            return expression;
        }
        throw Error("End expected");
    }
    // addition and substraction
    fourthOrderOperators() {
        let component1 = this.thirdOrderOperators();
        let token = this.lex.getNextToken();
        while (token.type === TokenType.Plus || token.type === TokenType.Minus) {
            let component2 = this.thirdOrderOperators();
            if (token.type === TokenType.Plus) {
                component1 = component1.add(component2);
            }
            else if (token.type === TokenType.Minus) {
                component1 = component1.sub(component2);
            }
            token = this.lex.getNextToken();
        }
        this.lex.revert();
        return component1;
    }
    // multiplication and division
    thirdOrderOperators() {
        let factor1 = this.secondOrderOperators();
        let token = this.lex.getNextToken();
        while (token.type === TokenType.Multiply || token.type === TokenType.Divide) {
            let factor2 = this.secondOrderOperators();
            if (token.type === TokenType.Multiply) {
                factor1 = factor1.mult(factor2);
            }
            else if (token.type === TokenType.Divide) {
                factor1 = factor1.div(factor2);
            }
            token = this.lex.getNextToken();
        }
        this.lex.revert();
        return factor1;
    }
    // exponents and roots
    secondOrderOperators() {
        let factor1 = this.firstOrderOperators();
        let token = this.lex.getNextToken();
        while (token.type === TokenType.Exponent) {
            let factor2 = this.firstOrderOperators();
            factor1 = factor1.exp(factor2);
            token = this.lex.getNextToken();
        }
        this.lex.revert();
        return factor1;
    }
    // numbers and parantheses
    firstOrderOperators() {
        let value = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](1);
        let token = this.lex.getNextToken();
        if (token.type === TokenType.Plus || token.type === TokenType.Minus) {
            if (token.type === TokenType.Minus) {
                value = value.mult(-1);
            }
            token = this.lex.getNextToken();
        }
        if (token.type === TokenType.LParen) {
            value = value.mult(this.fourthOrderOperators());
            token = this.lex.getNextToken();
            if (token.type !== TokenType.RParen) {
                throw Error("Unbalanced parenthesis");
            }
        }
        else {
            if (token.type === TokenType.Number) {
                value = value.mult(token.value);
            }
            else {
                throw Error("Not a number");
            }
        }
        return value;
    }
}
/*
    public static evaluate(expresion: string): RationalNumber {
    var digitPattern = new RegExp('0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9');
    var signPattern = new RegExp('\+|\-');
    var numberPattern = new RegExp('[' + signPattern + ']' + '{' + digitPattern + '}');
    var factorPattern = new RegExp(numberPattern + '|\(' + expressionPattern + '\)');
    var componentPattern = new RegExp(factorPattern + '[{( \* | \/ )' + factorPattern + '}]');
    var expressionPattern = new RegExp(componentPattern + '[{( \+ | \-)' + componentPattern + '}]');
}*/
/*
exprr: 4thORDER+;
4thORDER: component1=3rdORDER ((PLUS|MINUS) component2=3rdORDER)+;
3rdORDER: factor1=2NDORDER ((MULTIPLY|DIVIDE) factor1=2ndORDER)+
2ndORDER: factor1=1stORDER (EXPONENT factor2=1stORDER)+
1stORDER: (PLUS|MINUS|empty) (LPAREN value=4thORDER RPAREN| NUMBER)
*/ 


/***/ }),

/***/ "./src/structures/Matrix.ts":
/*!**********************************!*\
  !*** ./src/structures/Matrix.ts ***!
  \**********************************/
/*! exports provided: Matrix, MatrixIdentity, MatrixElimination, MatrixPermutation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix", function() { return Matrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatrixIdentity", function() { return MatrixIdentity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatrixElimination", function() { return MatrixElimination; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatrixPermutation", function() { return MatrixPermutation; });
/* harmony import */ var _RationalNumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RationalNumber */ "./src/structures/RationalNumber.ts");
/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector */ "./src/structures/Vector.ts");


class Matrix {
    constructor(m, n) {
        this.m = m;
        this.n = n;
        this.elements = [];
        for (let i = 0; i < this.m; i++) {
            this.elements[i] = [];
        }
    }
    static augment(A, B) {
        if (A.m !== B.m) {
            throw new Error("The two matrices (vector) must have the same number of rows (elements).");
        }
        let ret = null;
        if (B instanceof Matrix) {
            ret = new Matrix(A.m, B.n + A.n);
            for (let i = 0; i < A.m; i++) {
                for (let j = 0; j < A.n; j++) {
                    ret.elements[i][j] = A.elements[i][j];
                }
            }
            for (let i = 0; i < B.m; i++) {
                for (let j = 0; j < B.n; j++) {
                    ret.elements[i][A.n + j] = B.elements[i][j];
                }
            }
        }
        else {
            if (B instanceof _Vector__WEBPACK_IMPORTED_MODULE_1__["Vector"]) {
                ret = new Matrix(A.m, A.n + 1);
                for (let i = 0; i < A.m; i++) {
                    for (let j = 0; j < A.n; j++) {
                        ret.elements[i][j] = A.elements[i][j];
                    }
                }
                for (let j = 0; j < B.m; j++) {
                    ret.elements[j][A.n] = B.elements[j];
                }
            }
        }
        return ret;
    }
    // row-multiplying transformations
    static multiplication(n, row1, row2, mult) {
        if (n < row1 || n < row2) {
            throw new Error("Column index must be less or equalt than matrix size.");
        }
        const matrix = new MatrixIdentity(n);
        matrix.elements[row1][row2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](mult);
        return matrix;
    }
    static randomSquare() {
        const matrix = new Matrix(Math.floor(Math.random() * 4) + 3, Math.floor(Math.random() * 4) + 3); // minimum size 3x3 matrix
        for (let i = 0; i < matrix.m; i++) {
            for (let j = 0; j < matrix.n; j++) {
                matrix.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](Math.floor(Math.random() * 100 - 50));
            }
        }
        return matrix;
    }
    static random2() {
        const numberOfUnknowns = Math.floor(Math.random() * 4 + 3); // between 3 and 7 unknonws
        const unknowns = [];
        for (let i = 0; i < numberOfUnknowns; i++) {
            unknowns[i] = Math.floor(Math.random() * 20 - 10);
        }
        // todo: change below
        const matrix = new Matrix(Math.floor(Math.random() * 4) + 3, Math.floor(Math.random() * 4) + 3);
        return matrix;
    }
    equals(M) {
        if (this.m !== M.m || this.n !== M.n) {
            return false;
        }
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                if (!this.elements[i][j].equals(M.elements[i][j])) {
                    return false;
                }
            }
        }
        return true;
    }
    add(x) {
        if (this.m !== x.m || this.n !== x.n) {
            throw new Error("Mismatched dimensions.");
        }
        const res = new Matrix(this.m, this.n);
        for (let i = 0; i < res.m; i++) {
            for (let j = 0; j < res.n; j++) {
                res.elements[i][j] = this.elements[i][j].add(x.elements[i][j]);
            }
        }
        return res;
    }
    sub(x) {
        if (this.m !== x.m || this.n !== x.n) {
            throw new Error("Mismatched dimensions.");
        }
        const res = new Matrix(this.m, this.n);
        for (let i = 0; i < res.m; i++) {
            for (let j = 0; j < res.n; j++) {
                res.elements[i][j] = this.elements[i][j].sub(x.elements[i][j]);
            }
        }
        return res;
    }
    mult(x) {
        let res = null;
        if (typeof x === "number") {
            res = new Matrix(this.m, this.n);
            for (let i = 0; i < res.m; i++) {
                for (let j = 0; j < res.n; j++) {
                    res.elements[i][j] = this.elements[i][j].mult(x);
                }
            }
        }
        else if (x instanceof _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"]) {
            res = new Matrix(this.m, this.n);
            for (let i = 0; i < res.m; i++) {
                for (let j = 0; j < res.n; j++) {
                    res.elements[i][j] = this.elements[i][j].mult(x);
                }
            }
        }
        else {
            if (x instanceof Matrix) {
                if (this.n !== x.m) {
                    throw new Error("Mismatched dimensions.");
                }
                res = new Matrix(this.m, x.n);
                for (let i = 0; i < res.m; i++) {
                    for (let j = 0; j < res.n; j++) {
                        let sum = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
                        for (let k = 0; k < this.n; k++) {
                            sum = sum.add(this.elements[i][k].mult(x.elements[k][j]));
                        }
                        res.elements[i][j] = sum;
                    }
                }
            }
        }
        return res;
    }
    vectorProduct(v) {
        if (this.n !== v.m) {
            throw new Error("Mismatched dimensions.");
        }
        const res = new _Vector__WEBPACK_IMPORTED_MODULE_1__["ColumnVector"](v.m);
        for (let i = 0; i < this.m; i++) {
            let sum = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
            for (let j = 0; j < this.n; j++) {
                sum = sum.add(this.elements[i][j].mult(v.elements[j]));
            }
            res.elements[i] = sum;
        }
        return res;
    }
    transpose() {
        const ret = new Matrix(this.n, this.m);
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                ret.elements[j][i] = this.elements[i][j];
            }
        }
        return ret;
    }
    deepCopy() {
        const ret = new Matrix(this.m, this.n);
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                ret.elements[i][j] = this.elements[i][j];
            }
        }
        return ret;
    }
    switchRows(idx1, idx2) {
        if (this.m < idx1 || this.m < idx2) {
            return;
        }
        for (let i = 0; i < this.n; i++) {
            const tmp = this.elements[idx1][i];
            this.elements[idx1][i] = this.elements[idx2][i];
            this.elements[idx2][i] = tmp;
        }
    }
    multiplyRow(idx, scalar) {
        if (this.m < idx) {
            return;
        }
        for (let i = 0; i < this.n; i++) {
            this.elements[idx][i] = this.elements[idx][i].mult(scalar).simplifiedForm();
        }
    }
    addRows(idx1, idx2, scalar) {
        if (this.m < idx1 || this.m < idx2) {
            return;
        }
        for (let i = 0; i < this.n; i++) {
            this.elements[idx1][i] = this.elements[idx2][i].mult(scalar).add(this.elements[idx1][i]).simplifiedForm();
        }
    }
    addRow1ToRow2(idx1, scalar1, idx2, scalar2) {
        if (this.m < idx1 || this.m < idx2) {
            return;
        }
        for (let i = 0; i < this.n; i++) {
            this.elements[idx2][i] = this.elements[idx2][i].mult(scalar2).add(this.elements[idx1][i].mult(scalar1)).simplifiedForm();
        }
    }
    // a square matrix is a matrix with the same number of rows and columns
    isSquare() {
        return this.m === this.n;
    }
    // a diagonal matrix is a matrix in which the entries outside the main diagonal are all zero
    isDiagonal() {
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                if (i === j) {
                    continue;
                }
                if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                    return false;
                }
            }
        }
        return true;
    }
    // the identity matrix of size n is the n × n square matrix with ones on the main diagonal and zeros elsewhere
    // [ALIASES]: unit matrix
    isIdentity() {
        if (this.m !== this.n) {
            throw new Error("Not a square matrix.");
        }
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                if (i === j) {
                    if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1))) {
                        return false;
                    }
                    continue;
                }
                if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                    return false;
                }
            }
        }
        return true;
    }
    // a matrix is normal if it commutes with its conjugate transpose
    isNormal() {
        throw new Error("Not implemented");
    }
    // the conjugate transpose of an m-by-n matrix A with complex entries is the n-by-m matrix A∗ obtained from A
    // by taking the transpose and then taking the complex conjugate of each entry
    // [ALIASES]: Hermitian transpose
    toConjugateTranspose() {
        throw new Error("Not implemented");
    }
    isUpperTriangular() {
        // todo: check if definition is valid for a non square matrix
        // if (this.m !== this.n) { throw new Error("Not a square matrix."); }
        for (let i = 1; i < this.m; i++) {
            for (let j = 0; j < i; j++) {
                if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                    return false;
                }
            }
        }
        return true;
    }
    isLowerTriangular() {
        // todo: check if definition is valid for a non square matrix
        // if (this.m !== this.n) { throw new Error("Not a square matrix."); }
        for (let i = 0; i < this.m; i++) {
            for (let j = i + 1; j < this.n; j++) {
                if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                    return false;
                }
            }
        }
        return true;
    }
    // a symmetric matrix is a square matrix that is equal to its transpose
    isSymmetric() {
        if (this.m !== this.n) {
            throw new Error("Not a square matrix.");
        }
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                if (!this.elements[i][j].equals(this.elements[j][i])) {
                    return false;
                }
            }
        }
        return true;
    }
    // an orthogonal matrix is a square matrix with real entries whose columns and rows are orthogonal unit vectors
    // [ALIASES]: real orthogonal matrix
    isOrthogonal() {
        const MT = this.transpose();
        return this.mult(MT).isIdentity();
    }
    isRowEchelonForm() {
        let foundZeroRow = false;
        // all nonzero rows (rows with at least one nonzero element) are above any rows of all zeroes
        // (all zero rows, if any, belong at the bottom of the matrix)
        for (let i = 0; i < this.m; i++) {
            if (this.isZeroRow(i)) {
                foundZeroRow = true;
            }
            else {
                if (foundZeroRow) {
                    return false;
                }
            } // if current row is not zero, but a previous row is zero, then matrix is not in row echelon form
        }
        // the leading coefficient (the first nonzero number from the left, also called the pivot) of a nonzero row
        // is always strictly to the right of the leading coefficient of the row above it
        let previousIdx = -1;
        for (let i = 0; i < this.m; i++) {
            const currentPivotIdx = this.rowPivotPosition(i);
            if (0 > currentPivotIdx) {
                continue;
            } // this is a zero row, no pivot
            // leading coefficient must be 1
            if (!this.elements[i][currentPivotIdx].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1))) {
                return false;
            }
            if (previousIdx < currentPivotIdx) {
                previousIdx = currentPivotIdx;
            }
            else {
                return false;
            }
        }
        return true;
    }
    isReducedRowEchelonForm() {
        if (!this.isRowEchelonForm()) {
            return false;
        }
        // each leading coefficient is the only nonzero entry in its column
        for (let i = 0; i < this.m; i++) {
            const pivotPosition = this.rowPivotPosition(i);
            if (1 < this.numberOfNonZeroElementForColumn(pivotPosition)) {
                return false;
            }
        }
        return true;
    }
    toReducedRowEchelonForm() {
        const res = this.deepCopy();
        let lead = 0;
        for (let r = 0; r < res.m; r++) {
            if (res.n <= lead) {
                break;
            }
            let i = r;
            while (res.elements[i][lead].equals(0)) {
                i++;
                if (res.m === i) {
                    i = r;
                    lead++;
                    if (res.n === lead) {
                        lead--;
                        break;
                    }
                }
            }
            res.switchRows(i, r);
            if (!res.elements[r][lead].equals(0)) {
                res.multiplyRow(r, res.elements[r][lead].reciprocal());
            }
            for (let j = 0; j < res.m; j++) {
                if (j !== r) {
                    res.addRows(j, r, res.elements[j][lead].opposite());
                }
            }
            lead++;
        }
        return res;
    }
    determinant() {
        // todo: implement an optimized version, like A=PLU
        if (this.m !== this.n) {
            throw new Error("Determinant can only be calculated on a square matrix");
        }
        if (this.m === 1) {
            return this.elements[0][0];
        }
        let ret = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
        for (let i = 0; i < this.n; i++) {
            const minor = this.elements[0][i].mult(this.cofactor(0, i).determinant());
            ret = ret.add(minor.mult((-1) ** i));
        }
        return ret;
    }
    convolute(kernel) {
        if (kernel.m !== kernel.n) {
            throw new Error("Kernel is not a square matrix.");
        }
        if (kernel.m % 2 === 0) {
            throw new Error("Kernel is not an even size matrix.");
        }
        const sz = Math.floor(kernel.m / 2);
        const res = new Matrix(this.m, this.n);
        for (let i = 0; i < this.m; i++) {
            for (let j = 0; j < this.n; j++) {
                res.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
                for (let ti = 0; ti < kernel.m; ti++) {
                    if (i + ti - sz < 0 || i + ti - sz >= this.m) {
                        continue;
                    }
                    for (let tj = 0; tj < kernel.n; tj++) {
                        if (j + tj - sz < 0 || j + tj - sz >= this.n) {
                            continue;
                        }
                        res.elements[i][j] = res.elements[i][j].add(this.elements[i + ti - sz][j + tj - sz].mult(kernel.elements[ti][tj]));
                    }
                }
            }
        }
        return res;
    }
    isZeroRow(rowId) {
        for (let j = 0; j < this.n; j++) {
            if (!this.elements[rowId][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                return false;
            }
        }
        return true;
    }
    rowPivotPosition(rowId) {
        for (let j = 0; j < this.n; j++) {
            if (!this.elements[rowId][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                return j;
            }
        }
        return -1;
    }
    numberOfNonZeroElementForColumn(columnId) {
        let acc = 0;
        for (let j = 0; j < this.m; j++) {
            if (!this.elements[j][columnId].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
                acc++;
            }
        }
        return acc;
    }
    cofactor(rowId, columnId) {
        const ret = new Matrix(this.m - 1, this.n - 1);
        let rowOffset = 0;
        for (let i = 0; i < this.m - 1; i++) {
            if (i === rowId) {
                rowOffset = 1;
            }
            let columnOffset = 0;
            for (let j = 0; j < this.n - 1; j++) {
                if (j === columnId) {
                    columnOffset = 1;
                }
                ret.elements[i][j] = this.elements[i + rowOffset][j + columnOffset];
            }
        }
        return ret;
    }
}
class MatrixIdentity extends Matrix {
    constructor(m) {
        super(m, m);
        this.elements = [];
        for (let i = 0; i < this.m; i++) {
            this.elements[i] = [];
            for (let j = 0; j < this.m; j++) {
                if (i === j) {
                    this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
                }
                else {
                    this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
                }
            }
        }
    }
}
// elimination - multiply on the left (E*A); Row-addition transformations
// to mult*(row2 of Matrix A) add (row1 of Matrix A)
class MatrixElimination extends Matrix {
    constructor(m, r1, r2, mult) {
        if (m < r1 || m < r2) {
            throw new Error("Column index must be less than or equal to the matrix size.");
        }
        super(m, m);
        this.row1 = r1;
        this.row2 = r2;
        this.elements = [];
        for (let i = 0; i < this.m; i++) {
            this.elements[i] = [];
            for (let j = 0; j < this.m; j++) {
                if (i === j) {
                    this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
                }
                else {
                    this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
                }
            }
        }
        if (typeof mult === "number") {
            this.elements[r1][r2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](mult);
        }
        else {
            if (mult instanceof _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"]) {
                this.elements[r1][r2] = mult;
            }
        }
    }
}
// permutation - multiply on the right (A*P); Row-switching transformations
class MatrixPermutation extends Matrix {
    constructor(m, row1, row2) {
        if (m < row1 || m < row2) {
            throw new Error("Column index must be less than or equal to the matrix size.");
        }
        super(m, m);
        this.elements = [];
        for (let i = 0; i < this.m; i++) {
            this.elements[i] = [];
            for (let j = 0; j < this.m; j++) {
                if (i === j) {
                    this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
                }
                else {
                    this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
                }
            }
        }
        this.elements[row1][row1] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
        this.elements[row1][row2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
        this.elements[row2][row2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
        this.elements[row2][row1] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
    }
}


/***/ }),

/***/ "./src/structures/Queue.ts":
/*!*********************************!*\
  !*** ./src/structures/Queue.ts ***!
  \*********************************/
/*! exports provided: Queue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Queue", function() { return Queue; });
class Queue {
    constructor() {
        this.queue = [];
    }
    isEmpty() {
        return this.queue.length === 0;
    }
    enqueue(element) {
        this.queue.push(element);
    }
    dequeue() {
        if (this.isEmpty()) {
            throw new Error("Queue is empty");
        }
        return this.queue.shift();
    }
    peek() {
        if (this.isEmpty()) {
            throw new Error("Queue is empty");
        }
        return this.queue[0];
    }
    toArray() {
        return this.queue;
    }
}


/***/ }),

/***/ "./src/structures/RationalNumber.ts":
/*!******************************************!*\
  !*** ./src/structures/RationalNumber.ts ***!
  \******************************************/
/*! exports provided: RationalNumber */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RationalNumber", function() { return RationalNumber; });
/* harmony import */ var _ArithmeticEvaluator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArithmeticEvaluator */ "./src/structures/ArithmeticEvaluator.ts");
/* harmony import */ var _Queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Queue */ "./src/structures/Queue.ts");
/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Stack */ "./src/structures/Stack.ts");



class RationalNumber {
    constructor(n, d = 1) {
        if (d === 0) {
            throw new Error("Division by zero!");
        }
        // todo: potential for overflow. When Math.sign becomes available in TypeScript use it instead of the multiplication
        const sign = n * d >= 0 ? 1 : -1;
        this.numerator = sign * Math.abs(n);
        this.denominator = Math.abs(d);
    }
    static toReversePolishNotation(code) {
        const tokens = code.match(/\(|\)|\d+(\.\d+)?|\w+|[\+\-\*\/\^]/g);
        let i = 0;
        const outputQueue = new _Queue__WEBPACK_IMPORTED_MODULE_1__["Queue"]();
        const operatorStack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();
        while (i < tokens.length) {
            if (this.isNumber(tokens[i])) {
                outputQueue.enqueue(tokens[i]);
            }
            else if (this.isOperator(tokens[i])) {
                const op1 = tokens[i];
                while (!operatorStack.isEmpty() && this.isOperator(operatorStack.peek())) {
                    if ((this.isLeftAssociativeOperator(op1) && (this.precedence(op1) <= this.precedence(operatorStack.peek()))) ||
                        (this.isRightAssociativeOperator(op1) && (this.precedence(op1) < this.precedence(operatorStack.peek())))) {
                        outputQueue.enqueue(operatorStack.pop());
                    }
                    else {
                        break;
                    }
                }
                operatorStack.push(op1);
            }
            else if (tokens[i] === "(") {
                operatorStack.push(tokens[i]);
            }
            else if (tokens[i] === ")") {
                while (!operatorStack.isEmpty() && operatorStack.peek() !== "(") {
                    outputQueue.enqueue(operatorStack.pop());
                }
                if (!operatorStack.isEmpty() && operatorStack.peek() === "(") {
                    operatorStack.pop();
                }
                else {
                    throw new Error("Mismatched parentheses.");
                }
            }
            i++;
        }
        while (!operatorStack.isEmpty()) {
            if (operatorStack.peek() === "(") {
                throw new Error("Mismatched parentheses.");
            }
            else {
                outputQueue.enqueue(operatorStack.pop());
            }
        }
        return outputQueue.toArray();
    }
    static fromString(code) {
        const p = new _ArithmeticEvaluator__WEBPACK_IMPORTED_MODULE_0__["Parser"]();
        return p.parse(code);
    }
    static greatestCommonDivisor(a, b) {
        return b ? RationalNumber.greatestCommonDivisor(b, a % b) : a;
    }
    static leastCommonMultiple(a, b) {
        return Math.abs(a * b / RationalNumber.greatestCommonDivisor(a, b));
    }
    static isNumber(code) {
        return /^\d/.test(code);
    }
    static isOperator(code) {
        return /[\+\-\*\/\^]/.test(code);
    }
    static isLeftAssociativeOperator(operator) {
        return /[\+\-\*\/]/.test(operator);
    }
    static isRightAssociativeOperator(operator) {
        return /[\^]/.test(operator);
    }
    static precedence(operator) {
        if (/[\+\-]/.test(operator)) {
            return 1;
        }
        if (/[\*\/]/.test(operator)) {
            return 2;
        }
        if (/[\^]/.test(operator)) {
            return 3;
        }
        throw new Error("Unknown operator.");
    }
    static evaluateFromRPN(tokens) {
        const stack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();
        for (let i = 0; i < tokens.length; i++) {
            if (!this.isOperator(tokens[i])) {
                stack.push(new RationalNumber(parseFloat(tokens[i])));
            }
            else {
                const op1 = stack.pop();
                const op2 = stack.pop();
                switch (tokens[i]) {
                    case "+":
                        stack.push(op2.add(op1));
                        break;
                    case "-":
                        stack.push(op2.sub(op1));
                        break;
                    case "*":
                        stack.push(op2.mult(op1));
                        break;
                    case "/":
                        stack.push(op2.div(op1));
                        break;
                    case "^":
                        stack.push(op2.exp(op1.toNumber()));
                        break;
                }
            }
        }
        return stack.pop().simplifiedForm();
    }
    simplifiedForm() {
        const gcd = RationalNumber.greatestCommonDivisor(this.numerator, this.denominator);
        return new RationalNumber(this.numerator / gcd, this.denominator / gcd);
    }
    equals(x) {
        const rn1 = this.simplifiedForm();
        if (typeof x === "number") {
            return rn1.numerator === x && rn1.denominator === 1;
        }
        else {
            const rn2 = x.simplifiedForm();
            return rn1.numerator === rn2.numerator && rn1.denominator === rn2.denominator;
        }
    }
    lt(x) {
        const rn1 = this.simplifiedForm();
        if (typeof x === "number") {
            return rn1.numerator < x * rn1.denominator;
        }
        else {
            const rn2 = x.simplifiedForm();
            return rn1.numerator * rn2.denominator < rn2.numerator * rn1.denominator;
        }
    }
    le(x) {
        const rn1 = this.simplifiedForm();
        if (typeof x === "number") {
            return rn1.numerator <= x * rn1.denominator;
        }
        else {
            const rn2 = x.simplifiedForm();
            return rn1.numerator * rn2.denominator <= rn2.numerator * rn1.denominator;
        }
    }
    gt(x) {
        const rn1 = this.simplifiedForm();
        if (typeof x === "number") {
            return rn1.numerator > x * rn1.denominator;
        }
        else {
            const rn2 = x.simplifiedForm();
            return rn1.numerator * rn2.denominator > rn2.numerator * rn1.denominator;
        }
    }
    ge(x) {
        const rn1 = this.simplifiedForm();
        if (typeof x === "number") {
            return rn1.numerator >= x * rn1.denominator;
        }
        else {
            const rn2 = x.simplifiedForm();
            return rn1.numerator * rn2.denominator >= rn2.numerator * rn1.denominator;
        }
    }
    // multiplicative inverse
    reciprocal() {
        if (this.denominator === 0) {
            throw new Error("Division by zero!");
        }
        return new RationalNumber(this.denominator, this.numerator);
    }
    // additive inverse
    opposite() {
        return new RationalNumber(this.numerator * (-1), this.denominator);
    }
    add(x) {
        if (typeof x === "number") {
            return new RationalNumber((this.numerator + x * this.denominator), this.denominator);
        }
        else {
            const lcm = RationalNumber.leastCommonMultiple(this.denominator, x.denominator);
            const n1 = this.numerator * lcm / this.denominator;
            const n2 = x.numerator * lcm / x.denominator;
            return new RationalNumber(n1 + n2, lcm);
        }
    }
    sub(x) {
        if (typeof x === "number") {
            return new RationalNumber((this.numerator - x * this.denominator), this.denominator);
        }
        else {
            const lcm = RationalNumber.leastCommonMultiple(this.denominator, x.denominator);
            const n1 = this.numerator * lcm / this.denominator;
            const n2 = x.numerator * lcm / x.denominator;
            return new RationalNumber(n1 - n2, lcm);
        }
    }
    mult(x) {
        if (typeof x === "number") {
            return new RationalNumber((this.numerator * x), this.denominator);
        }
        else {
            return new RationalNumber((this.numerator * x.numerator), x.denominator * this.denominator);
        }
    }
    div(x) {
        if (typeof x === "number") {
            return new RationalNumber((this.numerator), this.denominator * x);
        }
        else {
            return new RationalNumber((this.numerator * x.denominator), x.numerator * this.denominator);
        }
    }
    exp(x) {
        if (typeof x === "number") {
            return new RationalNumber(this.numerator ** x, this.denominator ** x);
        }
        else {
            if (this.denominator !== 1) {
                throw Error("Exponentiation with rational powers not supported.");
            }
            return new RationalNumber(this.numerator ** x.numerator, this.denominator ** x.numerator);
        }
    }
    toNumber() {
        return this.numerator / this.denominator;
    }
    toString() {
        return this.numerator.toString() + (1 === this.denominator ? "" : "/" + this.denominator.toString());
    }
    deepCopy() {
        return new RationalNumber(this.numerator, this.denominator);
    }
}


/***/ }),

/***/ "./src/structures/Stack.ts":
/*!*********************************!*\
  !*** ./src/structures/Stack.ts ***!
  \*********************************/
/*! exports provided: Stack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stack", function() { return Stack; });
class Stack {
    constructor() {
        this.stack = [];
    }
    isEmpty() {
        return this.stack.length === 0;
    }
    push(element) {
        this.stack.push(element);
    }
    pop() {
        if (this.isEmpty()) {
            throw new Error("Stack is empty");
        }
        return this.stack.pop();
    }
    peek() {
        if (this.isEmpty()) {
            throw new Error("Stack is empty");
        }
        return this.stack[this.stack.length - 1];
    }
    toArray() {
        return this.stack;
    }
}


/***/ }),

/***/ "./src/structures/Vector.ts":
/*!**********************************!*\
  !*** ./src/structures/Vector.ts ***!
  \**********************************/
/*! exports provided: Vector, ColumnVector, RowVector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return Vector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColumnVector", function() { return ColumnVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RowVector", function() { return RowVector; });
/* harmony import */ var _Matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix */ "./src/structures/Matrix.ts");
/* harmony import */ var _RationalNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RationalNumber */ "./src/structures/RationalNumber.ts");


class Vector {
    constructor(n) {
        if (typeof n === "number") {
            this.m = n;
            this.elements = [];
        }
        else if (n instanceof Array) {
            this.m = n.length;
            this.elements = [];
            for (let i = 0; i < this.m; i++) {
                this.elements[i] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](n[i]);
            }
        }
    }
    static areLinearlyIndependent(vectors) {
        const m = vectors.length;
        if (0 === m) {
            return true;
        }
        const n = vectors[0].m;
        for (let i = 1; i < vectors.length; i++) {
            if (n !== vectors[i].m) {
                throw new Error("Mismatched dimensions.");
            }
        }
        if (m > n) {
            return false;
        }
        throw new Error("Not implemented.");
    }
    add(x) {
        if (this.m !== x.m) {
            throw new Error("Mismatched dimensions.");
        }
        const res = new Vector(this.m);
        for (let i = 0; i < res.m; i++) {
            res.elements[i] = this.elements[i].add(x.elements[i]);
        }
        return res;
    }
    sub(x) {
        if (this.m !== x.m) {
            throw new Error("Mismatched dimensions.");
        }
        const res = new Vector(this.m);
        for (let i = 0; i < res.m; i++) {
            res.elements[i] = this.elements[i].sub(x.elements[i]);
        }
        return res;
    }
    mult(x) {
        const res = new Vector(this.m);
        for (let i = 0; i < res.m; i++) {
            res.elements[i] = this.elements[i].mult(x);
        }
        return res;
    }
    // [ALIASES]: innerProduct, projectionProduct, scalarProduct
    dotProduct(x) {
        if (this.m !== x.m) {
            throw new Error("Mismatched dimensions.");
        }
        let res = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        for (let i = 0; i < x.m; i++) {
            res = res.add(this.elements[i].mult(x.elements[i]));
        }
        return res;
    }
    // [ALIASES]: directedAreaProduct, vectorProduct
    crossProduct(x) {
        throw new Error("Not implemented.");
    }
    // [ALIASES]: magnitude, norm
    length() {
        const length = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        for (let i = 0; i < this.m; i++) {
            length.add(this.elements[i]);
        }
        return length;
    }
    deepCopy() {
        const ret = new Vector(this.m);
        for (let i = 0; i < this.m; i++) {
            ret.elements[i] = this.elements[i];
        }
        return ret;
    }
    toMatrix() {
        const ret = new _Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](this.m, 1);
        for (let i = 0; i < this.m; i++) {
            ret.elements[i][0] = this.elements[i];
        }
        return ret;
    }
}
class ColumnVector extends Vector {
}
class RowVector extends Vector {
    matrixProduct(m) {
        if (this.m !== m.n) {
            throw new Error("Mismatched dimensions.");
        }
        const res = new RowVector(this.m);
        for (let i = 0; i < this.m; i++) {
            let sum = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
            for (let j = 0; j < m.n; j++) {
                sum = sum.add(m.elements[i][j].mult(this.elements[i]));
            }
            res.elements[i] = sum;
        }
        return res;
    }
}


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXhlcmNpc2VzL2ltYWdlUHJvY2Vzc2luZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9Bcml0aG1ldGljRXZhbHVhdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9zdHJ1Y3R1cmVzL01hdHJpeC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9RdWV1ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9SYXRpb25hbE51bWJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9TdGFjay50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9WZWN0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSxLQUEwQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxZQUFZOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsSUFBSTs7QUFFcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUSw2QkFBNkI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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aEU7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFLHNDQUFzQywyQkFBMkI7QUFDakU7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksdUVBQXVFO0FBQ25GO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFFBQVEsR0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLDBCQUEwQix3QkFBd0I7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxzQ0FBc0M7QUFDOUUsb0NBQW9DLHVDQUF1QztBQUMzRSxvQ0FBb0Msc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNK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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGNBQWMscUNBQXFDO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QixXQUFXLGtCQUFrQjtBQUM3QixjQUFjO0FBQ2QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLG1CQUFtQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztB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QUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxzREFBc0Q7QUFDcEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxjQUFjLG1DQUFtQztBQUNqRCxlQUFlLDZEQUE2RDtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxJQUEwQztBQUMvQyxDQUFDLGlDQUFrQixFQUFFLG1DQUFFO0FBQ3ZCO0FBQ0EsRUFBRTtBQUFBLG9HQUFFO0FBQ0o7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUNyMlVEO0FBQUE7QUFBQTtBQUE4QztBQUNnQjtBQUU5RCxTQUFTLGVBQWUsQ0FBQyxTQUFvQjtJQUM1QyxNQUFNLElBQUksR0FBVyxJQUFJLHlEQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbkUsTUFBTSxJQUFJLEdBQVcsSUFBSSx5REFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ25FLE1BQU0sSUFBSSxHQUFXLElBQUkseURBQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNuRSxNQUFNLElBQUksR0FBVyxJQUFJLHlEQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbkUsSUFBSSxHQUFHLEdBQVcsQ0FBQyxDQUFDO0lBQ3BCLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFHO1FBQ2xELElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDdkQsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLHlFQUFjLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDaEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLHlFQUFjLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDaEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLHlFQUFjLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDaEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLHlFQUFjLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDaEU7S0FDRDtJQUNELE9BQU8sQ0FBQyxJQUFJ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RUFBRSxDQUFDO0lBQ25CLENBQUM7SUFDTyxRQUFRLENBQUMsS0FBYTtRQUM3QixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDckIsT0FBTyxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDakM7UUFDRCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDckIsT0FBTyxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDbEM7UUFDRCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDckIsT0FBTyxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDckM7UUFDRCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDckIsT0FBTyxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDbkM7UUFDRCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDckIsT0FBTyxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDckM7UUFDRCxJQUFJLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDOUIsT0FBTyxJQUFJLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQ3REO1FBQ0QsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLE9BQU8sSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ25DO1FBQ0QsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLE9BQU8sSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ25DO1FBQ0QsT0FBTyxJQUFJLEtB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QUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3hDLEtBQUssSUFBSSxDQUFDLEdBQVcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUN4QyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksOERBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDM0MsS0FBSyxJQUFJLEVBQUUsR0FBVyxDQUFDLEVBQUUsRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUU7b0JBQzdDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDLEVBQUU7d0JBQzdDLFNBQVM7cUJBQ1Q7b0JBQ0QsS0FBSyxJQUFJLEVBQUUsR0FBVyxDQUFDLEVBQUUsRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUU7d0JBQzdDLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDLEVBQUU7NEJBQzdDLFNBQVM7eUJBQ1Q7d0JBQ0QsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7cUJBQ25IO2lC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QUFFLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3hDLElBQUksR0FBRyxHQUFtQixJQUFJLDhEQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEQsS0FBSyxJQUFJLENBQUMsR0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3JDLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3ZEO1lBQ0QsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7U0FDdEI7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNaLENBQUM7Q0FDRCIsImZpbGUiOiIuL2ltYWdlUHJvY2Vzc2luZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2V4ZXJjaXNlcy9pbWFnZVByb2Nlc3NpbmcudHNcIik7XG4iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNC4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxOS0wNS0wMVQyMTowNFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy40LjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zICkge1xuXHRcdERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9ICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjRcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMTktMDQtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJodG1sID0gL0hUTUwkL2ksXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDggb25seVxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHQobm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbmFtZXNwYWNlID0gZWxlbS5uYW1lc3BhY2VVUkksXG5cdFx0ZG9jRWxlbSA9IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/XG5cdFx0XHRcdGFyZ3VtZW50ICsgbGVuZ3RoIDpcblx0XHRcdFx0YXJndW1lbnQgPiBsZW5ndGggP1xuXHRcdFx0XHRcdGxlbmd0aCA6XG5cdFx0XHRcdFx0YXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmNvbnRlbnREb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4vLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91cywgZXhjZXB0IHdoZW4gdGhleSBhcmUgbm8tb3AuXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbi8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuLy8gKGZvY3VzIGFuZCBibHVyIGFyZSBhbHdheXMgc3luY2hyb25vdXMgaW4gb3RoZXIgc3VwcG9ydGVkIGJyb3dzZXJzLFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuZnVuY3Rpb24gZXhwZWN0U3luYyggZWxlbSwgdHlwZSApIHtcblx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFwiZm9jdXNcIiApO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhaXNBdHRhY2hlZCggZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXIgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlLFxuXHR2ZW5kb3JQcm9wcyA9IHt9O1xuXG4vLyBSZXR1cm4gYSB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdIHx8IHZlbmRvclByb3BzWyBuYW1lIF07XG5cblx0aWYgKCBmaW5hbCApIHtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH1cblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH07XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEgb25seVxuXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlXG5cdC8vIFdlIHVzZSBnZXRDbGllbnRSZWN0cygpIHRvIGNoZWNrIGZvciBoaWRkZW4vZGlzY29ubmVjdGVkLlxuXHQvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3hcblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSAmJlxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwiZ3JpZEFyZWFcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5cIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1wiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0gRGF0ZS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucyApO1xuXHRcdH1cblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcblx0XHRcdFx0XHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG5cdFx0XHRcdFx0Lm9uKCBcImxvYWQgZXJyb3JcIiwgY2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vc3RydWN0dXJlcy9NYXRyaXhcIjtcclxuaW1wb3J0IHsgUmF0aW9uYWxOdW1iZXIgfSBmcm9tIFwiLi4vc3RydWN0dXJlcy9SYXRpb25hbE51bWJlclwiO1xyXG5cclxuZnVuY3Rpb24gaW1hZ2VEYXRhVG9SR0JBKGltYWdlRGF0YTogSW1hZ2VEYXRhKTogW01hdHJpeCwgTWF0cml4LCBNYXRyaXgsIE1hdHJpeF0ge1xyXG5cdGNvbnN0IGltZ1I6IE1hdHJpeCA9IG5ldyBNYXRyaXgoaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcclxuXHRjb25zdCBpbWdHOiBNYXRyaXggPSBuZXcgTWF0cml4KGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XHJcblx0Y29uc3QgaW1nQjogTWF0cml4ID0gbmV3IE1hdHJpeChpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xyXG5cdGNvbnN0IGltZ0E6IE1hdHJpeCA9IG5ldyBNYXRyaXgoaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcclxuXHRsZXQgaWR4OiBudW1iZXIgPSAwO1xyXG5cdGZvciAobGV0IHg6IG51bWJlciA9IDA7IHggPCBpbWFnZURhdGEud2lkdGg7IHgrKyApIHtcclxuXHRcdGltZ1JbeF0gPSBbXTsgaW1nR1t4XSA9IFtdOyBpbWdCW3hdID0gW107IGltZ0FbeF0gPSBbXTtcclxuXHRcdGZvciAobGV0IHk6IG51bWJlciA9IDA7IHkgPCBpbWFnZURhdGEuaGVpZ2h0OyB5KyspIHtcclxuXHRcdFx0aW1nUi5lbGVtZW50c1t4XVt5XSA9IG5ldyBSYXRpb25hbE51bWJlcihpbWFnZURhdGEuZGF0YVtpZHgrK10pO1xyXG5cdFx0XHRpbWdHLmVsZW1lbnRzW3hdW3ldID0gbmV3IFJhdGlvbmFsTnVtYmVyKGltYWdlRGF0YS5kYXRhW2lkeCsrXSk7XHJcblx0XHRcdGltZ0IuZWxlbWVudHNbeF1beV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoaW1hZ2VEYXRhLmRhdGFbaWR4KytdKTtcclxuXHRcdFx0aW1nQS5lbGVtZW50c1t4XVt5XSA9IG5ldyBSYXRpb25hbE51bWJlcihpbWFnZURhdGEuZGF0YVtpZHgrK10pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gW2ltZ1IsIGltZ0csIGltZ0IsIGltZ0FdO1xyXG59XHJcbmZ1bmN0aW9uIGltYWdlRGF0YUZyb21SR0JBKHJnYmE6IFtNYXRyaXgsIE1hdHJpeCwgTWF0cml4LCBNYXRyaXhdKTogSW1hZ2VEYXRhIHtcclxuXHRjb25zdCBpbWdSOiBNYXRyaXggPSByZ2JhWzBdO1xyXG5cdGNvbnN0IGltZ0c6IE1hdHJpeCA9IHJnYmFbMV07XHJcblx0Y29uc3QgaW1nQjogTWF0cml4ID0gcmdiYVsyXTtcclxuXHRjb25zdCBpbWdBOiBNYXRyaXggPSByZ2JhWzNdO1xyXG5cdGNvbnN0IHdpZHRoOiBudW1iZXIgPSBpbWdSLm07XHJcblx0Y29uc3QgaGVpZ2h0OiBudW1iZXIgPSBpbWdSLm47XHJcblx0Y29uc3QgaW1hZ2VEYXRhOiBJbWFnZURhdGEgPSBuZXcgSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xyXG5cdGxldCBpZHg6IG51bWJlciA9IDA7XHJcblx0Zm9yIChsZXQgeDogbnVtYmVyID0gMDsgeCA8IHdpZHRoOyB4KysgKSB7XHJcblx0XHRmb3IgKGxldCB5OiBudW1iZXIgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuXHRcdFx0aW1hZ2VEYXRhLmRhdGFbaWR4KytdID0gaW1nUi5lbGVtZW50c1t4XVt5XS50b051bWJlcigpO1xyXG5cdFx0XHRpbWFnZURhdGEuZGF0YVtpZHgrK10gPSBpbWdHLmVsZW1lbnRzW3hdW3ldLnRvTnVtYmVyKCk7XHJcblx0XHRcdGltYWdlRGF0YS5kYXRhW2lkeCsrXSA9IGltZ0IuZWxlbWVudHNbeF1beV0udG9OdW1iZXIoKTtcclxuXHRcdFx0aW1hZ2VEYXRhLmRhdGFbaWR4KytdID0gaW1nQS5lbGVtZW50c1t4XVt5XS50b051bWJlcigpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gaW1hZ2VEYXRhO1xyXG59XHJcblxyXG4kKGRvY3VtZW50KS5yZWFkeSgoKSA9PiB7XHJcblx0Y29uc3QgY2FudmFzMTogSFRNTENhbnZhc0VsZW1lbnQgPSAkKFwiI2NhbnZhczFcIilbMF0gYXMgSFRNTENhbnZhc0VsZW1lbnQ7XHJcblx0Y29uc3QgY3R4MTogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gY2FudmFzMS5nZXRDb250ZXh0KFwiMmRcIik7XHJcblx0Y29uc3QgaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcclxuXHRpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XHJcblx0XHRjYW52YXMxLmhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuXHRcdGNhbnZhczEud2lkdGggPSBpbWFnZS53aWR0aDtcclxuXHRcdGN0eDEuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcclxuXHRcdGNvbnN0IGltZ0RhdGExOiBJbWFnZURhdGEgPSBjdHgxLmdldEltYWdlRGF0YSgwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcclxuXHRcdGNvbnN0IHJnYmEgPSBpbWFnZURhdGFUb1JHQkEoaW1nRGF0YTEpO1xyXG5cdFx0Ly8gZHVwbGljYXRlXHJcblx0XHRjb25zdCBpbWdEYXRhMjogSW1hZ2VEYXRhID0gaW1hZ2VEYXRhRnJvbVJHQkEocmdiYSk7XHJcblx0XHRjb25zdCBjYW52YXMyOiBIVE1MQ2FudmFzRWxlbWVudCA9ICQoXCIjY2FudmFzMlwiKVswXSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcclxuXHRcdGNvbnN0IGN0eDI6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IGNhbnZhczIuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cdFx0Y2FudmFzMi5oZWlnaHQgPSBpbWdEYXRhMi5oZWlnaHQ7XHJcblx0XHRjYW52YXMyLndpZHRoID0gaW1nRGF0YTIud2lkdGg7XHJcblx0XHRjdHgyLnB1dEltYWdlRGF0YShpbWdEYXRhMiwgMCwgMCk7XHJcblx0XHQvLyBjb252b2x1dGVcclxuXHRcdGNvbnN0IGNhbnZhczM6IEhUTUxDYW52YXNFbGVtZW50ID0gJChcIiNjYW52YXMzXCIpWzBdIGFzIEhUTUxDYW52YXNFbGVtZW50O1xyXG5cdFx0Y29uc3QgY3R4MzogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gY2FudmFzMy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblx0XHRjb25zdCBrZXJuZWw6IE1hdHJpeCA9IG5ldyBNYXRyaXgoMywgMyk7XHJcblx0XHQvKlxyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzBdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzBdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoNSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdCovXHJcblx0XHQvKlxyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzBdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMF1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzFdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcig4KTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMl1bMF0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHQqL1xyXG5cdFx0LypcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcigxKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdC8vKi9cclxuXHRcdC8vKlxyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzBdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzBdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoNCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdC8vKi9cclxuXHRcdC8vIGNvbnN0IG5ld1JnYmE6IFtNYXRyaXgsIE1hdHJpeCwgTWF0cml4LCBNYXRyaXhdID0gW3JnYmFbMF0uY29udm9sdXRlKGtlcm5lbCksIHJnYmFbMV0uY29udm9sdXRlKGtlcm5lbCksIHJnYmFbMl0uY29udm9sdXRlKGtlcm5lbCksIHJnYmFbM10uY29udm9sdXRlKGtlcm5lbCldO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHJnYmFbMF0ubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCByZ2JhWzBdLm47IGorKykge1xyXG5cdFx0XHRcdHJnYmFbMF0uZWxlbWVudHNbaV1bal0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRcdFx0cmdiYVsyXS5lbGVtZW50c1tpXVtqXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Y29uc3QgbmV3UmdiYTogW01hdHJpeCwgTWF0cml4LCBNYXRyaXgsIE1hdHJpeF0gPSBbcmdiYVswXSwgcmdiYVsxXS5jb252b2x1dGUoa2VybmVsKSwgcmdiYVsyXSwgcmdiYVszXV07XHJcblx0XHRjb25zdCBpbWdEYXRhMzogSW1hZ2VEYXRhID0gaW1hZ2VEYXRhRnJvbVJHQkEobmV3UmdiYSk7XHJcblx0XHRjYW52YXMzLmhlaWdodCA9IGltZ0RhdGEzLmhlaWdodDtcclxuXHRcdGNhbnZhczMud2lkdGggPSBpbWdEYXRhMy53aWR0aDtcclxuXHRcdGN0eDMucHV0SW1hZ2VEYXRhKGltZ0RhdGEzLCAwLCAwKTtcclxuXHR9O1xyXG5cdGltYWdlLnNyYyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LFwiICsgZW5jb2RlZEltZztcclxuXHJcblx0Ly8gT3RoZXIgd2F5cyBvZiBkb2luZyBpdFxyXG5cdGNvbnN0IGltZ1NyYzogc3RyaW5nID0gJChcIiNpbWdTb3VyY2VcIikuYXR0cihcInNyY1wiKS5yZXBsYWNlKFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LFwiLCBcIlwiKTtcclxuXHRjb25zdCBiaW5TcmM6IHN0cmluZyA9IGF0b2IoaW1nU3JjKTtcclxuXHRjb25zdCBpbWcgPSBVaW50OEFycmF5LmZyb20oYmluU3JjLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKTtcclxuXHQvLyByZXZlcnNlXHJcblx0bGV0IGJpbkRlc3Q6IHN0cmluZyA9IFwiXCI7XHJcblx0Zm9yIChjb25zdCBpIG9mIGltZykge1xyXG5cdFx0YmluRGVzdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xyXG5cdH1cclxuXHQvLyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGltZyk7IC8vIHRocm93dyBcIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCJcclxuXHRjb25zdCBpbWdEZXN0ID0gYnRvYShiaW5EZXN0KTtcclxuXHQkKFwiI2ltZ0Rlc3RpbmF0aW9uXCIpLmF0dHIoXCJzcmNcIiwgXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsXCIgKyBpbWdEZXN0KTtcclxuXHJcbn0pO1xyXG5cclxuY29uc3QgZW5jb2RlZEltZzogc3RyaW5nID0gXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBUG9BQUFGUUNBSUFBQUFaZnZSV0FBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQVArbFNVUkJWSGhlaFAxbmxHMWJkdCtIblhQMnlhSHFWSzZiNDh2ZDc3Mk9hQURkUURjYXFRRTAwQkVFbzZVdi91SnY5dEFIeWFac2s3U0dMRXV5UEtoQnlUWXBXUmlNSWlXQkpBZ1NBSWxNQUkxdW9GKy8yQy9lOEc2c1c3bE9uUno4Ly8zbk9uWHJOVUI3MVQ1cnp6WFhYSFBOdE9aZWU1OVErZi9QZi9jL0ZncTVmRDVmS0dSVWhYdzA4dm1aeis3TGc5U1I1WXpKcVRmM0dKL0x6V2prMURVVFduOWdadm1aNmNRb2x4TnJGWHBWejNUT1RhbW5FT28xbStXbk14cXFwc0xFb2FZcW5jWWFOWjJxT1JHbGgwZjl1SncwVHcxVEVScGhOTnh5QWVlUVFqM1N3azFLQUJLTUU2elJ4OElabkNKU2Jpb0pOSmFCbEdub0lmNVNYTG95QXhielVKM3p0a1YrSXNRVVUrZ1B4RXk4YU1KTkdIVk5KOEhOSW9KU3hRUXcxNUJwU08wQ2U2dHlVb1V3TTd4bURQNno5OVNVUTRXQ0lnUnlnZnhVc1E0cTRPZXd4Wm9YTitmb09RYURpQ1NwSmdXZ3QrT3N5elM0alQzSU00clNCbVNFdFVNVUxJTEZva0JtdkdveCt4NUpZOTRQUUQ1aHpBK09qYUpRVVkwTHNDMTF3UG4vL3UvOGZVbGpLeEdURHRDd0RxaUF3cEVGRVRCQ05zN3djc0hFb2loa0NvUUNEbk16YjAvWkZXbWk0T1VlUnRoSldBZ3I2RVJSdUFmT0FXVFJhRkFwOEF3S0ZqRHZzTHIwbWlOZGpJUnpkRWNSYUFKaEhGRHprczlsU1RvS2tSdWo5RW9uajFXWk1QbThGOEdrUk1GdE9RNE9pYnNPcjJkenRXVkNXd2tnQWdWSXNJdElRa1l4NDh3ODdvSTBtc0VpcjdoM2d4YkZpaWo2VTBsWTQwOUtoTHM2NXdEbGhPYUVQZ0FWNXZic0p5VXdLaWR3ckhhdnd6azlXSjBtOXBwaUhLVVVUMTRFaUN4QzBhakxLQVlDNGtvTVFFUFMrWHdpMkdtcFRrb2cwMEFPUE9CeElIMm1uT1l3eHlPSnhCUHlBK0grUC94M2YwOG44Vk1IUlZnTVJSY3ZsNUJ1RGd1cGxCL1dGRElTdDBwa0dxQVF5UTdYYWFiNWxHZm16RkxZaGJZV0R3R3RTWXlhQ3l5SmZjSnlCQWZnU1hFUHhSS3Bnd29vd1I4b1RLcGkyWG1KUUJlcXh5WEMzVFBKSGN5aXhSc29oYnRkNk1pbDEyUHBtbnNSbnByQWtLVGt6L1pLa2lHUFpsYlFhR2pTRWNBZDVNbDVnMUNtRTM2MFFtRVdWYkk4RjlmYzFGZlhaRXBUVTA0SHQ0cGEzNE5SRVZuVXA0dFZpMWtwMGFRZ0kwM0VEc1M4SHp4NVdoMTBJU2RvQ0hUeGxYQUJCM1djVUdmZURPVWlWVVRRZ1hTdElGR29DUGFsajNKYTREUmNzNTRLRVJYVFFGOG9GR2xQdkN4dFdWbjdOQWVZLytKLy8vY0ZhWExoK1ZPeFR3eWIyRU1BNGhVa0R2YzV4TjlNTDFPb0VCdWEzakNpS2Rta3NURXFxQ3pXWEc2b3d0c1cwZmpvVXBZelFLQUpIY2dZYURoTjZUcVZpTldRMngwUlVKYkswd3VicEZOQnZzUVBCK0tKeU44dVlmclVVQ3NZZ0tMaUZQSmFMNXp0VHN3aWs4ZnNqemN6cVZNbHVNMEZCY0ZRUTVFM2hEYVczS1FKWExDaWo0U0RPQ3IxemVQYkFLaVRoUkZkQWFzK0tUSDVDWHlDb1NEdnFhYUtXdEkrQ1NWQUw5VU1FOU1na2FVMEpTdFlTQkR3WU1wZ0ZVZzFuVXlVTWlFN0paaXRsMHlpNWdrK1NpRFZqVDhFdUlZbk5JRkQzOGppMnN6WWo4Q25TLzd2L3VJLzlDd3hxNFZOVk13ZTg4YWtObmZNWXEzVFRBa3YwQUJUcGw1ckYwRXNwWWw1Um9qUU5JSFhCQkF4QmlONEdGV3dTSnlTSEtmcUFDbndvMFFiMkVZK3dhZ0VRUlRQVDUza05LTmtZZ2M3b3lhUnQrYlJTSVp6UnBrWE5SSlhWZG9rcHJaNXk0c2FKKzZuWjJXTStEMFd5ZnlGbDFQc2U0RVc3TVFSYWI2dzNrbmdxaEFsai8wUVhUUUVHTmErbEJMRTMxTmlpSXJnSk1DOER1QUVWakdja3J1eEU2RjBLZ2hESHFlYzBBc1F6N2xXYmtJR3BGbk5JNFdWd3g4cmNYSTVFU3lVRkpYSmt5bkEyNSsyM3VNVW1TTEVkeW1jbVNqQk1Uemc3eW41di85My81RVhUT0l1TzUwUWFrd3dDSXhoOWJvVjRjTE9FclJxbCtTSCtXU25SNHNHWnhoZ0kzR2FBalU4TXMybnM2RzV2aDlRd0lDYjdrMGtJblcvMkNCaC9LbWtRWE5HOUZQQ3RuaGt6aHhkNVZ4N3hsbnI4WTJ4WHNKRW1vOVJhdHNBTkxpWFRKYUc4UWwzUnB0RXV6MkI2a2tpVVNJQW5QMExvUkZGQXpWYURUT0J4aXlwSXBRRlpEd3ZnTlE5cHJRbzh4QlBnT21qOXdPRmFlYmxaRjVrTVh4U0J6Q2RKaE9RQlNJRjhGSTE5cG1XT0FaOFV0UUVveUhoRTBaekR2MC9JSUVsUEttUldEUWVCUWRNaG1XNVRxck5USk1nK0o0aWd1Q2lpb0YvcXB3ZzgvL2c3LzFEVFVibVYzbE1DU1NhUWx3bS9EaUN5NnBMbkMyVFFPUUtjVlgrVk1TbkVxMmdPaUVPVGlqa2lRUHYrbnZHUnBNNjRJVHd6UnpuK1VEaDRVWi80aEQwNlhwaVFXbUJFckVhQkxoZ2FSL1JIUDVsdis2QUpQenRaNW5VcEppYkk2MTJkYW9FZTZPdGpFd1FUUldrZ1Z5VWNmVktNalBPSzBXbklHT3NSYU1aS3lUYVlWTUsrSGxoeW5uLzkrNWI1cUdmaXJwT1IzK2FjUTZvQ0FqNGd4Z3BMRXNJbHRZUnMwWkxNTWlVRGRCRmZJVVJRTU1CNFRPMEdrR0luK0twV3ZORzg2UUVobnpQY0NKYzNvZ3VsZm5kOEdNbW9rNE5CN3BLY0NBKzVlSlRzM3pQMUNyWjE3LzJWWjNzSkJsRmRHcWxCMXNDR0FiS2UxMkQrREt4RWd1TXFFNnBCcENRcVRiR2pkUjhiREtHbU1DMUtlWkRUT0dSOCtJdW45T2drNHF6Sk1SR1pvS2tSczZIZkUvQndlN0JaR2psbU5ZSTQxM0ErWTlBbjB6dDA2QUNZK2REWXhTWWt5S3U2dlZBczZOaEdaVXF3SG9hMFRQRVdWTVc4empMUG84V1l6alQwa3NGNzZkTHllbUMzdFlYNkhRNzZoT015a2t6Z05NbHplVDZnd1ZKeUtxSUdRWndsVHF0VG9BdVlpNGlUYUFqTU5Hcmhxcy96ZjhEOGdnV1JUS2M5SFhjbzNrRXQwK3FFckh2aFRRR09GQXVRcW9aVGxIemhGNEZtREd6L1AvNEQ4anVIcHJtRC9LVFZmdW5pbWJtMlJPZ1Z5OHZUdTVNcTlHUTd2ZDhSVGpobzVXck9hSWxlaStxeHpQSDlITXBLQUp0eE9oZ1JvSnBYa1FwemlmMHB3ZXF4S1RRbkZ5VmpCU1Zvd2VrbXNRaFo0cVlSOUVReDYzZFROaGFqQkFiVlZVREl0TmoxWUlsNGpHcFlFMWprVUorWG5TTFFKMXdWc2FGMndmM2o2ZlZDWmNEdUFRdUVuY2ljQkhzNUowdUFvV01wQ1U0Y254UW50U25nVkFoQUNSQUw1MVY2U1FENkNwbm81eGtkM3E1b2RGaVpmMlI5ajArUnVNcFFMTUJvNUlYS1UyaVJDZ3Blakk3aWRtS004d0ZEbjUwR0hvTEk5ZEZQQWxRYitUeVAxMDA1R1JHeVh0S1FRcFM2V1NDN09lLzlqVlA4QUVLRlNIVHNPL3BJdG85M2oxbzUzZFVvcUF5aXVIVTBES3BsQ2hBdVdIZ05KNDBrcUFBVkJKTVVObllwN3ErcHlSUjUwV1VKeGdOQ2pnTnQyVUNESXhxMlNpQUtMcUVNMStFdTAvS3gxWXJJU05QQ3dUZzVORkVpUGlvU1o3eTlvamhJdERabTNuM0c0bEk1blF5TFR3TUc2Q0l1OGlpSkpSdDd2b3hNZ0RhUkQzbW5tOWQ2QTA0Mko0TWNTRVo4cWVTT2tSek1qdVNJUEJjWWhxMmhCb2lGbGFZSUJYa2l0TmpwR0hiQ0hNd0VZc2tyV3ltMDZReE1EQTZtVE5GRnJSa3dsR2ZNRDNGL0lPNi9MdEtFdE1NT0xKZitOclhOVkNETlZvSG0wd0xGK3prRTRscEFoMlJXRHlOR2lFS0RRaGtWOEgwSWJUdXZ5Q0t1VXpsVVJZMzJuUEZRNVRUeGVKSlVCbkRjZUxGSTdUWG1WOVJRc0pUSlpxUEExMEZnUm1IMm9HeGZweGpYdFdFSlZrQmpBdHg2SUFtUU9OMlRYUU9aazdHYSt2S0xQQU9Zby8zVlo1RjRIa000bW9QWXlwakdXNWhhTThQV1NPUUxoYmIvT2ZibUZPWUtBSnQ5ZzhVUi9EajNnUkZEY3BGNlNQUXdXemVOVCs4TEkweHNZb3NrS3dRK2pQUzJzNko1aVVXdUs2bnFybisrK3FBSkhZTk9EdENjeW8rTUV4b3JKdHZERUNzaTBtU1dWM0pLaEFKMEtGWTFDaDIrZi91RXZSUnpEQUJLb0t6UDBlNHcxWnQzVXdKcWVrNHFLQUxXVjFPZ01CVE5PQUVOdThUR2h0UEpkRkZ3UGtJMlkyTkkyWW5OT2dOUENWaDBtR0IvbitXMDM0OWdRVkVzVGpCK1lRTVNodklVQXI1Y0dyQWN3cGl3Q2NMbzJKV1lGd2pweWtjRmNTRi9JSkR3YWZZTU5uamdmUWxnRWNGRTlYUlpXSHBDZzFVRzBPaFBTOEpFNFBtdWtjdDg3b3pMUlZQSWFUaGhKQ2RZNERsQ1MxWm5UNmZLQzlBTm5Hb2U2MURFa3pWU0FGcWZtYkRRQUdocHNpRFRoUnByVHUrTlFhWVB3ZUNTbExVOUNjcVVCSkd4Y05EMk1mSUtFbUdlVW1VaWFOaHdJUlh1T3RXbGZpVEdCSFo2TU1aR1JQM0dPR1RwM1RMTWdzVmgvUlBXTDB3alNMQTlPbjZFQnZMTUxIL1RoZllKQkgvcktJT2pZeUpJUXJSV2VYZk93Ujh6Q09hZkM0em9ZZzR4U3hxZXJpcXgzV2tKUURKUFg4ZWtRcmlnM1lQNkhnaU1jMk5TWVMrS2dReE42cE1CQmlHWTZjdUdRMmFSRmdBWkltV3lWUjdNUXEwYWRTRnNtekJFVGNGaGFCNDVtbi9BQVV5dFNqMHBtSUNtakViS056cjlESGpxVVN5cDVEUmlUeEp0cEJWQllpR1g3eHZvejZpbVBDZng3cEJVVVJJdXpJK09yUVYxK0M4dG9LYVNmeVlEVGs4T0NxdUE3NnRaOUNmVVl3MzE4ZmxSTTAwbDB0d216Y2gwVVJHMHBZc3FoenV0b3MvNTJSejhPSXZGZldoSTE3M1VCaEZDWktUS2VRbld3clNrMm5DRS9PSnAvSVZyR25GNGFMdStmc0ZwOHZjalZGaWxnK1FJWTFwTk9zSGlWMU9ESnZHR3RBZk1uSUNJNWxTVWdlWWd6VENnNllCVWx1bmszNlFwb0lFMkFPSWVZK1l6MGdKRXJQUytRUTBkeEtOQXh5VVJJMGpTRlh3VExTbG5nQ2pQTlFnSzRLd2pSTDluRXpxRnhZUUZBUFUwa1JDdWQvanFQUkNnS0F4bEFyckhnMGYyNFh1ZVVPd3dMUWtQRkFNNkk5ZWNrTmk3UVZQUVZZa3Bpa1JNSlduVjZIcmhBeng1aTE0ZmFBRUF2Sm9ueXFQTWVhZ0loRUVudkRJZnVHclh3MkQrT0NQTGlhTUVVR25HcXhoMTNFUnQ1QzBRb0xFTmNHQWxNZUJpTG5wMWNvS2hNYTdMKzBtVmRUTDRlYjN3RkVDT1IvL1p4WG5QeEVvZ1RFNjRaTFlqcXdQRnRBdTltUEF1Q3hCNGR5NUQzVllOOTRoRWhMWVNVQ1hoQkNOdGptNjZZSE03Tkh1VjIxVCs1eWlVUzF2U2NNS3NoZG5Kd0Nyb3FiZ3lBalJnb0JBRDI3Z2cxRnFDUXhXTkRnZTUzTEJYQjRRaHdPUENKQ1VFWHRhc3llTGx4TWF6TzllcEtTSXRBU0lWNXFxWVNTbVlhUmdSSmNQNyt3RVNBSURVUUp3SFNMcVRCSU1Db2tmL2FnZXNXZ3lBL0NLQ216cS9kUEZ1cXRyemg2cXRNU3lQL2ZWTDg4UjBlOXBRY1JKTGFrVm1DaUJoODZ5cFE3ME5GY3hDZGhGUU13cTRCUXlkSElmbmtpK2VWem0zdnAzRlhyLy85RThubTRPY2VZaEtrQ01GUkNlamNTdHMvMm00bk0wSHlOZElBd0FHM0NXWXlVTGthS1NZaUdZTTQ4cEtRQzJzdVlXUFZmVEZLcFl3Q3A1akpCdStrVTNaUTdFSWs3TVhYQ0JaMkZRa0ZIakhXUG9CZWVCVkM2V3lwSmF2QkJTTlNVMmJZNTZIN2FBamNBMmIwNm5HbnRoUUxxMHhSR1JleWd4a2dlTGtKdGdYazdna0NYQ1NEQ1VKNHA2R0wySjN1ZG9HL1pmS201ano4QWFMNDVNblFiTjZ3ajMrWFhsTkRXQkM2Z3hqdmRVd29CR2FPdWpZU3o2TUhOU3d4R3ZvbG9MTklaaStCTkx1OHV2NU5FOHUwbnpuVk1DQnNFYytHQVI5dVF3TXpNWHNVOVF1QVNCcWtCNWlTY2pnRmY5MkQ4cTZHa1g0cmU1aDFQeXRzUGlFQnYzQzJjZU1XcHV1SlFtd2FPSGgwZzZ1djNXQVgxd1NjYXh0dWh1akdTWGVEb1lDMXAvRVFxQ3JHUE1JdGhuVCtPSm1FS1VRYU9MVDR5bDVWNUQ4OTRQRkNSVWx5cGRzWkZXbWxvM3dXRUFBK3FhVHB6bUJWdlp1QXlJTnBqUUpVa1lQVWJ0Q2Z0MWtZaXBsVXNUUFM3enBpV1RWM3dPVEp4U1AzTkJHd2RGM1Ric0hCZmtLc0xGMk9nN3djOUxQdnY1cjN4WnF2Sm5HcFYwWXF4SEViNGN3R0hrNkJBM0prMmhoRkZjMHVuZlhaTGFjOVBiR2NJZzNTbC9RTVRsVE9WUFNhMlNtREI4Zm0yMlFFWlJmYUFJWTl0RFpaazlJaFhlT3FVRUtubjZCRGhGQ0VyTUdNSExLWkJYUkxwNVJnMy9FRUpBcXRVbDVXUS9PdEFadVMxd29zVEk2SzhhalNDZWsvSXBtV2hBU1lyUmxKbytQNSthVG5PTytlS2NibXI5RWJTWTE4VGZXeXh0aXR4b3VxaHRsRXM2MlNCRWkvRGN1VUpDenB2YlNpK1BCM0hDS0VyTVJBVkVwMTl6R0VPZzZaelVSU1NPYXVQU1dTOW1BdnhlWmFSZ3NzRGNyUE9vcFpjQjNLcCs1Y3Z3VUNNeFlSYnZ6b0E0MjlEcWtqRXNsVFhtSkZ1N3hHQzRpajhaTEkzMndDakJPUW8rOVlPQmtNbXlHUjk3VStPdCsxenFQNnZRbXdyenhnQ1BKbWpBZXNaRWh0bEVGTS95MDBBd0RsbkhjTXJmcnR4aHF3cXBZY0VLQmpISVJaeFZtNC9nQUUyVmpvQ1pUNG9KaWtVNUQyVUxaTXFDa0tlMUVRak1LYUM1UmZDZFpnK2pLTWJtelNRUVdORUhKU1BpRmlhZUd5WU9IakZsT3pTWDE4L0lwYlQ2SExRUlM1d2ZBeXBqdlpUYS9lNjkwRXJoR2dVLzBwelNOMjFSODcwdmMyQ3lLSnJDRXdXUUprMktwYWEzWjlqQU5DZ1N0RWxFWko0RGo3R3BuRzY0eDZNVEZuUG84REM5RUt5QVFtWnBpU2xXRlBXRndCaHpCZkNkeDFBY092QnhWOVF4RnlVbW1oZjFxcUZEcHRmaDBhb29RWUQrb2xkcmpoZnZsTnJuSmZBQkJHWnV0RlRjblFnQVR4RVluMGJSSHlRQnlMN0orNHA2SFZDR2s5RXhLTEdKcmdBU0RyZGJ5dFJVbHprR2M4WWFlRnlzbDBQVEJXTjYwdFF0RURNbVBrWlFkTWJZQmlDd0FlZWoxSTliRXVrSEI2b0VER29lbldhVElCWGZlbXE5VE5JSDRyQTJ1M0lnRFhLQldIU0dDUkFPdkdhRUthMkxHMVI4cVVJYzVsMG54UlNNalM3eEFSQmZFNTlJZFNMYnZKaDRqajJsM09OaUh1Ym1LUkoyUHRJbFdvbVZUS0ZEbTVrdlFSVzJETWdGTDh3TDY5ZDU2REVPODZ2Z1I3WDBnb0U0a2xVMGc3bVp5bjVLNUhRYmNIU2JJSjAvVUFKcEdxUjQzUHl6aUZVc1YvUi9MNEV3N2hWRUpUaUpCa0JXRDR5TTRnQnpnOGZLNFpjVEl3SW94NlVHMXdjeGlTTks1T3lFanhSK2dnbWhWS2Rta2lWWDBCMEw1Z0lkak9oMnRqTWxUVk5DSWp5MEVzL0VLUmRZZGwwVUpXQU1ZUnJNN09HcUdhZ1JRc2FDb2FUNlZKbHI3aEl4eE42YnhTQWpKR0F5dG1PWjh5U2p3OVpad2t2SWpEWGExQ2Y4SEVpU0tkMjVJSWJmaXpFMnlSRXdBS1BTUUJCaUhZQUtrN3Vsb2prOHdnMFZrOCtiVFBFWTlBa3pnSnAvYlllQWxoODVZR3laVDRvWmZSQ1YrRTM4Vm9zU0htOEtxc3p4Rk5vSlRLSUZYNXB6RHFtRzVJTWxSdUt2RXg0VTIrNXhpZUdueS9mUW44eHlHcUNjbXBPVzZsT2Q4dkVwMmcvQWJvWWVFV0VhcThNK0Q1VTl2K1B6cEl2YU4rTnNMYndVNkpya0p2RXRUODJ2UVl3N0xhU0pvcmpGUU1aK0lNc3FxaUsrVkhqUHl3bWJ5RXRGb1FVanlud0lFTm5hR0h6dVRDbTA2cFNoemYvMEVOVVdEaERCSTU4aGlYbzVzY2pTTUQ1eFlKejBHK2N0ajhaWTBTQVdJS25Bd3pJUURORnlJcFk4eE5QTlM4akFCSjdPZVNkbU9TbFFtUkpEUWV5bWEvd2lTTFVLbjA3bFBGK0ZIaUplSjNHc2JuOERONGJQUzdCa1lCUi94d1h4WGNSVWgxVFM4QkJjaHZSTmV5cU04REJGQjgzVHJGelVqblFrcVRnYzZLTEVjQ21xQ0k4MFBJVlhzaEhqLzZ4eTBnV1IxTVhqRkVJQ09GZ2pKRFM0QVZMMHdxRHlnWlRCZHNLZUZ1QlVVVk9IWWxJajNUYWd5akJhd0pvY0E1RU8yenhaamdOTWtGQVN2V1IxRFprRHl3Zm05UmlHMjFraUNKWEMvNEs5eDVETXdSeS9vQ29tazFyR1F3a2dqNC9GRnBoSEtleHpXRG5PNk1xQmJzSVBzNGczWjBjYnIxZ2s0R2xnS2Rvc0lhdWpJNE9RQ3dLelR5Y0Z1RUhQWWxPb0JCNmRNQWJzRVo4U2JPM2JSTzhEQmFoWjExNDIwSU5ETVkwU1pFTnlOcEltN1BsTVpZeExvK2tMSXJPSXdWTEFzN25ESlNoUEY2RUlGWFhoWHhqWWJJOTdkYVQ4NU9HdUFTSVVvaEFqcDVvbmhjejRwOUJCSENXaGpFelF2SGd1SFJHcDh4SXloYUNvaHU5QjRGSEhReHJDYXFPWFpqd3UvY0M4cDRzSVZPa284TjFkM2lVcThJUTFqWXJab3RCTUM4ZTFNSmFFMldDUWRNV2NqblV1dWg1dHdaTG5GUVc2Tk91UXhPNmh0dWRKTndxZ0NBV0d1SGk0a0lFUGpWUUh4Z1NPeURTTEMwS0FGemNCaENaTmVtSVVBMWtWYVNKaVduc2diNnBaZm1wemoydTZ4SXF4cVVSVHpLTVprUllGV2daUTFGVFhTZTlwTXJVUVg0c3JoRkhYdkhOT2hzRHVUU1g3MnM5OU1iUlJDZTRZMHhOUmVjbVJqNEREQzhhYjJHY2dDUjVOU3JRZmQ0UmxZV0duRVJOZWJFUitCSW9nVWN3L3Rzb3M3RjkxbWpkVlJBQXBwOGRJRlpEemNtcmM5NVNJbHBES0JYNlcwcklaaGNtTUUyRG5wUkpyMWxwRU1IcE9QbXRMay8yMzVPWnN3YUtBZlN3c2d3eW9qaE9RR1JpRDJHbXBxR2g1TUdQUWhHczh0WEN4TEp6dUFCRVhHTmwwMWpneFlnakRUMndoVG94S1pIYW9Hcjcyb2hqWnlkYnhOSThqdzUwT0JnTXh2OXVLS3NRUktlUkl3Y2xVNUhWQjVzbXN6S1JpUWRBTDdUbUJSaXlSV3ZORUlqYnpJY3lWcGt5MXUzMkVrT2hCVXdPQlZjd0RraWc2Z3lDcUlLUVU1Rml0c0ZnTkowdUhaUUk1c0N1S05ZMnJpYldjajRKL1VDUTVVbEdJT2J3ZmMxQmhUakJ6cWVhOUJsTWRGa25PQ3BGVmgyY1Q3czh1SndPam5FYWVsSDlYUTZBT25PZVpySzMrdUtmaU9PRmM0T3NUT2hSTUdkK2YwQ3AxcklOVUZ6RVdKUWlnT0QzY1VCeHp2TFFLYjZHOG93bzdLQ3lkb2NPcGJEWndxakQ1aWJJOXZmbEp2aUJwUlRiSnM1bUpqNno1VUplYXMxRXVOeFp6YlhiWnJ1Z2dQTm1sT0NWVFBGM0V2dzdlRzU0dlBLVGkwcVNKVHFTbFFqWSszdTBBMFhCZDBtTUYrQ0QyRWpIZUI2WUpyQUlrYWVobE5hVERqMEF3dGNqRVNQVFFoZ2NlQjVTWVJ3NDZRUUZiRnhnYWc0NHc4V0d4NEptaTFOeXlyM3p4Wjl4cFdhSUlNdXl6aXg4MWVCQTVLWWpzQitQUUdtbERNeCtuaGtNUU9NY3JWSFk1eWN2YlNmZXBxUzJBb0hsSVVFNWlCUk1ZNDA1OEFRZUhsdEZ3aHBnSk9BRHBlZHpFTklJZWkyWHhrNmVCZEE2N01BRGZlU0JINHVYWkhOaHNWbWdGWmk1VGFsSmJUc2c4aTJ6SHhvWkpUN1pEMVA1aEo3eExtdmVWVGZxZlRCZGtuQ3dHTFlMWXFva3NUT2tQM2RPckdEV1NBMkxtRFRhZUFnSmg4S0dhb2JVd2ZQWkI0cG1YOWVhZ0I4c2tOelBJeTB3Mm9UZU9DTFdnOStiQUptUXV4NVcxY0J3akxvZElkRVpseFJLZFNUb29MYXAxQnhBTGxvSE9GZ2hwbVF4aFFpVDdoai9oeE1BV29DVUxCaXhBWk1tOGhKam5NazMycFovNUtUUncwUm5jbnlxMmovcWlRUkhDeXhvc0wvRCtjd21NUk5TRWlCSnRxNVltbGlBNk9VQ01RRFQ5Q1drTG5HQWhpd2FrUU5GdCtEUiszb3dDaGdrTXVDRERYQU1YdzBqUG53c3hMdGRxUURUVndYeVEycXo4Q2dDUkhyRERtUVo4NW9nNWFKZDZyT1VDbzZxWU92a2xCbHlpYnJHYjk0bytjY1B6T0o0Z0laSERpWS9FWXg3SGdYem9wd2lRU2RqQU94TTcwSTFuYnQ4UlN4RStnUWNObEJpQnRLMm04TlFxWE1ST04wMDJkMi84ZWNDTVQxUWpYZlI0bEFmb0pWampkUXJ0REhxZCs1Q2d3bU1McXg2N1k1cEV0blczQ1RDMEdpR0ZCUFVzd0pBUjZWVHV0Z1FXSzBvTVBDbkJCaVJyQWhZMGM5blAvY3hQTWxCcFFyNFdHUk1JcjA1ejVOb3BrT3VnQm1rbURuZW9HMmxPU3FLSGhoWmRYbzVTeHBWNGhtS21sU1BJZEtJSU9WWHJoRjFDMGxQeXd5aWdlVUUrQmxPZkxqQnhBWjZUUkxFOG5PZGphRnJlMUJWMVNHak5LTUZMQjVITmoyaXFTbHVXMkxjZ0xNc2dDRXdNMnRnNDhVYzNnYTB1MUFOMkg4VnhUeC9tMEdHN3lQZTJqREFhb0NQaUZkRTQ3S1RDM0lrT2NhTEJVMmxVREFranFjbFlQT0dIb1FwMGFOU2FEL2NYejhManRnQTFQTW5kd3RNVEdMcGtGeDVJeE5JTERTU0tCWTQvS3NldStxMnd5S1F0WFNsVENCSFVMdTRKRU1wMEZrK210RlFDVVBkVVVZOGYxOHpqTkJYYkZKRUVXMXh4dGtveGhUbG1QL3ZUaEh1NlBJQkN6Y1EySmpKV2c5UkJSamRTaUFockluNU9yQU1UZ3VJalNsSGN6VkRCYzV6SFluZXptSXVJdzlVbUFGSUovSjh1d3VwSWRIT1M3eUZXQTZtTXMzZ25KVVExTk1jSEFBYzZhY1RyQTN0eDM1d1M2NmVRMG9FZmtuVzRKNUZrVzVyVXdUT3pTbktQRUhPRzlESWFKd1VxaUlnK2oxUFRnVWdXZERUYnZmYWZqS20wT3AySHFZNUk4eUtMVlVIU3RRQ2lWMWZNYmVMb2xZTEVPbU9SMXRONlRqTkJmVzRiMUF4a0dFZEZaSGFsVmJNS1NLU3p3M21lcitIQ0NaMWNtVEtJNWdYV2FnWmYyalRCQlViRmMxcGxBVWlBR0p6QitxWERuQmpvbUlFTFhEMk5tN2FvRGtZRW5IM3hKMzdTcXMwNUVxM0JrRG9ZY3hOdkd0MHhxVjlnMEJLMUp5ZmpCTGtWeThxdnBMMkVVSlZLQ0tXSzZ6YUFKVXhTNGlxajA0QUE1cUp6c0tBRU9FNGdOWkxaZ29HTFJRb0JxQ2s2aXpoa3BlRDNnRkpoQk5vd1VKa2d6YXVUWXRwdEp5ak5BSUFBaUVvQnFhTGxvZHE1UzFzTEJ6SXlHaEY3U1JOeW1JK3BkWWFCVU1RNmJCVzdmQ05Bc2hLK1BrUkRNMkhZc3NzSmo0TmJxTXpOUWtGZFlzc3VQOFF3OXlEVGRpSzJIMWhCYW1wblFqK290SVRvMUF1emNJU0JiQTBWRENNWlJXK2UyQWFsTFNvaU0wQXlTQVdCVEU1aU1KRWx3VlRRMDB3QlYzU1BoRkZYaUlzZ1RBK0JaR1A2SkFrWW5UMHVDbWVFTVFlZGJEclZ3UktLeC8yNW5IYVNHcHY5ekUvOGVIQ0lQTzJ6YVhXYUsrcVBpS2ZKb3lmMjdTZ1FOUEIwbCtuWTlZUU9vcEhKM1MyOGFld0FoTFBoMUxBMHJxSUlOQ0xNeVFCalRaMEtSanZkbmsvRXNCTlpLQWpQNldUYVZCSWxuWDZaS213RUhEZStTVUpjS0dyeEQ1a1pPQTlCK2hWa05JbHZ0UlhWOHFMNnZCaFZCSHUzd3puWXpNUGNLd2s4cXlpR3FCS1NPMGlJcVIyRkRBVHdEQVM2eFNZSnlkU2lWd0RGZHB6TWxJWkRiMnQ0SUdRYVM5Tmp4UkNaZ2FOMmx5MkNEOUdMZ2VvRXA5b0NJcHlPcEptS0VZaVhGTEhIOUdlTlR2ZGFKQmVNSm82TUNKbE5KQ3BaRjVFc2xkQmFXc0l5dlE0TkNSR0JSV1lTRDR1eE1SZUNZVWtLRTRnY0ptam9BVnJ3UC8wVFB5YkZlQ09KQ0U0YmMxVXlvRnVrYytGZDBSVlBvUXRhNmhMQnhFaUFlR29KZzQyWXpOU0JaMkpYU0d1RVh3aWV4TlY1SHR4VUhMYXhpR09rckNBd212T0RxM0s2Rk1pRjVoTjEwbFF2R2o2NTQzdEttRXlGYVVKNkJNYnB1cFd4dVRVRkJFamtkTTRBUm5rbXRoTVR4UndtVVRESjBBbzFKaFErbEFFdUtPK2lacmpmS1UrWkVDK3d5Y0ZCd1Y2dnRBTVJHVExGZnFQZ3hZYWFFa2hkZm9DbzNzSVlFeEdSRTVzUmVvVTRNTk5GVEJQb0FSakdiVXlFOVRReFNBUW1jZEtMSVRXNzFHZkd1TWlsd3pKb0oyWmhrWll6b2tvSGlqb2NXQTczSWpUWXplVFU1SHV0WkVHZXhaYkVvMHhFZU1MZCtPUUE5RWhJcEQ5VjBNN0NVUE1XRzN4MTNjVUJJWXNxOFE0ZDVpOVZpVTMrYi8yWC96ZkI2SVJXd2pObFpCbE1MSm40aTJkS1pxZXBNQUhlRG43Y2NTTTljWUsxTlIyS0lydVhHcExERW1tWVZkWlZLWEN6SjlUajdiRTFGd2FuVzIwSytIa0JScnFFQ1JwVk1JMWw3SEo2Q0U0alRyeGNzWTdiTHVseHJEQ0dKaE12WkI3UDZEU21ScUU0VFlxbDh1YVpNK1ZTZVdsbHVYdmNyZGFxbWtaZGE4c3JOMis4dmJLMFZNNnkzZDN0Y1NHN2UvZE83L2dBL1Foc3VRNzdLS3l5ZUR5TWFyaFZjRkpZZXNpY0VsOVRJam1SeHdpZXFaTnNNQ2RxUzVoSmpOUUFqUkJibHFoaGpGS1ExelZTbkxDUUdCRjRHQU1yWTJTUnNDY3JaUGpDSGtxVEErRmVES3EweDRVQkF5RUZIeUFRQlZaUXIyeURFaEtGSmNJNkp4MzYrVEdBYllZSURGRWlRQmhkZFRBVXlRTmgxQi8rMTd6b2p3d1JXT29odjZJS2s5bXg3a1dRcURoNTFicXBiaW9tbDRvQ21NbHEwdUYrRlozbUV3UG4vOVovL3AvRmVQVmhYUFRYZU5PWnhKd0ZVWmd1V0FnaG5zRWNURXhBZUFXbEN0YVRGQmozaEdPU2dpbmtqYmo1azV4UXhSQ3UrMU95SHphS2VMQkNjMjZleDZCc3laa3c0SVFaQ0EwbVlrYkN3S1lOUU56aU9pVkZYY2ZiN1E1NWw2ay9YdUpndDFlNVVlRU44ZFcxOVErLzhHSzczYTdWR3J3cHJvNWh2OXBvN2U3c1pMMkRRbUhhRzVIaE84ZmRiRFQrMW0vKzJya1BmNlJTYnkyZk9mdmFheThkN2UxSVI5eUU1STVWSGNTZllIUkNibFdXRUNIZElNdVFzeDN1ZEUxOU1ZZzNqelFPbXFCWGdIbVJjTktveDk2SUdIY0Z6T0ZLTDRVODlva2N4U1hCaHZVTHkzRG9Hb0Nrc2gyUldaQjJUTWhuVzNRaTF0VlVMTk9OK2JBblB1Smhqc2RKRU5Jem9rTXFDdnRRaDIxQjJ5MjB3ZXVHZmNrVGgraWFGeGlhT2l3QkFFZjl6VDNybWNrdHhCRHMxTFJoeFJ1YmFFaUVua3YyaFIvL1VXU0FCVVc5d2RndDFqVlVhTVJaNkRoNWhWb1E5ekUrS0h6NU5CVTRNS2tMV01JRW1WN0FkQWNja0ZVVEJSWUFUand0SEpob1lwNDBWa1ZBSWxJSHpoWDRXRDBWTlNRU05ERW85V3BwMkZsTW9rTGNlRDdSQW95bjQ5V056VS85NEErKzhPSkhOamZQVGliRFJxTXg2dmV5L0pnOXdXUmFWaldibEpzTHc4NWhZM0c1TkJ1OStkWmJ5NXViRnpZM2kvdy9rOG1aTTJmWE44N3VIKzZQQmhwRjJwSFpjWWZETFZ5Z2lyT3NJdGxDUEh3bzJJOS92ZDl3TkV5bWVXOWEvSmt2anhJTW1aQ2tZTUtXOTFNWkFqSUdNbGFoTndVdjF1enZ4VHlzclIyL3JsbzJHRFNzTE0rT0xPSXNuTm9KOGdoT0NLOURnSmNUS3FFWVNPbUU0MEJwWTZONTBqMnNDRmpiTUpqYjNsVVU5WFBTdE9KaXNSOTNNblVDWWFZcWlPbWhTNXhObnZGd2pGenRmc212K2NSSVJTdWJFc09zWC9hVFAvcWp1SjFtZUIxT3RQRTlLRENRQTlNMGFOZjRva2REYzVEaEdHeHh1YzVDQmlWSTRWVEZOZEVUcWFiZmVHbWEyTHBZVU5vZzhZSEFrM21VZDJqREsyYUNBUlg5aEJGdVNLSGpRMFhTOFhsTUNLTUpyVm5BMHpWL2NaV1FiQXJpcGZXMUwzenhTMWV2UGJIVWJtZkY0bmcwa3YrRy9YNTM3OUhDNnVwMFBKcU94MGU3RC9KWnVkRm9Uc3VsNG14MjY3dXZQUG5oRi9xN081VnFvYkcrM2x4ZGJ5NHNsckxpdURzb05odjkzcEZrVVg1VUNNZ2I4Y3lIU0pFVTFHb1FOQmdFc1gwUGdPNUtrbzVnZWlKMzZqWVVYWnhWdUZWRlhyVFRaWWYwcjFVeE1RSDVGcFVVQkdFelhUSnRDeEplNnJJQnZZcFNlTmlhdHJXN0VBTGhQRVpBN0lnSWNXd1BLS1FYVlRRaEVTUFdBaXM3RkNST0dRZFAvVWtHMkp1cmd4aDlZN0tZbElLaUtuU3g5UU12cTduQWlab2lJSkk2S0c4ZG1WQ2pDQU9QWXNucHJQaEJCUmtnKzhLUGZGNlFReEVUZVNLZHJMaHNGWE5aRklzUVJhMkU1NzgwelZId21SdU80UmJJbk5KVmlxWURUaDJrQnlOQ1BuZFNCTmtVaVN6V1M0Z0ZyVjYyVHl3QUhXRkFFUENNQXJjNVhxUHdxMEJmWWMwS0dWVEUyYUVBaHBEaUtPUSsvcWxQZithSFBsZHZOTXVWaW5vVm1sbVdINDBHNVdxMXNkaG05dnlrVkN3dUw2L215NlZSOTNqWU9WTFczTGh3Y1REb0RtYTVqYk1YangvZTNicHo4LzZOdDN1NzJ3dUx0ZlYyTzE5c0hBK09jdU1SN3JFTFZYQ040RGlzbXgxTWdPSnZ0aWl5R2w4VElxekowQUlVeWlLUWFzQWtja2M1dVMybm0xZlYydC9IY3hockJHZXhEZ0pOSWJ6VkJIOUNFTlk0d2MvdFB5L0VKQlRBNmlPaDBHSU1DTyswQUh5UVVIVXl0YW5JdGZyenYwVUQ0VTJYQjVzR2prdzlSMFhEVVhxQ0NqOGFJMUg0TXdjZWhSbUk3QTVXWkV6R3RQQlZpMjRPOWRHVC9jVG5md1IvdXhHcnl2SEFpb2pvNTArV2Naa2J4bVJvQWl1TkVwNmxZWHlhd05rajZDQmxuUEJ1Nk9YaStTeVpaYUVoaFhSSy9aN05pbnUwaXVSZ2x2bWlPc0ZURU1ZSUMyWUFWcWtRL1FIRlZWdEU2U0VTZUJaTmJwcVZpai8zMVQ5My90eDVyazc4QWhUWGVqRXBWMnZham8rNlI2VnlaVElhWktXS2lEdjdPN25oUWJsOVJyTU5ScDMrWUZTdnQ4NmV2elFaOWJ1RFlhUFZxbGVxbStmUHpMS1NQTnhTcXE4dmJ1MDlZT3VocUpUTDJjbGpRRitGTFJCeElDMXNDVERTa2M4OEVmUWtZejlLeDh5czBzQndzNmk5aW1zN1NYajJObUloQnFMemFoRmUwd2wyNUhHSUUvb2FkbHhvQ0JHQllaalpNd0Y0YlpwQTZkckNwcWFLZ3cxaStpQ0lsalZ5WHhickFMK282VEdpTUYyc0lVM2lxNEJGa09TQ3pFTENJUW5kZERuR296QlNGZXpOa3Z1K0xPMXBZcWhlYVM0M1ZMUjFEODNFY0piOTVPYy9EM2VtWUJJZ3oyU0xSTkVaV2VDSUpSRXJZZDJ0SXF3YlNrdnpXUUlKRDV1VlFUUjVNWjZPT0V5YW1uUTY0dTBxL2pUWXN3aVhhQVdqRFBTbU1YemFKaTRpOS9iM0ZGYk11RktrdUdjc01qR1h3bSt5dUx6eVUxLzh5c0xDd25ReUdmUGRoRm1wVk93TkozS1g3RlVzWmdxeVNyVXlIbzBMeGVKMGtpdVZLc1ZpZWZ2ZXpXSitxSVhUMjk4dU5SWjI3OTlhWE4yb04rcUQvdEc0VU1tUGg5V0ZsY003dDNWQmFMU1hObGZQMzkrN041Mk9NaFlmZDFEZXJWcDF2SWdrZ3IxZFlXK0lDczd4anhNNUMwQ3pqVDJLck85OW1paDVMbW12enNub2xXMXNJbXNxRGt6b3hXTW55UXdNY1pwM0VZNGhTQ0lzUWFQSlNkNnl0Mk9LUWxPUW84M2tYZ1VKZmd4QWhvS2FncERHU2RGclNaTFhnbHh6ZVZRVSt3V1JmUk1hRk1ISG9NdDhNSnlqRGFBcVdHbHVxeElUd2RFME1NbCsvSE9mYzVjMGN4RXVCUmtRNHhrVlZ2TTAwQVkzY0FvZ2tFTFlSQjROU2pYUDVqV0dGUUk1bGc5aXJ0VkdlUmJOYkt3S0JQcnpuQnpPaFVSRzlMdTJEZ0hpWU5PQjlpSTJHS01GMCtuZXVQYUFrWllRQ1UySSsxc0lmSUowY1gzenl2V1BmdnUxTzcvOHI5KzRkMituMyswZEh2VmVldm1XaVBkMmovanc3WFJVcnBRMVlEUWNqd2I5M0dRb3VGaVlGWXUxNFhCU0xaZW1oWHBoY256WXk3MzViLy8xNHZKeTcrQmcyajlzbjd0OHNQVm80OHIxVi83b2QzdnZ2WEh4K1UvVlc2dVBIdDBrWXFXSEpiR29Kd1loZG0yZ2VCc0VTL0Z2WlhrZkFDUnFTbXdyWnFkb3l5NzYyTVk0M3hQTlBLLzByMk9DOUk0ZFFEVVRxdUJxV3dDYmhEM0Iya0JCUW85N2lYS2FtTmNHUm13Vm9oM0ppV2phdWg1R2NKdWFiWFF3MG1LQkt6VDBnREpybURONmp0WExucUdUZmxDR0tYTThJR0w0VXhudTFqVHBhWXk3QVJFRElTMldJOFNiZTF0RCtQL2liL3cxTEFNTmltTVZydU5vR0ZHR3dQNWpOT1BZNU16WnAxNDZZUUxtQXdYS0FPZ0pFVFNGNW5mYVlCeTlVc0xYUDJxc29Ca1FtZFdMeU15aWx1azl4SEQ0Q1VSVXNNSDZUZzdNU0IyVUJKQUZVTkJRNjZRNDBTNWd6RFAxMmtKKytibFN0VGFhWmNmZDdtZzh5UTBIcFdacHNWTHA5QlRUQ3ZYeDRYR3ZYY2tPRHcrZXZucW0yKzFVOHNOUHZIQmQ4KzA5MnFwTnUrVzFTdy91M2w0b2pXKzhkL2Z5bGN2SHcwR3IwU3dVcGtmOThlNzc3eTR0TDdVMkx0MTQ1WnVUenRFc2E2MjkrTW5mLzkxL1Vpb1VlUWRXTXMwVFJ2SUNSWklSdXp3WDVXUHJpazdGOFVoTFJCRXYrNGtlbjVJL1NOZ09YQ0xZWVFXLzBCbmJ6RTNyM2EzTUV4ZC9CVUFDMkd4akY0VXJOeWwreDZZb2dSUkVoQlZ2a1dsVVNYeFlhRnlRMkJXWkhrSHhnV2FPbWJ4R2paVkVkZ013M2NhaWh5cUVGQVVGcDNIQ0dRd0tOT3lDRUtZQ3hkM3NwVFZJaVJBZFVSTHNUb1lIS1RJbVZsQVlWZ3prc3gvNzdPZWdkR0hHcU53d3dQQmdDVHZKYXZYY0RCcG1ZSjVBZkUrWkl6UVZJTTUxckV0dXJ0YStZQVdmcUV3WGNEcFJHT2dLQzg0eFdOSmhqZ1VDRzRLb1Eya1E3UVBIbWZuSWFnaWlROGx5UEoyT2k1WDY2dldQYlZ4NnZyMnl1Tmh1THJXcm02dXR0YVZtbzE2cWx4VC90VWE1S1BwQ3VhamRRNjNlck5UTE4rL2QyKy8zRDBhRmIzN254bko3OGR5WjlqaGZ1UEhxZDY0KysvekQyemRYenB4dkxLL094c085QjNjVVdyblJxRm1ybGtybFFiNStlUGZXdGUvN2JMKy8wMzMwcUx5MGVueTRiYk1yZ21RR1M0MThockVDYVY2SHJqL0NLNnhOTVJubnRCWWx2SnBqb3Q4MGp3OVVrNmJSeEZybUw0OEppMEVjTnVwaVZhaUxoMFE0aElhdkFFQXNwV2hFRGpXcDRIbnlZUnluZUoyTXdBV2tGbE93c0ZJUFRZYTRZUytRdDRJRGo2a1NDYWVZQlhKRENXQ0lpdGFuVm1nc1dCZmVRUEFkQUlWYVhDMFpsVWFwQjhnclgxdXlFSHVtY1Arc1FMUEU2b2E5THAyR05URDZpR2xPSEdFaDQ3RWp1UG5LQnVKa2I2WFk0cEJ2eEJRSFNRNXNhZGVheUx4Z2h0QjJrN2k0R2VCOG5qZ2xRQ3pzUHhFNHh2VXlHL1VHWG1ldVVTU09rTmV4cmtPUzVxWmo3YzQzcm56b2lZLys4R0o3cWQ0bzF5ckZTcWxZcTJSVGY0MVlOSzFtZFcvL3NKVGxLa1V3ZXp1UCtzTlI5M2luV1cvMWU1MVNvWDNoeWV1djNYcVk5WTgzVmxyYTdtL2ZmTE82c0xENzRIWmgycGtOQnB2WG41R0N4V1o3T01zL2VQTlBTcm54K2xQUDdqMTZ1SGJ1MnVMU2tuWktCOTFIcytrSVRUVWJqOGFsZVRLYVU1MEVWYXdydGNkM2xIVGlNYm5JZEhzNlNYc1l2bzB2N2FZenJRRUFva2NHaUV4dlZVTjk4WmYrWEgvREdoaklBVWhzQ0dOek1kYit4dFdFRk4xcXEzWVlSNHhxSkFWNndsOTEwQnJCNFhKQ2t0cWVETjd1aUQ4VDA2YkI4Z2g2L2FWajNoMlhwNkJKaUtnZzQzSURuYlRUaWJtOEpOUUg3RE1XY1pQSXlUNy8yYzlpSGtlaXowYW44QUdLZ2xOOEljT0c2c0NlVWZOSG5HSHRrNXpFaWdtMEVpMmtKRnlka1kyQnVFMzAybGxpUXZoTFh2QWhNbXhaYzR5a1c3VWpWMVNtaHhoWjNaZ2ZmdWlCL0duTmdOSkliV1M5OFJYTVYrREdrL0hDNnRubmZ2QUxGNjQ4VlN1VjZ0VnFWaXoyZXdQdGlWdU42aVNmbGJKWnUxRzhmMjliMi9UdTRlR2pnKzVScHpNYWE0T3ozMXlzZit5cC9tYytjM1Z2NThZLy9Ydi8rdG5ubjk4NkdHelVodHI5ckt5dkh6eTRkLzdhdGR5c3ZIcmhVbjlTZW5UcnJYSG5jTzNzK2ZYTFQrZWJ5dy9lZm5OU0tPbXFjbng4c0xCNnZ0NW9QM3IwRHY0TFNSRVZQOGg2MU1SOEdKTTBvdUFtK24wWWc0WVQzWjZDRitoVmtIYm5FYjZ5SUQwWWhMWXNJUGM1MExGaE1xT05oYTF0TndZcFVxQ2VadUVYVlFJc3BNZ2txV3U0QkdhcTNSZ3dCSXllUnlUVEFYaFhwVUZhS2tGbGdNR3VXUy9FTG4wQUFiUFhVbitJUWlHcCszbEJFSGdhaWpLK0dacktXa2MvaGNVSmMxaFJwRGQ5K2V4SGZ2aUhJWlJVV0Jyamg4SFFFMzBaYjFlb1loVDhDUjVBRzQrV1lqRzhJa0pBRDdIRDdCa2lXeThNYmc3a202QXdFMDBvMDJodmFCUGpjaVpoSHNGbXBpSlBzdk5oRm5NVEQyd2RCS0RWSk5uUjFGbC93WXN4NHlsNzlNbGt0TGgrNGJudisveTFwei9XcURkUURGSytOOStvWnExS1RoUkhuZTUwT0xweDg4N3RCM3VEM2tpQjNoOU9CdDFlUWJkK1dlM0xuOXVzTnpiSGcvcnpIM3E2dmpUNDlWLzZnODNMMXp1UDNyOStZWFAzL3ZzTHF5dFpJYWVWY2Z6b2JuNDJLQlJyeC8zeDdWZi80SjF2L01iaTRzcnl4Y3N5elZ1Ly82dU41dkx1L21HelhDM1U2OTM5KzRTeVpVVWxuaHZLSGpLaFk1cDBycE1BZFVsTzVmWEFxNmhyTEVNd0Z0MFo1czlGaEg4TVlRelVGd2NzaXhQcEFZNERuOGhzSXNUTkVXRCtNeEFCSWxoaFpiYkdDSlhHT0h0R1hLVU9jSzRVZHhIdmNsS0tvYURSOGtIRWlGanhGYmw0dU1uR0pDNGlJdVdrU3ZoQ2ZLaGEyTFNiRVZFVW41blBaMDZlaGZNSnhyMmdkU0wwczg5OWpzMk1RS0ljUThzaU5rYklpaDJ4SFN3d0lDSEVZQU4yRXBVSWJHRnVycWgxMk9Ed05JRUhhaFFzMVFzajlwNGhJSU01aThhU2dtWVV0VURtcFlVVVNLUUp4SGd1b0VSbEptd0ZxWmtqbGVKQ1UrbENIL0tzbjcvNmtVOS80ZHJUTDlacUxkOEQwanNaajBybC9QSlNzN3QzOE5aNzk5NTQ1LzdOMi9kZmZ1M3Q0WFNnclkxMnplTlJZVGdkN3gwYzZFNnhsczArKzVtbi9uZi8yLy9zdi9tdi84NWYrdmUvZG5aejRmLzEvL2piVDMvOEIxdUY0ODNWNW1nOEhCd2NIdllHK2RHd3NYSnVPaHFXYXZWNnMxRXBGYzU4K0pPLytjLy95ZWpocmRXemw1Nzh6QmQydHJjYUt4dTNYbms1UDU3dER4NlFZaEQ3WkNjajJkaTNXR3dMQ1RDWnBOQlhSdWV1d3lFdFZVa29TVlBiU3pValNmTkM4dFFwM2NXS3JRQk14aXg0Z2poVWp5cE84VjZOWllrZ0ZOTVUvckkwR0dMUGRhSW5UTTNDa2NHZENyQXdwSHpXQVVVb0JydlFTVUkzSjNCMGlTSlJtckdaU0Zyb0k4eGpRVG5TQlRqa1B4ajRubU0rRFp4OXBwdXhpQlZ0c2RYZDkrZC8rTE9vaGl3U2s0a3ozZ3JHZGpUbVJWeWlCSDhaQzRvb3hzdUlKNGRkNFVqVmdkazV0SHJGMXNQaTc0UU5vdzNIL0RTTThGa08wbGtTcXlsYmNna0FUUlcxbDBRTTFjUnNwSkJnb2t2SlpES3V0OXFYbm4zeFU1Lzd3dG1MVDViTHRTRlIyWmNWU2xtaFZPUm1aemFjdlAzZG05OTlmKyt3bjUrVktrT3Rqbnh4TmluMnh1UCtxREFlRHZkMmR5cUYwdWJHU3BiclAvZlVwZk5YTG4zbTA1KzRlR24xd1lPdDMvNk5sODljZmVMczhtSnBlS1R0Zjc5M2RQNkpaMVkyMXNhNVlxTldteFZyUi9zUEI4Tlo3OUdkai8zb3p5eWR1M2kwOStEMm0yOGUzWHMvbStYNnhWeEpRdFpxeDRNOUsrcG5pSmpPMFFuQWI0eU5sZStKWWZidVJMd3VWTVE5aXdKZHNSL0JiUzlFVTZ6d3JHeUNXYkFPRnZIaGFwN2RGV1NLUys2cEhBL2hLMkFnbG9VQWY4alM3MDFCd2N1eDV5WkVDY2tqSGJwZ0FYRlVuZ1ZSSUEvdXFyaDFwcGlGSkNFKzllZGxBRHFJQXhuRmtldnRld3BpU29MU0dNZStyd2hHdU9FWGF5UGFBTUt4bWJGeGJLZ1liZ3Q0elRHY3hSZ3FtMEFGU2xsUittQm1CZ3BTV2lITnVNajhIb24vVEc0OHdwaDNRa1NPWVNRWWM2ZUNzUmdoZ1AzR01ONUlCMmMrdU0wNGg0ZjR5ZkZNcmFRdHhHU2NMeFNYMWphWHoxNTg4UWQrN05rUGY2Szl2Tkh2ajdUOHVzZkg1VXFwVk9SenNkM2o3djcyN3RiRDdSdnYzKzhNUnNXc2tGV3kwYUEzN094UDhyTmlLU3RYYXFNaDk0cWE5Lzd0MjdQQlVYdGxjYUV5K2RoSG5yeDBlVjJoOVovOFgvN21oejcxK2F4UWJwZEhtNnYxenY3aDZzYnF3OXUzcHZuYS9zNjllMisvMXQvZmFTNmRhVFhyemJVTDNZT2RYR214M0dpdm5UMjMzenYremkvL295Yy8vc09kd1hTbHZiYmJ2VDhaRHdoQkNTOTkwQ3VGUHRHdG1mek9xR0xkdDdZR3ZDcmluME9wS1JQYUMvd2xVNGNsTVc2NFJCYW1ZUnVuTHRyMmhtSUFLNU9yQ1hEOFEwQVFMMW9QYXFyaU04TlJNeG9rc2U0K2gycTQyd3dKcXJoQStBck1FUEdpMjNPb2poSmpVOU5TcWRPc0lrd1YwQndpRU9oeFl1d29kd1UzTUZFanJWNXVpNW8zV3MwQjlpQjUwWlBMLy9YLytEKzJyVWoxTWpMalVJaElzM2xzQ29udUlrb3VWYlpkRkNHVkVOWDB4anhoZ3A0cHpFZXFJSXROSnB0cWNucmxBc1lVaXBnWWF0UlN4aUYvaTFoNUJRUERXREt4KzRUZWwyYllhUXE0QzRsdHVXaVhHNDJOY3hmUFhyNTI0ZEsxL29BMTArMzFCdjIrZG4rVktzOWV4dVBwa00rMUREb0hSN09zY0hSd01OSmt1blVkOUdmRllyWGVPRHpzN3g4ZDFvdlpyRkx2OTN2Ymg3UHA0SGlvSzBKdnVMZjM0UGtYbjFMWTVZOXVyaTQzdnZudDc5WTNubDNkWE50KzJEazdlZi82dVhaaE9qazYyTGw4L1prc216Ylh6MDhsLytqNDRIRHYvbzMzemwyNjJ0NjhzSFB2Um10cDg2aHptQlVxRCsvY0xHV2xZYW02ZC9kT1lTbDNkK3RsdEZBc1N6TVpVS0hzM1V5a2NZS2JkU2VVVXZ0NHdrL0h5TXdLSmdkNlljYVhwN0Fzd1JQQlJVT0c0M0c3b3pJMzQ0UHVndVBiaGxtdTZBQW9GclRNeTRWOHFaQXZadm15VE0rSWZNbWZmQ25MK3NWY01aY3JhbERHa3BDak1zZUUzMVBTNVlIWnVPblRuREszR25pZmQyWHdQc3RWV2M4VHNucEIrV1Y2Q2xudWNWelJKSGc4TnJDY2RVQnY1VmlQMWkzNmc0K0hlcVRtQWdEdFNJRWtlc2pXN095RStHdC85YStTS2VZRmRxWThLV3FoZ1hCRUtPUE1Ba1lhWmpHbGwyRDMwa0hlRnhOWm1vbm5ES05XSWZKVlhPTWhKb0FtVmZUTDdtWmhEdWFGR013cVY4VHM2dEhpekVxdDFmV3pGNjVjdUhKdFpXWDl1RGNjajNURE9ad014M0xtWkRRcGw0dVR5VlQ3Ny81Z1BCbU9qbzhPQzZWeXR6Y1lqa2JpVnk2WHcwaTdlL3ZGYXEzUmJJcURjbWlobHBYeTJiM2RqdXpVNjQ0T0Q0K0hvK0ZpcTNadWZXbGhwWFg3L2J1ejJhaFVyTC94N29NUGJkWSs5dFR5WkRSNGVQdTlTOWVlenMzNnhTeTN0YlY5Lys3NzdVcjE4a2MvWFNrVmp3NjJLNFZzVW11OThXOS8vZnJ6bjdwMzk3MzZ3bnF0MmJyejNydWo0MjdsOHRLYmIveWF3OElmWlVSRmRvVGF2Y2lxL3RGVVJ6eDNxUXIza2Zjem92SW5ITEdxTEl5Uk5Vd0I2Q1NobDZNY1UvSVJOMEFkZkpWSkVROWM1RTBtM21iUzJ1TnE1NGd2OGxrNGhYSkpnUzR6eHpMUXZrK3lLZENkbExTeXRBQWtxdCtCa2l2c1FmblJRQVJHRklNcHlEVlVJZ01Uc1BQaS9SSVU0cThtVnpMVWh4dGFwWDFCS3VoQWNlVHd5Q0t4T2pXallJVUcxa2p0VXlYSTZQM3IvL3YvZzA2NlVwSmJ4WVdYTFdTMkN1R2tqeXJCaUUzeFdEOFJBRzNIaUZlYUd3ZDV2Qmd5M0hEdzlCUkcwRFpFV2srTktQNTVDenNNT2sxa1dwbE1rOHRBNWZwU3M5VnFMYlEzejExY1AzTytVaXFQeG9vVDdqbG1CUHMwSzJhVDhhVGYweGFHclcrL1A1Q3pCa1BsOXZHQVJ6VFNhOWJyOVN1VlNxbFNsRytQajd1U1lqUWUxQnYxNDFsdE1EcSt1RnlkWmVWcXVkUTVIcno3NEdBMEx0VHJ0VWVQSGg1dTczVUgvYVZXbzkxc2FITXZNU2ZEd2NYYThibjFSallkajNQNXpiUG5CcjFlcGRrcUZyVENPc2ZEOGYxYk56YlBYUzdYRnhybHlhUGR2Vm1uYytHRkgvd25mL2Z2UEgzeGN2M00yZVB0aDlYRzBoKysrNi95azJPbk5lY25kaXdrZUxVbHJpRDVuVytha0MrSHNycEFMUWxTRU9ZTG84cEdpbXdzS1pnZEhndkkwZThMSmI3am0wVUFCUzRJQ3U1Q2xoVUxCZDNGQUN1T2kzbGdZcHB4R3Uyc1Q0aXJxVm8wcFlJbUlTNGM4WHlmTFFVb0hpSllIUmFJNDdBUnhJd21TMmhUdStCTVA2Q1RSQXhWMEVEbGZ0UjduSUtqUkRnd1Q1Q1luMHJpVE1GNkNmeXppbnF6SC9uTVozUm1CdCs3V0w0RWE3OGNscHpHZHh3Zng3b3Npa2hXeVdOVklUa3ZEazBNRTN0UWYrYXFnZkQxd3ZFT1JHYkFPMWdxM3RrbThKVkY4Sk03ekluaE1lMDBxOWJPWG5qeXN6LzlwU2VmZlg3anpMbEdjMEhSZHNCams1bDJLU1BkRlJZS28rSHc4T0RnY0wramNPOTFqNmZqNFlUUEtIWjYzWU5SdjVQTERhZURydVpRbXRRdWJIQjhrTXVQcXlWdHFNYmxiTkplV3RUd1IvZHV2dkRjVThXY05qbUQ3dEgreG5MajNHcXIxYXhzcmkwL2NlM2l4dGwxeWJlL2UzL1FQZGpmMlNyVVdnOEc5VC84b3plS2hkNDczL2wyY1hoODhjbG5GcGVYN3Q5OU9KN21TcVg2NXBVbjVJVDh1TnRjWEt2cTByQzI4dnB2Ly9JUC9kVFg3NzM1emViS2hWeW1QZGJ4L3VpdzE5L2g4cWg0OWpVM2RqSGV3c3ZvMnNPN3NHZVQ2ZFRpUFE0Wlp2cjQrMDBZU2ljSGprYmhPRm5mSVNNU2dzU09ZSnp6Q3pqWkhET1Q1K3lFZ2pmeE9NNU5CemlEeUZ2U2dhRXBEUWx2eGw0Vm5oMC9NaE12Q0drR0NqN3ovbUFxUUhONmFab1ozZUYvTzE2SEtuZDdjMFYwV05SVUJEOXVKRW9PTTZIbDR3UGxNZVZmK3cvL0kxa3kyaW95RUVvaU5WZ3VtTXFvVmtuaHJqcFpIdHVTM1RtVGRvMHhCYkJMR01LRElzR0lHN2Z3bk5uSUs3V2tTVldzanlaVWhsTFFzc3BFNkd1TE9FOHJsY2JhaFNzcnk2dlZVcVZReXJXV1Y4djFoc0tqZTNSWWEyZ1QwdHJaMnUwYzdnNjF1eDJQcExnMkFhUEpTSEhTNngwT3VyM3hRTWt4bHprZmFmeFF1L2pKZURRWTRMOWkxbDViSHczSGs5Rkl5RksxZk8zNnMwZUhCL2Z2M1JsTnlkK1ZmR0ZVeUEyNlEyM3VlN255ZUpJZnprckQ0MEcxVWRIMS9NNnQyMGU5L0tEYnYzNW1ZYlZ5Y0g2cFVxdzExNWZxNjVldkQ4YUY3ZHR2N20xdGpRYUg1NjQrWDlSbHFMRTRIZWxTVXhydVBoak1DZ2RIZzhuQlZyRmNmRkFZdlBIT3J5dFNaU1RlamNPVzVEb3VtTnlROHJRSUcwcys4cnB1VDhPb01oZmJVUFhFQmRGbXhQcjJ2T3pzQUJKVGJLMk1USGFYQTVUZHRiNlYwUlZNUmVXWGd1N2VsVzRFYU92aWJRN1pYWVRGSW41amIrUEVWTXpObE96RlVEdVpra1NTdlB6ZWh5YVFJSjRONXlPWUFHcjdISmlYNlJOYVJBRTZrOUdKcDRteWsrQlJFWnd5SGt3QzcyRUpkcEFFQW1MTkFPQ2dVenNhcCttWmkzQW5yNUJUdFJzTHllRXFrd212MnBUTXJXemlXcUxoRWk2ejVnRWh6ckN3M0JXWWpXQzBTZk9xU0hPdXE3SWJWdzRhQXRONk5BQ1NUT0lUbzh4cE9xdlZXNXVyNnd1TmFxTlZ5VlVxczlyQzhzclphU0diVGtlOXpwRnk4RURia2M1QjUzQnYxQitVS2hXbHVFZDM3KzF0NzJnSEwzVksxWHFwV21xMWx3ZkRZYUZjcjFVcnhZcEN0Nlh3VXp4VnE5VnlwVExTVm42V0d3Nzd1cnhrR1d0Y08vM0ZoZmFzMGxTWUhQWEhEN2QzNzc1L1Q2Vzd2emNjOUh2ajBiQnpVTXBOZThOZXM5SmNPMzl4NytIRGEyY1dudGhzWG5ueXlzcTVDNDE2dVZKYjZQR3U3QU44Vm02c2JlZys5VGcvRzlhYjdiMzkvY3A0OVBMdi9JdW5mK2luN3QrNmMrYlpaLy94ci93Tm00Wk1qdEt5cHo4a0lEUEtDOXl6VW1SajBydWZEaFQ4dFE4WE1MS2JMSWU3TUthRXhveTRnU2NCYkdEVWxNMWtjMkJ0MHJWeFlhY095SE1wd2Rxcyt5Wld5WVpGQVcyK3JHMU1rUG1pSzlNb2FhUWRQQTdHOTFvK3pNQjhYRTdzUXNjSUNPTElaMkxJSjFwa1ZRRzhTNGI0N29wK29wWFk4Z0JqckYzdyt0TWw4U2IwMCs0bmhUdWpWU1Faa1dpWXJVNytiL3hILzZGTWFINDJWdm9ENGNoMmp3Z1pwRU0yOXpJaEQvbVcxQmRXcFhVY0pMeUZqak9TaU5vWEMwMkdlb1MxMEU0SjVITnlDMTRpaThmVEF1UmpvQWNKV2x4YXYzcjJiTFZWMTRabGxDLzF4NFZ5dFRhYjlMVlI3eC8zeHNQKzBmNytVYWM3NGVGZGRUclJiajFYS1ZmcnJYcDdjVUZiRU4zK2pDVVE0Y0xUSGNtcVRLVU5zYmEvY3Vvb3k3cmFUOXRYWlhsV0dvZ3VtdzJIUSsxcng2TmNWeGsvVnhqa3F2dTlnb0o4TmgxcmRlaGlJclhxMmFSUzFVeVZyYTJIMjNmdnZ2SE9yZkdETjU3ZHFCZHI5ZS83NUNkTDFkbEtlM0YxODBLNVV0S3V1VDhjRmNvVjNzclY4cXMwSjduOGQzN2xGNnViVjZ1bCtxTk9yemdiZi92OVh6M3FQSkRLTXAyWTI1eTJwK3lNMk43Qjg3aUdFM0xhd25aY3NoWFJLWVA1dVJiSm5XOHdxVEVyZ2RWQm5HcTNRdDcySXhodHpMVTFkM0FyeFJQVFdtOFJ5czcwaFB1TXB6UXAzL04waHh0VzcvdzFtNkpGdVEwWENjQ2Rra0VCUkpBTFF4SEF6SFRxY0RnRVJsTFA3L3BNQ0Fab3JveDFQMTBnZm95QngrTUN6Q3lQaDBTdng4aEtqNG1WQkhMWjUzN29NMUtNWHRaaGJHUjhEMlF4ZzlCeVlYNVdwZk1ONjJDS3VxRFp4M3VBWGh5a2VDekJRUDBSM0dLbVM2Z292Tmk5cnBqTTBZMXpaRitkbUZJMFhLTzVUR2J0OVhNZmZ1NUQ0MUtwUHh3ZjlhZWxZbGwrS21hemhkYnFlRENlbFNwWnNWRlpXTmk4Y0dudHpMblZ6ZlV6Rjg2dmJweGJhQzgzV2kwRmRuOHc3blJIazNHKzJ4ME4rc04rWHp2OGdUWThnL0U0bjVVT08wZTZtODIwWDgxSWdicWthOVJnTmhzUEI2VlNVVWVsWHVIUlRUR3JWaXYxUm5VNG1CN3NIWXpINDBxcE1KZ01aNk5odDkvVm5ra3JTUXRzT002L2QyOWJ1NXpoWVBmQk8yK3ZyYTR2cmk3ZnVIM243bmRmemtyWjR2cjVQLzZ0WHhQUE4xOTc3ZDVyM3lxMmxnWTVwZExzbFgvN3I1NTY4VE9UNGZHNE5ObmV2WkhpUEo0d0tyWlRaRWNqa3JzZGdXZWg4VHJGN0NxT3pwT0FzeDhjWXdwUzBnaVduaWxhY1FOTlBNWDZVUGdTOFlRQ1kwM01zS2gwa2cvZERXOG1GcFd3Nm1ZS2NuamNHRk5EcElQdU5EVG13TjhrTlRvSk1OcXdTM1JCejBTUHgwWnpYZ1N5T0EyZUdpYkI1L1RpNlhnNm9RTXYzWFRiUFc4ei9TejdzUi8rSVRYbU9JaFU2US9kNGFLbTdFdXhuWWwxbEVSUEZTbkpDb0FlQS9wZ3RMM0FTUjErYkd2MkNuemJIaS9vSlZBSFB1QkNibUlpSHY5cDJxVzFzMDljZi9Mb3VMUHo0TUd3UDJ5dG5WbHFyMnpkdm5XOGM3K3p2MVdxNXNlRHZtYXZhdmZDajdnVUJvT3Bncm5MSGVyZzZLaDNkSFRjN1E2R28zRi9xTGdjOW9iYTZReDd2YTQ4SjJTM1A4aUsrU2tmcDVWVy9KNUd1VnpwOXJXWlFXbWhlcU5wNTdpck8xZWw4SHlodkhVMDJOdnZWTEpaYzZIYTYwOXFoYXhjcWVvS29LU3J6VkJ2b0JWU0dFNnpaNjZ0SEhmN3hkbG8rOTc5NXZLaXpMdHg3bUo3WllsUG9JNTdzOTd4TTUvOGRPZlJqZVBkN2ZOUGZQaTdmL1N2ODcyRHpXYytzZEJzN0haMjd1MjhnWlZKNWNRUVdRVXJrMXV3TnhnUWdBSWlNZHJlNmFYSnNERVB4ZFFwV0ZoZEErTWgrWWxoYlh5Yk9pS0grR09kRkRFNWJNU2RmZzcxQXdkL2VoZ1doU3VsZTkxRkZ0UkM5QlNleGdBUFBiMmlvS0E0M2oxbnRGTUV1S0VLQWNDNDRTVVI0TWtCY3cySHh3a1NNczNDc0pqRmE0QStZS28wZTJDeW4vamNaNDBpRGhtR2pkekpJVW9uOGhUUFlXc2ZhaFA1OHFON1JHMmtocUlqczJJZC8vQ1ViM1JDQ21ad0FWRCtaUm5RZ2M2K1JtZ0kxOFpaWTNIeG1TZWZ2ZkgyTysvZHVEUFF4bnJjN1QyNnNYdi9yZnpvb0REcjU2WmQzV05PQ21VZUhwZXJFOTJac25HYmRJNTduWU85NCtQRDhhaXZtMVV0QnQyNnppYWpZYjhybVRPZXhraWtvaUs4MysvM0ZQMzkwWEd2TjU3TXhxT3g5djlPL1R6d0cyWWxiYjBiamRhc1ZPdE1pdmUzQncvdlBlb1B1NjFXcTF4cXRHcGFZSk5PdDZ0YjMwcFpkM0xUUnIydVdMdDJmdVA3cnJXLy93Yyt1YkMydWQzcEMvUEdxMi9zUDdoLzRkcDFDYk84ZW5aYis2Njd0OCs5OE9scWUvRmJ2L1NQWC96aG45amUyYXN0dExMUnFOWmVlZU9kMzFic0VOWThpQ1RZMWZDVEd1ZDFZY0N4bXhjWnR4ZGdjSVB0SDNFV1I0UURyRENuM1JqaFRnYTJrYWxOeEhoWlA4aU5ZUTNvcXFIYWJzYmp3SFJDNDVCenNZRHFGek5JMUFGekZTTENnOHpZQTRXeXowRzZ4NzBRUWtHZ2k4aWNReGgzdUMyQXBzVkwvTmw5ekVjZ29JbFZNNEhPcXBoSUJmNEtKK01EWGNqLzUvK252eXFrYkN6VVhETXBhbFV4TEhZbHNXQndMcW1vakoyZGRSZ2pHWGd4MkdyNjVCNnlodENFUEVWNHhBRlEwSEZWVlhGYmFkLzJvZ0JJTDg4ejFFWlZPMmcrdERpYWNkODVLL0l4Z0hLNTFxaFU2dVB4cE41czdSMTI5L1lQTy90N2xlSmtjYkdxWkp6NXlmUTBOMEwwVEN5MCs5VldZTXlUamNsc01GS09ueDUxeHIzamlxNE51aG5URHFsYUxUYnF6VnFqWHFyVnl2WEYydUtpcHNpeThpUlhIQTV6V3p0SDFkSk10N2FEWVg4OG1wU0wyZkZ4djlXc0huYzZXYkZRYmRSMTc3dlNLRC9SMWlyYjEwWll0NUpacmZYYU4vL294VTk4NnViNzc3NzF6Vzk4OGpNL2ZPN2FVODJsbGJkLy8xZlBYSDA2WDIyLy85cTNWcDU0N3RFZi9kcm1wNzkwNTl2ZnVQVHhIL2hILytyL1BCanR5N1lUMllDb0pxSW04WkV2dzlxTjR3dVppc3dRMnhxaUNFOXdnY1IyK0U5YlErenJINUhScFZWT3hzcGFmWHhqV2pEK2NFNlNEd2c1UDNmWERsMkRmTHNzSFBldmpsQWxmVGIwSXMveGxwTXpGN3RUM2w0bDB1dzUrNVhFSllEZFA1S0lVbU85ZUhSNEd0QVVUMCtrSUJmQkl1YWNpQjFmd3FLaFB3eWh0b2NsL0trNlFpblZCc3dIQ2NrR0lLaUNjWlJDL3YvKzEvNlBZc3ZlVGVrUk1XUkpaUVgra3g1clFNUUEzQ29aaUhBWEIrMGRGZlJjSjNHRmkwWnBXU2pJNVN5a09GVTBTcjBDbklla3B6aHIxa1RGb2hEZTJJSWRDczRyU1lBc0Nnb0RheEl2Skg3SFFRQ2JJeFlsOGtncXlTdTVlRTZuT0VFTmdqNmVaQ2ZNSkQveTQyelJqQXU1NlZFdnQ3dVRkWTZXRG8rRmsxenF5cFh5NDJKV1hGeGNyQ3kyQndQTlVsNWRYNjYyRmlxTmhYWnJJWmVWZHJjZjZvcHh0TGMvbm96S3BjSTBYMTVjcUYvTjNYbnVFeThlN1IwMmxsYnUzcm03c2I2VUsxYis3YS84c3hjLzhmMXJsNjdwUmxpVzZkeDZhLzNLVTcvenovN0JzNS80M0dnOHlCVXEyN2RldWZUaTUrNS85eHNyVDd6NFAvenlmOEQ3cWppZldOZUIvTEtYY3p3KzVtUjdjM01rSHlVM094VmhYQmxMVVE3Z3ZLYTR3OXF5bEp6Q1QxWGlyWWg0dWRleHpqWlQ5NmtFSUtOVjg0Z0dwSjJsMkNYSytUUkJwbHQ0YnJFd2Y1RlZ4c3hzbFBDaFloMVBxQmYyQUF5UFh1NGRIT29xR3FKdXZJWS9BeXNmdXkzR3VESCtPQWl6ZVMzL3oyTXMrb0M0Wi9DZnd3Z1VET2xCWndRMEEwK2k0UENpeW43NlIzOUVpa3RBaU5IZkMxamlXdVNJUy9IVEgzcHgyQ0h1VEdjTkRkUHhaRmMzWURha2l4KzhwTUs3ZUw1M2dITjBZUkNHMnpMaUpaVllZUnpZRlVIa1B6ZERBRjNGd3FNZ2VaN0RPaktCTk9NaGRNUzM0dDQ1a2R5Zzllbm5lTFB4bEI4QTB5NmRUMTZ4TEhnd042eTFCcTIxblhwbE1KcFV6bXhldXZMa3N4ZXVQOTFhTzYrOS9PSFJjU2tyZEE1M2Jyejk1cjBiNyt4dGIyM2Z2YkczZFc4MG5UeDRxSWdmcjUvZG5HYmxvL2ZmUHR0Nzg0V1BQbDl2TmhZM3o3enlSOSs2Zk8xYXA2c2QxK1Q3UHZkam1ycXo5ZjZvZTFESzUvcXovQnUvL1MrKy80dC8rY2FiTDUyNyt2UkVlNnp1c1ZUY3VIQkJtbi9uN2QrWnpnWll3RjdYb3RVSjZWbjE0V1JsZFVEU085NVFoN1MyS2V4TG9lam4wSkRaTkdJNnJFb2FnNExsQXoyMHRMVndOQjgrWndJY3JSSUJaZEF6U2hJWFRVWCtZNGlKdkgzSDhnejI3aFZoTEUrSUl0QkN4bUNZV2NBVHpxRUljVFJIbURnR0dNYkZqblhqNFo4Tzk4SGZsTUUzT0lBQXBaaHhUMktDVExuOGYvT2YvblZzSTJtbHNXVmpLU0FHNlZ4RmFxam1uMWxGa3ZHVHZWQTVKZzFEbWltc2xXaXdvYWJ5NHhaV2prVXdYaEJrYk53eGxZamd3TldBdDRESVdHWW5HakN4aFJTMWFYbXdBR05iRXd5VHdKWWtMaWJzdWlVNm42QnlyUEJwUXFkSVFsK3hQbEpHenl2b2hSbXBTZEN6UFJ1ek1UQitiMnZ0Y0h1anRiRDBzVTk4LytiNWk5VnlPVjhxN1hhNmp4N3RiMjAvbUF5MGdXa3VMalMxbjFwZWJHdnZuNVdMMjI5OFkzRHIyNS8rd284dkxtOXM3KzVVNnd1dDlsS3UxOGxLdVZKalpXZjNxSCt3ZmVINjlZUER2VUsrbm1XajNSdmZHUjg4WFAvRTE0NGUzaWhPK3MzbGM5LzZyWC82eE1kL1RIbmlWNy85dDdkMjNyU2lhTW1uSGFRSnhVR2hmT1hiUTl4aEc3Q1NNUmQ5bUJORGdhYXlJOVIwNXRFMWJWcWtWeWk4b1JWQXN6RGpmVDcvK2V4RGtIT3pvb0g3SWljY2tucnNqMXhIT3NRcHpDTlErVWNOWFFUa2xveEhuYkFKK2xoV1BKYVFVQkpHWndHaVpGbW9oU0pLZFp5UmpVZ2pDT1Y2NzlEWVNrZ1IrUk1sS2VvOHVhelJ4L3llSmNMTUFVWXpmbzNmWkZoQ292ckowU3o3dVMvOHVNU1RRdXBXZklvS1NWQTdjamF5Syt5Y3B3WDdnQmJwUWNVd2d6cEk0SmpINzliQWxxSmFaS3A1dEI0MGRHQTlGNG5LRzM1SkNZbkswaE5Tc25NbDRSSXNheWdaQzBtTXh5SDVJZWZIRTJVWEhyekxLSHpRZHpiVFRhb3p1cDl5cEh4UGptY1o2TTR2L20rdEFDTzFHQlQzazFGdVVxa2ZOQmNQZDdkeVczZTNmYk03NmZkNnVlbG9lYUZ4NmR5NTVaWGxqWTMxVXFYUzd3NkxwVks3VWF3ZnZMWC8xcmZXVmx1TGk2Mk5pOWZQWDNsaTY4NzdsWHgrTURqY3VQcHNxWkN2TlpzUDMzMmxWR3MxRmxvUGI3M1gzWDEwNFVPZnlJK09oOFhtNHRMcVpIQjg1NDF2blhucVk5bzdsK3Z0VzF1djdoL2V0ZjZTV3M2T1p6U3NaS0pEQjBhd2pUQ1p3b285alJBTW9Fa1lZcit3YVFvRm5iQ2JEQ1ozeTZKQlk3SWdFQUk0UWdNTXpJZzRBYjZhWUhGaXo1VjZVbzVqejBuYld3ckxwK0taVXBReHRmL0VVSWV4dUU4c2dSaWlYczlvcWhnQllGWk1BdzF6bUlQd2ZBcGNveXlBWjNSdElBeGhkdWFYK1Bqa3hRVkdWdnJ5VC85RWtkMGFXelowSjJxSlJjZWppeU9iUmM2ZmV6UHViQWhYM1kyUUJJeHoySXVyN3RVaTFzVldOV0V1SnQ0a09tK3dJZFFzTVJzODUvc1c3T1JyRE5kZlBLbGFYWE5Ic3BPaHFVRG5JbWhET0FkNGN5SzdFK25FcnVLWUhnS0ZneDYrdzUrQ1c3R3UydDl1MWtEUnEyTThaRGR2LytVSGk2c0gzZDdnL1p1SHQ5NjlxWEF2NjlhNFZwWFY2cld5N2sxYnJkckcyc3BpWmRZNmZ1Zk5sLzY0MmF3ODlmSHZXMWhjcURTWHVnYzdXYkZVckphWHpseldQbVhRSHgzdjNsKzllUDMyZC83dDhya25GdGZQdHRmV09rY0h5eGVlcWJYYTc3enlSNXNYbitqbU10MFJsQ3FOUXJuOGpWZisrWEI0aURpc1lZU0p6MzdLRUVyUE1vQWFzZ0lXY0RwUUIxNDBTaWY3KytTZ1N5elNlc0JpNFg2MXNhQ2F1SW8rczNEK0ZNWkU2bGVYT0JLT2FoTFpPSU5jeXdzazJaZDNLVlZyRUlTZ3FZS2ovM3pSVnBzYXZpZmRsazBueTJCU21EQVRLNWdwNEJ4ZXBrTTJVWDRpblVIajBTQnBtVDUwSVp6MEIyTUlYUWVBd055OTZsTHkxUy8rWk1Ta1l4UEFFUTlBMjJGTkNMdExJRjI4TGVlZHVJa2l1RTlnUG9ZeGgxa2M3TmxaVDBVV0JEa2JsT3ZJM3o0UWk0V0wyNGhtSkxUNThDdEFhQmk5VWxEM2xRUXFodURyK2hxcklOY3VpeTJBZXVRYi8wS0wwZ0d4THQ2S2JQOHd0WWJ3alUrRnUzaXl5eUh1V1JKaWhFZHprOUZzMUd6TnJsejY0bnYzZHJlM0h1NXQ3ZTN0SHZRR3ZkM3R2VnFqMmE3a1ZySzloZnorNGZiRFN4Y3ZYUHp3eHlxbGJEeVpMU2hiNTB1anprNTVjZlB3NGQzOGVEQ2I5THFENmNxWlM4dXJ5N251OW43bllQZnVuWTByVDNmMjl3NjI3bHk0L3R4ZzBLdGtsYzU0b24xV3VkcDQ1ZDNmN0E4UFlxVW1QNGJQSXB2SmsvN0ZkN2xBbDM4WGNOendpT0N4YXhsaTR3alEzbDFkckIvNmVSQkpraVZBQ2U0b0dKYllGY2c4bUNyaVV5VzRFbm5nZlVZNk1XVXB4dVZWSFBDYTVpSFdWRWNhNTFDbEVhYnllZTVUY1hKU0UrUk9GN2hiYlBybmdZN2Y0Z0N2cWNQN3lCenpRdXQ1TkN2Tk5DMTJvWkVVWjdnZ0JWS2hWRlFnOGpsL0JhM3lzWTV5bG9GTVI2RllBaW1vSkh3cEs1V1Z3Y3BGOVFrdnBGQjBnaWlXczNKWkZOQ2FYSHg0ZTVJVlVITG9NNHVXalE1djVYak14WEpDZWJhUytNblNKclVOcXlnaStTVXR4YlRqT0g1S1RzaVJQd0t1b1BXaHpUb1AzMGF6L0NpWEgvbXVsQjJPc3NMWUg2VE5xNlViekprMlBPTXBueUZ6ZG1lMXNNZFJ0TFA3bjh3S0U5Mm1ydldPZTgxcXRUY3E5WFBaeW9VTGw2NDk5WWtYbjNqaGN1UFMwbWh6cWJxN3M5ODlPbTR0clM2dVh4d2M5M1JydS8zZ2dlSncvWW1QYnIzOTdkTEMydUgrd2NMRkQyWDUwUi8vaTc5ZlhUbzNtSlkyMjh1S3ZyZCsvemVxemVhc3Y5UHQ5VnZ0dGVIQlhSbG0xdG10MWhyMVdwc25NZkxMYk1yVEZIeEZETW1SSWlteWRSR2dqRUVRRjJRRW9sOW1jUUJobkxGV0NOZHQzZkxnWEVXdGY2c0FkeE00TEhvdmJFd2xkZmtnaFN5QXlzU0RRRERZVTFhZFRNZGpmclZoaEpWNHJHdjcyRmFUNlZDTWxSUW0weEUwTnB6NDZ5eW11aStTdFoxN1NDdHlrNDFQSnZLM2NGRFFCVW1VWEhRZ0RUQ1BGaHlhaHJrVVUxdTFjTDJsNWZ2cHVCV0o0Y2JCZUJ3WmVPYnlRTzFtK1Qxa2RHV2Q4SUdTN09lLzlBV3RNNFdodGl1eXBwYUZueVlSZzNFNFFmUFpPZFZhbFFwaXAyZVdCMW1jUkU0VXF4bFZOTDI1aWMxTFhDblN0bDZIZ3BpYTRQYUJpM1R5YXZiYW5mS3p3bXhkQ0d0V3ZPT1NDek9Hd0JZMmhPaVQ2eUJ3ZkZzeHAzUVpTQlNZRE90Z0M2ME4zY1pDUStEelJyMnNwZFNxWHNpMDJ4RWxqaUJ0VkRwN0c4T2pSNHZON054UzlZYy9kdjNDZXZQeVpyTTRIV2gxZHpxSE8vZnVOUnMxOFd3MUZ4WTJObHVMUzdQeCtQQmdmMjk3ZSszQ3hmN0RHKzNOODN0M2JxeGYvVkIrdUpjYjlScXJaK1dNczVzWGJyejlVbTQ0WFRoenRmL28vZEZ3WEY5WUxOZWFqN2Eyc21ydDV2MXY3eDdjWVozTEExN3pySGExSXkzSk1VNk55cDdlVVlTNVJNSTZsaTdRYWtFb2JrZ1pVcDg4QVRmcFM2QjdsTE9KLzBnbzBoY2lrNWtqTlJ3VFk5dUNDaElpRGRpVU90SHRCUW5UbUUxSURoSXJZenlPa3dtakllSUVuUURPY1JaUFpDSm5UbitNQWtmalgwMTA0bkVET001NHBJU1RZa2tlakJaTXJCMldTZGNCcG9CZSs4TS8vK1dmNFUwR2d0bEZjWWs1YURrNkEvQk5wUm9uaFVobWRhZy9ZbjRlNjZ3SHNWT0pXaDBhNm4yOCtHcUFZaDJmZ1VVT1M0akNra1p0aFpya1JuZVNnYVNVTjBseUVwd3NoQW9vVElBU3hsTGJXWXBsN1NTbW1JWVd3NUN2aEpHYk5FcDQrVmRrWXF0ZGpRM0JLdUpMUXlLQ1Q5cHE2cTlkZXlIZlh4MzJqNHVGYVZGYmplN0J4Yk5uR3ZYS2JES2NGdXZEWHFmR1R3SzM4c1hhOGFPNzllWDFlMjkrcDFocHROYlA3RDI4cDd1RFVuT3hXcXRuMVhydmNIZmw0aFBEZnE5WVc2ZzJsbzRldm5QMnFZOXR2ZkY3WjU3NStHRFFyZFRxbmIxSDdiVk5UVFFkalI0ZTNidTMvWTZ1Y2pLRnJLSWJGN2FWeVRLY3NCOUJLQ0hsVzVzRlBBaG5EZkFhU0FqR1RrZzhzQzFHaE9POGlGYTJpMTdDM3dHaE1pMG9FUVEvREorR0VTaWlWTlpsSGxsSkJCWXZpdVV6eStqRHdXbE8rRkl4ZGN3ZkhtY3grNXNoOURLTm12UGRLZTRWYjA1cWNrR0NUd3AzNFQwRTM2bEFLdVpjbThDb0JWTWs5b3loV2t5Qnh1YVEvWVd2ZnBIZ3Rta3hHWVpMb1kxa0VkTnVLc0tCQ0hTaVBHRWQ2ejdCSVJLNmlyY3NWSW5ZYkUzRG5SYVNDSU9zOGRBM3hFVXJoVHU2RWI0S1FadkEvMmNpWGZXd005Y3N4elFLUkVZWFJDMDdlU1dRd3JsUUNwdHVTVmt0TEFDTkhXbWdybXZ4c3kxZ1BGYkVtRWMybStiT3J2M2N3VTVub2l0aGxsOW9yU3kwYXF0cksydWI2M3VIaDUyZHZVbTNVNmxYaStWNmEybXBVSzBkYmQxcG43czI2aDN0UDdxL2ZPN0svUnR2RFh1RGxYTVhxdlZhZFhHbHU3L2JQblB4Mi8vcTc1ZUwxZmJscC9jZjNtMXVuQjhQWncvdVAxZzllL25vM2h2dGpTdmo4YWpXYkgvcnpYOXoyTGtuR1dRNHZJUkhDUTVjQnlROGNvTWhNakJoVkFZd0p2YUVXSW93UWlxNUkxWEVBY3lkRmVoUGFJV25oaWpIek9jMEMxT0kwaWxIZlFLam91aVN5RWswNW11MFIxc0MwNmhEa09JSmJFS2t0U0dIR2dNaWRhb3dKM3JwY0FEZ1gxK0JhWktNRUFsc3dwdVZFSVNFVkVzODFJc002alcxR2JKVXFlRk11RHNjRll6U25GaVZOQnJpUjZ5UmtGTnhGQ3NBaUdNVHE2blZ3TU1aY094ZE9JR2xJNjJUeDlIdkVyRWUrc3B6a2w2MUJKUmtXRTB5V1FIaUd5bDVQNGhWSGtvNnNtMkN0SjNVU1pvUXVHa25veTJOVG5Ed1NoaHI5NmI4amR1b3gya3p3OER4aUZVRVcvbkxSclJGWjlPVjFrZDdCeGVHeHdjN3UvZVgxczVyMDlKc05xclZValdiVkd1dC9lMUhtNWV2am5yOXlTeXIxY3JsV2tzREsvVkd2YlZjYVc5MEQ0K1cxdGFyOWNyaG8vdmFRSmVhSzUxN3J4VkxsWTFyTCt5OCs0MjJ0dmozM2p2L3hBdkhuYjNCNGZiaDN2YlpKMS9jZTNSZlY0UGU0ZjZ2ZmVzWGM0V0pkdTF5aXd6bC8rS0ZkcktNYkdkMyt2R0NyV1RqQ1pKM2JVbWhuTlJJZFk3cEUvKzdZRmFSYTRoMGhJd09zb054eEtqek9rblEzb0NMak1nMHRyNXFqUkU5MWplbk9YK01KZ0hoQUU5NHM2OXlwL0RtcEFHcUpSUVRNSklJQzlGY0l4dkNjTGF2NHpaRG5KeU1WSXVIZCtvaTgyWEVBK2NIbWd0UWovZ3J2QkJPdGJzc3NrSXIzb0tjNWJLLzlQV2ZKWGdkZ1Q0Y3JGWUhvem5LQlVTbEZ6bmJlMis2Q1dhamlYVEhOR2UvZ29jWm05QzhxSkJkb0FHc2h5MUp4alkyOFMzdHBMTU83alVGZUFFSWhTRm1iTUc1a1dJZmpnSmpoVDNKRzdOakhXcklNSTA5bEdKZEtvdU0yeTcyUURvd294YURwc1pVbUpoaE11YkY4MTk2ZEh2L3p1MWJLNXVYYXJYcVFxUEdQMWZLalM5Y2ZxTEl4MDV5NVVxWi84bzE2WS82ZzRXTkM4ZEhlNHNiVjc3NzBoK1V0S0dwRjdWL1AvL2s4NzNla2JZNzQ5N2gwYU03OWNYMTJrSzd2clErcXk5UGpuZXlTcjFjWDl3OGY2MS92RHM2N3ZiRzA0Vm1zOVB2L3Y1cnY2VGtvV0JUSXBFOFlTemNnR0I0ejBrQkxFVTEydUhuT1IxeG12SE9mc0tiekk5eHBKYWRMNnZSWXFpOUVGeU1rRGRRSDNPNEdPL2t6RlpEY09RRzBFWXdPVVQwbVFHVG1SVStvOWpKd21pT09PaWp3dlVHSFpjZzRHK3VPTm9IT1k0NTVqN0ZhY3dQRHE3UVdBb1Y4OUw2QVF2cytjMkdJZlAxNXJHejdLOTgvV2NsZ1BjWW9uSkFrOThWMFR3MWRCNTNzS1pBSm9oVmlkb3hMWldnRjBBYlBwbXVDRkc0TnRoNXNWa1hMTVVZTGlUcWhkQXlORExOVTZ4akYxVlBmaXVMbUE3OUo5eHhTMjl1c1cwRll0YjNsMkVUMzRNYkwxYTJuUTZDWG9CWFZPd0ZGZVlhemgyc3BrWUNRelpJYm1QOU00WFJzN3ZiMjBzckcxc1Azcjl3NmNMTk4xOC9kK0hDRC8vd3A3LzcybXRMeTR2RDduR3p2WFMwZFhmMS9CV3Q3dHZ2M3BqT2l2MmozZVhOODRlN3U3bDh0bjd0MmVQdGgxbTFjZWU3MzltNGNMVllMT3ZxdDN2UXFaWkx4L3ZicStldkhUNjZWMm10YU8rajI5bjc3NzY4ZWVYWi92NU92cm40aDkvK1g0cEZRa0YyOHFaU0ZwT0o4QWIrY3hHR3JaOHRURXBMUFp3Z2xtMmxCM2MvR2dOUzExNUhuZlJXcmJFMnZPTllIUkNqUHJEMXh4b2lzRkVVUGhRbFZVRUZ2aFVMVXQya0J4Y1oyZXNoOEM0YUlFblVORlk4a3BTTW81djVnOUlqNUp0WVRPRVhCam1wT1JLWTNON2tJRElJZC9BNE82QVlIc1EwQmJna2JqeXRWOUVJT3hxSnNyL3k4MTlDQWdJVHNSU1hicWx3Y3FCSHdWWVF4Sm9nN2duMEV3cVdBc2pvaU9Lck1JeDV3UmZXbWpUa1EyWkVkSk5BcDBtNEs2REhzNUVUTTc4ejRVY3VCS2lQa1dKOTdJeE9xcDZOZFpraXc3TXE0R09qRU9VYWJsT3FpY2Y0a0RDV0FxQVhDd3F2NmJYWUpKYjNmNVBDMlpVdjVvZU5vcTRodzk3eXl2cUhuN3Urc05CZVhWMjRmdjN5SzcvL08wKy8rTkh4WUtDTlRiMng4UDRiZjdKKzdibnRPKytWSzVWaVZ0aCs4R0JwZmFOYW5MMzlqZCt1cjV5cGx3dm5ubnJ4OW11L3UzN2xlZVg0VW1FMFBOb3JWZXZhOGZjSDNheVl2ZlRQZjdGWXJpMWZmYlpXYlVxZ25ZT2RQMzd6bitzdTM4TElDNFF6OWduN09WcWRUV2pRbHFwQjZRQzJtYU40aWN3RE1CYUVVQW9pUXNDR2hnTHJ3eVFpUkhZUDJNbFFZOVVGam5CMHpsQnZwQTFHemNOUVhTWmkvNlZEVFUwSEg2OVdRUkRRVktlTjdNRzB2ZTBRS0xIbEZNOGZCeGxkaFVpSWVHVWVIMnJCU0xCM0psei9MU1FMd1dGTm55bmdFeGdHZ2dpWTVpejd5Ny93YzdadUZBTVNROEk1Y05scWViOHVWblM1SUtZSUZPdDRnVUZPL0hTcFZnY2ZPNEJENnJXR21oUGpTeXlzQ1l6eFF6aGlGOHQ0bjYyOWlvTmJZWjN6dzEyaVgzazl6d1lHU3VzdlJkbU9RNmVLUXBwbnRTVGRaSVhVcFRXUUYwLzh4UkppL2VqQ0VXUzZRN0NiWUpBN3QvYmpWODU4OHVKbTdSTWZmM0psdGYzWnozNWlvVjdxZHp2SEI3dlhyMTFjMmpncjJhZVRVYkZjbG1iMzNuMTlraXZWRnhiSHcrSDVKNS9idjNjalgya3ZYN2hjTE9iRytXcTkwZHg5OUdCaFpWMUxxcnF3VUc2dGJiMytCNjF6VC9kM2JwZWJTOXBnTEMwM3V0dDNxMHRuZHZaMlNxWHFPemRlZXZmQkgvSndQVUlWQTh1dk5scFlEMWZFcmhpekdpdHd4aDFTWkdzYkhGV01kOXRKWEhwcW5VQWRldW9HQUFqckczQkkrL0dWbTZxSmJ3allRRWdpbnVtcWkzaVNQZFBLa2Y5NFY1VUxoamZ1aEREU3hRWEUvWTRTdWpSWTh3dVgzdHBrS3NnSlVQODVaTjF5ZU1hK1VwVnFYZGlSVGk4UlNBRDE0L1Y1UVZBcnhsTEZ1YlEwcTRpZFFIVWlyekZjc0pibS8rb1h2b3pFSWlKZUVYSitTZ0tyb3R0NmVjMkNjWTh4SEI0Nkx3eVRDMHpEQUV3dndEVUF1bkdRUjJUUUVDdFNOZTlOYUhkT3hPZTBRVmVDOTNzV0NTa3RSU05Ndkx1RXp0WWZwVEVRWmtRciswdHNNYVROUlBZM3hIVkQ5d0FzR0Z2QjhrZzB6SG4xN0U5Y08vTlRseTZ1NnlhMjFXcGNlK0tKMmZCbzFEOWVQN08yY2ZaQ3JWcmlvV1NwZExCMWYzRjFOVDhiUG5ybjVlNWd0SHIrZXI3YzFKM0wrcVVuYnJ6MnJVYWpQWjRWN3Z6aFAydXVuS3MyS2cvZitzNXhmN1N5dXI2Lzg2amFYdHg2NXp2MXBUUDFSbXMweXhYYjV5ZkhqN0xteHNMSzJyM3Z2ckovdkhmajRiZTA2ME1pRzNFdVA2Rk13NWFreTQ5V2ZMYndpUjVpVVdFT2tjV0dFV2VCbnB1ZWdya3hGcnhsQmcxVXBFZGtoOG04ZVlGU3RSS2E4Z0w4eU9nT0dac1lqbTVxY3RJci8wM0taT1l3THlrYVl4Q3lpc1pUZTNTNFRSWHplZkpJVHdRREYrbHdOeEdzRVNFZHRYMEZnMVNrSWJXdzZHUWE5VnRGNG9xYU4yRE1SNWNGaGZ0WEpVUmtkWWR1K2lpV2NuVElUd2U5YXRpR0J2MXdsZFFpZXFGRTZVRVVFbncwRUFxVmdFSkRyQjNpa3M2Ukh2bDgwMDBkYjlwRlJsZDhBeENqMC9RV3FXREZ2V2o4UmgzOFpBN3poTE81Y2JBR0tCZ3JabVNzOGFHL1NNSGpWaXdrMU1YVlQzN3EyYjlZTHMzS2hkR1ZLNWR5V1NrM0hyYjRmM210OTk5KzdadS8rYnRuejUvTkZjdjVRbkd3ZXo5ZlgxaFlYaCtQeHl1YjV5WDV3WU83dyttRXI1eTAyNlZxbzk1c1R2c0hpMWMrMUd3dVpyUGg5dDBiaXlzYncvNVJjM0Z0ZVdWcGIrdHViZm5zckhlUTlSOFZHbXZpV1NtV08zdmJoMW4zdlR0L1FFajRvQ2c0eUM1SVNKN2hqVlhzcjRKaE9TZGlxYUZ1SGt4NFo2K0dGTlFGQkExTmpEbm11MWUxbGQwVlVQSVprYXF6NTlNYVVsTUVNYVdTcXVJZ09BakJsOVpFcjhHNlVxaXRlVHdwbm9hcmdJelJFcEJlSklJTGNjSGthak9EcU13Y0IzSEhTVTJGdi9pUHNQaVhDUjY3MHJ3WTQ3Tk9ERWt6VUNSdGVCYXg3VnoxRWVXc0dTNGxJalE5ODFGbi85NWYrRW9JTG9IaWpDVjgxa0ZxU1dFUkdRV0FpZFEvUDZEbFNGc1p4cHFNVVJvTHVadUF6TzBsNkZXTG9NRGNjTTRtSXpibHlzU0tkZjhZcWVOZWlYbWNHL0tKTG9ad3p4cUxnOUZNQVVOWk1aNDBBU0JueEFDOVdsUVNRWE14eXN0ZG96Qm4zTGZaS2MzYStaLy8wbisxMEtoY09MK3h1dHk2L2Y3dDVjVzY3aThiamViMm5kdWRUdmZLVTg5VVNybUR1emNsVmFsY2FpeXU5VHVkalV0UFNxRDNYLzVtcGRGcWI1N05UY2QzWHYybTdwWUxwVkpqNmV6OTczNXpjZVB5Yk5nNSsrd251M3RiaStzWFo0ZnZsNWF2SG03ZGFDNXVGRnZMczlGb1ZsOVdzSXg2dlVQZEFSemR1TFAxS3JaR2VBd2RzdG5TYkJlVWg5VDBWUmdrWkJqYldtSUJ5UGkrcWUrWE1nRDFRYXBYK21RMURVNkVqQTdkWjhMRmZvRUh5OHR4US95Ym1nS0ZUcDVIQUF1S0VEZHJUV1hydzljSDJ5UmFJYms1aVNQeWhUU0VNazVpZnI5WWluSFprRjlVQzlZZ0Ewd2JKRXhpeUdKYmxPQWFZdWtsUUc1MnJKMWFVNksxdTZNT01pY09Lb1RsT3NtM1RVSjg4QmlZTGc1K1Zvd3hsREJ3c05BZkxkUm10K2tqT0VCcE95T0hwVmU4cGEwWGhyQVczc0t4cTFGVEdaMllabzhlQ2Q2eFRvS2ZqS2REaGRUOGFUdDdFdVY0UHBnQkRZc0IvakJscnpMR2NQN2dCRCticXpGcWNqMWhlb3VuVzhJUVhmbnAvUHIzTFZXejVYYWptT1VPT3FQTnpiUFRmdWZoZTY5cDg3MS81OTMyMGtLdXQ5OWVPN2QrNGRLTmIveFdxNzB4NnU1cDI3MTE5NTNidi9kTGw1NzkwR2ozbG1hdDFSdm5uM2xoLy9YZkt1WUxDNnNicTVlZU90aTZkK3VWMzlQdUthczE4cVhTS0d0dDNYNm52bkpSVjgzZTRhUGV3VjRweXlhajZXdHZ2bDFiMmh6MUQyUXd6SVhoNXdiMGcwVmpvOHU5NlpEa2lZelE1dmtqSGhNZ3RiejRlUVFwSzhPTm5LOUw4WlJmQ2RPZk5WZW95dDBaVGlGbWRHbVFqVHhKWExuTmlDN0hZK1I1UXRXWTJIamdUcENRY1dtQkN3bU1mQlF1NCtxTXU5aXFjcXMxbnFqZ1JDTjA0QncvYStDL3FnaGtQMnUvMjlIS2J0clE2c0l1SUQybWt4VHFFRXhoTmxmRUY1TVNRdDRqa0UvTk9kNjY4UTBiTWFEcy9tVzBEME5oTDJESm4rTEJLcnRQaGFzWnhUVWh5d2dNR0liRzNtSHg0R01hbXd0eEVpejVVcXFXdVVLTzlDa2lLYThROTA2R0orc2piMm5pRTEwYUtISG02ckZFWU1ZY1hGZFY2VktvU2xabjJhQWVRYzlGemJXR2FubllXTFRENWY3TFY3T0ZqejMzNzE4OHU1YWJETjU0NVhWWmE5VFo3eHdkYlY1NnNzeS9vTXUxVjg1MEh0N2V2UDZoTXIvNk1TMVU2cU9qM2ZiWnE0dnI1eWFEUWE3V1B2UDA4NHVyNTE3OXJYOTI5Zm52YjE5NmJqVG9LNzRxMVZxbFdzNk5lODJsalZLbHNuZnJOWVg0NXBVUERUdjd3KzVlYSszUzNzNjlTcVUyR0kzSHczNngydmlYdi8vZjV2TWp0b2F5bkZPTVAvWk1LU3JWek8rT0NHMHZCaHZaRmU5NVlHLysxQ1RsdzBDUmFVck1neXU5N1dDTWtDY00yRGNFaXBUTkpwU3h6QlZIQmdzbytkb3AwNFAwUFBTcjEvTXBUL3FoTlVNZ2cwY01FNmtYSEEwN25peURCOHlEREJnT1pIMDZXRmljSU9sQ1BMc1pSNE1CSnRBOXlyd2hDbDRSd0VGZ2VnVURYVEZXQ3B1dmc0WENac0xNdFZaaEhLem1reUVxU3dwQSt6clA3Y2Q4eXFiZUlhZ2JMdFJlTFVFODUrTTRrNUpFSWZIbWlQWDY0emFVdUtSMnhPc1FrbFZKMEkvNWVKMnlPMi80TzVFelZIbkZFeERCTkNkc2daUTBSbG9iWHREYUZMRVhkSUtSbkg2T3lYVXB2dENpRnhkUTRvQXIxc2VlL2ZMMWk1ZHFsZEw5Qnc4WFY5WTNONWJHdmM3WlMxZjM3cnp6enN0L1VxcTJTdVZpUHBzV3N1SndraDhlN1pUcTFYSzlkZi8xM3gxMWoxYXVQMSt2MXVUbHZidnZubi82aFQvNDVYKzRkL1AxU3FVOG13eHYvdUcvN0IwZHRDOCt0Ny85b0ZoYjdCM3MxcGMySnNOdWErMU1kZm5pMGU3RGxVc2ZPdGpiTHBXS0cyY3UzTjU5YTVydmhIdDBPNlF3MGpaZEFBNVhPQ253MWVWZ25DbXkvRDRHQ3dBRi9DVEhHTGJrM0cyeG1WRm5LWkFFbzRmQ25OalV3YmVMdE4yaDVsZndza3pScW5saEZmSHV3OVQrc2dGdmlGdW1lQmRSUldmaEl4NTExa1ZWTHJILzVWbVFnb2w0SEsxZ2tZL2tGN3c4eE9PQUpIcHlFKytseUhFNFhHNktKeGFPSmdheE1BZ1V1SWJYaUN1dUpvcGVoNVluaWlJcUpoWXByaWZrQkVSd0VwOEVxZzd0NStFMWowaGtTdkRKWkY0eGtIR29WNDMwWDRFYzkvU3lNclJrbUNPT0tMQVNHUXdKdTBqdE9wallnUzZNVUF4Um9LdXBHSVlwK3hraU9lU2lvS28zTFQ1NGdHUHpJYTJMVGxvb3c5bllILytTV1Qwald4ZTBzQUt5UDY0Z0JQenBZM256MnRrZitNaXpQN082M056ZWVuanp6VGRiemRydW5iZlBQUEgwYk54ZlBuOTUrZXpWY3IwNkd2UUtwVXBuNSs1dzc1NnUvdE5CZituTXhjYml4dmJOMTVWQWlvdUxXdmo4V1BieXhzVVBmeVEzNlphYWl3dkxhMnRQUG4zLzlUOHBWdHZ5elBIMjNXSitkdXZiZjNoMDFCbHBjejhiSGUwOVVzUU11MGN5UWIyOStLM1gvbWQvWERSWGtsQ1dqTGVIK0VRMEg2MVRhQkp0T21jS1loNzRLaGFsUUlrZnVlTjM3b2hzaHl3THhkL0RjZWg3ZitNM3dDUE14YUdva0MzbVM4VmNzVGdycWhhbXBOdnlHZi9pd2I4M29KMFlILzdnczM1T0JsNVk0bEFpMnZtV3RuckxHa1V2eTgwZkdZRTNBZWo0OTFsVzVzK0Z6K1RoMG9nbGU5b1Jna045TWJiL0hRWjJLTFc2VGtLT1QzZkNnUmpqRS85aUpZejIxVDRDSnUyU2VWM2pjVWM1d0VtOHBjakovdUtmL3ptaE5JbEVZeHZONGd4Wm9YT1lDQ0RnVkRtMGRRVlFMVGtnRXlaaWlUTjQwY0JBY2x0aWg2bmowbnpReHhnMDBZR0dwSFAyNnltcFQ0Y09hRzNnU1BETWFWWm1CMy8rNG9RRUtyQlVDSU9SNlptVWZoMGF5ZDJJKzZCRFFtRndrRjZiSzgvLytTLzlwODE2L2VEUjNhMmRnMFpqa2Q5RUhZNlhWamRtazk0MGwwMUhnL3lrWDE5WUhvOEd6ZVVOc1JrUEI0VlN2YjEycHRKZUdYYVBpOFdzZjNUdzZKMlhteHVYdG02OHVuYnhpVXBqWWVmdWpZZDMzdCs4OW9JV25XNGNjdFBoOHBuTHhWS3hzbncyRzNmejVjYWRWMzZ6dG54KzBEa2tSZVhML2R6d04vL2diL2xMTWNTT3BIUElDbFNvT1RjSDZEV2dUbElyM3d5TkpRdE42bWR3S2tMTElnSTBnRkhRaVJWWE5PNXdvVFJ2Q3IvR29TWlI3bXRGcEhBM1dWRU05MG9MaklmNGM0TWVMamwxMHBEMGlTbXVKcUdDVjU3ZktHQXl5eUxqUjhZUjdPV2hoaXVGbmRhRTNDVUlsOXE5VUlxTUlRSER3VTRQZGlJNktab0NDbzlTd01SYytOL0x6MDBIdHU1Vi90SXYvTFFqVDZNSkxHSkh3eUppL0tMQWlUU1pvZzRaNk5NOE9nRlFZS0ppZ3RoRlJQYU5Rd081ZU1GSDE3YjVJdlpGalEwTVFjOHlpR2VPN0Z6QWU0MGhIaGRHVDBNZHF0Q1UreEROb3J0Zk5xYU43a1NDTmdMeUFlYkFwMHB3M2hMcnBmcXJYL2kvbGd2bDk5OTcvZkI0Mkd3MDMzejVqMHV6OGJWbm5zMlBqclJSR1kvejAzSHY3TlZuWjRWeTU5RmRDU3FIUG5ydnRmVnJUL2VQai9OWmxWKzhLVmZyemNYZTBXRjlhV1Y4ZEtCUml5c2JDeXVyZDM3dmY1a1dTaHZYbmoyNjkxWnY1MzU5N2RLczNPaDJ1Z2ZidDljdVBqM05sMXFMYTBmZG8rTitydGxhdUx2MzN0dTMvbzNTdHJNeWd2cUhHeU9ZMU9RTDFON2JCSVp3akZvMERuT0hPMzdsbHpZWVFoRW5ZcUpFcDdtS2pGQTJiUXhuS2pNaGNPbWxUMU00Y3VITUIxcVpVaGNCeVVUaXQwaDhydHQ1WGFNdEJrdUk2d0h6cW8rMXdESTVLWTVPT1NGKzJzeHlFZFR1d25jRU5PZFVBcW1pVUdHc0QrZHBleDU2VUpJQnJtcVpJK3pwZFU3akNaR2F3cXZCYnpCNUFqZ1V2Sy9TN25ZNGY5ck5Mc3Ezak1LeisrRmFvTWdqT3RXbDBCT2d5QUpQTXZhRkl3aTRYb2pWaEswWVR4VkJFc1NFTy9mcGF0TGxUUmdZVDBHNDZ4ano1RVE4V1hsY2FrSjRyU3ZyWStGbExUYmN5STZlcU1OSmhGYk1EaVpYS2ZQcEVzOC9ZU0hqVU9RaGV3NGl1VWZuSzJlKy8rekdwUWQzYjczeUo5OVJiN1ZjV0ZuYkhBOUd0VnBsMkRtODkvNmRVclhVYURUdjMzcXZXcXRXMmh1OXptNmwxbHEvOGh3L0I1cGw3My9yMS91NzkvUEY4dmFEMnd2bnJwU3o0dnIxWi9mdTMrb2VkM0tWOXJsUC9Pak83WGZrOHRXckx5NWZmUEs3Zi9DcnNvbTJFTjNkcmM3ZTF0cUY2OVBCMFhBd1hHbzFTdFhLbzkwYldVbmJqRUt4cEcxR29hTHdLdkp2MHRocFpMcVRMcUJMeGcrbVNTK2xXQTcySG9sQUIvOVdoa2pVUmxzRTBwQ2ZaK00vRXlqdStQbkx2RXpCbXNreUxTcCs1TmNCclkwTlAzUWRlNlNNcjZ4UitPYWFPWmN5OVJhS3VWSkpCQWhJUkh0MjVRdzRhQWxvT2tsU3lDU2JGNHg2V1RNc3FIU1BRZEhhb2svSWlFczhHbDdrUHBGOUFPRkVQa3h4UlFqUTR1bUV0eWdLR0tVN05rWDVjYTR3eWV2UVRxWXc0VzVNUzF5SHIyWWMycHRuR3N0N1phcDlVeUZ1M2d1cFg1MS8vdWQvd2xORzBMTUlGSVVPT2JaQkRtdWlEeFlhYTVFc2t5Z1JtWGpqOGlGNkRVQmtDY2RUS3EwTmh6WExnRHpOblNVcDMvcVlGNnVGakI5ZjkySy96a3J6d1RKakZCYnhwWVNyaWZhaTJFMDJLT2lxUk1MejVDd0RZZUpPaThTQ2JRMXdjeFhYV2JWVUhPMHllYld5OXRPZi94dU5TcUc5dWxZcWxTNWN2S1RoNDBtdVVxK2RQWCsrZjdUWE9UcThjTzNwY1hlbjBWclFiTVZ5YmZmMjIvbEtYZnZjNmFSZlhWanQ3Ry9seDkyRmphdVZMTGY5enJlYVo2N1ZHaTNkS2VlMUFlcDFzOW5rOE80N2krZXVsUlpYUjROUnZkVjYrT1pMRjU3N3Z1N2g5c3I1SysrODgwNHBQK1BPZFhEWVhGci8xOS80bThQUnZzS0g2RlE0SUxBTzRpWUE2Y0FEaFlnWmllK2dGNENYU2JNYTRXc1dXVTFFL3NWZVZqOGJjZTVpWTQzejZNUThGV3JjSkRpWGV6clJNc1E4ZFRpbUhjM0NnNlNMWG9GUkFMU1ErQktQakltSnhkS0J6djBHRm1aZUVqbk00ZThYYUZvU2xGUUZrdHRxQUhLeVlwVTBieGZqVlVaRnVDdE81L3NUajRLemRXZG1EeGVHUUNjVy9HeUg1enduZUZzR1FwMm1CVzBueHNyci9KNGMrd2NBWjJJbCsvRms3TGFLY2piNU9PVm14YVcvakVpRWU5L2lGVUl1SCtmaVNlS1FZRFVUMVg2b29pWXNJckluZkRCOWtQTlRsN1QrNENuK3Nkd2xMcGxlenBhd3FPNUxxOWExUUNtcDJMQVg4Wlp2bTNTZ3Y3TTRUaXI1Z3V4WUlZejRaaUx4QktwY21IN29xZjkxdlpRZEhCeTgvZTF2dmYvV20zd05xMXpidW5lN3RiSTU2QThrME1MNmVYR2M1clBwZUNqZXMrRng1MmgvZEx4ZnFsWjdCd2VhNDl3ekgzOTA3LzU0UEtxdW5DczNsdlozOTJURXh2cUYyV2k0dUx5K2ZQWEZ4UXRYQjRlN3g5c1BYL3VWWHh5TmNvMjE4NGZiRDlldXZlajkydkZMdi9tcjJzWm9XMzg4UERqWWYyZitkV0hYWk54UWhDek96YWx6dVRLb1U3NlNybFNWZE03WTFsTzlXS2VZVlpUcEk0dVRzTldWcTdncER1UmZyM3V6WWlMeEtaVVlXeEZiRWRITDdGeG4xQ1ViTWwzQlZ4S0dLOWtMcWJIbGtuc3pibkRMWERXZ0x5ZUQ0NXQ4MFd2R29KY0t1cWdIRkxJTDRpRVNiOW82WGNybFhnMENjVHlKbGE4Vng4MGVFWnl5cmNLZUZNN09sbHN5ZGk5eTBiakFENXpOc2p4Wm41K1QwY0ZLSTdYN01rS1VwME5oUkhUNmdYZEVwNXNSNUdvTzU3Q1IwYXRqTmhweEV6YU9JN1lvd3FlYXBnNUZQRnNqdmowVU9adUVEUTFKbmFCM0N1ZndkWUNzendQRU1BRUxjbDZJWU5uT0ZwVFp1RXRqSDRpUDQwbUZreGtXOVlySGRVUzhUdll1SHZGM3pCVWJ0U3gzZnZQelQxLzVxTFp1M1lOOTZmR2pYL3BxdFZZL1B0aVZFR1ZaclZSOGNQdTlTbU94ZDd6MzhPMVhKYVVHYXpVKytiRWZYRCs3V2NIVnRjN092VXFqZmVHRkgrenRQaFJWcmIzNThJLy81ZEdEbTVrMDFkVFYrdkhoOXVCb2YvLyt6Y1cxczB2bnp2YnV2WGJtNmpQYURsVVhWZ2JEOGRXblhwZ1VTcjNqNDhQZStLMGJmMUN1S3RvVlFCVExpZlE2aURaQ21qQ1NPbEtTRE9xYkQwZXprTUFzREVkOENpem5ZMW5LUFBqZXZTaUZMNVJTQWhaVEFwSElabURFdERjNVdibFk5RXJBMnRUZXEzZ2ZwYjFOR29JQVltZzV1UVE0eGJMd3ZLa2c0ZXN5Z2pkNEtCUnBpQkJIZUZ5SnMyUmtSS0NUUDVDcUZidUtaZzRCQ2xNMk13cDA3emNjRG9FbmhmTW9wdUJkU2tFQnJRMEFhMFNURmd2K1JlOVVFRU9yQW9hblN2YjFyMzUydnVYd1psMUgzRUY2ZStLbUljSlIrVnpSeVV4ZWVYU0JJMWpabkpEc0ZhOXNWQ1NVY3JrdzZUQVRKWGZSZTYrU0h0Y294d3VqSlNRMTlKSmtBQTU2c2VLVEdsS1NqQkJHazlheWs0cXZUenhuRTFZS1VaTytjRVJCbVFZaU1nM0lXQWh3R3VzMW0zenF4Zi9OUW5PNWtrMGI1ZW41NjA5cEtROEgvWGUvKzlhVnA1N1oyRmdaRC9xbFN1M09LMy9ZWGo5VGFTN21pNVZhbzZrTVVXMXZIank0cGN0ZVkyV2ovK2h1cmIyYWxhdVRmcmUydUtiVk11d2Vab1haNHNZVjVaQ2QrN2RxMVZMdnpuY1dMejVWYTY5bnRXWi9NR290cisvdDdRNE9WZlpYenB3LzJOdFc5QnoyeDYvZStFZWo4WUZFVlFEb091WVFRV2pWRGx3clIrRmE1Z1d1TGdXOVNSeHVTVWxiUmVNZDdiSERNUUwxeVFZYXpsYWNnYmFhcjQyZVpNNUN0dE1wYkJwYmNQZHBIcGtVZG1GSjA5dTJQSk1YVXIyU25IOE9rZkRhc3FpR3Y2bXBEUGtadnZ5R25sNEpGdHFwV2kvVmN5V0U1SXBPbUhxc2R5Tm1SVHBIVnc3ZmwwT25IbE5RNFdGQ1h5QUxnT2xNVFdENXlMNzZsVThUM3c1YzFwUGprckNtVnVZR0NDUUVxbGxoZnRncFluK3NKeFlBSDk0aVdQbnR4UmpybmJwcmJZUDRhSjJJZVh1Zk8xcUNucDBMaThGTGhTc0FnUzRPNHh6L2VTS3VXZUgrOEUxeXBoWDJXVWxlU3RySzBwUFF4NEV5UEVORWh2Vk5KeUs5WktCNjdmS0x6LzZDQkd3M0s4TkJWNzR0bHN2ODA3SlJybDZ2dHRzTDArNys0Y0grMnNXcnRkYmk0dnFsOFhqSWxYUXkwVlNIMnc4bXZjUG15dG5aZEZDWURLZUY2djZ0bHhxclp5dk5KZWx5Y1ArOSt1cTVSbnVsdC9OK1kvVkNmZlhpdEZBKzJycTdzSFpHTndOY2pHZXo1ZVhsdDE1L2FmMzh4ZUZndExhNU1aaU1Ycm54UHhVei8vS0RYN2pRb1BJcmtTRHRyQ3ExUTBWOTlBU1NheHp1RktDVGJRUEFXWU9ESndYem1hM2E4ZGdSRXBsTDA2a0x0THE5Qmt3VnBNQVkxcjI2VldLMVlFZ2RramhXRkoyUStabVB3ZzBCNEErWkpRbkplY0FKcFlSRUJ4L3VGYVhDVk50dTFybUx5WlMvMWFOSUZsS2tpbUlqR01VYWdBNVpnWDF6d2pwaW14TXJ4TXlES0lYN3FaSjk1YXMvb0dqenJwbHdkRmlUbTFWcERVU1dkUmFQY0hTZ0t3Q0lXdDFIaW13eTRuMVczVVpEcVVOZHlxUndvSmV4OE9jK1c1Y252OS9wOTQrRUpPaTVVTEJtMkducHV1VDlIRThkeVdweWlRekYzWTloMzVCaEVWVUJZTExBcUk0THV0b0F3cEN1MU1YakNOWTlYLy9PUC9mVWY1QWI1cCs0ZnU3ZWU2L2Z2L0ZPdGRtdTFGdkQwVlRXYmpYNFV0NTQwTzEzK0Y4SUZiNmRXc3VOZWtkN0N0WmhNYXNxejNmM0hyVFd6dXZLTnhuMnlvMkZZYTh6Sy9CMVZjMVZLV3ZIV2lsWGEzdVA3bFVxamZ0dnZsUXFsMHNWYlJLSzdYTlA2RzczY0crclZtL3FacVhSYk4rN2U3TlFxdTUxdHU5dS83YTJEeElTSGVVdDFMUmFEaDBVUXo5Sno4OHNXbDM4RngwQTBBVklLM29VaWFoN1FrUWtpNjhZYXF4d0oxMFJtbTU0ZTJFY0FEamJVSWVNS2FLd1o1S080SUlRZDdBeUdRQk9vOHhEV0s4RmRqZHVDZWtSdW04a0ZrRndXMHVzcTFnS0Z3VzBzN3A2dWJEekI0MWpIUTdBR2tVZTlENWVwOFNFU29mQ0hXSUU0ckJrZE1hU1FZcnM1Nzd5L1FwMXgzcks3dHJKa0xBSlVHK3NIYld4K1NiNm5kZnpoRHVoNzhUc2R3a0lYMjR5ZUFUa3VIZnVKNkJqTEVIc1JPN1ZRdHlycVdYZ2ZaR2FYcDNvRm5jYmFDTHJFT1V5bnRhbExZUUdUdVE2bEp6UXdCaDJwQkR6Ui9oZ0t2SVQ5M1dFQkRScnk1OCtjK2F6MXk1djNuamxUOHBaN3VxSFB0SHZIZCs3Yy92V2pYZDFsVmxaV3F3MUdwSmxNQmhXRysxNnJUdyszbSt0bnRlRmV2L08yL1gyYXFYZTZPdytYRmhlbGJPSzFVVUZRcEd0Y2UzNFlLdFNLaGZyN1hxcmZiQjErK0M5UDE0NWU2M1NhTzArdUhsMDJGaytmNzFjcSt2TzU4NmJMOVdYMTQ2Ni9YYXpjZXZXN1VhOXNkdS92WHY0S29KYkwxMlhyTEwzMy9hUlBZZS9FTjhsQUdpTWs0WnM0QTBKclRVVDVvQmpvTnltQnZBMHhoSk14QzNCNnZHcGgwVE1QbCtBMHpkNG1IazFCZ2R3NmxJN0hhWVJlNEpiWjZUbEw3WkZMaWlGT25JT0Rkd1I2bGtRWEd6dUJwZ0ZKTVA0cytpQ1UzeURWYThpUGhrbzRoc1l6RW1oQ3d5ZDVvbE1xck9mKzlJbkZZNU82bXhGZEtHUFdDY1hSMHdUcGtTemI0b0ZqRlg3clYzd0NtaC9mRjR2a2ozeHpJdDdVeTdnSk85Z3lFTHl4c1lEMVZRbk0zTEYwQkJsZHg2ZUZpYU9hdDRQRHl2WVpCaFhoU0JPcGdIUWhZeWdKNmJKNUE0YllSenJlTkVlcHFVaHJQdHo1LzVLczdLODBzZzFxc1cxYzFjUEQzWWxnNUp6cGNJL2NscHN0MHFWaXU5VjhvMW10VktwaklaOWlaZ3IxVnJMbThQSnFGeHZESS8yTkhsMVlaV0g1RmxSRnkzdDRQT2ozdUJvYi8vdW04MHpWNnVWYW1QNVhQOW9lK25pczlyVHYvM0tOM29IeDFtMU9UamFMdGFhV2JIU1h0L1lmdS8xUC83MkcwKy84TXkzM3ZoLzUvTmpRaUQ4UWNSVE8yWm80eXc3ckJpZURyMDVLNVlTZ2g5Zzl5QnBLYXdob1IwM1FSc0FJMU0wY2JjcERBKzdXRGJPNHl3YTJ4WnhhRWNVV2g0L205RklCeHI3Q3BFaE5FTVFETHluMGN0U01kb1RCUTVLZTAxTmhpT0tydDRpeGpld0F5ZHZhaVg0V1RNNEdDZUd6dG13OUcrN0VpUkdzdTJIaVE2Z2RHWVdJMU93cTRoY1U2b1NKdnVaTDMrTU9DYjZGUFFhNEhoMWtsWTArNjBmcDJRKy9RdkdlM2N3UFBNbjdvbFhaM0hsYVUyb3pKM0NXaWNKRitrZm51eVUrT2FZSXgyTWV0bkRzTXNnblZzSDM0dUViTjZ4a1RJa3NlM092aHh6SktYQTRVbWQyUG9SN2s2VnRySVZOTXBoby9nOGMvN2NYenk3WEp3T083WFcwcTN2Zmx2SldEdVc4YkE3R0E2UEQ0NjBZeWxsbVc1R0o2TnhwVmJWVHFSWXJRMDZIV2xTcmxTSG5WM1pyN213cEZ2NC9LaWIxVnJUUWJmYk9SUVRMWWZaZEZSZlBydjEzdXRacVZocmIwNlUrVXU4QWQ5c3I0NTZ4NzNEbmZGNHRMUzJrYTgybEUyVTdQZU9PclBhOXFQOWwveVBHK1YwNjBoOFVGbEZCNUlLWG5meXNyNzBFT0xvSzBwcEZuRmtiYzBranJnaU9wQmtPNnlSbUlvYUhQY0d3cmtOQmFiMVFLakpIZXFVOGJqcDlBZzFoZFRKWTlVRGdGQWVNd2NSVTYrWVZaVWRwTDRRelVwUVJhUWlQWmlNbUZNLzRoQ2g4SUNRalkwQ3dESGdrSitIdS9DS0ZrRmFJR0lGZ2liclJReEVhQ0o0R0cxcFlJb2hDOHJ1SDFXazhnMW4wck8ySmNRZm42ZU5PQ2FMVC94N0VHTGtwTTdVQ25RdUJjS3dBQnk3V2pBUjJkeU9JaW9mei9LK25Dam5GalNrSjlhbG9XQ05raGpTZ1hUT3NyRjVMWnZzZ3kva05FRENPWkJzNkhYQ3ovakZmaUpheUZFYTY2dWxLU2p5aXR4TzN0SzJaM25saS9YS3VVdG5GdllQOW0rLzlpZkQzdkdacTA4ZlBYclk3dzIySHR5OWZQWHF5c2JHc0hjMDZYY0x5dXZkbzBLNVVpblh1bnNQZDk5N2JmWGlOYjdLbEZmY043SnlxWGU0VzJrdDU1VFlXMnQ3ZDIrMEZoWm5wYXEyTnBLNXUzVmJXNXdIZDk2ZlRDZVZobGJIUm1FNldyNXdiVGdlamJmdmRrYlRjcVdwZmM2dFI2LzFSOS90RDdjbFpBbUJKVHlKVnRyaExsUWhUUFNTbVVJZkg5Z0dhbHdvaGFWYUVWZHJISWtZTE1TRUwyZFpreDJGQTkxTEJlTjVvWVF4K1p3T0tWeFRleURXWnNuNThHd2FoWldkTjlSblNrTStlTUVjQnpnUWlSSmdzeGVoR29tNVp5R1VnNDg4cnFaSFJGdUtpb3NvSVhWd1duRXhDTWNUYllTSFY0UkcyVWlDUkVWb3NDL1FNSWNZQkdtUVNKQlJBRkV2cEJUNTRwZGZkQ2FPM1V1RXZPS1Z1Q2NFdlhYeGg5cVV2NTJNdGVFNXlmUkVzWFlraEx1WWVkUENuRHJpQ2lDZVNHcWt5U1NmSnZIaVFXaU5zb3dFdWt6QXJZemR4dHNRT0VnN0JxUVZKQVhzQVZvKzhBQU93Q2p6M0FTY0lBMGx4VEVJeTVaVzF2NjlDNnZON3RGT1oyL24zZTk4Yy9QYWM2MzJVcXZkR3MzeS9jR2d0YlRjYXRSTHBlTGdjSy9ZV241NDQvVnlxVlJwdGJnUktHV2xlbU04NkhkMzc1ZktoVktwSnFFNkIzdlQvcUgyRWJ2dnZkeGN2NmpJMXlTemZMRzVmdjcrUzc5eCtXTS8rc1p2L05QYXlwbkdnbmJ6NzdYWEx4MzNPNTNkclZHaExwVmZlZS9YRG83LzZMaDMxNEdGcXhFVzRRa1hOaVNTMmd0ZlJsSVBaQ3hiYnp3aWx0Z0YySVFhcGRIaFhHSkRCekVqaEYyT2oyMGkwY3MvcGllVXlmMkNtSWhJeGlrT2ZBTE9lSUhBWmMwc2lDR1F1c2ZmSWRTVW92TU1NSXJDT1kwV00wdm4wWVJaT2xoc0FTWWdTa3pDNktCVlZEaUszU1dFWWtSY1V5ekRHTzFRU0IzME9NTGdGMTMwbW9zcmhCQ0ltRkx3cDcvOFlSN1U4L0NIZlVyY1VKS0RJNGlKZXpGVjRQSTVCS1lnK29YUzdqeG1pVlZCVWR2cEtXNWt5ZUloSXFIZ2tFY2w2cmxTektwcmtLNGU5cElGazFnOGtNSEFGQnNUNTg4ZGl6MFY3SGFNZmVaWVY0azB5VFdZakFJQkNDSW5YNisvc05UNldLM1lLMmVsVjMvblY1ckw1ejcwcVUvUFJ0Mjd0MjgvZXZobys5SE9ZbnU1VnErVmlzV3RPKzhmN1R5VXVCcSswRjVtZ3o0ZWltVlIrYnRZbVBXUFNvMTJzZHdvbGdxVC9uNjF1VHdjOHozRGFtdWxkM3lRejBvU2V6Z2FWcXExeHNhbGQxLzlrOFdscGFQOTNjbG90SEx1K3NIdVZxNWN5NHJaYSsvK1lwYnJJV2JvRXM3R2ZvNDIyd0E5dzB1T05DbEorQkdXMmd3S3dkWFJ3UmtzR09MNDlLMm56SVRkR1hoaUw5aGhTbWFJelFwV0MrdHlnZ2FCak5Bb0htZlpkSUl0RjU4MlF4eXZNcEtTNmJ6OElOR2xEUlRlTTRhVnFTWWoxR0JHZ2NIQUdHUmtaaGZoQlFXdGxZeUJFVWtFa0ZCRWtDU1FTRm9MSG1XVHdaSUs2OFU0c09CdE4vZkdpejRCL3JMemVGWndDbWN2cm8yS0h4ZjZycFJuNVA2eEY5N1V6WTl5dVVIZUdEWXd2bUhOOGQ4YkZkbTZZUjJwUzRtL1FPNVhsM1lwdWc2TTg3ejE1U2FlSW90YkpUOSs0UU5NczZMU2hjd21rK0FERWdOdk1Pb09LV1VoYnBUaWZXd1FmRWFBOXhUOUpubkd6MndMRjA5alhBVElmclAwTUJ1ZkZ2T3pkdnN6N1ZieDhMRHo2T0c5eGNzdmZPUnpQeWsrZS9zSDQxdzIxQjRxS3g4S0hnOG5rMG01M2l5VjY2Mk5TNVZXZXpqc0grOXVLUVdNeHhNeHJpNnUxODUrU0dFMG5vNkczZU9zdGlnbkxaKzUxTm01UDVrTUpYdHVNdXp2UGN6YUYrKzkrL3JxdWN1dFJybGFxODNLdFZ0dnY1SWJqVGF1UFYrcjFMdmpCNlVpbDNJWE5obys1QmYwcytlUTMrNkVBQ1hZaStFNUNHd25KWHYxSlpya1k5d2NaQVNFOTIrK0NKaWIvMmRXY05QSnc2Q2xBTVdCSEk1SzRTS0tCRVdUZzYyeGU5VklrS25zVGRLa1R2UjR3d21BVDJHckE2RWdGZ2tMd3NYTEQwb3RIeCt4ekJOblFkQ1RKNVVUdGVFd0gxZzVnL0tuVGhLdHNuTEt0aXJ1ZHdtZUhzSUZVNkQ3c3AvK3lqUGFkZmdKdW5DOFBjdkRFell0YkdtSWUyMUxHS2twcWNuOXVJaUZwNGx4RjB5dEFLYVdhTXJ4bWlnOVRHUldWY3pLWG9YM0ZKaklkeHQ4b2toR1lhQmU2dVdORFBuVTJTQXB6a2hwSmlDOEpUTGgySGM2TWtUcFJ4TVFPUlFFT3pscFhpVWtFVlJLRnlyVkgrdnU3YXdzdDN2ZDdqUFBmNlRackNtVWE3WDY5czUrdWJxUWxhcExTd3V0OXJKdU54N2QrdTZVYUN3MnRMbHB0UExGb3JZeFdhVldxbFI3QjF1ai90RzBVQngzai9qMFJGWWxyemVXYTB0bnQ5OTllV0Z0czFScElQRjArTjF2L09IWko1OHJWbXI1eVhENXpKWHQzZDNXMHJweS81MnRWMi9jL1pYeHBJdlNva1JValVESUZGaFNGcDlodGZBOGtlY0x1MkN5bTVCRUR1NFRrcUJRTTdqQXh2bVlNbWR1Z0ZHeW5LMUJvUzJ5V0YwWVVCQW1wb2N1Q0RRNDJGQkFjem41M2dMR0YyMHNyNFpTaDNuemNoQUFJQ2RWeEFOSTRoVXFLWUZ3L0JDaEZUV0N5bjhFdW9ZUlBRRTUrSmdOMFl5Z3dRRnMrV0tRS01EUDlSVnpiaEhvTDJRLzllV25GTmJwbDZBSVlvVzRCbkhueWpKZ284SjJSYU15WlhHYU5xa0FGcXN0N2ttc0hZZHZRKzBhS01FakI3Tlp5aFRIT3VCam1CdmtFckw0Nm1pL2FiaE9NcUhHaTRiZ2NBTFVTUnpVYlFmNlFJVHdyVzJZSnBpVjdBQk5XYTcvVUphZGE1WUwxNTY4M0QzdUxMWmJrOEd4OUZJV3I5VHFNejRDblZ0Y2JJcFI3K2l3ZDNoOHZMOVRhOVIwdzEydTE1V2ZqeDdkelVwOGxLQ2tRTy90RjdWM24rV0czYjNxd2lwYnVmeXMzK3RrMVlWZVo3dTV2S21ZcmphYXVYTGwrT0RSMHZxRm80ZTN5b3RyQjd1N25lUHVVWGZ2NVRmL0Z1L0lJcGFYTGFZa2xPZGVJM1dRUFdpcDVqcUhDYVVnS2hFVFVFYlR6ck10eEVkZHNoMnhZR3ZaSjhHV1h0VzJFVWJTeFR5YWdhYVlGOElFeHJrREs4SU5zOUt3VFVtVDVtczZVU0lRMHNvRlpxUGl1WkdCR1VGRjlBWDhlQktSaVR1a0o3dmM2TElXcG5BUjRPUU5GWXlJTkVhNU5rRVFSd0NpV295T29qa2hnUWJ4S1FyMzY5eFc4a0F3YmttNU9yQlg4VFJPMG5CU1U0a1phVHlibFpQK05vZ1poMkdZakJnTlFYeElWVllYd1JjWVVqemdxWHpoeXpQR004WXNiVEFRSW91Y3JUNnZJdklSYlc3ZllHS1VReC9JSW1UOC95ZTBseTd0eFMrUCs3bGFlVnFSZjhiRGJOSXBWYXZEd2VTd2N6VG9qd2JqeWZMeTBrQXh1N2QzdExkZkxGZmJHMmY1SVBoMDBGeGVtUlhLdllQZDZhaFhXMWpWSGlkWEtBNDdoNlhHSXB1cGt0SjNTL2ZtdWtyc3Z2ZnFiTlRMcXRWOHNUcnRkNWJPWGRHK3ByMTY3dkRCTytYRzh2THlTbWU4Ly9wMy8zWmtHUW1lN0tBMmRzSnlNcXRESjl4ajg0RzNNV3cvUUREcWlpc3ppaEl5TVZDd0tLVXh5U1lTdVNLRXNTWWtpUEVjZVlNdVllWGE1RWExUFpuSUZOQSttNStNNzRtRUZqRnBCWGZNOXp2d0NHWTZPeDBoRGQ2U0pJUWZzZ2luWGcyRU5sS2lwMVJuSU5rZzJMbkJoNHF4QkxjU2dSb0tRdHdlU0lGY2hvSlpoTDRLaVpjOWcxb25mQkFwempUanhRQUZEUHQxUDJiaGtTSjdHRy9LRmZvNnZQZzBwMjNsb29IMmd5UzJYazc4NXFpbTdLR3RnTC9QNjArb3NUTmpFNk91U2E0d3poV21jZ1grb2l0a3dUNVlHUlBHUWNPOTJFUkFSSWRVMGNTc0MyNzhJN2hOelNXQk9aaFRiZGFHTGhVYUlSSEVaYkZZV2J2OTNuc3JxNnRpdGJTeTlPaisrNlZ5dGRsZXFqZGJvMmx1Y1dGQitGS3AyT3NjSFJ4MVpsbFpqSlpXbDJ1TDdlSFIvblI0VkY5Y0VaL2g4YjRzekY1L2VEeWRqTFRYT2RoNTFObC9kTnpoWitCWG4zeXh0WGwxT3VpV3RQZkxpclBKWk5RN0hvMEdCd2VIcFZxOTF6M3VkaCtPcG4zYzVjZ1FRMFVlbC81SURGZzB2aHQ5cWhtOTJzbEFFM0FpazhHaWw2ODZ6WXIrckhjaFA5Vk9zRVFLWmorYVRiMVBaS0J1ZkFpZE9DanlEMVBiNW1vU2NXbFM2UEdObWlBRDVwOVN3b2NCUklOR3lheVlQamxKdGs2aFI0S0JwZlgwRlFjL3FDOFJtRVdjREdoR1ZvZ0w0OFRkeGIwT1RoMFd6NkhrRCt0SUpJSlNTQzZNU2plcVBRd0dMcUtSZldJcWtyVlFBZ2tyMTlxajZ4Wno3RnRWZDdQOVJtWDFJN2VFOHY3S0NtZ0FiMy9xVU54cFphR3l1amdVdUZ5Y2xYUnhnZ002cnRuMmo3MkVmVmdlS0lPdXNGYnRUNnZhZm1yS3BUWmptRFBNR3RtZE8xSi9BdHlTcVZhL1oyQ0lLb21PYUxMRkZHSFZuZFhxSDlkaXZmemtVN3BCYkxSYTkyNjhlL21wRjhOR3c0SDJNK1ZhdmJHL2Z6QWFUL0tUVWI1N3BLdEJYcVM1UXJXNXBOdnozdUdCN3IvclMrdUQvbkh2K0dEVTYrKzgvNDV1M0NYU1pEem9QTHBWclpSMnR1NUxrdWxrWEcrZk9UN2NLMWFxMHE5YXFlZDFUYWtzOWcvM1N2V2xnODU5WkpSVWhLK3RpS2lzVHdHODE0U2w1Y1Z3bFEzTXordUdPdnhtZ05jSmRoR0J4TXZML0pGVjdBcm9sVXMwUkVIdlpoRElGYUpSeUdJUVpyY2JIY294eW1Ha2lRc3ovdU9UTUVrMlBuWWxGL21RcldScmNxZ28vUWRTRWNJbVFORWlWbWFKVndnc3p5U2MrV2lvdmFsaWI0b01maDRaSWVadXhoSGd1bkVrOURtd2g2bEp1dXFFQnJ6eXZRWHoxSktmSG9lZUp5Y1d6RE5aeitxRTZMSk9YcHVaSzVvQWRSSkhUWTZXSWFRUUhrMlhDZ0dvSmlFR0QxRmFYdEdqSWhPcTZmcmttQ3ZKY0hlQzBRQ0NNWkNtMGV5ZUVSVFV3aGs5UitrRlk1MTF3Sk5lRndEWTB1VnVnZVlzcERZakgyMDJMOHBHOWZKMHNWNWRYRmxTWEM2MGx3dkY0bVNzS0NydUgzUXE1VUtsWEtwVXFzVmlycmZ6c0xXeVVtMjAvSm01c1JobzMxNXJOQ2FUMmZIK2xsVDJ4OEl6YlZvR3ZXNnV0OXRjT1ZzcFYzWWYzTXRQeDFteFdHdXY3VzNmcjFRYjlmYnFlTkR0RFhQSEI3c0w2K2YvNUtWZlpEa2lsVlh3SlY5QThxTmcxWEpsVWtNZFdRcDlaL1JZMzZSdzR0VTF4TUFlaXluSWpMakZIa3hESEFwQ3h4VVVqQmlLRTVOQ3dLVDBCeGxBZ2s4ZnNLVFkyeGdhSFU2SzUxVlJGMmdmY0NENWhWaDJwZnNFOGxLL3hxQUI3UlRUMUFGRlVZZmZubmRSV3k4TVFpSE14VThyRS83TVpiU1lFWmd4RlROU3VCU29JYXpNSlI3WkY3NThHWmdvRkZsa2QzaW1WU04rRWZySXpES0FqNGhET1ozTW0raWY4UjZ2c1k1RXhwclVMcUx0eWlnTnRLQmM4bmd1bzhIQmg4R2N6YytRSjFZZEpjU1VUaUNGOWo2VmZnOEduMkJvWmFkcGErbW55dm5LKysrOTk5UXpWNnJsVW00NmFUVHF4OTNlNFZHblB4Z2VISGFHdlM3djk4OTBlMWxzTlp2VmFuRXlIQndmNnA3MVFLNFNnRjZWU3JGY0dYVDJjMW1sdWJRK0dvNnJDKzNqUnc5dXZmbFNvNzNhV2p1citPL3MzTldlWHJaNzk1VnZGd3VaMXNna1g5ZzRkL0d0Nzd4VWE3ZHUzZnczN0xoMFVaQms4OGdRZ0lpaE1sY2tOYk9DUHpwa0RKY3BhWUxPNFEwcEZRNEpsZTFtWFYreFNiSzlPQWl3RVJLY2ZDamprNDg1dVFsWFJsTVJTV0Z0SEsrU09zMHdBSUltbW9rR3ZDQ2VYY3h4Z25BeEhrWUExd3dJWjBrcVArZndTUHdMTjQzZzBRaUNHVzArckhQSHVJNDVSbE5nS3hHcHdzdmd4UUcycXNBUnp1anVLTEUxWUJuVzhCMEFuSFNyK3BVcmtGQmc0TkgwUlpPaHBneFloNUs5VHU2TlNFUUltbWlnb3FiL1RnNzdWbGRpTXdFUjR4bnR0cVFSSkFLcFFMZFIwTXpwNHpBbVJMT3hhTm00MkRmd3BvajVMRll4TzFNc2Z0OWcwT3RzM1h2aG84L2taeFB1UVVzVlplaXh0cmVsNnVIKzRiQS9LUElaNFZ5dHFBM1JyTlphck5WcW5hMjdqOTUvVTl1VlltMmhYSzdxMWxhZDQyR2ZlQ3pyQnJYZDcreldtdTNEaC9lMWc4K1hLc3ViRjdUYmtjV2JTMnY1NmJCWkt3NUdVOTNKRG9iRDl1cGFwN3R6OTk1M2JObTBqSk9rY3JXRlIxWTdIUUJsUlVTWVluc0RPSnBoNUhYQlhnYmlsSnB4RVlDbmc4QWNxTEdKTUJCb2p4c0UvTGN4RGRUMlFLZDVyN3FnVmpQWjJhRjJjcGhBZU9LTkhZU0ZBWjlXVVF3aG5ZdlVNRHVpSUpNc0FzellVZ1V4cnlEV2ltRlhBMlVVY1pZc3ZNc0pmL0JnL0ljMHVGZG5tS1hpSnRIbkJoMFI0aWZDeENubXpXYy84NVVyRElWRjRHZ3BaRmhnckNQUWMrWVJTUmdiOWdRYWZWNEErTTFEelFJRk5RL2tNUmdKNHV3RGtyUVFZS0lTK2laaTExeDlFVjJzNlRRQmdlNStDQ1JkU0FBbXNocUdkdHRYODFMMVUxbjEwczc5ZTZ1cjYrdHJDdHlzM21ocVczSjBmS1RoKzN1SEV6OG85a2ZiSnBXeWR0MFZmN3B6MGxwZUw1VnJVeDYyMUhQODY5aWlOalNsV21NNG1mV085clczcVZUcWhXS3AwVjVhdTNqdDhONk53OFA5dFhOWHRMMFpUY2ZMWjY0ZVBMeTVkdUZKU1RIcEhqUVhsN2UzSHp4ODhFZldSV21HaUNlUnE5ZmJWeTZva2RGMThBUG9BbUo3YlJXMTh3YVdxYmlERkd3MTR3Q3ZJN21iM2FoZ2hZT1lHOGxiSTlKUFBIVVFLd0VRU1NSbWJLbzlQWjRXc2JpcE1rODFhYVFtaDE2T1FNY1FEeTdvZ28vRmtQeDB3Y1h6Mm5VT1dMODlnOFp3OVN3aUoyQXRnaWdaUkl1MnhCWlRCbEs4a2ZGTEZYUXA1cmhDZ0RLM2lBejRhQUt2ZVJrcUJLWVhFUjBpVUZxZzdPZStlalhDUndlMFRJM3FnYlNrTkU1cURBOGRoV0RFalRBVVN6VTlEbHBlaU1lZkNMaWFJQnFrbkVHamZKek1nTGxnNEFOUnJhTUh1ZkpVQnZSaWhCWEhXTGF5OFhQTmRmQjRvdjZaWW5ucGFQOW9hYmwxWm5XaFhxLzRXK2FUVnJNdG9SVHI0OUdrMXowK090Z2Q5cnVUMFREanlqd3JaWVZLbzlWY1hsL2N2TmpiMi9Fem9JSnVwcWV6NmZIZTNzUFhmNys1c3FheDVmcGl2OWV0VlNzckY1K3FsWXJkenU3QzZ0bnBhQ0RIMXhyTG8yRzNVbDhjVGNhbGFtMDhtYjM5N20rem1aRmcyTXd4VFpId01oSnIxUmpFdGptalBya1R0ZW8yRDNlVFVuUk9IQndjYzlLZFVYUVJCR0hVeERBSXpDcHNDanNGbG5yWlFiTUlIUmRtNkNHWUZ4UnVFRkpEMU9EN29STTR1elcvVUlnbXBrTTg5ak8rNjZDcGdsOGdrTCtZbE50QUpBaXNwb0J6TUZjTkI3eXB1Snl2cUtEMUxDcklQNStMZ2NrNE1kYWJIQ1MzNG1nWGdqRVdWcktxQm1VLys1WExESEFBcVZQbWhBWW1qTWxVMFFrMnZuWGhPMWVJWFh0cWQ4Y3BUWWtzbkVuQTVBVVRlRDZOdGhCcFNOVFdRcktib1pCelllWkg0cVU2RUo0WkpKS2YxcG1DZXVwRnc4b1BLRDdLMWZwaVBiZSsydkp2cVpTYnpkWmtOaHVPUm9QQlVLRXZDZmQzZC9jZTNDM1ZHOHJqRS80WFRWWHJ1Vmh0Rk11MTBUUjM2K1UvTEZYcjVYS3B4R2ZnUzdxTDFTNmxXbHVZVEViajBmRGc0WTN4ZUxTd3Vqa2RqWTcydHVydGxmeGtNaGdPUks1WTBqVkJJVElZamQ1KzUzZjhmVHdaVGVyejRRSGVNOEJXZkhjK3hDWmVnOFE2OGdSUXFnSHovRUhtd1lYeUpraWE2c1ZxOW00Z2RXaTNaUXRpbG9qVWNQeUppV2hDQ1NNd01YbGs0Q25DWVR4dldxREJXV0ZsVlh5NW4xR000Zm9EclpjcjcxS0NOZWUwZE4wVURTSWlwQkRFZ1ViYlBWWXRBRFp5ZU5kZDRrZy9yQzBaM0h6aFFqVThyazVNQVhPMEVONGFCVEVFc0xKQklvQTlkWHFBbzh0NDlyTmZ2UXFwVUtKMEVLdGhCb0xGR0pmSURGSVV4YmoxeFRaMkRDV0MwRE9UR3EwTDAzSXlFeHVRZnNSRk40dW5IdXR0VTFvaVJxZ2dIbndkOVNaUkUrckhKR0RFRGJZMkRUYTF2MFhGd1FSRzVVc2ZLV2JWVWo2M3ZKQ3RyQ3hWcXJWNnJUSFdOclpRN0hTT3VwM2pScVBXWGxwWVhWOFQrZkhSWVVVYm1xSldSNFZIbnVXU3pEd1o5S2FqL215UzE1YWRuOGNvVllxVnlsZ2IvMEsrMWxqczlicDd0Mi9zMzNtajJscXFMS3puczJ6bjF0dk41YlY4b1hTMGM3KytzRFNiakxWc3lwWEs2OS81VmUvRHdoOENzS0J1MHlXcTNhT1hEQzk3azg3dGFXY04vTXFCMTIxRDhOcjVZR2tkdUJCNk54MHEyR1p1S05kaEhMY2ZGNUVJaTZuVXBjNHdNRmpSbjM3cTk1ZzRPRHQyZlFRMWNRRnRGT2Q3Qm9HazZTN0Jsa1F4N1l1SU1TSkxBc2ZIWVFDOXUyS3ZJamdHQXMvNUUvR2FsZ2kydEdHTkVNYVlTQk9FanJxNGFqR0s1UW9IZ2hkTUlmdlpyMTNGMGdoRnhJc3RybUNjZVZDWmR3eW53M1JXS0xCUWNPSTdIWm9ibUFJZ0ZYeTV0TkEyazVTa2phN0dlQzc1TUt3RUx5eVNhbzlRZ3hIVzBFaFdyblVFR1lRcXFha3JvUktucHRWMm85ejZvY2w0cUN2VWFydmVxSmViclZhUTl2cTllM2Z1aUVieHJUQ2VUY2YxV2tWTFlUSWNqRWRkUG9ZMm5aWkxaZTBtaUxmY3RMbTZXYXFWTVl0V2UxYldmWUV1RFpQcHFGU3FWUnZWZkgxcC84RnQzUUZYVzh1VHlmUm85Mkc5M2E0dXJCVW1mWkdKaDY0UzkrN2Q3SGUzZE0yUUgrTHRTZndpY2NNM01tZzhSSGRKZ2VLYnkrUjRIVkxhVnZBM1pOVEZucDdlV1licE5HVEtlK00yclUySnFha2NFT3FjMjBuRnhvZE15SFRsTll6MWtNbU5oSWVNV1JPVmhpWUV3b1JJcEhaUGpiRkVHYkdWSkVlUzhEc1lBRTJBQ3ZZZ1NHUFNKNjFDSE5oSWZjY2REaFpucFdlR0VBU0Vxb2VZTThHRFFRaWt5QmVFSndJZ0hoeUVoSTB0bTgrKzlMWHJXUnJEVER4Q29Wc05FenlHTElkNGFCNDBqaTVCbWhheEpMZVdTckJPcnpRbC9PUWtuVEJWOElGZXREcEFxYUVUeGhNVFMySSs3b2d6ZW1xVW1nd0hNdEwrMWppUUpMbGNvY2dUYTRtbzZZclQwbk5adWQ1bzFKdVZ3c3B5bTA4ZHpIS0Q0ZkRoL1FlZHpuRmQyeEtleG1pZ2t2anhVbnV4WEMxWDlGZXVqSWVqako4MHp3YURRVTJibkVxdGY3ZzNuWTI3blU2MTJSd05oK1NkTWZsSzhodzh2RHM2N3VheWNyRmE3eDFzTGF4c0tQbG41ZEtrMzY4MDI1TkJwMVNwWGJ2MnNVNHZkN0Q3SHUrOE9heWxCSjdEVDhsRHRwVVVsMEJFc3c5cHBOcXVRVWUvcmNoT1l4NG9PcHhRU1lyTzhkbzdlZU9yUDh3TEJYa3hiQmFRWnJYRjFHV1BnUklwMUNyejV0ekljei9nS1RjMU1zRXN5MFJQdEVFYTk5d0pHVGZadnUxR1dycU1jV2g2OVdxSTNDcEFrV0lNREIxZkJHNjRsVkVXbUIxZHhMRTlqbndJQ1gvZXdMVEF1bVFhd0lBeEM2dUNHYkV6QnZ6YTE1OUVWbWN1aDFSc3pnVjdicUh4Qk9KcjFoREgwd2lIeWlwWVRoSkRFb2pjQk4zMEo5SWthOXdYYzVoVzBzNHZOOXlJczZsVFgxcHk1aVRWVVJ4dHc2aWVRV2VhVmtDTk1CQk5Kb01uV2pta3BPZHNuTC9lWGo5WExtZkZmRzVwcWFHTzZXUzgrMmpyNXMyYitYeTUxbXdvdTBzbEtUd1o4MzhGV3MxbW9jZ1BDTlFYV21OK25DRlhyVlduNDFHbWpYZytQK3IzUnQxTzczQ3ZNQmxsaGF5NnVOUS83dkRwZzk1d1lhRmVydlBPVkc5MzYrRGgrN3BKcU5RWGVwMkR3bXhZckxkbjQzNngwcnh3NGFsSnZyNzk4SFZzVzlDY0hNaUo0N0NHbXJoWjFrWXBleTJGaUpUSGhsSGp0cFRGK1NVdUtZL1I1bHNDZFlTWm9NZG14RDhFZEdCWXdnc28rc1hUZnk1R3FWQ0xDQUJNdUpvMlBveHg1cFQ0aVZZcmpWVW5hWGx2M2Q1VVBsYUhvNU5WWlZha1hpWkZDd0x4aEFEVkh1UE5VNGNJbERqQ3VRcExTeDR6bXNaeHdiczJ6SUFWL1RSYlRkT3dUOEd1WVV6elZDRzdQd0VsMW9XSURXVnd4Q3NRemFmWEdPWXpKUlcxV1FoR0R1SlljZ3NVcGRETUY3Y0lQa0ROcjVXQndYWlVNRWtsV09nUGgySUFjQ0dBVHFxRElZT3hIWHc4QW1rMUw3K0d3dXgrNTN5V3F5OSthakl0YUl2U0tNMFdHaFdHVFNkSzdicEpyWlJyQ24ybGV3VzZVbnl2MjUyT3g3VkdReW9QUjhOU3RUb1pqWlRvdFJKRk5oajA4bmx0M2JVeEdmTy9zRWVqVXFXaU8xVnRUWGEyN2hVcmpYZSs5YnVTYktHOTBqazZhcXljeVdlMThhQ3pzSHEyM3pzdUZRdWo0WGcyMVo2cXRMbCsrZUNvM3psODN4K1hSYWxJNmc1OXZPWEhHaEtUdU1kS1hLOWlEV3Vsc3IxeFNMRlp4eGlSNXBOVElpWk9WVkhiMnQ3ZGlTOW1TOWtma081RUFwUGtDdHNjMm5rWFp4TUhTMUNPZVF6dWVCVlcvR25pSzBod2gyaVNGaWFMdDNVbHY5OFJzKytnREc3a1ZpOTFOZkdwYTVIaFhIWi9VaGtIQzhsRkx4bUV3YTRkNGpwRjhZdzZPZlNoSktsRDZiV1VmZVdyenlUQ2ZGYms5MkxGSFduRWxOaEtmQ1ZDY0VMb2pLU0NjY0lJQnVRTVZuRUtQcEdyajJ5a1BtNVI2SWd3RlIvOHhORFlEU1JUaXRxU2tvMGVVeUlvQm9uaDFQQU5lNm1GR2J5bVpZWDVRbFdOa0xsOE5WZjllRkU3a09OT2Z0cHQxYXJhbEkvSG8vdDM3emRhaTYxbW85MXU4ZlpuaFMraDZ0NjAzVzVuSmNXM3BoUTdQc0tqK05hMmZ0UWZERG9kMmFKVXFzZ2wvVjVmd2xlcnpkNTQ5UExMcjd6M3lqZTMzbjYxc2JTU0cwMTFkenZSeldsbnU3RzAxbG85Tit4M1d1MjFZYityelV6L3VGZmdCM2JMKzRjSE93OWU1VHNubmlXdXBkWURyNUJ2WkJQMXNWdjFOa0M2WUU5SEVoNVF3UWJrSlZVd2tZblVHY2FoTS9EWTAvUllsYnlKaGZHTGtWcFBZWFc1VGR6bXNFaUFzVGp0U2VEVVNLTTlCUjRnZW9RaERJM0RoQ0tHa0prNHlPNmFDK0ZGbVhuYnBMYkZRUWFiR1VvSHV2Q09hWHZjVFB3Z3lKZGU1aGVCd3BLeHlVcmUvb2xZWjVIQlVraEFyeXN1bTRwVExCdWRGa2tUWlYvOStyTWVvS0RoTTNRT05lYUR4Z1Z4UFlFWEsyb3pGaDI4RVVIL3BDU0dBQmJSWEhrVDZ1VmFUZUU5VE4wZURXZjFlbzR3cEcvT3BTZjRRSHFkcEJZY0xDVDJZa3RBd2lPcHE3YlZmQkR4aFZ6bG9IdSt3bSttekliSFI5VnFRUnVQbzZQRDNlMkQxYzJ6Q3FweXFUQWFEYlIzWWZlVFpkckZLTlBucGhNMStNRE1WTGsvcjhUT0Q3bnlFN0dqMFdRa01jYUQzb2owWCtudVBpb2MzRDY4ZmVQdzhLaVlteXlzTHRjYWk2Kys5SzJicjN4N2NYbTFQODVQOXU5VldzM3F3dXJlN2UrS1phV3hxSmplM0xpWXo3VzNINzJMS2JFeEtuRGdadmtKckgwY3NTN1pPZEFYZDFqcmNCQUlOYUZQZlhCeGw3Wi9EaVZ4RkE2NzR4TTd5cFJoN21UczZFNUlVSEdaQUxZQW1scitnSXdHcEk1cDNFQ1lzdFhVRkt4Vmk2Q2lDbzBrZzBMVzQrd21JMDFHWkNNYUE1akNUWTZwYXJWU25Lam1VYXpOSWc3cUNiV2N0aFhWakk1N0hrSEtUbXBFK2lDWTRZQVpHQldVQUlxWXIzNzFPVGE3dG51bSt3UG1VeDlUUWl4cC9Ya016TUZ2Q3FnU1FLQ1NocTJlMjlHckFSZ29PdmhXTnV5Q2kxTy9MVGZWOVF4R21rSkYzZGJQYk5CVjV2UjZjRTl3VW9FdDVtWlo2aEJQYjN5dHZFWnJld0NTelV5eVRtNVdMamFlcVpTTHRWSzFkN1MvMEtnVlM0WGQ3YjJGNWMxYXZhd3RDdDlJMHJaNk1LcldlTGFvRWNOQlgyNGFLbitQaDdQUllNVC81eWlNZThlVDhWRDN3THFoSHh3ZmpnZjl3ZEgyOGVGZTcvN05oZFdWTTg5OTZzSzV0WFBYbitlWGVYTFQ1ZVdsVXFXOSsvNTNWMVpYRnRZdTlPNjlYbTB1RE82L05pdldkV0VwbHN1eTg2cHVKMnJyVy9lOGlaY0tjUzBsSUhDd3ZLYklBQytjZlNrMGlRM2RjYUNOb1M2S1FObkhlTlBEZ2gyb09yQTVGUFJEQXNMMFlYYWwwcUFoWDhBbzJkb25NaEdnWUZrekVnM0QrU2t6aUZXRFVTZjI5MWFFV1BSRU5qNDdlTU80eG9QWlpFb3Z3bXRPbkpSaUJzaUNqMmhSeEh4aTArSTFBK0IwNWsyZ3ZCMm1zejAwd043WG9XRmFBTVM2bXM0YU1aZHV2YlFlMkN0bVgvdmE4MElweEdNbFNRZ3h3bFNTZzkySXBLVjJ0Tm02dGhTQVExQVNxNWFOdUYrQlBwQlFBTE5aaVR0WDlpMWhPUVc5d3Q0ZjI1QldLb25hckFUb25QaDdhcWJRZ1d5b2xIVDIrZ1FUV2prQ0NIVE1wRld1WkYrN01xdGNiVlp6OWRLMGM3VGJhRlExdHQ1WVhGNWVySlpMM2VPajd2RnhvVmp1ZEk2cmxmSkVBVDRZYVJiRmVtNHkxQ1pHV1gvVTZ3KzdoNFhjUlBleldnM0hCN3Zhd05lcjlXcXRVYW0xU3JXYWJtLzNiNytkSHc5dlBqcm85N3EvL2s5L2ViYzNLUlFMNWVGKys4eUY0YWkvZFA2NkFyM1FXQ21XaTlzMzM2bVVKcVZxWXpZZERTYXpPemYveEFrUVhRaEw5RElDeTd1Tnl2alBpUjhIcGpnSW10UnJ2NXVleW03REdtNWlVZ0d5ZC9TNG1WQzR4ZjJZMlNNRHRPM1ZRMTR5R0QzU1AwRDR4c3dSaTQ0bkJobUpYNlFSZmlIZzdDd1NFQW1OcmhnZEpZUjBHc1pyTmdJWTg3UXJQYjJZNDkrNGRPc3lMci9iMlE0QnRPV3NQK09FNFVBUU16RU5zRW5KaWRuWHZ2NVJZYjN4OWFKRVNkZGs3N2tkSElqK2lSbnVtVFFKdHFKcFc4cUlXTlRpcFFKUzNTS1lpQlFLYis0WkJqZUZ2bHVtaEFPd01JaHZZbVJWbGdmalRUbTIwNzVFd1NGdDJGZWpobmJjV0FGektLOXJzNnZkc0FCNVFrWVpaMWYyTzVOczBqMS9abVY5ZlhOcGRXMXY3N0NsSGZwaW8xYmpqYVNseFVXSjBUbnFQSHE0dGI2eGNYaDRPTkd0NWVHQllsMUdIZlQ3U3YrVGNWL2hPeHdNeC8zamFtdHAxTzFMaFBGVVMzVldxaTN1Yk84TXBxV2R3OTVrTU43ZjNhMVdLZzl1YjkxKys2M3Z2dnpXL2RkZnloKzhYMTlzYkwvelV1L29jRllvdDg4LzVjZEJTN2x4dDFtdnp3cUxlNDl1NENKVVJsbkI5bjI0VGhiQTJzSW9VcmxVUXhua2RxSHRaQnZqU0IxcUFnakUrUFJOM1FnNERBK29BWEtjYU1QUjRxQnpTa1h5c2xZWFpNYWFYckxJMHhCNmlHcVk4SjBTSnhvMW1WMGlFZWpNaURzaXhlSUkxWGhOVGZGVUw5LzRnNGJsSElyRTJyQ284YVRCcm8vbFpGamNZSmpJd2p3T1lKZlRaSjRDak1MQU13SXpKbWJVZFNUNyt0YytIbGloWXAxcEp1MmlaQjROeHR6a0FTRWRoZVpoVzZpTFFNWXg2a0srcU9sU21ETGM1c0xNSW5Ib2l5Q2VDeWpDN2N3d25vY2lGbGQyblFWd0ZVVU5iY3JSUkFkcEc4TlpOMm9odVpLNlNVWlJySXRQV0lmY1VIK21OOGhLays3R1dydFFydXpzN1kxRytWcTlVcTN3aUVWMDJyb29sSXRaYVdWMVE1dDRzUzVtaGM3ZVRqNDNxVGFhNVVxbHF6dlVySkNWS3NNQi84MmhXbXVXR3MzWmFKcGw1YXpTUUl0WnNYOXdPRDdlWFZocW5iLzJwTFkvbHk2ZWVmNkZEMTE3NFNPRFhPSGUvZU9WbFlYTmF5L3V2dnZ0M1FkM2VnZGJyYlZ6eFVwbE9ob09lOTNOODFkMzkzcTl6aU50UGtKQnJCY0dsZ3FPY2t4QmhMbExlUFVrU0U2eE0yd2x1MU1WRkNRUm1aWEF0Vm14UDNSWTN4bEtRUGpDbFlyOUlSSzVJeElZTTZZVWhJODF2VjNqcVczemNJMDZNYjRLVVJRMTNpR3dGTlBPUkhZVGJCVGE4aU9TeGlFT1lpY2FwQTdWOENNVEVzdFcrY1RMUlM4a3BqQVpEd3lsL0trQysvaCtqMmlZMXpGZ2hIS2xKMHE5aGV6bnYvWkpGa3Vvd2JQOWVJOWEzV3htcEM3V2NNenBiSDJ3RzRNUnlySVN1cXBwMldMWUJuUHBISEpoSUp2TGk4ODIxSHpXSitJMUVLUm5pU2ZDaUhWRTV6YVVJWklZZWdUZ1lQbkc4eE12QTIvWjV4WWhsOHlLeGVXUGxZdlZNMnNyL0xKQVZseGZiU3VyNjJJald5bHJEM3JkenY3dWFEaHVyNnhVYTFXdHd0RmdrTmQ5cWdTWlRMVElScE5odFZwWDFKVEtsUW0zSy93cnNuSDNpUCt5Vks4alNiRzBzSFptOWNLRlJXNEdhZ3VyNjVlZi9WQjdiWFA1N09hN04rKzkrZ2UvdjNMeFRMRlFuVmJxZTN0N0M1VjhaekJxTEN5WEdrdjVZamxmS01rVWw1NTQ0ZUN3Mnp0NklFTkpKZFRFYkhZTVprMjV5bGdpU1dkTWdLMEE3Y2p3QWFUQ0tGWnA0SndJWmFjYXpvNStreXZLZlYyRklDN1BaaGhMUUh5RU1PVEVyQ25WejdXRlA2NmN4dGh4amdkTDVHQmlteUdNaEZJWEFlcGU0Y0hnS2RHTFUyaG5QVVNqazNvVkNXUjZQQTRIa2l6TitkNGR0RHAwRXFBUkRMY1ljSUk3YzVrSTVvak56aWM0ZUtqNFd3dUdaNy93MVU4bGxtekswWjBubzRwdkdkQ3hHdzZ3OUJSTWtScmc0NEtid2hRT0dzU1Vpam1Uc1lvWUxETFNETnlnUndMWkZmbWlHUmNnQVRFMkhLd3BWSE9vSlR3eVF4LzJNbzJmblBvT3o0Zndra1Q2TGc0S0Z6VkRwY3czMzZxMTJ1Ym1hcXRSeTg4bUUyMjQ5L2FPRC9lbkEzN1hybFF1S2RtT2gvM1pxSzhjejV0TGt6R1BhN0p5dGRtbzFodUZJditxWWpvWjVyTXk5NXFvT3VPM2JjcVZUSVB6czhiS2FtTnB0VjZ0VHJMUy9WdHZIKy92VG5QbDdzNzJsU2V2TDErNHNyeCt2blB2enNIaHdjN2JyKzdjZmE5WXpaYk9YQzFYRi9JWi94Q2owVjYvL2ZhM2JTQXJpL1d4RXNXK0NHT3J6N0F0SHAxR3FwS09OT2tHSUdvalNidlFJWmlETVc3am9UQzlRTG5CcVlzUldOWk1rT1R4Z1VtTmxKaEM4TlZWMnJoSjNXSlRDakxoVmNzOGlpcGhJTWIxSk0zd3JKa3dVQk5HdW5YZ2hjZm5ZWW9jNEVNN0RwSEMyUWhUV2d0M1dDUG9hTHFYa0FnQlFFTkREd2RGRnY4TFgvc0JaQktSUWx3RjRUUXlDUmNUNitLaGRrd2FqQkJhbUxsWTZ0WE5ITVZHSStibWNZOEJFVkI5b3RJRkU5bDRxSTh0V0dOT0hnNWNNM09xUmtxbEJFUVBCWVRrTzlmK0h5b1NtdHltRkJMNXhueVFTK2FLbTVEOHFIUjVyMU9vbFdjMVJXR3UwRnhhWE9DbllpbzZ5dVdLRW5tejJWaGEzOVIwbllPZHlmSFJkTmd0c2N2UlRXekpIeVJiVkdRckpTclFKVW1wcE5qV3BhSWhvTnFvRjRzbDFvTnVGbXd5UGl0ZnJmTnZlV2Y1QnpmZjdoenU3Tnk3ZC9iYXRmSFJicWxXdi8zbUs1ZGYrRmo3NGpOYmR4OWt6ZVZpU1hlNWpmcmlzaTRPazhua3hqc3ZIejI2WVdkaHFMQ1ZpNklrSUdjeU5BelAydFVVNk8wR0NEMlFxSVpLdFMrL2Fxb29BNEYzUDMzQStGaFk3MURURUF3T1YvNnhraHdoeTdvVmdTUkVwUEFnd1dWNEZxVGNJUXlWYjdISVdSTEtsMXlRT0ZwUXdyZ0pUK0pLdGZsNEptclRrMk5wTWhNeVEyZlpPRXhBU0ZwMUVZWkl4c05CYzgyYnFiWjBGc0ZMb0pEOWhhOS9HcHNJeEhTUmd5VWNmVEJrR0xVd3RqZ1Z0ZkZKS3I3NWUwTG1sV09MV0gvaGt3bW8wWlo3eXJDSWViSkxvWWJNTk1EV25FWEVHdUIrbkl1UlY2MHZBdlRTcERNVTg0VVJIMmlOaWZPdy9PSEplTGkyVUJkK090WHVvOVJzS0hKMTg2bGQrRmlMcnFRZFJTNDNIUFlIaHdlVlNyNVVyWmVxcmRieVdtUjBFVXhHZzl5RTM0VEpUU2VLVVg0eXlXbXFMTXJHWXFXeFVLN3lDNUxUS1o4d1ZtanhUNURLNWY3aHdhaDdzUFB3b1JnODlmRWZLRlFXdnZsN3YvL3c3VmZ5NDk0TFAvTEZiLy9PYjFRTC9meE1JVjlwTG0zMCs3MjF0YlB2dnZYSFlSMFh0Q0FBdzd3UnhYWUczblFsa1JLSnUxVGJjY1EwelFpV2VUZUFUaklNamZTcEs5TTcwSDNRbHM5a1N6eG5RV3o2bU1yMTNNN01RMVAzbERpRWZCUkpSMDRuTitrUVJ4YUxQWXNyeVQ3SlI1b05qMWtCWVR5WFc5SExJWEhvb2dFZ2xFWWhXdUxnRjJwUnBFb2dqRS9qSEJZSkUwdlVYY0xZeHRtZi85cG5hTk1vNkY0ZVM3cURTeDRjY1FDOUlDVzZsb0NuOFFxWkswK3ZLTm1CcGNtWTI2R3ZFOTVVYWpheFBlc2xnVW5WQldIRU4zbVVLUkRZR0E4VUh2N3hxM2dFdGJ1WVpFNmpPaXVKaHZYQWRTaWZOUzZYRjU5cVZrcnJHMHVEUWE2OXNqZ2Q5RXZaUk5sN011cjMrOE4rdDFzbzhJUFZ1ZWwwZE53cGxvcjE5aXFTeHUvVDh6eCtwbmlmamNheVFybFN5OG8xTWxtUmYyc25JdjZMZ2RhT2puSXRVMit4bWk5Vnh1UEpzSGZVV3R2VXpUQWhzTGpTbjgwV2w1ZExrOTVtcFRkYVdQL09xNitWNitWK1o5QmVYVm5ZdUZEUUVxcldldDN1M3ZhRDZlRElqZ3NqVThLamp0Y0VBS1dtYXNrcVl2dEJBTGRZeExrMzVDQjFWdTRXS1UvS0dZYkZDV283aHJ5SVRWVkJKTzlyWnJyVWlnYnM3UlpNN1I4bGRMOThNWDlLeG1VMnNydTlnTy9pd0EvMENtYVhZdUxncUI3U1ZxSmtHcTRNMFF0eksyUVlTUng0YUFwSmRGdGdWQWF5ZW9UWHZCaGh6anJyUktKMGFGS0JkMWYyRjcvK1dhVXRzQnFndzVzWlFsTzhBUkFKZzNHb0VMVkdjcEZsdzIwRmJFc04xT0ZRRGlWTmx2QXdqNmJDVjIzUmNIOXBjemd4eUhhcEdWR09LU080MmNWRU0zVEFvTWFIdWZsRmY2YlFjTFpQK1dwNS9UUDV5YkM5V0szWEc4dXJTNVBCb0t3N3crbW9YaTJOeCtPam95UHQzNnZsOG5DazI5Yjg0dXBxcmJWRUJ0SFdwWkNWaU9OU3FWTEppcFZTclNhMmZpK2RoN0thZzlaMHJNMk1ZbDB5Wk1YU2RNTHZEYXBMVzRiSnNEOGQ5QnFMeTB1YjV3YmozSERuN21KejRlSnpIOXM5N3IvN2UzKzRlL3Zkck45LytxTWZlZmxmL3BNelo1ZHk5YldkN1lmeWY2bGNPOWkraFNzd05CVm4zSm9BakM3bEhtUDg4bDhVTXBOYk9qQUVYV0NJSHpyOHdtZk1vYjJOaDBBcHM0V25zTG5VTVVwR1Z1MWdsM0ZMMkJ4ckcrODNzTjBrMGFpT0MvaUo0M0FIYmswMGtMbWNpbnVUQzNhdGx6dmhqOXhxNk0vdU5MSE9sdG5ONk5VSlp0QkdjYWU3cUJONVFwcEh3TUU0bi8ybHIzOU9pQlF4dHBzTjVjbEQzR1EzQ2NpU2dJRUE3TzhWNHFZb3hVSHFZVXVhTEFOcEwySTRhMTlqbXBUcEdXSzdFS3prQURETVJkT1RrbEVpMWlsY09NTjhNS0VYV0Y2SjZCYzNtcFluVjJwL3ZGeGJLZWNtL2RINDdKbU5wWVc2OWhYRkxOTzJXenNaelRQb1Q5cEw3VktwMU8wY1Zldk5TcldtNkM4Vks4bzkrbE5kckFqbXM1UGpZVmVyUkFyRXRVZ1JMNkhMNVNyVEZ5dUtVNlZKU1RlYlRmbnZPL2JaWk5RcjFocUZjck4zdUovckhaY1dGa2V6M01NNzk4OWUybmp1czE5OHROdko4cE5MSC9tK1gvMmYva25uM2p2ckc1djMzdnIyMmV2UFA3ajF1Z1pySGx2U0UwYVpSM0MwQmFpSkt6Q3BnSFNieForeExsQmdLQ0VBbGVabFlTaFlGWGF6cDhHMG9wWmVKRyttdGJGbFh0ZTJ0dFMxYTFKK0liTUlieGZnRVI2VHozc1Y5eWEyVXdnRjlWTGIvUWJtY3pBL0FRRVpyQkFtRWh4YVdjSVlwSk40SW0zQXpBbVp0T0grVDMvbXFWN0xyd0loQlEwODdjbGhTazdaWC9wem40ZWxTTVhMWmdsUXZmUGgwQVdCTGVueG1nTTd4a1RFdW9tTlo0S1NRQ01GUnlZUTh5U3UvL21QQUg2TjBQVFNoRXdmYWpNQnNVNG95eE5XSDRQU2kySTJuT2c1c2FqZ0R6Y2t6Nm9YeSsxbkxtNHVyaXd2emdxbGN4dnRVamFybDR2ZHdaaTN4MlpqNVczRTFZUVNzVndxbHFyVldrMVpXdkZhMUJWWTBUM2wzMUU2U25KSzN2NWNWMFdiRm4rSVlNcmt1aUtYdEhzcGM2SERWUEVJbkVjK285bDRmM3VyMXgxT1p0b1ZGZzhmdkQ4YmQ3Y2ViT3VtNE9IN3QrdjFRbFl1dGxmYmIzM2ozNjRzVkthVlpxTmVPc28xNitYeXdkNGRYVlhEWXJnQXRxa0VKSGw4cHVBaXJ3RlJCNXpvT2V0QUdBSGFtOHVhQWlLMm8rQkdSc3FZR0ZVbWxEN1JRVTdoT3Fub3grellGS0FJd3FCZHdBTUQ5Y2hadnBDYVFUZzNIYklKNjhjQ3BXU1V1Z2hPQVV5bUl5Q1JKU1FWZUE4RTBPR09PQ2R3RGxoamd3eXcxWkFCS3lWbE5Vam9Vek5HWGNqLzZqLytUMlF4djYrdjAxVFh3WGdHbTk1STlnZlZRWUhRS1FnRTYvS3ROcDk5MFZxYjAwc09QamJnWndWK1F3a1VBY0dTNU8ybjVKVlV1U1pxMUl1MG91TEdSeDREVWpma090bmlGaGxOQlhIMWhCNjEyVWpnNU9ta1VMN3dVNWMzVjFiYTlaMmpZU1hMNmhWcE5KR091M3NIR2xRcEZTYXpiRFRvdDFyVnhLOVFLZVFVbk1ydlEwK21YUjFQWE5CS1UyamFFRkdwZmpSVTZzL25kS0VvNWtwVjVibkpsSys3MW1yTkVaOUE2RTdIbzhGbzlPajlXK1ArWURidTFSYmJ1cUxvenZYV3pYY252Y1BsdFRPTmxmVWIzLzdtMHRwS2ZlUHkvL08vK0srWGxxdFBYNy80c1IvN3FmMkhEK29iNjkydGQvMzQwUEdJVGFWUlBCOUhMTm5TcHJRamRJQ3c1UU9EMzBRTVBXZTVBTytvUjdjaWRNdTVhb3BXQ2dLb1lrOXpjdmhCZ3gvbThJZGh4SVJhTHpmaWJLeW9HS09XWFdwSElEZ3NlQXh0RnRCb05wTlpYbytDMHRGamJHQVlpZGFoaXpDQzFNTzdYRnBRc0lpWVVSR0ZBVHZuTVNDY0dVZEJxRmd6WVRobU5JMHFnakQ3SzMvdUo0aDZEaFl1ZmF3Wkt6MUhlcFhFb1VLMmRwM3dUdkd4NmpVd3V0S2x4OG5iVjBBSjRpNG5WaDJrYmRLSENOekZxcHpQNHNHQlVhNGhvemlGY05Dakd6RGxJUktPQmlnRW1WbnFaSzFuVnpZdXJ5N1ZSN1BzNktpN3ZGRFNma1I5NDlGWVZ6ZGRoOFZyTXAzeXI4MzVXVHh0UzhyRDRYQTJVem9YSXhrbXBwZmZDQm5aUWRsWXR0Y09Ud3BvU1FqU3JuNldsVVlUdm84L0hrMUdHcDdMVFVZRGZxN0RuMERhZm5ndk54bEtuUGJLYW4xNVBWK3ViTy90MVJ1TGxaWE5sVFBuMzcxeloxYXM2SnJ4a1UrK3VGaXZ2dmZhYTgxYWVaekxManp4a2FPREI4b0syQjRiaHZseGtzNzRqSFh0VGhyaHZHaWxKblc4TUluYVlSbmJWVmhycUg2eEZwN0NOZkp4VVhBb0pVdGhtWXQrN0h4U3d1eVU0Q0t1ZHFVR2tML24zSUVCSkhMeXV5ZjBNaUFrRWhtYVdFNUhUZW8xaGdDRkdaMU1RcndHc1NsVWN5YWd3VEZBSXBnQk9xbFRPZ213Ym84MTFkVFJqMVFTK2RmLzUvK1NsUk9yeTdWZmdlRlRqVUlyM3lsRGFPWDVOM0FVRG5ScTRSRUZ6dmtxa2ZnVktTeHFNMUZic2dVZlJDUmZNVnhJTDI0eUJkclJiUnhhYXErTWJJalAycGZPQUtwdERKOWk1YXFKeXZ6QWhpYWNGR3FOcXo5emFYMmhVcTFNK1VtTllibWtmRDhwNU1hNmN4cE1Kb1JzTHQvcjllcVZVcW1zUzBqV0h3N1Jhekt1VlN1dzBiQkJWMzRwbDhwOHVERlh0QTIweWVGSHhtYVRFVnJ4eTVLRDhYQlFyRFEwdGZiNnMvRllReVhLWURUdEhuZW1vM0YvLzBHdVhLNDBGbDc5enN2Mzd0ejVrOS84TjhzWExxMnNMTHoxNW52YnQyOXZyclErK3Z5VGw1NTRhdmVvSjE2TmFtN2pJNThwREtaTGw2L2RlT2xYcFJES1lCRW1rKzFrTVl5cE5JY3hPRlN3bFEzclRPZ3o3ckRaOFJUWFhZeUtuMHdydy9OeFZWbks3dlI2WnBiWkpMNE9SV3IzcEtyMHNxblRYbTF1Wi9XNnhWa3NjQXFoVENwbGp2blRJYmxRaDJjUG40b0poVG8wY1BFUU0wTjB6eGxZS2FTR0JiU3dacHFHODk3T1JJQ0tGUVovSXBGbEZSQ1VHa2pXZ0Jjb2s4RTlsLzgzdi9SZkphUEE1S1Rtck9yRWR1eDJiRzJOeG95WWJRS3BJWG80SkNaU2FESndta2tuTzRHcCtjMWJjd2FXTGNDUzJwSExPTUpZT0dVQ2tSSG1GamNBcnd1SE8rUmVBMmloaVR4cmFlTUhsbGN2TExYcXl1TDFzaEx3dUZvazNOV3JoS09rcnNTc05OOGY5QmZxTlUwOUhJMUdReUpWd2Evd240aFVycCtOc3hJSnpxczJHNDlIQ2dpbFBFVTh6eVZ6eXVqandhakhtMHY4enlqdXkwc2wzU0lMM3h0ME80TmVUd21rVXE0TWVnZUhkOSs5OGVvYmI3Lzl0cTVyMVhwdFlYbmwxZmZ1RlVlVGFyTjY3c3o2K1d0WFI3TkNzMXpvYjcyZks1WVBqM3FmK05tLy9PWXJ2NjdsWjFOZ1N1SW9ET2VFRW9HS0tkV1FPMXk3b2tRclNQakhiM1lJZzZIV2kwOUIyRTV6cjVpWHpBZVJtdTdHcm5ZQWZzQzA1RWdvSStFays0dElJOE5yZGhRQXpBSUlzd0R3RU05Qkk1aktaODBDRllMQ1VwQlJGa1FRdlo2Qk1rZk1DeUNNVGlqNVEzNVdCd0tSTGhsdnNieHBRQ28xYVVPcytqZCs2Vy9DaXlJdU5yY3JHR05WUjdrMzRxb1paMVNRdUloR2N5cnNoQU9OalNBRjFneWhzUDJXMURJYTJ3a1NzUlVLNGNNQkZ0c1dwNG1KQ1VFVHBTTFk0OUJSMTVCcGFiRjErZk90V3FsWnEyaXZVcXNVQjhOeFZaQTJJdE9SQ01kOEU2L2E3dy80Znh1VjBtUTRHaytucktyWnNLS3JnSFpIVm9PUDRHZ3JvK1d0ekYwb2FyOHVldDJDbGtzMTdkaG40K24rVVVlbjQ4TmVZM0ZCKzZOKzk3amszVm01VXA1TWh0M3VjRHJwTjVxTGcrUDl1My93cjg1Y2UvYld6ZmVucGRMTzRVR3AzUGpkMy9pdHM2MzY1V2VmZXYzTm05WHBlR2x6ZFcyeDFGNVozM3EwZDdpN3ZiaCs5dHB6TDNTUHQzckQ0K1FrbXgxRGhnRnRicXlEMktsZ05wMjR1bUJURlp6QjJUK2Y0U0EzRyt4a0J3bFNMVnBUMloxaFdwb0pHVkZPaGExeFFkb09tNDhOTDZFWVpwRE50YVAvcEJlL2lCazFxa2hNQzZVejdOTTBQbWtRa1pFUUxvTGxDMU9hRndSUXBMR21nSDQraWxrY1NqRjFxb1dmQThKUUJYWCt0Lzc1MytLTUpabkpvS1VBMWluTTVWc2dCdEgycjcwSmtBV0ZVNWZvdlJ6MElnWTlqVFEzVWVTY3g2cGlLVkZLU2daRDlaZ2N5WGpBRFlCZmpZNm1HcTRTeUlsZUpKcm1sejVTV3JwU0tlYlByVFhsWTIweFJwTlp2VnJoRFNQUEl1cGlsdlg2dy9Ga1dLdVV5ZlpveGorV3FsYlNUbVkwSGl2VGl5TzNmU0xlNnh3KzJuNzFsVmV1UC8xMFk2bDV2SDM0dTcvNTI0MldkbmV0blllM0xsNTlLaXVXOXJhM3ptNHVYWHZ4MmFXbGpkeDAxRG5ZSHgwZkRZYkRybTVhdCsvY3Uzbno0VHR2dmJOOStPaXdYeWxWTmk2ZXUzYnAvTXFaczIrLy9lNlY4MmR1di9uNnhjdm55d3ZMOTIrKzB6czRycFVMMTU5Ny91ejFadzRHQjRQT0RtWWk5OGh3V0ZYS29vYk5qUWRjQklDblNPcUVVVFVIMVFoM1VUbktwVFQ2bVVERnhGaHlQZ2cyWVYxc1RvZDdDWCs4bGdpRFFQMXBvY0RUTVJmczZJZ1FCQTdmend2eS9IOForODlvVzVia1BBd3NYN1g5M3NlYmU2NTM3ejdiM2VoK2FEUWNBWWdrREVHQUZFQVNwRWdRSUFFYWtaVCt6Tkw4R2YwWXJqVS81OGZNbXRGbzFpek5pSktXREVWS1N5UUFFaUFJZHFQOWEvTzh1ZDRjZjg3MnU3eVo3NHVzMm1lZmUxOURqSk9uS2pNeU1qSXpNakl5c3FwMmxaQkpBdjlscGpRSjlOTFFPVG5yRVJKVmhBeUZBQ2xoenR3SzVBZVArQ2NJZ2hkcEZZbGdJRTRwcTMvNVgveS9tRnN5S2dFSnNjcmk3NVhlZVhsUVI3NVhrYk1RRFFVTjJnR25tM0ZnMlVyV3pScklpNWtTb1I2ci9nb1VkRXdRTUpJa2dWb0xsVFNSQjJrNmZYV1pQNUlTRUNJQ0s1SXZNYmhYL3F4bXVKMjZ0ZGFwb1E2NE1LbW1OK25OSUJOZWRXWmJobTFaWVJ6RmdkOXFOTEN0aEZKQ1FRMHRkMTBQbGVTWkZzV2g2MXAwZkFwdGREejd2LzduLzZmUjVPUlgvc01mZmVmOWU4dmRsOTU2NjZ2OTBHOFkrbjUvbWhUNXBmWGxvK00rNnJxd3V2S1RYL3JTWjM3dVo1dWRGaFovYk5DaUlEenRuNlp4R2dlenJoWThQVGg0NzV2ZmlMVDY5cVdMRU5yUzhzYTduM3pTWFZ0OTl2MXZ1czFPNkU4OHkyelp4Z3JtVFhjbG5wM3N2UG16czhFalBZL1FOWEVYMmNublJnZHdsa2FXc3FPS1JncGd5TlNpaXBnVVY2TXBNZHA4UnNtZWFaWlZDaWV5cFhnUlVUYUdjV1hsU2FQT0NHcWFRY2w1U1U2eWNKVExjeVUzQXJuTDRGYUFacW1aUnR3Y1R6VlVGMlprZ2d2bktrK3BDZzhMWEZqeXJCWUFpcUJkN0ltZ21lQ1JyaFM1NFRSbkNNeFgvdVgvVzg2Q1VvY3lWOVdMSXdFeGFuVVZaNk1nVTVSQ05UalF4cGJGRktobUsvbWdsOUpteWtoMFZGSFNMZ2lHV2FMVk1pK1lWbVRTZE14UzVqSXF6V2VPOGdzVm45VHBkcTc5QjFFVXJUU3Q1VzRkYWoyWXhxWlJORjFXQnpNT20xNzNiS3hKR0hyWWNMbTFwV2R4bktVcCtEbFFjZjVpeFlEclV2TnE0V1Q2L3IvOTJ0Zi82SC83eHZlK1VUaXQvc25vdC83YUw3ejd6dHRmKzJEL3pzM050ejdhNjdicVFackRZWStURE1yZHJubEJHRjVlWHZrLy9KLy84ZEwxeS9DRSt2MytrMGNQSHorNDkrN1h2bnI3Q3o5OC9jTEZKdzgrckhXNmZGakhzQTRmUHgzdVBqbzQ3RC9lNzNlYW5ta1lOYy9jM05pNHVMVyswdlB5OFdEOTJzdjI2clp1UkVVYVlnZGVydXNWS09FeklrZGtNU0lrbEYyWmdJT25GbHVCeWx4SmxBY1pFTVVCQjVFc3pCZUFQZ2xDT1Jqa1RxRkRPUEQ3bUs1MG13UkNqNEpNU2xSR1JFWUtKMVRFdWhnbFdxcmdueW9taFNTREVTS2tYeVgxdkkrQ0tRa2txYURVSnJhUnpWWHRGSVNRc1FWc0E2MDdtNEY4WVVNKzZNQlhmL2YvZ3pqRXc0NEtXL0NUaUJSbVRCTHE5ZklTUVZxVUdhV2hVQ1dDY1JKV3dMcGxEMEVPSWdkR2xKclNHWUlpTDNRTUlJMEVpRXdrTGoyaDJTZVVMWmVlU0FDd2VONjUzdHA4T1FxVG5aVmF3N016VFg5MlBPNDJIQmg2VGJkbVVXcnFoZWVhR1BNa1NTM2JLWEplbmNTUVk3T0tyYWZuT1piTjBVM2paSFkwK2gvK0wvLzRldy9mamd4clo2WFhYWGJ1UGRqYjY0ZXU0eDJQWjVjMjFtMHJlWFE0N25hYWovYU9OM3N0dzdRdTlCcmYrZmdoSmxCRDAvK3ovK3ovZVBtMU94OTg5TUh3NUtqV2FtcHBkbkl5VHZRTU8vVDIwaEpjdm4vM2IvNXRra3dQSGg5Z0V3eGZxNFVkZ1Y0MG05NzZTdWZHbFFzYkYzYysvUGpabGMzMTdWZS80RFRxMCtGVExLSm9KenFNZmtKV0ZBWTdUYWtwUVpUTHJraERyaUNVY2Y2R0RIang2VXNoaTBJTE5ZWkNCazh5SzBsbXdvOUJUa3lkWWFoVFo4T2lsRjV5MVZIeFZ5TkxJT3JjeUFwdzlJZ3RtNjhLbGFlU0dGbGdxTXJLLzFueVBGQVBBV2laVW5wUWdSSWdjUlVwMVIyZ3lqTVArdmViZiszUFN3UzVpcEpuSkdWcDRHVlVFQktwVHBJdCtvZmxUaUs4dUNsWGNkVzFkdUtZRkpPQUtXL3dVanVKZVBXZFpMd0tLdGR4MlNEaGd3UXYwekxDUUFJVlFWZk9hQlNlZGJJaVlsV3I5ZVpGMDIzRCtZYUtvNm93S1k1T3hxNk5EYXVORlIybTNUWUx4NEpld2F1UkQzOFh1V1VhL0NVMTNCWXNwQURMVGxQdDNULzYrZ2QvK0YrLy84bGJIejA1OFpyMVdaenQ5OFBCS0VHbHJVWWRQWGx5ZUd5R3lXUTI2N1dYK29QVHRhYjlZUGNFTzkxWm5EUmM4M2dhdlArdHQrNjk5YzAzZi9SSERNdmIyTjVhVzFzdm5CcVdsNDJObFhhbkE1NFhybDBZSG8wKy9PQTkxTnFmQmsvNzQvNEF6bFVySyt6dDFlWDFqWjJuRDU2RXdYUjRldENvdGRJQ3ZjbW9hdFdJeUZtNnJaSWNFV0lvS1VZeFlNd25NSmRJUWFpanlCQVpsQzFQRkthVTVvaVV1WXh6N1NOS2pwUzVwTmdPU2JJSTFrZlNjaUJRaXdTNmNYTTJWWVZWQXhYTU14aVh5cy95QVBORTJUK1FFNGNnc1hsUkZpNGpBcVNSRmdvSFJQamdBbkZ5UUt1cmVxU1UrYmYrK2w5US9LaW1YSktJbDA0SUF5VkVwdUJHbjgwaHFZQUtMV3pLUU1sSXFPSWdxQ1pBU2FNT3lNSlpranpPcDRINko3RUswZ0xrTW9BU0s1QWdpUllDdENUTDY1YzFHOXZVb3Rld1RkTnliT3Z3WktvWGNRUHFidklTamV0Z2VFQUg4MllrY1d6d042MjBHWVpweG5FOG13WGhKUHlYLy9mLzRwLyt5My95MWU5LzlNcy8vNlpuSk8vY1BZTGxXV3A2Mk96Mkd0cVRaMGRkejExcWVLUEFqNVBrM3U3UjVuSm5OSjY1MFBMVGNidnVZUUhCVlBLelpQZndKTjYvOStEdGQvL01uL3R4STVpNHkydXRWc3R3dEowTFc2c3I2M3FSN1QzOUpFK1Q0WENDL1RSY21WVFBUa2JqNFdEdytQN0RCKys5Q3pabzAxS3o1clNXaXl5TGdzeHlLUlFLQVl1aGlFTnU4VlNLSktwV1JtRjF6NlFxZzBZN0xJbVNHc0RSSkUxWlNzbVR3a2RFRkZyK2hWTGxTQlQwY3hPR0FBU0hnL25NRm1COVZUaURzM3hrcUJ4Um5ubUt5WG1KaFNocVBNZElnZnhVcE14UTdjUVI3Y2FBU295ZzJpQ1o0S2Z1ZFNwZ09hbzdNODR3a3BCNUlkSXNjd0J6bVFGSzFvS1JDTThxS0pENEdiWk04Wm82RWRMbGtrd01DU21VRG91WVdUTlRLb05rQ3FvSU80V1djZkNpK3BVazFXcFdVYXQ1NkRmOGc4QVA0eVEySFFzK1U1cG1yZzFkd1dhVXRoenVDeFkrK1BkNW5sdVdOUXVpMDJuNHZYLzFUNDkydjFGZlhubjY3T2o5VC9hM1ZqY2JWclEzR0M5MzNjMU96U3lNdFpZM0NXYVBEZ2NyamNhVnpXNmpidlFuSWN6L2hXN3Q2V0M2Mm1xZWppZjFlbTA2aTV0MUo0d1NQL0k3N1pYZi9lZS84NW5YNy9RMlZ4MXFTTjdwclc1dlhYenRqUytjSEQxS2syalFuNDRuNFU2M2MvdkN5cTNMVzV1WExoWXpmM3UxdmI3VnpiTE10VGd0NjY3cmoyWm1qZTgvWTVEZXk0Q0lNUUxNNVZDSnBscTZJUm5TNEVpa1pBRktHb1ZnTmlWZnNhSlZCeWNsYldpMzRBaGxOczZDazZTQUdzeEZqSUNxVkFIYlVrYlBta0Y0b1dHSzhubGVoTE55S3JmcWZBbWx3a2hNVWJDdFphRkZVcUxNMy9ycnY0UVQzMktGekRQT2lsQThlaWdMWEFGU3EvN05UVHZQYzNGdzhhTzBlUCtsa2lHT1ZhaklxT2RxNEtSM2FMcktJTEE4ejBES2c2YklxUnJFK2N0OGxWSjQ4UVh0aWJ0ajZWYTc0V0tjNnc2L0g1OW54Y2x3NW5rMXozRlFDWjhiNWdQcWFEQTllUGFHdDd6NXlEcjZ0ci9uZitkZi9TOXJHeHRQOXc2NzdhWnBaczhPaHlpKzNHM0ZXZjE0RkhxZWNXRzlXN1AxSmRzY2dmTTRXS201Yjd5ME01NGxnMW5ZYTNwSFU3L3RlcFp0akdmQlNzc2RoM0hUdHY3Z2o3NTFPanorNUZ2Zi91bGYrb3Q2UE9CZHFzalBUeDcwNzMxemM2VnhhWHU5NWxtUmtaK09nN2NmN2QxN2VuTHY0ZTZUbzJGL1BEMDhHUEVGazdiWmFqZkdCN3VOWHRjb3NFcDVXcEdxQjdlVVZpZ1ZWMVpCcVMvK2VXSU9qUlNnV2cwa2w2V0lSTHlFMHV3cFBWYUVpRmJqS1U4N211V0lBOG1qaERPUTRhZ3c1QXdsT1NQQTZFak5aelNxOWpNS0ZUL1hKS3JXdVVZdTVDTkw5TEFFMVZEU1V4ZFpDMEZZenZYa1RBYno4SzNmLzI5UWdleHFlSTFGQVVqVkZxSGE3YWpOQVp0U2dSUW9iUWtwU2d4WU1zMkQ3RllCUE1xMlNTNHo0WHkyK1ZEUGlaUlFzZURGQ0lpK1JDbGdTK2xNelJFQXBuSXoydmhwK0x2ZHBsTjN0UTA0Tkk0TGxYNjAyKysxWWU1aDJJMDhqUjNINGxNenBwV2xXUlFHRUJGRTU1ajJzK1BKLy9SZi9wTzczLzV2VzY3MzRmN29SejUzSnd6Qy9hUFQyV1RjY2UxUm1EK2RSSFllYXFtMjF2RmE3V2FobVpNNHhoNjRhK2xoYmp6cVQxelhPUjM1MkJzRWVXSm1tWjdscG0zVU5YMlk2UzFiT3g1T2Yvb3puL2tydi9GWE42OXVudXc5Z0d2VXFqbTZ4bXVuMy8vZy9rbC9jaklKN3QyOS8rMjMzbDFxT3NPUThqa0pNaVBYVnozajVzWFZkcnZaMUxNLzkrZC91YWc1ZVRycmJsL2szYndGRVVBQVNNc21rc0FvQjA1RUtMNE05eXBLaU1BdUZwUmhVdVdnNjFKT2tCU3pTc2pXazBnZVNDclZxSUlWQ0VlRlFWUWVVaUNDYVRaR1JlY3RMdkg4THpFcURnYUtCditvaVhFcHAycFVWQlVzeGdtcVBURFZ2TTR1TUVjK0I2b0s4N2QvL1ZkZzdtam9TTVppNkNxYmdDSkVBTlFVNXhaQTVvNnlNY3pBQXNpSXpDdVd4N1NTbFVZVnJHYS9Da1J3d1JUcnd6ODJzc3dBbEhHeEltS2RoR1lPYkdESkZxQXlVRDUzdXBHelBndW1TUmgzMjQxMmcwL3EycFl4OHZtY2xtM1RJS0tuWUlVWUc0bHBaQnF1NStWNXVyL1gvN2YveSsrTm4zN2w1cVV0T1BaclRlL085VlVuOXJkNnRYUVd4R2sybnN6TVBQK1JtMnQzTHErdXR1a1QxVjJ2WmhoMTIxbGJhcmM2dFAxTE5hZFJ0NmRSTVJqTjFwcHVsR1NPcGgvMFo5dGJ5MzZRUnBuMitQRG95ZjFQYmw2K3ZuWDFvbE9yNVY0bkw4d2dqaTB6dmJCenNWdjNuang2T3VtZk9waWpsdGRiWGQ5WTd6ZzZab1czdnJyODVtZHVMYSswUDN6bm5mSGVzOEd6UnpENm5kWE5MS00vVmlvTUl4dzlrVWM1eHBRbFJTaENwTWpLT0lpVUFNWHpCcEFVWTR1ajhpWWxMV01rREJIRFVYR0FBTW1ocWtnNTh1UmNGaFRHTXZRQTFnZVFBMFhQdUNRcUtPbExPSitTdEZSWEp1ZkF3U3RyWko3NmFSdmliQzZBUXl0a1ZTTUJLajZ2QUJIenQvN0dyNUNQZElZbjRsVUJIQkdBVUVmK002RXlLMkJHMlJENk1Fd0MrV0pqS3hBbUlGTXFYY0tjWllsVG5TMnJsU29yNHNYS3NYSE43RjVnZEtIcnJ1dHVMUE45N1h5UGFWRU1KMkVZeDNYZTRzZVdqNU9YRDBYQ2l1VHl6RHFFWlJuZitaZS84OS85Ly81dlAvNmxWOEx4OGVIVDNRK2Y5VzlldmRScmVVbkNhNWZEVVRBSmtxWnIzRDhZUG5qU0g4MlNkcVBoWWErVUY0ZXo2TkhlYUxWZDZ6VnJwek4vcDljOUhvMTBBN09NVHl0QUNPTWd2SFgxMHBPOUE3aFRjWjYvdkxQOEwzL25YMjE0OVl1dmZiN1RibzRtQTVnYU9HRFQwMGtjVGh0cm5SLzc2UzhVM2ZiRGU3dmJEZnVsbGQ3cjE3ZXViN1pXbHBzVFA2dTFWMTk3ODdOOWYrWVBobm93MUxIdDFXMTVTQlRPQm9WU0Nvem1nQ0NDQVRBRGllcGYvSlJLZU9jVWdrZ21GNUhQVVM0ZUZaQnJHWjJUY2tqNWgrb0VwUWhFOVJHSWd0MVJhRGF0WW9hR3FtakpVUEw1TDgxZUJKQlZLSjVsaW9Lb0xJN21MUlk0MTlvRlZyVHVLSzZ5NFhFSUVrY0VZdmlqUXlyekdSYi96N2ZrdWFTVW5OY21SYzVSbElrRjVHSzIwS00wVnpMRkJ2K0NMS25ZTVltallhRmVueFl0ejNYU291ZzJiWkRDaVU2elBFN3l5Y1RuSlVqYlNuaEpScmRobkZtVXBmVWlQM3AyL0wvK1AvN3hPMC8zdnZtOWU5dWJHMnM5NytIdTZiLzQ0M2QzVDJEWU5jL1JzelIzemJ5R0NTU1AvUTM5OFA3UitIQVVqcU5rbXVhak9CdjVZY090TlZxMTA4SDBsU3ZyZzlFa3prekxNZmNIcytXNmEvSjNKSVdGN1hLU3J2WnFzUHJ2dlBQUkpFeURUejY1L2NVZjlScU4zc1pHYjMxNWFXUHp4dFdMbHk3ZDZEVlcwemh0UlVlN0o0UDk0OU5oSEwvN3djR05LOXV1a1I3dEhyLysrc3ZON1F0NU9OdDc4bmpTSDg5bVViTlZ0eHorVkFXU0VGRnpsT1ppRVRjQWVBd3ErODR6TXlSQ0hBVlJZbmlRaE1Md3JGSUVoVkZRTWxkeE9aNERvSjdEQ3IwQUMwbng1MjAya1M5aU1QVEVscldyZW9FRXFWcVhaTm9nb2RZa2FhdVFTRWNZTDQva29WUUZSNUF5bUgvbjEzOFZwTUFDaUQ1ckFMS2hHY1FySndvSEJ1YVhKUE1Fd3d0d3pzOWFvS3o0dkFobkpLcHhFaUdjVVpjRlMwUmN1Rk85N1JwbWxNUjFmak1WTzhaOEZ2THpkek0vY1N5akJ2OUJiaTlqcDJwWkZtLys2bnJraDEvNS9YOXRhZjNqZ1g4OG1iNzN5Wk1zU09XZE1mbkJaUFprLytUTzVlVmVvejZaaGxnTlhNZHN1YmF1NVMzSHFOZnNxREJjeDZwYlJuOGNySFpxNnowUE11dWZqRGZiRGl6L01EV21ZZXJWYWtrVXI3V2RLTlg5d0YrcGVjTlpGQ1RwdDc3NzN0ZSs5KzVXczdiVTdTeDEyeTdXSXFkcjF6dUJIMy9seTkvMmdtZFhiMS9WMTY0T1QwK1NJUC80Y1BydXZTY2ZQamg0V2RhY1M5ZXVyMXk1R0IwOUMrUG85T2d3bUFhZFhzL20yN294aGtvSk9BUVVDZzhVblJLOHhLcWdWQm4vQkNGV2xCSURLQldmYS9yOFdCVlZYS3JCVTluend1ZWhiRXdGODJRWlVXWFBRMFhENDBMcHM5ajVLc3M0UU1Vd2o2dElDZEJiRlpuWGJ2NmR2L21ycENxVGlNbjBxSW9vRzZ1eW41dnVjeUN2aGRaOUtxaHNOdTEvai9JSGdhcGxzUTJJNVdaelpuUXR3MGlLUFBUREtKeE5aajZmbjJrM1duVytqaDNxRGlVdThoU3VGbHlBTEU4d0RRK1BCci96ei8vWjcvM2gxMU5Ocjd2NjFaN1Rzdk0wakRMVHREMzdXcmQyY2hvNlJuYnZZTFRhcWhWSlZuUE1yZlYyMnpZM2xodDVFTUQrTjF5elY3TkdzN2pqMVZaYWptVVhlK01NQkRjdnI0UkJnTFpsV241N2UyVXdtYzFDM3J3ZFRaTk94K3RqSXRMTWY1QU1Eek5yK2RLMUMrSG9TTmZ0OFdnVXowNmI3YWJUWGovYVAvcnUyeCtHYVhKeHBiMjkxcnR6ZmVkLyszZGYrK1NqSjE3c1g5NjZGbXJheWNOSFdwSmkvY3J5dkxPMGJGSGp4VnpUa25FY0lGOFZaQmpGbXhDZzZPWXlCTElVNUZ5ZVJLdUlIRVFMK005SXlWbVlWdnptMVN6Q3A2Qm9tRmwyam1lRXFYT0VDc21PU0hUZUtsVXBBQmoyc2NKdzF3aFNhZWFjK0l5bXBHVExRVTI4YW9ENWQ2SHVxS0ZrU3BBRWNnbVZDQUFzQUZDSjUrSXFNZ2VXUHgvWXhoZkk1bkJXQ1lsWjZZdTBMeFlHSmpldFliYUVxR3RhY00raHNtTS9xemViVFE4N3l5TGg1YUFVcmc1L3VzRUw3V2FXcGpNLzdnOG1IM3ozTzNmdmZueDQzUC9DeTFldWJyV1NNQnhFbVYxejE5cTE5WmJoeDFtZUp2c0RQelBNdzBuY2JicWI2MHVSWnRYcjlWN0xhanJZdFd1cmJhL1Q4STc3cDlpUVh0OVpuUVRSazNHWUJNbVZibTFydGNNSEZvcGlhNm4rNUdScVp2a2tUcGJidFNnckN0UGU2TmJmL2VEUnZYdjNibDY0c1BQcVo0YmowZjdCczl5ZlRJWWozMCsrOTUzM0xDdjdzUi85b2ErKzlaNVhKSWsvV2x0YWZqUVk3KzRkR01ObmU0K2ZUc2FUOFhpYVowazBIaWRKdkxwOXVScndVa0l2RE1laWRBbWxEVndBcFJ3S3FxaFNPNEJpSjVxQW9KQ0tacUVlUk9jcEZSY0ZVY0NmUkpaWkFNa3RHWncxdFl3QUk0MlpFNWEwaXBMWXFvankzUkhCYWJIOUNoVGwzTHBYREtEdXYvR1hnWlFMTXRSb1praStwRWhVQmFMUG1pTDNxNVN2bzZqLy9lSEZJdUoxbGNPZzZzRlpqbjh5R0pwaG4yVGRnbDkvdDJ1MmxodEduQmFOT3BSZDl6eDdPZ3VTSktyVlhIandjUlRTQzllTUtFcVBUMDZIQnc5UGQzY3YzdGc2T0o0Y25ZN0hrVEVJODdwVC8rek5qV2JEMWFJa3lwS2lNSFlINHl4TGgxTytURy92ZVByb2NIeGh1WUhkc0dzNVdWNDR1bmJwMHJwYnN5ZmpxTm0wc2JwTXMveGdITTJtNGN2WEw1eE9aMjNQelF2OUpJeHR1L0FzSnplc3dTeGM5cXlqaWI5VU0zNy9ELzQ0ZS9hc3MzWHQ4a3V2aExQeEoyOTlPemphZS8zTlYxdGVQWXF5RlN0RWMzL3lDeThQeDVNM0xxOWR2TFpaWDFyVkxRUGJBejhDeE5nMll3bnFiZXpZWHBPRFQxZVV0b0poMFFRTHRreHcvMUpobEhScFQyVzY0RmhTS2VWaFdxRkFMUlJuYkZnS2NmR01jWjZqWHdUSmw0YVY4UjhFSlkyQ0Z5ay9CY05HbEUxbkNvdUl0SmpOcmFDS3NUOEFNREgvSHRTOXlsQlNxb2crcFhrS3BRNW5oQUlxL1dKWUJCUW52SWhIRHB1MG1IT09CUDJTY21Xa0hCRDQ3bnJ0Sk92RVVaem55WHF2R1NYRkxPSVBPT1FUWTl5bnBta0dEOTYyK0FJWjFCSkZTUmpEWWc2Uy9ic25lODgydHplaCtkQ2JhWWdOYURLYyt1a2tuUGpGOFNSY1dXcTBhM2JkNFJ1YmROT2FCUHhZMlVlN3crV2FZM25PYkphTmc1aVhoaUt0WmhsSlZ1eWVobjZVTFhVYVdsRmczM3h3UEx5MnZZcE44OGhQMnUzV3hJOXIyRlZveGhnK2Q2TXhpMEwwK05rNHZQdnM4ZS8rYjc5emMyMTErNlZicmJyV2JobkRVMzgwQ2liRDRZTm5KMHN0NzlHemtlT1pnL0hVS056WFhyM2hybTE5K01tem5TdFhXdDJHNDVvckd5dHVzNmViTGxwbzhYZFkxRS9UTk5XVHRDTHJTbFpLbk9XNGwwQ2M0RlVtVG9xNHBKc1RJNEx5TWtLTEFPWmxyQUtrR1JSSVhMQlZ2S0tYM0RQOXhwbGhubDNCUEYrZFhnQVdralpWZE9pOTBxTUtGa295aWx6ejcvM204K3BlYlRFRjlRSndoMXhHejRDMXFNc0JDMEZWWERJVEVFUUp6ekdSM09jRnVnZ2dVSU14NXdPUnBZVTlOWmVoaUhtYU54dGVHcWRaQW51YWQ1dlFMc09yT2RpYThqZkQ4aXRpZURSaitOMXhjbnF3YitUK1crL2VXMTV0emVnU0pJMmFGWVp4ejlPN2JoR244U1JLazl6Y1dHbDdPbitYYmZNaFlWNHZPSjBHOTA0bWI5N2VydGR0ZnhZYzltZGplT05wWnRuV3MrT1JuNEYzN3RsR3c5SXZyamVmSFEzRERHYVh6NTZuaHRieWJQanhydXRNWno1bTQyQVVtbzY5MUt0aEJ1NSsvUGJhMm8ybHJYVnZaZjNCdlU4ZUhoNjEydld0N2VVN1gzcno5T0NnYmVWaG9xMXRyNXllK0sxYXcxcnFQSHp3OU9tei9uZ0NqOGs5T0R6c3RSdXBVemUxekxUNE1oeElodVpkblJFNE5HTDZLVEpaazhzc0pVWjVLWlZrbDlLWEVpV1UybC9SQWtGdS9Lc1E1MERsS2tZbFA2VXVETXhnS2Y2WHMwOWxjVUFsTWc5eWxhT01nOHM4dm5qNVExV0RyaUJHRmxDUHN5cUJacFJaTUZiTVFnRWU0THYvSlp3VUd4em4vRWo5YVNBY1N5aFJVamNiSXhXb09zb000VE9INTdQS2MwbFRKdWJKaFNDOFM0SXlRanpmOU5CUG1uQlIwQ25iNUNYMU9JTngxWmQ0dFlaZkNlWVBVUjByejdKNnJaWnJXaEtuWVJ3T2o0L2UrdDc3ai9iMjlwN3ROMTNUS0ZJSGJrR1VmTzRLYnlabHVUNEswMGtDVnZuRjFiYW01dzNQaHZlUFNYUEVhelhhWkJaZjNWanBOSjF3Rm1McHFOZGR4OVNQaHVPTzU4N0NjTDFiU3pOek1nNXVYVnExSEpzMy9IUnRzOWVxUWRwRlBnbVNLTTAzZWt1SC9lSG1jdTlLci9IdTQ1TkptUDd1SC95UmY3RHY1T1pmL08zZi9NSVhQMy83OHZyVmkrdnI2OXRPdzN2eko3N1EyMTd4TlR2SmsvN2pqMnVCZi9uNjlzaWZEWGd6SUhyNDVObmxuYlVnMVQ1NDU3Mmw1U1g1c3BxU0ZxWEVrd0lxSXNmN0hKSlFqcWVZRXBHdFNndThTSS9FUXZwY0ZrRGxuaStrWXB4T0Vpc3oxQW5IUmVRY09KNXNGL0huNmk4YnV3ak1sMG1tRWtxclVSbFBaRFBYTWhCaDZmczdmK3N2Z3hhandza2hnY1drcEFMaFV3SkZzZ0FLS2RGenBoMmdzZ0NTWXBMSEt2NGNDSHF4U0hrZkdmOHFLQ2l6RmFqWmJPcDdFeHNiU3BiZ1hPVVQ5bW1jNkhwbTJuQkZiTXgxMkR4NDc5Z2w1aEw4SVBKbnc5T2p3K09qbzRkUGRnK1BCMW1xTFRlZE94ZDdWcUdOcDJHVTZxSGxESDM1SlZTVWRib05jQmxObzNISSsxV09aUitNWjRPeHY3WFNXVjl0c0FwTmEvWTZ2WnFqSmVsU3h6czhubDNkN3VSNSt2aHd2TkdBUDJWajQveGt2Ly9halkybXFXUHBRQ09Qc2FIT2k5dVgxcHdpbmlaWnErV2VCb21yWi8vMDMzenRMLzNTWDREejQ5U2N6dWFGOXNyR0Z2eXRuVXUzWDNuakMyOSs4ZFhQLzNDVUoybi9vRmZYNi9WMnU5Y3hISHQ5Yy8yclgvbE9PQnJ0N2U1TnArSHk2bkt0N3BVaVVqSS9COURxVW1VcXIzZnV3RUJEK0RTUjRCV29IUHlUU1dYWG53Y3FUSVdYVVpJRUQyZHg1aWhLMnVNcVhvVXpzdWVDQUhQUFFIaStBQ1JIVzFXV1ZFTWpRNFZmS0M0MjN2eTd2L21YUzNRRnlGRTJ2aUpqVkpHZ3dOejh6MEdSTFVLWnNRQnN3RUlQbmc4bCtneUV2S0t2b013aklJVnU0YStZUk1Zb3NmZ042eUozNUJYNDhHS0RJS3U3VnJQdVlPVk9zc3dFSGcySHV1ZTVvWm5SZURROE9UNDhPcHlPUmllRC9zSHA0UEYrLzhIdUlDN3M0VFR1eDRWbFlUdVl3QzN5NHhTYWVSUmxoNVA4MUU4dTlGd3NCbkNTUjlQd3ZYc0hseTlCNTJ1RjR5YTVzYjNXbmsybUc1c3JKOFBoZEpac3J5OXRYZHcrUGp6WVhPMTA2QXNaL2NHMDNmQ2FUWGU1NFU3Q3VON3k4aWcrR3N3UzE5dloyTnhjVy9aTTdhT25KejFidjNuek12WUhuYzByblViWGFYVnMwL0lhYmEvdTFwdnRuUnN2VHd2dEQzLzM2OS8vK0JCN2hmNGdMSFR6OHBWTkk1LzZzMW4vNUhqcUo4dXJLdzM1NElMU1d5V3NDa3JaTFFDR3RJeXBYRkhFRW9VelVRSlEvamxoaVJKWXBDcHpKU2hRY1lZNVpabFRJam1JUHdCVVJzbTJtcExxOUR3d2x5MHZhNUVpY3FMU1N5bFZqNmc3QzFSYXpHczNZbHFaeVF3RnFvQmM2MXhBbDJWZWdESjdBWUJEb1BQQktpU3BpZ3M3S2JRSVpha1hNd0NDNXlBeGhrbHRlLzNJQzZMRUxBcmJOcUR4OGtxdG91WmE3Ym9GOXliTHNLVmt1L01jazRMUHVoWFIrUFR3RUFvL0dmYTFrQmNkWFlkZmROb2RUZmVHd2VGb0d2aDhMOGZMVzUwaUNzTW96RFF2Z1cra0ZaZlhPdlRtTGQyek5GanBSM3VuVHc2bWJyUGU2TlREcUZqdHVyWmhOZ3h0TklzK2ZueTAxcXoveUEvZmVmZmU3aXpSNEs4Y1RjS2Q5YmJHRzYvR1dxZnUyYzdKMk4vdGp4dU5acWJaVzJ0THg2ZjlxUi9CTGYvV0gzMzFELzcxbDlmYTdTczNOaDFMNSt0WG5hYnR0VTNiTVUwN0x0ei82di83WDkyODBQNzQ0ZjcrZEpENDQ0OCtlcnhXYS9ZODdjcVZIZXc4cGxIYTduYnE5Wm9JaU9PbGhDYW5YRm1KRWl2RGlTZ1NDSlgxQm02ZUw5SVdLSk1ZUVZLZkFkTmw5RHpJV011LzBpalN6U25MQ0RGbDFnOE01MEMxalVFeEs3MFN6c1hTalJkUWtXcnFxbGJJeWZ6N3YvR1g1Q0U2QlNDVVBJbWVZVmxLK1F0elVJbVMxZjh1S0VWWDlLWGZ3OVNubGtXN1M0cm5GaFBwUTFsU3BYR0d0VDFKbXZ4STNuVGtlUjY2bm9TUmJsazF6KzQyUGRNMC9UakdQaFVHRzlNZ0NLSzh5Q04vV3NTallIQzAzYk9OUEltUzdPSmFyOTd3QW1oK29VVUY3OHZDQUYvbzFacU9YYk4wRGJPQmQyeXhTSmpicTAySHJ4Y1RTZXM2L09kUmtsM2IyV3AwMjgyYUEyN2RiaU9ZaG5CUkN0djh6bmZ2OWxiWEh1NGY4WTAzcGpFWUo2KzhkUEh4ZzZPVmJoMEx6U1JLK2xHaFpia2ZCdGN1WHh3ZG5mQmhuVHhIRS9lUGo4UGgrSE0vOUlYMitocTBrR3NUcEdid2c0bEJGT1lIOXc2bStmTEcycTBMRjU3MmczNlMzejA4L1hoLy9NbjkzWEE0ZWVuMmJjeWZUcmZyMkdxRkw0ZFBoRWV0Z0xJQUZxVUprQ2dPWWtjWW15UFBRVW0xQUdYR2k0Q3Nrb1FSeHNGWnBTc1FxaEpLbWdVZ0JrVTRDeGQwc1FKRlRvVW1HWUJxSTNGa0tCV1NuaEFrTHJwdi9yM2Y0RllWeVRNdHE0QnhrWTFLcXZ0WWl4U1Z0UzZUQUZKWFVLSUVWSnRMVVBJV1VJZ3lJWUFCUWNQUUdPQ2YwL1V5Um1DYzFQeVZwZUdicS8zeFpESVpBbUViZkE0Vnl1MGFlcWRkdHkyRDd4TGpvejltbG1WdzNHRnBvbHcvUFRoT1o2ZHdGTHAxcTJsckw5KzRlSEZqZVJRbUVjdy90b1RRenJ3NG1ZV2Z2YnlHNVFCTU1yZUdZNXhsYTUxYXc0R0YxakV6NGx6SCtqRkowdjM5WVp6cXMxbWk1NGxkNUo1bloybmU3WFdlSHB3ODNqdTVzdG5NYzMyNTE4YWttYzNTd3N5d0RYQU5yZFd1SFoxTyt0UFpjcXVlV1o2cng1M2xGVDhJclVMSER2Zlozdjc3YjMyM2E3ZnF2WlhXVWlPYURISTJMTy92UDM3cCttcDdkZnRrLytEQnMyZmhMTCsyM0w2eDF2M01uU3ZqTU96N2syZFBueHc4TzN4NDc5SGF5bEtuMXhZZkJHc1RwUVY1bGJvdUVwVG9HVkFqcXNHUnpOTGFDS0lFSklCUlVObnY1MkV4ZHpFUU9ZOUx1aXJ3QThOWmtVOEJJcFc2QzVSTXFXa3N5eVByS0swK256V0hXZWQxZDBVM3oxK0Vjd29uaVhNWU9TNnEreUtVelZCQTJqTEtueEJYb0RBcXJwNXFWZGZNZmhCUGdOQXpXeFZFYjRaYU53alNZT3BEWGV1MU9nQVpobDYwV282RjJaTm5NOTkzWEFzclFCVEh2R2FwYWNmSEo5SGdNQTNHY1JUWWhiYmNhZVZKc3JUY1M0c0NUamI4OXF6SXdqaS91dG1GY3dKSHg2cDc3V2FyVVc4ODJ6dStmcWxIN2pFVTEvQXNXN1BNSjBmOVozc0hYcXUyQjVkbFBMNStaZlBpaGVXcEgvUE5Oam1mWDMvNTJrYWRiK29yNGlURlZyTEl0U0RKbGowcnc4N1ZzcWN6dU9ENjFscmJyTFczVnJ2OTRhQmQ5L3hDZjNwMCt1MXZmdVAwMGVQUC82ay80OWJ0MGZHZVVlVFQvUWZmL2ZKMzN2M0tWK0h0di8zZWd6Z0x4MW4yOXNlUDh1bHdmYWx1bTI2VUZBOU8rM3ZIcCsrKy81RVo1NjFtcTkxcThMYW1LTEt5T3lLNVV1N0VMa2JQWVpRTmZCNFVzdVJWQXN1Vk1RRm0vZUNnQU1wS1hUZ3JlajVlc2ZwVVVKcTRRTXVtcXAyd0FCMWFXYXFBWVdDR1dQZS9nak5WYlZHUnBTYWVPQ2RLSDBpQmxDSURnT0trUUw2VGh0cFlLOS8yalVJc1dCSlVWQUxDVEF4TnVUNm9nRnJZZjRFNTIvT0FFbnpDWGlWSXcxYnFSMkU5MDYzWmNBU1hwYmU4ekJXOEtCekhvQy9EZCt1YjAxbWNaL0RtYSt4aWxvZGhFa1NSZjN5UUJKTTRtSElERzZkSm5ydWVYYSszUG5xMEgySldRQ0E2YU0xWGJtd1lPWGNGYmJnSGRmZlJYci9qR2h2TGJkbjE2bkJkbnA2TWo2WWhQSkJyVzJ2MVpxUGpGQThlbnl4M20yNjNqWDFrTk1OTVREdU9kZlBxNWtxdlpWdVdINGRMUzB2MWR1dmhrNzFiVzB2akNQTXZPK3dQTUhPd0VDMWhiK29ZdlpYVjRYZ1M1TnBvNm4veTRQSGdlSkNjSEc5ZnVSN00rby91dnYyOWQ5NjVkZWRhYUM5OWVQZkJXcWVWek1KT3R4VmkxZURQWFlwRUw0STR4WFRDUXZINDRQamh3OTM3ZHgrdEw2MHNMWGNvTEFRYzBEbWFjcEVmUlVuRktERnpaSWtpUW9MU0Q1VVBLTE00ZzFUSmlsS1c1azhKM0R2VCtJSUlBMFJTVllxZ2pnQ3h6Z3RweEVpcU5GQ3Btd3FpTFVyRmtTZGIwak90VVlxdVdveHNPVWlOOHN6TWM1cis3d0dxQU8xRlZiMXdSWVhnU21rQ21FY016YmJTWTZLVkRTK0I1QUJoVSthbytPSUtvR0JSMFJXd1JybmszZy90d3ZSbWZnRFB0OWx0OFRVclNlSTVWa04rMTJ6SkwxTk52Z3RTN3EzeStvdzJQRG9lRFE3aXlSQXVQK3BOWVlWWnUyRTc5b2YzZDJjUnRCY041eWRVYmMyOHVONm8yVWFtV2IxdTEvZkR0eC9zL3RETlRkZlNvemhiV201LzdkMG5VMTc2MUx2dCtvMnJGelpobm8rUG4reWRQajBKYnIxeTUzQnZ2MmtaNDNIUXFybFhiMXhlV1dwUHg3T1RZUUIzeTRMYll4dXpPT052cml5N2Z6SllYbDJiaFpNMFNCdnR6dUhoRVgrZHdvczY1cU9IRDc3eTVUOCt1UGZvem1mZldGbmQzdWcxOXg0K2lhZERaMjMxMllPbjdYck4wUEpyMkEra0VSZzJHN1dhN1Y1WTdtNnZ0R0xUNEFZNHpoODlPZkRIL3JYclZ3eFRicmppWHc0aTd4S3FlQ1hkY2lna1FhQmFTNFJaWlVZRkNxOEFDUVppeTFBcWFRa2NXWVVoVGgxTHduTkJRYW4rbFc0d2ZnWUxTbkptMStkUVZsdE5BeEFYNXQ4dGZmZC9YOGlsdE5vUkszYUtHVldQVVN6em9zTTRsTldwcjhxZmdjS3FVQUZub3pJeEtJU2dPcllJWitSVmJwWFN3c3lPelZhU3BFRWNPcVlOZlU3aUNGNUcwN01kMTBhN2ZOanpMTWRlRTE0MTJnS25wbit3ZTNSMDZDYlRKQXFLTkV1U0VGT2hrRHV2ai9aT0JqTWYvR0U2YXJieitHUzR0ZHkrdHIyVVJRRWM3eUFJMmczdkQ3LzJ3WTk5L25xZUpyMWU4MTk5KzI3S09XNkVzK2pOMTI0c3J5MVo0ZGcyemJjZTdLMnZyYzRtMHlzclRhMUk5bzZtUlpKNjJPUWF6dEhld1lnTERscklrY1FHTkUvVGVzMTl1SGRnR0U0ZUJZNVRYOXZlbW8xT3U2Mm1ibHB4bEF6OWFQOXdmL3prMFIvKzdwY3ZYVm82ZUhqL3BSLzc4ZjdSNkwyUEgrVFlaZ3huajhmK3pzV3QyeGZYdHRwMXJFMVkzUGIzKzJ2dDlzYWx6Y2NQbmtZK09wM2FUbnZuOGtYMWlqSUtVY2xVWkNrSlpSTWxoM1lUSTN3MmNrTCs3d2NvUkc3Q1ZJS295anhJM1RnSTcrZVpva2JhY21Hd0dBU0VkUm1YOFNGZ0NvSUNSWlNuWUlpYlFUSWVBTHdXQnlBVFd2ZFBVL2RGUS9zY3FHTG5RTWdxSk05U1dQNFlVZFBoVHdhVVdMVDZud0tjRGM4eEtwdFhSS2taMmwzYmNnYjlvVzd6cHJHOHhqS25UZGExTk0rUCt4TVllSG1XeGdyRGFEeWVqazZQRGc3MjYzb2Nqa2JSREFZZU5nOCtpekVML0dlSHcvNk1EL0ZDZ3E1clk5TjZiN2R2RmthejdyYnR3bks5cjcvOWNKeEdWemRXbSsxMmY1Sjg2K005U2xUWHd5aDU2ZkxtaFF1YmRUUFY4bXc4aWRaM0x1enVINzF5ZWNreDBBeGo3MlM4Mm0zRzBRU085TjdwY0RDYXdlZTV2TE0yREdKL0ZqWWJYc3R6UG5tNmIxbGV6VTRudzdGbE92VjJJODBLN0NWZy9tdWUvZDZEcDhlVHljV1Z6WjNiMTd0YnQvcTc5N0Q1SGtlSjRacTl0YlZpNHQ5OXZMZmZEMEovZG5BOER2SU1DMDVjNkFjSHA2ZXpDWmFMUi9jKzNscmUyTnp1eWUwNCtnSVVud2hSUU1sVGRWM0dUd3lXYU90em92OTA0S3lud2xJUno2M2k1NkRFMDZpcDJDSUlxcHdLWmY0aW54ZmlZaDRaeDJyTWhRQlJSU05JQWVEbUZmRjU5eitoTXlwSGNmaEJaSXFyTWdRaUtSWkFkOFduK1lHNnJsYUp4ZkFpS0J6cWxhclBVU2dVSTVvZXB0ckU2TUp4UVozWVkrcnkzdW9JRGtrYVlROHhuVWJUSUxGZ05tMkwxajB2UnFQeDhQaWdmM3d5SFE3MFpCcjVQcjh1WEJTd2YvdW40N3VIZ3lCSjVZNGlYOVFPeFVWUDdoMk52di9vNlA2ejRZY1BEbzZucyszbDFuS25NWXEwVE5QdjdaNUdLYitKZ0FsbWFkcHJyMXh0MXkwOVR6VERkZXBOK0NQOTQ5T1hiMjVDb1IydjF1cld1bzE2cDFQM2h4TS9pZ3JkUGhsRUwxL2JOUFhpOGJQVHJiV2xtcTBkOUVjZDI5WE5PSXhpcTlZWm54NkhhYkc1c2xJM3RKTkpnQTN2ZHo3NE9Cd0d0MjVjMnJoNk0waG0yMjN2QzIvY3ViQzVkWGphdjc5L0VpYzVuN3NFZVdFOTJ6MTJzcUpoWkZ1OVJyUFhuUVRKMDhjUDgxbDA2ZXBsS3JFb0M0WU1xcW4yV1NKWGNSckw0UlNEV1FwZjVvQmcxVW1CRktTcEZmejhxT1pTeVlkakpkckFlRFVORnBrQXFnSUt6ek5WaU5HU0hxQnl4YU5TeWZKY0loVUhnYkl2UXI5b3U4dG5abjRRa0pwa3o0TXFyQUN4QlJKR3BjYXpWaXA0YnJvL24zMGVsSUdwMk1xNUtqQ3ZXaUxneXR1bys3TWFGTlN5TGRoeXFBbDB0ZUc1Y1JUcHBwbm1PbndaS0RxdlMvSXpxL3pLMlA3VHA0RS8vdURldzY1VDVQRTB4RlkxU1daQjlOR3owNFBoakEvZlFINmNJUTVYUmtiNUZjNm8wSUtJNzhoKzVmcUZUc1BoODJOYTd1ZjZZWDhFWHgvOUcwOW1uNzExeVhPdGhwTVBSNkhaYU5icnp1SEpxV3VpZHJ2WDhCelBmZStEM1ZkZXZlaTVwaitlWkpaNzkyajgzaWU3Mit2ck42NnVES1pobW1RN3ZmcWprMzYzVmd2U3pOU3plck05bTQ1eXcvWkRlT0VKZlA1bncwbC9OTzQvZm5qajZ2VzFsZmJsNjllV2Q2NTBscGNuNC9Gc0VyYU5lTG1KVmNsbzFhenQxVTY5WVQ4ZWprOG0wM1V0di9QNnJkTnBPTVZPTnNxdlhMK2thVWtwVzBxVDAxdEVXbUhLU0ptc3hLNElHSlNLcTN3T3QwVE9oclhDUEErQ1Z6a2dabVFCYzQ1QnhRRlZTOXNRWmE2aWxOY0pLbitHQklLWmw2MFlLMUlCUmZPRDFWM3FxblJkemV5enBxaml5a0tMNHlSNnQ4aWVCR2VsWktLZTQwQXZIeDFGbHlvb3IrSXJhOEVvODhtMnJMMkU4N1d3bVRBTWc3UVc1enAwUFV0eXczS2FuV2FXUk0xbWt5MDNyVFRGWnFOb05selh0ZndnVE9Ka09PZ1AraWY5dzhQM1BuNWs2WVZyR1hHU2Z2UnM4TkhlS1hhSDJBQkE0VjJUSnh0elNKZlhHMWo4ZUptV1paMTY3ZnJPQmphRmNDUjRnZDl5N3owN1lwc0t6VGExL3NsNFo2UFhiZHFuSjZOYXI5ZHVkOXUyL3Y0bkR4cW1kZm5LYWhSbC9kUHBkT2l2ckxXWGV0ajRaZ053aVZNb2NYODQzZTdXTWswYlQ5TXJTOTdqL3F6VHFpY3pIejVTdTkyYlRVWlpHdWRwWHF2eEkyYlliVS9DNEhkKy84dDNMcTZ2cjYzdHZQU1pyVXRYVnpkV3YvK2RiNStjaktJb09RaVM1YVh1czZPaHJ0dlJkTm94ellFZm5nNkdEY1BxOXBaYksydGJPenNPbkM0T2dHbzd4YXFzdmNpVktTTGtXQTVIRmM2UmxDQUpFakpDZFpNUmgwN2dlRVpWb3NwQlYzang3RXVRWFBXOFFvV1JtTExjbGY0Z0x0d1JQU3RhYldvSlBPTmZ1UEhsTGhVYk9ETy8vcXM4bDdDbzFpeEJreVV4K0hvb2dCUmNKQkVOeUdTMWtRNHBFSllxTE1JaVprNVFZcFEwd1VubFZaZ1NTdGFxcDB5ZVpRRlVrcTlYNWRYRi9EUnk2SkxvQm56MGRydWVwWG1uMVhDOVJxWVpqdU1FWVZDcndmMTE4aXliQmxHWTVZL3ZQNXdORGs4SHAvZmhyWTk1aGZ4N1QwL2lOS3Z6YS9HV1llcFFlbWh6dTluczFLeXRqWlZabE1FNGU1WjI0OExhK25JYm0vVXNTMnFlNTliZEp3ZW5zeWpoRjhBMDdlN3VrYWtaVFpjM3ZPTENYbGxmeFFhZ2E2ZHdwckg4dEdyZWFES053OENQaXZYVjFnVGI2eWlGaWpkY2E0cE5SWkMyb2MwMXB4K2tkcEhadFVZUUoxZVczUHY5c09Qa1ZzM3FqOE9kOVdWTTIybW11Nll4Q01Qanc1TnBmL3paejMrdTArNTIxemVQanc3ZWUvZURhWlIxYXU0a1RqRThqbXRBTFBWdUU3WUFjMzZ0NVFiKzVKVlhQM1B4MHJJdXJ3K0NBTlVveUJqUWNnbVVvcTVVNFJ4VWhvelI4MEdzbmtUNHo1TndKWTZXUytFQVphNkF4Q3NFemlvd2psSWxIaDBSQkVHZEZuTUJnaFVheVNoeGJMKzBwNlRrbXdoZzNaR1lCeHdZNGJSZ1l4bWtQRFNlY1NsR1FtYVZ3aWpKaEZJQksxQ1lYT3dIdHhJaU93UkZBMG1yMHZNekJBVktGVmNBYjFoT1JMS0hud29vVlJTZWxlK09yQno2bHVkSm5rTmZZWmhkdnVLOWlHSytiamROVWt3SzJFdkxzbUV2VDRhenB4KzhmVElhOVEvNFB0N3RyamVheFh4OHhqUWMzWFE5eDZWVnR6ekw2TFFibjd1NWVYRnp1WENibDdaV2Qxcm1Fbnh6d3pDMVBBeGlyKzV4OGJITWsvNFk5YUxCbUhFZlB6dmMzUis5ZVh2anVCOXNYOXd3YmNkSkFnUGJpVlRiM3V3a2Z0VHdyTjcyNm9kMzk1MTZJMGxpMHpEak9GdHZ3eW1haFhGeDNCKy9jZXZDM3VrNEs3TGRrMm0zWG5QYzlPZ2tlT1hDNnJOUnVMblMyK3A2SHovZTgvMW9iYW10WmVtVHc5TjBQUG5jajM3UmM3Mjc5eDkvNTV2ZlhsMWQwbTEzTkJ3YVdmSDBhRVN2VE9PUFBsNitzSnJXRzBWcWZPdXQ3OXk1ZUxHejF1UFFRTHpVZUFBdm9ha3dselVpUDBEdW53cmxVQkl3SlVRRG9RclZPTXE2TFFlbHZncFlJMGpFT0VzWlZhZXF0b3hMb296elVKN21BVXlnWUt4TmhSTEJrMXBoQUp6SjVtLzkrcStocWdYU01nNHU2aWh0UHB2TktxNW9wSGtxQ3l6TEl2T2c4RklLTUUvT2N4V1NqVUF6Uk5ac244cFF3cWg0RWtRb0N2TWNjT1hSZUJQVVBBNXlkQkllRGRKRm5zRjNoMUxHVVl4Q251ZGdKc0J3b2pmWWpRMkh3MGQzUHhwT3d0bmd1TzRheTh0TktCYnNzMlBiVVZiVWJhZFZ4MlpBWCsvVVhyMjYzV3M0U1pxTnd3SytkMFBuTjdJZFM0K1RMSTBTMDdYaktHdTNXOGZETWUvWXdzbWdRSXJUOGV4N2Q0L2lvdmpzcTdmc2VpdWFEV0N0UjFCc3kyMTV4ZXJXVXU0MGoyZlo2WERxR0pydHVxZWo2WGF2cVdlSmEycCtGTC85eWJNM1g3MksrUU9lazd4WTczUk9aek9vckc3cTQ3RmZjNHdnakE2SDArc2JLN2xlM0gxMkVveUg3L3pSVjkvNDdHZis1Ly9xLzduZHF5VlJNcDZNKzdQWVQ5TGxYbU56dVpOWlJaaG56V2JySk1EVzFkWGk3TUhqZzFmdTNMR3dkNmRpbEZKVm9nWlVVcWI4eStpL0Z5aDZodEtXcTZOQ3pvZGRLbUtDV3FNMHAwUWhTZlhBYkNCT1NwVUJVaTJEdW5FZzhUTUNZYzBnV1RURXlzN0tjTXpWMnpCLysyLytWYURBQWxqb1FhNmVMWVBISXFvc2szSE90NnhNUENMSkxmRi9RbEJ3RGtuNVNtK2xpZXlpQkFVVkRkdURUaU1YVURXQU1uZ3hnQVV2Sk1MMWVES0U3c05QeC9LZFdGQ3ZZWi82aDkxa2xLd3ROK3VPM1czWE1iVlNYbWhQQnlkSDQ2bi80UDRucm0zYzNsZ09zaXlIKzIrWWt5aGFhdGF2WDFqYTdMWnZYMXB0dVBac0ZoUnBQbzNSYWN1TUF0dWxQNWZuYVJoSEJYYTF0dE5yMVphN2pUVFBKclBJTkhUVE1yTzhtRWJSd2Vub1ozN2t0VTZuZTNyVWJ6cHBWRGlaM1JoR3hhT25RNmZXUks5T1I2TjJ5MnZVbmNJd3hzUEpxMWMzUk56R09JcnY3L1d2Yi9iQ09BL0MwTFdkeTcxNmtHZllQV1I1T2p3ZE51R3JSUGxLcXpZWStXR2UxMXo3NGY3K3g5Lzg2c3M3OVVhNzl1R0R3Mm1RTlZ4enRkVkk0THp4R245K3NkVXdpL3pHYW1OMWN6UEtyU0x5MXpZdnI2NzNzQ1JoSEpXa0lVMWx6aGFzTCtMeUc2Z3p6UE5BQjRialZjWlZwQVNGeDRGMXlPbGNrSUlTNUhsbDlSYklxb0FFTWFuQW9ucCtkb0lGWkMxUStzTlEwYXRjQmk3NEdqdzE1SktuYWhGdi8ram0zL3FiLzVFVUZqbExCR05lUU8vSkN4aXNnVVRPZ3lMandzVHlDM2g5a1pJMVNUQmtrcFdjMlJUcDNMd3owaEIxQkJERGhpSXFMQ29ta2lJVjRtdzg0aVZTQXJCUWFyQjlNb0tld1NacUtUOFdFL0c3cHpwL2xKUmx1bVByM1ZZZFhrMWVGRW1TK1dHWW1iVVFBem5jTTdYazBzWHRtNWRXdW5VblNMU2o0WFJucmJYWmFjSHpxY0dNVytaa09NVll6QktNTzJaU3lKVUlLc2tYeGlkOHRhcGpvMlB3VHk0c3Q3QU43aTYxYjEvZWVyeDNETmNHZmU5NjduTFhlL1RrYUsxbHdEVnZMaTNGU2I1L05ENGVUNVk3MkhGbTRMYTV1dEp3N0ZoUEJzZXp6N3g2N2NLbGRYODRqR0pzVGJOSmt0dWUrNzI3VDI5dExxOTBQTXQxb0oxaEdOYzk2MlFRV0NiZjhHSGJMc1F3Q2hQTTgvVkdzOXVzYlM2M2RpNHZqWWV6dzhGc3BXWVBvclNJMGdmSG83MHhOK3AxUFhVZFkyOHd4ZnAxNjdXWCtVRWM5UWN1MUZZUnRGSkVRcVg1SEFlUnRxUUF6MnYyZVRpZkt5TXJZUUdCTk9xQWJpQUdjVXB1YVY3UGd1d1Z6Mk5JeVRrZ0FSZ21oYlBrc2xvazBRQlJmU0xaRzFVSzZ2N1hrYTN1azNKK2lJMW5TYkh1ck93c1VBYWw0eUVZUmFQZStYSFdpYXBpNmNrY3I0NE1xbU5WWUdkVVVCT2pyRVZXRHhKUTZrcHcwdTVLOW1jQkJhVG55RGlaNWhNNEVOaWxaam5NdkFNSEJrbERjMnZOTE0wczZLYkpOd3FtZkRReW1BUmhwdGZyMDcwSGp4NHZMYTExWEhPOVY1OW83WVBqMC9ISTM4U0drQzlheWh6SENudzRCZGtzeWVKQ3MvbE1TbDZ6SGV4aTR5QXlIQXVldWVkQUFoay9PV2xZcjcvMm1wZk9IaDhNd3BRdjBMdjM1T0RseXh2ZisrRCsxYlhPNmNscGIzM2JxM0h6c0hzMGhOWjJtOTdoWUFJQkptbHNHOGJ2Zk9POW9aL2YyRjdGREhTTUF1NFhaa3l6VVlkajl2MEgrN2MyMTVvTlVKbHdmanl6T0puNjZDb2Z0SFJzejlENmZyemRiVHc2SEtCUXIxMjdmZlBWS3k5Znd5WmtlV00xVGJYQlpEcE5NYzlqaU15ZkJUY3ZyS3p0YlB6QkgzOW5vOVZaMzltbVRQa1pMZ2dYK1FRWkJKRnRoUkhkNEpBQUkrNit5cG9INHN1enlsb2s0T0NvUEF3VVJyYmNCNVp4S2hWL3QzN2VZcGI2UStOTHJhQStpQTR3cVk1VlVHcFRSbFNON0FpTFVETkx2YUxxNk9adi9zWnZLRnV1Nm51dXlpcUlJRlN1YnFtM1k3UHZLckRkaWpzQ082U0NWRDlYWE1wUEJkWG9pa2FKV0pxb0NwYWRrYklsWGxXa2lpOTBGU0lsbVpwK3pOTjBlMytTeWZlN2VDZlpkUnpUdG9jVDM2M1hNYkh6TkhOc0RSdlFMTXVDS0lUN081NEcyODNpMlZFL1RBczltZldXbHg1UE5HVHRIWitnK0VhdmpTMnZaZWlZUE5pQitrays5V09YMyt6SnNBbkduRW5qeERUdFRDdXN3Z2lDeUlXeDlScUZZVWVEWTc2RFlCYnlhNVZGOGNIZHZZZDd4OTFXUTAvQ2VxdlhXKzdCYWNJKzRmdnZmYkxpRnZ4aGhqekwxbktkNDlQQnZmM2pQLzcrL2ZjZTl3M05mT1BPenVicVVzM1FlOTJHcFdWUEJ0TzI2V0RsMFV3TDdsT1FacU5wbUVWNXIrbTA0STVyY0xleXNSOWYyRmc3T0J6LzN0ZStmM29TL3N3di9jcnJuM3NsVGZ6aGFOUzB0YldHQzA1ckswdVQwU3laanV4TzQ5SHVvWldrbXpzWElPbTVnYWRTaXJMeVFqTUhTRElFVkJ4NUFIVVpHZ1hLdUNwRjFCbW9naHc0anBRYU9CbFphb3lLSy9WQUtScGNOZnBRY2ViS3VDc015VGdsT0U5S3Q0STFsbXlWbTY0Q1c4RTlzU29sOFlvU0JjM2YvSnUvd1R5bHJJcGFGS3VNOHhFWWhMSnVDV2NZTmYrb3RXZUJlS21wb21kTnFrdFZVSGdobGxWRitra01LbFF6QjZGcWtuQlFyV2QxcWllS2h0eElDVlpzcUs1N1ZuN3F3NTh4b2lnRTc0YmpXcTZYOFlrV3pjVWVOSW5oakxpTytPN2MwT3FENGFTZjJPM2wxYlVMbDRvNGNMcWJSMlBmYzJ0SHgwZUhvK21GdGdjL0JkVTBQTS8zQXhnaEtBbGZiNUduZGM4Qm50TWcxN3hXMDdYNU1sUm9lNnJicGwxUGcxR24xem9lekpEbzlEcW5vekZtNE1QZDB5dnI3Y0owMWxaWDRIOTdOZmM3My8vNCt0WktrVVRoZVBybTYxZXphZjgweU5BUno3V094LzZUMC9GZ0hQL1lhNWR1MzdqdzRkT2psbU8zWGN1dVllOXRMYldzbW0zeGJmUmEvdEh1OFoyZEZkUEdZcENlakVLdlZuTU5iVzhjQnJxeGYzTHl3ZmZmK1d0LzlhOTJHdGIyK3NybWVyZGxhalhYN1orT2o2SW9tcVZiSzkzTEYxYyszanMxNG54ajV3SVZuZXJKWVVCc3JyZTB3WlEvb3pJVzVWZ2p4aElTTDB0SmZERlV2Z0RMQ3BNNUpjZE85QUhtRlVtUU1RbEZwOWtGdm5LVmxmM2xha0NNS0M0eGlnTVZIVm5RSXJvdWtxc21ReVlUUXpqUWpwT1BVSnEvOFJ0LzYweTMyQjZsYlZXbzJpZEJkWnR4aUVCV0lnYldYV2FWdVovR2dVcXBMSDFKSVBTVjZxdkFQaEI1UGxEUFZWMklseEZWZkQ2L1FZQmxCOFM2WTVyRG9wN0FkTWN3cnBwak81N25EY2Nqdm1ySk5PSW9ySGsyUkRMaHJVWCthbWswR3M2UzRuT3YzRGp1ajlzN04yZURrZTA1SjBlblFSd2VEV1k3blpwcVZEQ0wwT0dCbnhpbVhpU2hBNnR2NlVFVVF3ek5WZ2U0TEUwczI0THJYK3N1eFRFMm1QNTBQTDE5K3hyQ2s2ZUhtRnRCa3A5TW96VE43OXk2NnRWYjhJSGUrdDc3VGMvZVdzYUVURmVYTzdXNlBacmxtRlFPZG9aWkZpWnBmK1ovNjRObjQ0SGZhVnAvOE5iOVc1YzI3MXpkaXBMVXFXRzF5cHF0ZXNzMmxob1c5dEROdWpzYkJibGxPWTRiQk1IeDBDY215dUJpSFg1MC84Ly90ZjlvYWVkQzdQdDdUeDU1V3Y3VzAvN0VUNUk4WFd1WXE5M09mbjg4Q2VLMTNrcXowNExHRTBTemVWQWpSVjNFNkVEQ2pNd0hDQm1VdkNqMER3eWlBNVdieWdIS3hZb3JEZ2lnVVhoTmc5ZFFsaXFKVlNoclVmVENwOUpzaFFkL1lNcEpVcTRBaUFpQnFMaEUwQmZtbXIveG0zOWJkRWc2Sm1VV0EvMTRCdVJXTkl3Z0M4UlZPSWRoS1drWjJncE5RVTNpSFRHejVDbUVpdFZ6UWZIaFVWWVZNQkVPd28xc0piZENzaTZGQnp1SmNCS2FSajdPdkdtVXhmNDBDR1pPdlFGdlpEcWJZbFBhc05Ybkp2T2E1OEJ2SDAybUdYK1NDajNNNGNzK2U3YjMwcDFYanc0UFlQZGRwMzZ3L3l6SzhxUCtlTDNsd1duSnNnU3FjK0tuamxzcm9objJ2TmdHWkJGMmg2WlhiL0JKc2hSdXNUNmV4VzZqalprVURyRThSQy9kdk5ac2RyeUdPemp0dy91Zmh2SFJ5Zml6dDNicW50Y2ZEYjd4M1E4d0hwOTVhY3ZVek1sb2N1SHlKbmFXcnVmWk5wMTdTemRjMTJvMW5QM2gxQjhIVzB2TzkrN3VYZGxjdjN4cEdYTTRuTTBNR3h0clk4a3AvT21rMVdxZURrZHdrK0I0WVE3VFJ1cTZhK21udzJub0R3YTdSei96UzcrNmNYSEhOcEpuZTBmdzNUdXUrOUxsQzYrLzl0S2xheHRqZnhwWjdkV05qZDVTRnpvaWc4aVJFMjNqNk9keUZIVlgra2RSaS9DSlViWlQyVDRWUHd0Q2pLQkdWZ3k1R2kvaExFY0VUb0Rucm9pb2dwV0JmejZ3ZGVXZ1N5ajFvVm9vSUZUK0k0Nldsd1FWc2ZucmYrdTNTcFZDSGZ3ZXlMbUFJVlI5K3dGQlpRbU5kS2tNeE1HR0NwNVhzWkJRSFZiY0Zrb3hNbzlMVUtxdjhDVkR4Wng0TkJWNE9pL0l4WlFvNlprcldhalR5Sk5zbUJweEdJR0FvODRYeWFTd3E3WnR0dXI4b0VlUFprempJN0g4aTFBY2JuV3VhWGR1My96b3d3L3JyVTU3YWVuakR6NHdDbTVQRDBkK0RWVVpXdDNTVHNPTWhnclczUUV6ZnBzeVI5bzBIUXVWSnZDejRJUTBlc3ZOZG12di9nUFhjYnNySzI2anNkU3FYYW9aendiakpHVXRlWml1TkszSHUwZDNueDFHWVhybjRtb0g3WWxqcjlhY1JHbk5zVEZQYkU1Y3pUSHNDMnU5RHZhbmxuVjVyVjNIOXZUaytQaDQzSzE3TGV4UXNRcU4rR3FuaTF1OThjbm8xcFZseDNJT3hqTUxReTNQRGhseDBtNjZVS1pHM2VxYTJyTjN2L0Z2LzltL3lHYXpMNzV4YlJqNC9mMWpCNU5qR21tRnZiVzZzYmE5MDJ4MytEb0hhb3lva2RKSUF6b2d1elhsbGlnOVVaYWVBbGZDTHhVOUY5ZFhYZllva2FKRk12MUFVT3EwNENVdVI0d1oxVkhGZjBCUUJXbXpaVDg5VjE4SlZJa0tXZUpacXRTMzhzaTFDclAyMTMvejd4QWw3YXQwVHRYQk9HZENGYWhlcFZaUmU1WCtWZG9tYzNGT0tVYWk5UHVsRVNCaUtWV0xvaGNYaGNKaEtBVTBENlJuNVBsYUdNb3NJdGtUVlpiMUVRT09sbG5NSXMyUFU4Z3ZqRk1Rb1gvWU5ZWkozS3piclhvTmVnbk44L2xMN0F5WlVScjNIejllMzFpRkEvRDQ4WlBsaTFmcTlmcko0ZEZvY0hScHZhZGpZMnZvL1dta205WnUzemRzMTlVek9QWDh3VWRXUkdGVWF6YlJpanlqUGQ0N25kU2JyU1F0N0hTSXFXWTNQTTF3RzU2YlQ0ZlkyZTRQZlpjdks5YnZ2SFRwZERCNStPd0FlZ3lyZjNXelkxcW03MGVXVjhQZWVqb05tODBhM0tVMGl1dlkvYlphMkduRVlYTGowcnBaNU0yNkZ3YlJIMy80dEVEL3NraXp6THBscjY1M0hLZlJyT2tQOW9adzc1ZGJ0V21TajJmKzlsSnI5M1NjK3ZFbkg3My85TmxUckVZMTEzbnRsY3ZmLy9qSmFCYjl1NDhmZi8vREovRm91TkV3SGo5NnZMRjUyVzIxb0FuVmhzckUxbzVIS2lKc3ZDaUo2QWJpa0xsWTM3bkpsd25BWEZocktwdzYwa1doZG9sVFFWWkNUSHBrMFJoSnJzSndOREU1VVpDRHFYSXh5aEt2Y29GaEExaHFNUWgvcFpSY0tMakJBNzJpQklaSFZhbjVOLzcyM3lVTDFSTVYrWlNBNG1lMVVrZUZWOWtsbVhEaWx3TlB4V05FNmVJOFNOTVhnK0xBK2NwY0tic1l6aldHUXBjcElOV1Z1U1ZiQk5Va2dPb0lTRTBvYUdqQXY0YXpFaFc1ZzVoaDhxNlFybm11TzV4T295Z1oreUVmZXl5S01BcEhwNmRycTkyN0gzeW9tZGJHeFp1ZVZ6T2M1cnZmK2NaSzA4SEtzTnB4NjY0endmeUE2MjN3TVRFYnBwY2ZaODJETUxhOW1sVmVwU2hPaG1GbUdORjRzTmx4eDdQRWRMMW11d3ZQSnhrZGE3a0dsOWswekRkdTdXREt0UnZPKy9kM01VMGU3UFcvZUdlYlR4cHJTWlFhSmw4bFdYaVdEWlBINTVEVE9KcU5UazRHbit3T1ZwcU42MWZXd3lEZnZyQ0VtZnJKazZNM1g3c1JqNGVySyszTjFjNnp3MEd0M3Q1YWRwNGVEMWNhZFhoWnkyMHZEdURxSjlnWm4weWljRGJ0Tlp3TEY5YTlSbU55T2w3dnRiN3c4cVZuVS8vaC9tRFNIMnowNmlmOWc2WGxkYSs5SkZwSWl3N3JJVnBPTlZYaldBNmZpcXVrNklEQ0szMVE4WEpvU3RNSHZJeWFGSlJBSXdYaVNrZm5nU0E4aFlOUzhSSmYwbFRNVlNzUUJJbFkyUmpHV1M4VVlrNGtkU0VPZGYvN1NLZ2dkR1dReDlMb0FncDNtZVhzQ1pCa1ZOS1FIUy92Y09vUWd4bFA5VldMbDJnekltZjBLcUI2eFpaeHVvYXF6N0QzSWxhMGxCVXBBbFVqeUtRaTZSS2JLZ1FveGVzeFp4TUExVkcyVUNrZ0RnTjB3YTQzbW5tYUoya3M3NzZGZ21wdzE0OUhJM2d5ZVpieDhvTjhnbkxpaHhzdCszdmYvT2JtNVdzckd4ZE54d0cvaHg5OUVNeEc4UGNicG9YSzB5eTNkYU1mcFI0L3o4UnY5MkZQR2NTSjdWaWU1MkFOc0UwelRISS95UTEvMEsxNXg5Z0FabGxuYVJXNVFmODRTVElVMzF4dDNMNStOZGV3WUppRDhhdy9uR0ZMT3ZVVGJCNDA3SFlOS3dyalJndWJBZjY0Ynp6MVc0NngwWEw0NjlwQys5NzlvOVdHKytvclY2SWdURE80WCtuZHg4ZGZldVBxWURBeU5XTnphL25CczlNdXpMTnBZUVk3anRudWRIcHVBZSt0YVd1blUreDM2N01zT3pvZDFkMzYxSi9VODJSbnZmMXpQL2VqVHIxdE5yMlQ0Y0NPNHNuZ3BPVzBhbXNiRkRpZmVWWUdXelJHUWpscUdDT095Qm0rREM4Z1lmWEJBVHRBdVptemlKRkJKSjl6L0tVNnlSVmRBa2JLWW1UUDFMMEtwRlFSVmt3YWFRQnhhQ0x4b21aVUljd1pVc0lPL2tkLysrK0RyZ3BVVUJWQUtoTkxKVm1abWpHcXZMQ2oxckpaMURaeVIxQTBxSThWUzJCL3BBZ0MyWkNQeE9rVVVsUHA4eEFwZUdtVFVMS1VkS2Zrb3doa01paitpaTNMcXJpTUFhY2w2akJNTTRyeVNjNXJpR21hK1Vua0J3RzJnTTE2MDNacXJ1NGdDVytCS3lEa1pKcEJVbXg1OGIvNzhsY3YzWDdsNWRkZm5vMW5jR0w5cWYvbzdzY3Vud2FteXlqUEkraEJsT3FPNDZIVmNJOE1FODQzN0NoZmZTVGZaWWVIMFBlRGxwbkRnWmxNZzNFUVhieCtnMjlzSFoxaTl3bHJ2YlBTc2VIQldQeXlVcEhsRHc5UDRmNC9QQnp0ckxaZG5WK3NuNGFoNTlWaDdCM2JQQjVPMXJ2TjlZNGJCTkhxY21Odk1OMDduZ3dIL3ZwYWQzYzBMZUtjZHd0Uy9iVTdsNDVQK3JhV3IyMTBvaWh0ZFR1aktGeENXck83blVZVXA1TXdhYmt1L1BpZTUxMi90TEd4dWR4ZFdYdTJlN0EvOEU5T1poYzIxbDkvOWZiVnJiV05ubm5rVC83MUgvNjdubWF1WEwyaGhoNWRWcllKd3FYa1ZRQkdkUEhGSUtxaUpva0tMQ3RMaE9pU0dpa1p0WEtzU3dXYkI1VzFHSGtSU2NOM3JqM1NHQ0FseVhwcENxa3EwZ2FjOGM4U3V2blhmdXNmVU04d0E3QlBSUmxnWDlpd0tuVlhRWFVlWEtwdU1KZWRLWU1xSXBHeWNXVkEzM0xZYjZnSnkzTENjYm1VQm9sZFJ5QWZFZXc1Ym1XaldidGlMa2cxOTZSSmFtWUR5VWtzQlpFTmwrQmtuRUN2ZUgwOHk4SVlFR0o3VnhUWlVxOEYxUTNERURNaDVWMHBlTWJCc3BOKzdXdmZ1bnpqNXBVcjE5SWtETUt3ZjdCL2ZIUms1akhzYnRPMllZWnpWSmdYbWVrNld1WmlIdkFwUS9ESTRjcGpwY2pUbEZjYng0R2RKeFk2YWVtVEpOL1l1WmlHZ2VIRHkrR2pPekN4TkJVV0RocDJwZmYyanVNNFJRdmVmM2kwM25LNkRYZTU0MDREYm9VeEdZNEhzeUxMWHJtMTBUOFpiNngxc3lBcWltUWF4MWh6bmowN2JmRnVhNjZqZzNseDZjb0dSamVPazQ1anRUdlliSGNnaFhvTlRydCtZWFBKTkl5VElINy8wWkZqR0s5ZTI3UmI3WVBUMDlIeDRkcEs5OEpXOS9NL2RQdng3dUhSeWZpcjMvcm83UTkzKzVQcHMvdWZ2SHJsb3JPMkE1NjBhQ0prTlNKS3ZNb1VVbGtsU1l5b29Jd0NqNnFVd3FpeVpDTEZsZXFyVVpZQVI1QVRRQVpObExCaUs5YVFXUWprUUJLSksxYkN2S3hJaWloS3BLVnRaeW91YmVBK0VoanoxNmp1cW95MFQ4WFAxRnJGVlNNWXFQbUttSUZhZU5aVjhpMGpDS29VVUVES1BKYUk0aXdSRXBkOHBJamFvVmNiNG5OWmpEdy9xY0JBK0toV2dRelRCbWZtb2pyWTdNUGhOSXdUQStxQVVFQlBzeGorUXBIek5VbDVEck9YOERWS2FaekVzTjQ0RFU4UE5kZmRYTnRlMjFqNitKMFBJYlY2dS9QMC9nY3BuR25iU21SZlc3Tk5uOTVSd3Rjc21YcWFGMkdTdUs0TFhjZHlGYWVGQlRmbXBJOW1OZXMxeS9FYXJRNHYxYy82MFArVGlkL3liTGRPendlTmdZV1BrcncvOXRFTGFQeUR3OUhlOGV6R2haVm0weHNNSmg1L1YrNlpXcjY5MnAyT3ByMjFwU1FJUEU1Zi9aV3JXNXRyYlZ0TGpWcHRPSjRkSFI1dDlacGV1LzNCL1lQQ2RvTlp0TlN1UWE5V1d3M1lrQXNYTm0zUHZYVmw4K1dYTC8vZU45NDdPaDM3Zm5qMTByYmptalhYV3VwMm1yWjFlV3NaZnM3eDBmSEJPQmlPcDFjdlgzRWEzc1hicjJIMWdGUnBtSlNjcXlBWW1oaG81RHozTE1oa1dCZ3NFSWduTEVHTnU5SXVGUmFuRFZpZGhRV002RDNxT3RPMGVTN3laUFRQZ3FpNDBoQkpDb2I3Q2l6a3YvWmIvNmhzQ2pWU0dpVEtkQTZwN0s0cUtUVkpwUFRVeTFJU3lra2lqWk9XcUo2RFFGVXNrWktHeDdMYklnN2tsM2dTazdNU3BhSW5rN1BBdWNSMnlqVUU5SVJUU3d5RCtJaEV3dFdZK2NIcGVFWlhSTXRRZDI3b3NPYVlUZGk3d1JTRExraFQ3RVRoYkVSSkRQUGJyRHV6c2IreTJsM3A5UTZPVGdNL3ZIem50YnNmMzgwbWc2WnJZeVdLNEVIci9FckNhQmJYYkIwT05sb2MrcUZsOFZFVytCOGh6THRtSEF5RzNicmI5R3pOZEEzWHN3MVRtdzZLSEE1MFdQZXNScU1HNmZsKzFHelU0akJiWGE0UGhqUEhObVpwZGppYVlUOTZjYVh0V2tiS3ozMWowMUFzTmIwUUcrSWE3OTZHczJBVzU5TXBINDU4ODgyWGVwMnVQeHIwSjVGdGViUHh4TFR0bzlOcG1oU1lWSjZlclcwdW9WbFdyYjY1dldscHh1V3R6ZG00djlycDNicTB1Yk85M0trVlpyMFpCS21wWjYxMnM2R25OeSt2dDFhYXgzdW5jVkw4MlYvNUcxWm5TV210R3MxeUZOU0lTeHk5Z1A2cDNPZjBXdzM5UEhENTVVSHhVUU5IYmVGZ01WNGFSRkNDajZpV0JDa3I2b2NzMFEyRlg3eFpXYllFS2FFa01WdW9LQ3R1MURvcHJadC8rYmYvb1dnekF6RDRGMVdycmpVb0pBRjhCY1BGb2d5cXNoeFZvd2h6U3pWbGZUQU00dUR4VWo5dFBMdW5Ha1RWcEhJdnlrWHFGVXhaZkNGWFdYM0dGVjBWaEFsbGdTRGlGcDdzc0d4NWRhTldyei9lTzhoejdBc04rTnN3eVhDYjRRdGtlUUoyRWI5OFlFUnhrc0NoZ2VGUGtsQzNoNGRIRGMvZVdPMXFic2NQL2VYVjljbDRjdkwwSTVCWU1OTFM2NDduN1dGM1dQRGpsWHlZSnNreWFCLzk4UUw3NE1Fa21HVkZ6ekdhTmRkUE03dlJ0aHdyRzU2a2VuRXltalk5dSttNTJBMmdNYTFhRGV2UGhlWGF5dG9TZkhwNDJGRVFEZjN3aDI1dWtGTVUxeDB6bW95eGJzQ25lUGpKazl1djNPajNoM0N6TG13czNYdDJlRzE3dzNDOEs5Zld4eWY5L2NOaHUxbGJYK2wwMnZXbkJ5ZVFCaTlsdWk0bTJ2MEhCMTZ0WmJ2MmREeDI0dG5XYXRNelV5TUttcXNiUVJqWEd5N1hHZGQ3OVBTazBlMFlzN2psRmhHc1FscGN2dlZHeGpjbmw0K09sVUVKWE1ZUk1oUk1pY2Y0cWxCWmJsS3FjY2RZQUVtVllCRWhLTXVTdndyUUNobEUwVFFWSkZmcEFCVzN1a1VLZHVYb001QytMTWgvaElVMlNIRmU4Z1pHTk5QOHk3LzFud3FGc0ZCRUVzb05CMjhwbzVoUzNOSVBVUVRncEVvcHAwVUNrR1VqU0NOQ1VUU3NGYUYwVktSaGJFRnBMYWkxaWkzclVvRmx5Uk5sS05ocUhhZ3FRZ0RnQ0x4SVJGUmZXSkV0SytKclVHM1hlN3A3WU51TzdicVpQQUhOUFdqZ3gzQzVzelRYOGlpQkZ4TVZkTytKUzZJb0doMTkvdldYdnZ2V081ZHYzTUIrRDdxMjkrQ1RMQW9iTHBZZzFHbkF1R0JGR0laSng3TnN2dG9nbjRVSkZoTzBnRjZUWlhkNzNaT1QwM2JkZ1grZjhxT1Vlakk4UVMrbUFYL1czYWp4cFhuWXZycTJjendOYTViV2E5VVJvaVI3ZWpJYUJYSFRzWmJxVnBTbWpxbGhiVGc4R2ErdnRhWitzTHEySElmeHdXSC8rclVMOE1NT2p3ZEhCLzJWMWJXYWxadDUwZWwwTE5md2JIdWxXLzk0ZjdCM09uMjBPM0JOcDl0cm4vYjdrSVNlaExldWI2OXRiUjJQdzZkUDl3Wmp2akJ6TUV1LzgrNDl6TmpydDY2dGJtNSs4dkRaOXRyNks3ZXZEaWQ5YkxTWEx0MmdYU3RsTHVJdFZaYUJDZ1JFNmFpbzBXRVFCYWpHWFJFRGp6aVhYd3lRV0hRWkw2VytaVUcxd2t0UU5WWW1VbWlFVEFaYTZkdGNIeERBUjlwVzNoemdJR1ZTQk9Ra29PVXRPVURkL3hGblNEa3pwSDBxajdOQmVrYzR5NTBIa09FZ2luc0c3TCtxNHl5b3BPQ0ZKeE9jSk1TTHlNaW9aUGhwRVNtb21sUzFxb3lYVWdhTnNrQlE4MUprdWduM0JSTHBOQnQrVkl6R1UzZ0d0bTN4Vm1zQkoxc0xVN2ppMkhueTU1c3BJRXMwK3RPNTRkWDFLUHlSMTIvOHQvLzlQLzM4RjM4azk2RW9XcFRsaHcvdW9YZDFXR1dRcGFscjIzbWV4MW5lc09ISDhLUHZXWkxWUEJkbXdhblZ0OVpXSHV3ZWRUeCtnVFhVYkxZMUdLSjlVWnc3L0RpckF4ZkNsc2R1aHRPZ2hpYXo2WHJEdGU0L09VTDA2Zjd3cGUzdWRBYlBCdzYyb2R2ZW83M0IrdytQZ3lqcjFxMDRpalBkdW5KaEtRcjR0ZmpqZ3dQTHRDNWNYSzAzYXRQaDlPcTE3ZU9Ud1dhdmhiYVpmSURad1A5eXQ5SERmT28wVDA1NDRXaTVYZnZzSzVld2U2bDN1cTdEWnptMUtHdzEzT09oM3o4YWpETHRqNzd5dmMvY3VueXcrMlR0NG0yanhvK2psRDZNR3BSNVVDTllycjBMZXJrWWxBNXd1SEdzSnNaQ0xucXVWRnlOdUpBeGNsYVIxRElmNjRvaDdJb2lvQ0VXSUNYS1VUMm8zNGlmK1FYekJjcjgxZC8rVDg2NENDTVZ5RUFkVkp1cStVU1NzajNTRHRFMmhNVjRHVXJLTXc0cUtFb0dKSGdralNSWmlBMUZBeVFpUmdWcEtuRVZ5blpMS0p1cTVveFF5aXpDNWxSMG5aZUpXZllBQVAvMFNVUkJWT2FrS0x4Ni9hZy9UcE1ZR2cvT1VHM1laeGhlV09VMGpiRitXYlpqV0E0TU15MDNmd21WWGVucC84UC8rTTkvK2svL2JQL0ozYzk5N3VXVGsrRm9NazFuQTlPRVUyUkJkdGd5WWkwSTB0emk3MVNOTk0raDhhYXBlMGJSV3U1Z0tDWWozN1kwenpEOGdpL3gwSUt4NjFwQmxQRDZvanh6anpvOXh6a1poZzBuaHlrYWpXZU9vVStTekorRlFaWU9aK2xxWFUvaXpMR2c3WFczNXYzUFgzbi9rMGRIWDNwbDUrSlc4MlRnMzc1OTBjalMvaWk0Y1czejhjTzlQSWgyTGw5b3RsQi9XcTgzVmxhV1BKZVhSdUVTYmF5alBXblQ4NzcyblU5Tzl2WjNWcHRGRkM2dExDK3RyY2NGRnEzTWRxM04xWjZoSlpQK2NaUVZyOTY1ZnZIRzVYL3kzLy9PU3E5VGM3MzJ6azF1amRBRlVSMlJjVGw4Y0FVNUl1WFlNWWpaUmhMSDV3S0xsZllibWxmcEVzZGJTb0ZucnE0Y0FqaUNLcGY0RWlVMExFa2RnSlZVTTBSTkVqNFhDU0lPUGRXYTFaV1RZV0VOQVFHTzVxK0tkYWR1S2UwQlhnV0JDaWxOa1VCSzFGN2xFaGJveTdnRVlWblJDQ2lxUlF5QndsSklhYUlLSXFPUzZ3SlA5cGx6aEVmMm5ZRjlVWlRTTmhJSkIrSkE2Ym5PNFhFZkdMalpmQ2d5aVRCMk5KclFiRGp4dW9WdGJiZTk0bHBPWGlUaXUrbk85T0FyWC8vdTdaZGVicmRxYmJkSWRVOTNPdmZmKzM2dDdtSk40S3NiYlgzcUo5aGZUbWR4M2JVeGhqWWZyQThiOEZ6UWlJU1A2MWhaNXJyMktPYXp4MFV3aGRhalVsNkIxSTBHSENPc0RrVnhQSTA2TnEvQURzYkJiQlp0ckhUZ3o4REhPcGpNbmg1amo0RTlRTkhzZG9NNC9jYjdqeE5OM3ozeVAvUFNoZmVlOUM5dnJUZzErM2h2c0xtOWdoM2Y4V2hVcTJHcjBsaGFibi93MGVQdmZ1OEJIUDNOWlNjT29pQUlZbWlIb1QyKy96Z0kvQ1F0N3Q3Zk96d2FIWjVPUG5yL1FSeWxtMnVkNWRYbHlXaDJZVzFwZFh2dDdmY2ZiYSt1MUplWHZ2ZldlMXFXWG5uOUM3bnRRQ3BpZDJGWlNnZGFTZmo1SU9Nb3VTb2lnMUppVk9DUUlLTEdzbnhHQ3hFaTZUeXI2YUVlODFhV1c1azVNYzlscUhnaWNMVElUYW9tbmxxdWFLb3FwRkpGaGdEci9vK0lyNER1clpDWHhhaFB5bjRxTkNMVUtaU2srUlNlUUdCaVNmdUFMQ2VHVUoyWHhhZUZra1VaeWhxSWxqbXE4TW9TcU1EMnNOMFVoQUxGWVpGQVJVcThUSGhZMDhuRWg2S2JsdTU2RFQ4TWVQRmZOK0ROTjVvZGpsK2V3M0x6QWtLUmFIQk9UdmYzbnUxM3UrMm9mOVIyMHNSc1JIbng5anZ2TzBZR0Y0VFBoYVVGUEJ6c0RTNXZyOE54TDRxODFXNFZkaTFOUTB2TDY0WVIxN3YrWk56MnJHbFNlSzFHT2g1QjRXeGI1NWRFYkg3QXc3RGdicG1uUTc5Yk4wekxIUEFIVThYV2NyZlA5MWttb01MMll1QkhsNVlhN1Y3ejRmN3hSN3RqQ0JrYS8wT3Z2NHp0eE5lLzljbm5YcnMwbll3aDV2Wnl6OU9OS1BKSG80bHRha21jK0xQZzQ0L3Y3VDNyZHhyMXF4ZFhkeTV2MTF6NzJyV05MSmdjSFkxZmYrTzZaZVp2UDl5YnhGcXIxVnhkWDl2YlBRd3pJMHExUkRkLzU0Kys5Y2RmLy83aDd2NXl3K3AydTZQaGNPUG02eW1HV0ZTQkZsUXMwWE5CU2Z2Rk1OZXpqQ1F5cHFVdGwxS2lLK1g0aXY2VVFTdzlJMXdIcUYzeXh5RHpqVmtMek5rMktYNm1jcUFSeW5KeVVpc2tZdjdLYi8xREtBMjdJUTFVeCtlQnpKRWxPaVp4Vk0zb0lxbmdGK0Y4Nmd5RVM1a3JzMkllcEpNSWtzbldxL1lzVktNZXhxWVNzMWNrTHZuSVVjRzVla1cralZianFEK0F0eHJIaWVlNmpWcGpPaDFuZVlvTm5PMDFkT0NUVklZQVJTRW92Y0UzWlF6SHg2ZHhIR3owN003S1dxM1JubzRHNzMxOGI2WFRncStFaldtV1JyMTJEVHRnRVB0UkNwOTlZMjNESC9ZeGhieE9ENm8vR1EvcWVoNGFXaHdYYVRTeGVDa0R6ZWM2QVAwR1lOaG5jVzduaVdNNVFaaEdhYjZDcllabmJpNHR6VEwrb0JiemFoYWtPMHUxUUhNZkhRNnlvc0FlNGNmZXVON3JOci8rL29Oa0ZyOStaek8yblpOQnZyWFY0amZDVGQwZnpkYlhsOXM5ckI5V3Z6OTBQQzhKODR1WE5yQVhmM0IvZDl3ZjNicHpjZmZCazQyTDI3cm1UV1lCTCt3bjBXZ3dOUGpqZHF0SXMrMmR6US91UGo0ZFROSXcrS0dYcnlTbTFsM2UxbHRkVVNBSStrd3BsYURGb0RJdXc2Rm1BcGNDcGR4bmdSUlNWdUpsVUJPQWpJU2JNSlFqRXpMNkNndk5ZSHloSUovY1JDMmkwT1hvSzNvVkZqbFVHS29PZHNHaTY2Skc3SStvUG9QOGxMdU1LeHBPdFRranRFKzJBZ1Yyd1FYdktaYTVCRVdrbHFFWEF5cVZwVURGQ2FMaWdEbSs3TU9MZ1pWU1hzclJJejNNQmdLMjVBeHFRa3RyMlNvS2hSR2NiMXk3ekNLR0hVUVIvSmlsNVJYYmFiU1hONkY2Y0w0eEVIRktJODBYNzdsZVhGKzU4NFVmUzVxOVFEZFNxM2I4NEtONGVMaFYwOWZxVHFmVjNOamNxSG5lK3RKU0VCVkpsUHB4WEhlc3dyQXdZeExEbVBFRElHYWVKVjY5R1JkRmpSK1hoRE9pZ1Q5YXorMHdKSXpWQkR1SEhOWHBVWm9XY3JzWlRKSWtoYnNNbi9uMW0xY2FqVnE5NXVXMkZhU2FrV2E5WmgydEIvRnBmd29SZlBiVmEvL2lyUWNmNzRaeDZ2NnJyNzV0dS9YcGVIYnQra1UrbldEWm05c2IzWlhXblpzWFZwWWJ3OG5zOGNFbzBLMytGRjJCNitUOThJOTl3YXQxOWcrT0d0aW56RVlQN3oxb2V3NjgvS09qMDlPVGs5blRKNy93TTE4d1hYc1lGMC92UGJoMmNidi84QU9Pa0JvWEttaXB4L1RwcXhGVThWSlBTZzFSUXpZZmFKUWlHMFVqUnBjK04zOTJKRnFFZ0Foa3FERHEwZ3FEeWxvY1h5Z2JrTUlmS29mMkFFa2RnREtnb0FyQWtKS3RTaVVPemdqbWZ5alduWnBVdHUvNVFBTXBrMEdCZEJWNHRLR2MwNkxiQ0NSSCs1QXRkYzluL0xsQWNnSEtwVW9pL2lJb0F0S2NWWDRPeXVhOUFKUVBUb3FuYXFTOHl6ZE9zdW5VaitMSU1jMmFWNE5hZUY0OVNvSTRnZjl0VGFNQTdnME1QQ0RWc0t6WDdVYjMwZnZ2eEZyOXlmdmZQemcrZWYvN2IzZWJ6b1A5MDE2cnZieTZkSFI0R2tZeEgzYm53NXF3clpuak52SWtEWUpadTE2RHBjelRMSnhOa0R1TllTSnBVRHg0N2hnY0Y1dFlmcTRkTzFFL3lLdzhhVFhjSEk1RW1tS3hnVmpyelZxNzArbjBXbzVtWEx1NDdtUXBmSitEL216Q3h4anluWlh1U3EvZHFIdnZQVDY4dXJtOHZ0NzcvcjNkd2VId3hyWFZSL2YzWDNydDF0R3pnM3NmUHgxcHpzT25nNWV2YlVQdnZVYjl2L3RmdjN3d0NJd0V2bndJZ3c3OVdldGdYNXRzTEMxZnZiTDU4U2NQalNodTFxMW1wOXVxdTB1TzBkdGFmZlR3SUkyaUcxdkxacmZYdUhBTHVrS0JxMEdaNnlLQ3FQNDVqQVNJdm9xWEkxVU9xRXdiR2FaeWFPQ29sNXpMdWNPeGcwNnJVcVdHTUVBMkpBTW96dWlHeEZWVndxRUtCRFgzRUZkSmFZbjVGMFhkRlpSNUVoUU5NZVFuSUNpeXE0NThNSnBZUlNIRlZCRUJrbFdCYWljRTBrbitxNVZFdFZzaTdKNU0rcktmQkc3c3BDN2hxU0tNVnhIR0ZTeGdGTTk1RUdlUkxEdnQ3c0hoc2Z5aU9qSmgxRzBYNDI3by9CSVRDRHpiaW9DSC84NXZqdGtpN3R5b05mM2RoN3U3ajJkKzlQaG80SHFXMitvKzNqdmFYT3JadWo2ZStBTS9WazhDd3gzQzBsR3YxK0d5Tnp4K1dUNHRpakNPalR6MVhIT01mYTFSMk9Ld21yYWpXeVlhbm1iNU5Femh6M3UySFdzWnJCRFdGOGZGZXVOcWxyMjYxRmxxT08xV0kvWW4yR3VPL2Zoa3lsK1gxRnp6OG9WbHg3SWZINDk3ZFdkenRaY1pOcmF0SHo0NWVldWp2VWFudmIzaVprSGtPODcvL1B2ZlhlcjJYcnExNDNyMk1hOU5GVW1tK1VGaTFqclhyMTVBd3hKZCs3ZC8vTDNIdThkWW5Wc043OHJPMXROaGN1WFNoU1Nhdm5aMWM1d2xCd2VUY0RxK2ZldTJ1ZlVTdWdmaGNsend6OUZVTVFDdmZpaEpxMUFOeEprem94d2JNVDJnRUdPa1JuWmVCdVhWd0VQam9hYWtxUEJxbWtsTlFOQ3BrYVFpcVdZRnExOE1Rc2V5K0orekF2ZHlpVkZoRG5QTE9wOVNET0E3cDVHbUkxZnFrN0FBWmFVbHBjUVhTSEl0ejJoZ3dMa3FpeUJWc0oyTFlRSEt1cVFCZEhVcW1weXU5S2VzRHlxWEVZQXNhcnBWYk85c09WNDlTNHN4dnlXWmhsRUFvbDY3ZzQwci9PbHVvMU00TnQ5ZllQQVpZdHR4YW8ybGs5TjliQjQxUGNGdWRSVGw2K3VyZnBMZGUvek04WGpmYXVvSGZQd1NUR3BlR0lhbTdjSlppV0pzV0RXSEU2cUc3U0JNZnM4ejhxencrVXZVSWduaGttUzZ4WWVLTTNnNEJkOUs0R282YkQ2L0RtdGEweURJOGl3TllvMjNVN00wakxNNDZkVDVjQnVLdjNQdjJRemI3aUJ3SFJ1T0NtU1lodUh0YXhmZi9OekxzYTcvODkvN1pwUlpWNjV0OGhhdmxuLzMvdjVYdnIvMzd0MlRWVmUvdWVGZHY5QVpqc1pmK2VOdi9wUC81bDkrK1dzZnBIN3lDMy9tUjk1NDQ5ckRrOW5iOXc4d3h3NEh3NjkrN1oxTWQ4SnA4QmQrNm5ObTNleVBvb1A3OTZnSUZMNG9FZ0xpOUJYbDJZei9QVUJKNWU2V29JWlBRT0ZWd0FnaVpBV0RpbFBmRkkwYVI2aVI2RlE1N3FJUFRGZVlNa2lwTXc0U1lSQjY4NWYvemorU0tYZzJGeG5JUnpxbkxISEpTK1hLVEVYWEdaYzV3MytadUNSbVNWYkRaZ0FqZ21HMEloWjZjaEFVYzFsRzFVVVNFSk5FVVRPR09HdWNseWVsWWkrbmdtKzVVWFE0MGppd1R0V09DczJmdDdCNVdxdlZDTUk0OUVQMm5KZllzVVJEd2N4bTNTT0JZWHRPRGJ0RUNnZThUS3ZlNnRXYjllYks5djFQUG9ZYnROSnAxR3puL3Q1K0VHZTAxcVl4Z3dIUFVzZmdvekZ4a2ppTkppeTluc2F1NS9DdGxBWDJBcGJYWGk1U1RLK1lXMVFNZGxGWW5zT0h2ZlJpRnNUd0tQaGxlcDFOREF1OTFlNU0vYkRlYUtDalVSakJiZzZPVGtJc1AxcStQL0RSTEQ5T3VsNnRpUDM5d1N4Tjg4dGJTOCtPQjV1OW5ra20yc25wK0RzZlBzM0N5SFc5ZCs3dFcwWFJxanNYcjk5ODhORkhTKzMyVXN2c2RMdm9OMnpyZE9hZm5JN3U3bzN1NzQ0bXM5bkpaSFo2M0U4TTg5c2ZQakxqZUhCNmRIbHJTN08xVHg0ZXdqZmJmdW4xdE42QlNLbXBJbHM1Y3JWU0k2RkdrQ3FoSXZRMFpBaGtqRXBnN2h5cDZEazZhampWV0NtTVRLY3FXVVVFU1R6cEpSLy9pbjRSV0cybE9BcEloaExnZ0xIK1pYVlhWVUF5emtHRk9jK1Y3UzRKcWJnTG1lcG1nVW9oVWtvSG1PZjRDcDZnTGprcEdsVlh1WDhuZnM2NUpEN0R5Sm9uZ1lySkdQNHdMVlUxTWowNFMwbEtZc29XekpFc0d2WDY3dTRCSDc0eVlEMXpHRTdMaHQ3cWp1M3dpVWN0aDBiQ3VNTVdGSVlEYyt4MUw3VFdkcjcvNVgvZDlsekxNaDRkOUF2TnhPNW5PQXM2RFMrSzRsbkVuNFNhMkEveG9WOXNCeHJ4ZElSWkFWOEZUUUEzcTlWZXUzak5QenFFa3FFcEp1Y25saHArNkd3MERkQXUyOVJ0L3BZaWozT3IyYXJCWllHdkJXc2ZoVUdhWjdQaENNdENNS1B2RVlCcG5oLzBSNWMzdW52SGc2ZUhnOWR2WHRnOW5mWWFMcnlnMVpWT3UrRk40emdLNHd1cjdmY2VIdFliN3NzM2R6NzQ1R0hQZGU1Kzh2SEZuWXZyYTYzbFh2dmU4YmhicTEvWlhqSU1iUnhsUzcwdTloaFhWK0U2MWJhMlZyOS8vK2xrUEQwK09QN1puL25TdmFlN2t5Qy85Wm5QcDUxVjBUYUt0SlRyL0N3RHhNQ1lRc2lRQ1pJbFZGeGxDb0VpQmxvaDU0d2tzd1NGZ3k5QVpTdjFuOEJYNmF1Q1ZTbHBGemlTaGlxbkdDNkdDc3JkZ1NxdlFNWG5tTVZrR2FyNlZETlJnUVN1TzZvRmNyV0Uvb1B3WnloMzFoaFVCbGt1VUVUTkI1WmdvMlRyemZhQWlXekF1Y1htcmtwc0JvNE1vcmxxZVFMZ0tJcGR1bFdJMEJtbmsxa1JDQTJ0anF3azRPL1czSGEzalI1a0dSL0h3Ulp6R3ZoeERzWlkvM1gwd2EwMUxkY3pMWmhzdm5ZTVRZTnJ2TEs2enR0Q2FUcWUrV3U5VHQyMVAvL0dLL0JzTTZrbTVJT1ZhY095Z3Nta1ZXK0VTUjdGZktnWTh5TXJzc0h4Y2IzZGRUMFhPODBnNGFNNVNScnpFNm1ZVElZV1ljY1E4akUxTFBscEV0WGNHcTlTUW9CeGl1cEJpSjJ0eFo1bEY1ZnJOYm1HNlVmWlY5N2Z1NzgvM0Q4ZEhoK1BJTjVuaC8wa1Ntek52SEpoN2ZYYlY4WisycTQ3MkJDSDhuVGs5VXNieTB2Tm5aMlZmL3F2djNGMFBNWDJvZGxiK2FQM251NFB3aXViUzUrNXZyNjEzSHpsNVplc1RxZnJlWnN0KzVmZXZQMmpYM3dEVTZlL2YvQ25mL1J6V1JHUEI2Z0Zjb1p4RWloSGpZTURVYXRCVjZDU3hGUkV6MEZGejJ5NVN3TjJjc3VOMmlvQmhvWXFqU0ZaY0ZjRUZFYUtFNVJ4SXlOWk4vallpT0FCcFU2cVlteHZ5UUdtbEFVd2Frby9wRDRDRXhWZUJZV2Z1MWx6VE5rSVZURkE0b0FTc3hoVWgzQ29oTUtHTWpCTzFaOXpuZ2UyKzZ5ZlpVV0tYaDFWcmtwV05jd0R4a2d4d1JIV040V25xeFhYYjE5UCtNNE43QXkxWnJPTlhMamdZY0p2b0NLT2Y4dHlNcnJrT293c2JERTg1WjFYUDIrNkZsL2NvdVh3N3JHeDA1TGdjN2V2WkNZY0UrY1VXMUc0Mnpsc2J3enR0V3ExSUk0OWVTZ05yZzVjK2VsNDBscmR5RTNiNTRYTHlBK3A0VW1lMTEwcmhmZURDY3puMTlBUFRsM01BM2dYL0lGSkZNSGJzUTJ0N3Rsb3EydnFuN20yc2RUMGxocnVZRHJERGdENjkrRHh2ajhiZi9Ka2J6U1pvQzRVN3JZYkoxTS95Wk5helR3NkhXTC9jV0c5TTRtVFY2OWZ1THpaK1oydnZmcy8vY0YzSHo3Y0c0VFI3MzcvL2ovN28vZDFmZ1BjV092VzdyeDY1LzI5NDQ3WHdEUmVhVFp2djNSNVBKbHVicXpkdWI0OW1mbVU0VnllTDRBYUJjcDhEZ3ZKY293VWpZQW9TSmxRVVRteUN1RmZwbEJVMFVqdDg4SU1penhWVUdVQUpSa0tVejNPQmZQUDAzZEhURGpDR1pNNXd5cWxnblBBM1RRQ1luSlUwNk9hYW95d1ZKbWhpZ3VIaXFFRVprTEJWV0V4NGR3TVNPMDB2OFNwTEFMVFp5a0MzUUVTQ2krMTMwQUJtQWhXTWdlaEFXMVpIK01vVXRZS1g0VHZ3clA3eDZld2xVQTI2L1VnaEpieWc5ck1Ob3c0RGFIbnBPWkNsTWRwMWxqWjBNSnhmemp4ZzhDeXJDUU1XclorYWIxbkdjWCt5U2hNMG02cjV0QnBLcURUcnVjbHN5blUxNFloNWErM3pEalhsdGZXL2RQOVdjU1hUc1p4YnB0c0JqYnRVY1p4c2VVS0tQWUJ6Vll6U0FyVTZEbFdqdHcwTmRJSXd6WWFSNjVqWFZwcnJUUnIzYnA3T2dtd3dXVlArY0poNjk3am82dWJTNmdPTGNDUytOYjdEMzdrOXZidTBmQnhmN3JhYVc4dXQ1bzFyOWZrQzFRenpXNDJtNDFHRFpPcVhYUHY3Ui92N3gwOGZISllKT21OcTl1ZVoyUG4wTkRUQjA4UHNGZnZMblUrL09CdXAxbGIvZHlmMWxvOTFGZEt1WlRybVhRNXFPaUhpcDhMMVZBTG9DTXFlY1lLSk9wTTVTbXgwQWNWSVpDVUEvNGNnRGRLcWlQeWlWRjFLUzFTSU5VdGNqTi84YmYvNFVLK2dCRE5HNkdTa2xhNHM1YW96cFRZT1R5WFhxQXBHeTE2cU93NmNxV3RpaVhGbzlvN0R5UllTSW9JVlhFV1FGenhKMU1wWGhJSURRbkU2aE53SklyRXlHMjFXejdzWThLM3A5cTI3ZFpxTUtnNlZBZmVpNmJEcytEcUNqOGJTcS9wQ1Z4OFhlOXNYTmo5OEozWlpKd2tjYnRXNHhkTWJXUFFINlI1RGs1MWg5KzBxVG5tZUJZMnU3M1I2WWxqR1UzUG8rT3A2NEVmcmwrODFOOTlZcm0yM2VqV21wMXdNdkpNQXhzSW1oaTRSS1poNndaV0Q4dXJCekgyRkRSWUtKb251WmJFT3V4OWtIaTIyVzAzVzNXWHJ4eE9zNEVmdy8rZnh2bmU2Uml6OEVLdmlZNVpqbVU2enU5LzQvMHZYRjN4bzJqM3hOODlIR3l0THE5dnJYN25nMmRYdHJ0cHdJOVFicXl2d09XN3VMWnN1cmJtaHpjM21wUHhjSzFSeThQQXRyQ0xzVjYvc1RueTQxYWplVy8zMElvVG83bnE3bHlmYXhKRXFvUmFwa1c2cGRLZEJ4QnlsRldPU0o1UTBhSHZQSjdUMEJLUW9VeXdTaWlGcmFvVm1ITmJ3QkdRbkljS0VGV0RMMzd1cDgxS1VhUG5rS3hmeFdGWlVaWkorbGxWeGNJVWNZaER1REpJbXlFSkFna1V6VHhJS2JIWjZ1NkQxRElQY3NPc3JIMmhsQUlod0pHdFVNdVp5a1h0VkhIcEZGbFd4R3dWaGNnZFFxYnBOKy9ja1BkSDYxRmUyQlk4RkZmZU8xUFFwY0ZtZ0hmdTBDNkFhZENDR2xxdGZ2bWxPeHZyRzFxV2phRmdZL2o4c3lnSVBWTnYxZHorR09hV2o5Q25TUkpPUTlPcDVYQlRXRkllaUl5Q0pBaDBwK1laWmhqRzExLzlERFI3NmtmVE1NUUt3OStPOEFKY2hsbW1hOWhIc05QWTY4UitDRThwNXIxZWlnZXpJcFhmR1JaeHR0R3FiYmE5N1U2OWdXMEVuSHZiK3Y2RGc0UERFMHhnckRHR1plK2Z6dURyZDV2T3dKLzkvcGUvL1QvK3N6LzhIMzd2YTROaGZPdGFyOWR1UVJLM0xtK3RMTGMrZDIxcjRBZkRXZlNsTjI0VldiQ3p2YlpVTHg0ZG5ZYXg4YVV2M0hTYzNMRGNTYXcxa2lHYUFHRXEyVUxRZE1BNEtLVjhPYnFWWlNscHlqZzZnejA3aElrQm9rTlJEb1FFdVh3REJLRHlrR1VjY2FBSEpQUlY0R2lyT0FTaEFuZUwxZmdDRk04WGdWYWZqZ25qNWkvK0hUNGlwdXBjSkZic0dhbDBoa21Ka1MvUFRMRUNNY0NJQ2dFcDBHNVZCRkFTazB3aENNQ29BRkFTbTllaTBGRDBNdU1NemxoSVFSWlFIQlF3TGtYVXRGR0hFbFJjNkZWN1NHem9TOHRMeDRmSGNKTGhTME5yb0RaK0dzUDV5REsrTXhXZURvcWdiM0FxUUk1elkyMXJhWDNqK080SFdBb2FuZzJQRy9NMFM5Tk8zVHVaaFBXYWk2WEtjNjJqNFF3K1NSWkhmQllTMWhrYnNZdy9qWFViOVhRMkdrOW5XNWV1RC90SHZoOWdXUmo1RWE5cDhsV3JHbHdhMjNMSFFZVEpoMUpwbkRodUxZNERQbUxKeTM3YTBsSW5pVEt3MDdKa3JkWEk5R0p6YlgyTURVR1dEYWZZZnVRYlN3MDRTQjg4UEdpNzVrNjNOZ3JUazFsNmE2TnpNQmlCK2ZGZ3VySFVlbmcweXBKOGZXVkp6NU1sUjErdVdhZWpDZWJ2OVozMTRYaG1tY2JORzl2LzVwdnZmLzd6bi9kcTFzN0Z6WlBZWHVtMWpjdXY4bTZjRXQyWlpKRVVld2FwTGtxN0F1b3VFT2VHY3FHc0tpVU1oRzBKSENMOEM0NTVDanVQbzBnVnhCUldTUVZFS201QXpZc2lSVXJ6ei8vMmYwSVhrTVhPQmFFdUkvVEx5RTR1RWFvc01mdzR5UlFuamxmOUtzZERGV1F1TUJJUUI1S1RWTWdraTEwRmxrWEl2QlNOTXVjc0xWQ2VCSkN0a2xXUnhVekVtU1JiUmNrV0tDUUNmNGdrVkhKa2NVYm91dWdHN0s2ZlJMQVcwTlFNZXBrbmNESlNlQlR5T3lwWTNCVFNBM25PeDlScjdhVzczLzNHZERhQkMrNXFCUnlMV1JoMUc4NHd5TEJiaGI5UmR5em8zL3I2eGttL2oxeTJwOURTcklDVDAxdFpDNGFuY05nTnI0RU53R3cweEU0MFJtTnlEZHRRaklHRjl2QmlqaEVudk15UTg3Zm0zRnZIb1kvdTJLYlJxdGN3OXhKZ29zUjByQ2pKZXAxdVo3azNDOEk0VFk5SDR4YldqeVI1Y0RLR0hDOTJMTTJyRFlLNDQxb1hON3BZUG1xdTliOTg2OTc3RC9aZnY3UXlHRTVldWJKbWFYSERjOWM3OWIyVGNhOWQzOWxabVFUeDN2RjRQTXNjcjdlNnM3Vzh2dm05ZDk0ZEg1NnMzdnBzNXRZaE5DWEhhaXg0WmFhVXFRQlVyUlN5MGxiRW9RQ2lJaVZheUZXUlVxR3BGMElwY1JFWU04QzVZazVUVDlLU05hSFNuMUtSNXMxUVBIOFFRTjE1M1Iya0tLQ2FVZjBMaU82SnNndGFuVlh1YzlYSXNRTE9IL3dMVDRLaVBHdnQrVE5sOUR5SEJhaEtuZU1tOVBNZ1NNd3J4a3VlT0FrRzRoQVVPeUZCWnFEUUFOMXV0d2FEb1dmWmZzUjdtWTVsWTNlSVBrSFZZVEkxdU5lbUFTT09ncVpwY1NuVjlZMGJOMkhYajNaMytiQUJaZ0EyblJwZlR3Q1h3T096N3pDdi9GVlVNSnZWYmFQbWVieThvSm5ENmFUZWJJZmpvZXZBZmRKNnE2dmp3NzJzME9JRUM3T0dmVzZXWnJialFDbFRUYk9kT2xyZ21tYkN0ejlsYVRqRDBvTW04U2xLdUNyOEJyZjZZaktXZzlyNitzcjJjZ2NhUDVtaHpuQ2pXenNlK2FOcGRIVzl2dDViK3VSZzJCOEdQM0p6bzllMGQxWjdUOGZ4eVRpNHViVjBhYU01SE01V1Z4cm9SR0ZpSyt3Zm5JeWJ0YzdkdzJFeXhrS1JCa0h3K1ovOGViUFJ4R3o1eXRlL3Z0eHN1WmRmaHNnb1E2cXZrbUI1TGdlaEVpeWhGTHNDR1FDb3ZaeDRLQXNJU0NIcU9CUGxhUTdscUttNEhDdlZKNmk1VlNYQlNCQktFMFF6eTVtRFRDR2ljOHdBSXZhQmxhbzhWYUE2S1dJY0pTbVR0WXd6QXF1UFVlYVJFYjQ5aHI0STJDNzJHS0NLZ1pXMG1DaytUQ1pYMHhGQXl0VkFjVmIwMG5RcUdiT2tvS2l2YW93d253Y2lxMmFvT0wwOEdoKzFLT21MNy96bTdVQTBYampuMTIvZmlJcThVYXZQNGpqTUVnZE9QTHhDQTlZVlpjMmtNUGlBamNsM2svSFpTUzIzbDFhMlh2M005dVVyVTgxK05KaEJvdyttZ1dmcGxrR2o2MGVKNjVyRGZyL1dhZ1pCbE1RSkRMbnBHSFhQdVgvL1hnemZQTTJubzJHejAwTm4rUjRObzRpU1ZMTmMrUDZUSUJyN3ZtY1pKbi8walJVbUNVTS9pYU04elVDWVpGa3N2eUZIcytDNmptSnNGbEplMG9TbDE4M0xXNnN0MSt4UHc5TnhDSWFEaWY5a2YrclB4b09wLytoME5QU1RsWGE5N3VnWGw5dmcvOUdqZzI3TGk1UG8yMjgvbThYSjhUVGVHMFdOZWpQQjF0aXd2bjMzMlV2WHQ5ZTYzaWZmK01QZTB1cFh2L210TDc3NTJZTlAzb08vaGRFcng0SlNSeFNDTG9lZTl3Zmhxbk1JQkMyaEJBb2VpemRwMUFpcVVJNlVYTDB2aVhsbG5CeGtmS1FXUW5rQ25QR3NZSTVScXF1OGY3S2xkbUZ4THEvSHF4ck5YNlF6UTFJcEI1cUt0WXF3VitXcFhJMUtqSUEwYUo1U0lEcGFUU21tMFhxZ0ZIY1ZHQWZaM0RsVEhFcWpLL3lWRFFaTzZNdDhacW8ybEhBV0o1T3pMTlpZQmZ5RExmb0xxYW9Lem9BQ0JZRnBORnV0dzcwRGJDckRMTWUyRDhaZVJsS0hiMlB3Smc4Wm1SYUdXMC9sRVIxMHF0WHJIWHowa1dQd0RjYzFrNytrYmpmZHczR0lyYU5qR2ZDOExkdkowaGpiWDZnN0NzQ0JUOUowT1BVOTA0RHRiQzR0RjFnMUVwVEwrVzY5aG1zNERuKzZhanNSTnN0OGpOZkViTVhrUWJQallNWmJUdGl6b21GSmlwYjRjUnI2dkNTYUdvYmoxVERBVVJEMFhOMFBrLzBoRHJ3a1g3T01iczErKzlrd3hlWTMweS8zbkNMUC9VUjdjandLb3ZUbFMrc2J5ODFoR0QzZUhZOEN6SGE3M2FyM21yV0xtMnNmN2c5NzNEeGt5dzBybmt6c1p1MHJ2Ly9WamEyMTVjLytCTFJIaG8rQ3hRbERJeFpLaGttVVFSUlV4bFhrVDBPamFEZzZOREtMVUJhVXNpcW5VZ21Xa2h6SnhZbWxFYW5vNS9ocWRzMUJrRGlwc3h5eElGWWpYNnE3d2t1YlZNVnpMUmJWVWEwdDFZaWtuSnFJQWd0ZVVtNisreFcxSTNkT011WVNLUVZKekd3QlZWNEZkcVJzd3B4YVdBcTlLc0p1U2FPUkZsa2dnNkJLRlFicTRRVU14cEV0bVZCWlJTTm5vbFQ1T1lpVWlYTmNMT2ptNmNtcEt6OVdpdlhjZ0UySDkwSS9CRDQxVmdiWWUxUkJVNWJCN0R0d3RzMjl0NzlUcEFtNjM2emJjS01kWFV1eHNtRzNhbGl1WmVTR0hVY0Izd0NQT3JDY2NFM1JweEVmc09IVFlJVlZhN1dEWVIvOFVSWnRXVnZxWkNhZjJJYXl4Z2xOT05hWEpFMGF6ZFo0T0VERDROYVlsb04rd0xTRDYyZ3l3MWFZdno2MFBSRHo4cWlaZEdvT2RySzhXcTlyTGRmcHJhL2MzZU1yYnZxajJlM3RIamE0R0pKNzJLcG12SzExZGIyNTFtdDduZDV3TW12WHZZNnJZdzFETDNvcm5Yc1A5NkZiWFk5VGRYMTk5ZTdEK3kzVFhmNmhuMG9OM3VHdHRGTUdRaFFMeVhJOG1VQjJHWkNISU1PaDhwQmtnUkl2cFZRRzhMUkpvaGRrUlF6NUszcDErQlJRcEMrQTBrOEV5UzVwb0kzbW4xUHFYdFd0SXVoUXlVZHFZV3ZsTEVlaVNLUENQTVh1cVk0cFB2eUgwQldIRjZHYWI4OERpMVVBQ29RU3d3SU1LclVBbklSa0JzRkkxZEpKMVdTSlZvQ3RKNXNIV2lpZnlvTUFTRWkyN1U1blBKMUd2dS9ZZkFsdmxNWjhLbEpXUTNaSHArSmpTckFFUko5QU0rM3UybW84R3NTKzMydDVSUlpqV1loU2JUb042cTdUN1hqSHd4bVdpN2d3ZTdEY3JNZU0rTk1PUFlpQ1hxTVdwSGwzZVFYdXUyMWEwNGhmWkYxYjZwSkswMk8rK0lhL0JZRjFod3ZsT041c090YXpKTXhRUDUvRTRBT2JwbkU2bkJwOGx4U2Z1NFFYeHB1NndhVHRlZWh4bWlTMlphODBhMXZyeTN2SFF6NjVnQjVtV2RPaVlYclNuOFZwZHRJZjM3eXcxblEwdDk3d2srenUwNk9hcWZQYWtxYXRkVHB1by9uZXgvZXhhMm02K3NiR2xtTVdINzMvMGNzLytYTytYUzhsQ2puTG1jbEtRUlg4eVp2RjgzQ20raUxra3JlQ2MzektFVjRNeWtkbHdSZURBbW9MQzVLUmpKdHUvc0p2LzZlTWt3UE9sZjJtYzB0U0dEUU9nU2dFYzNpUWsyQjQ2YUlLNHMvakQ4NlpjRUNNYktsYlozeDRLSUVlRytrVk40Q3ErdmxBUmlwSU0yUUdWWmd5bEFDZXBCSG1SQ3Rob1NKSkFlWmlrbEtvWC9JUlkrdWc0Zm5hNnNwNE9wdE5wcTdqb0JodlFScDZGa2U4OWk2dXYyNDdZSTRVaWtEUjdQWnl2ZFdLRGgrUFJwT2R6ZVczN3grYXJodkdTYk5lcytGcTgvNjNybG1XVitTdTV5U1lJNFdHYlNjV0IxUFAwMXhyOTVabm83NkJLb284VExKT3ZXYUpDNUVrS1V3b1BCcDAxb0YxNVNQNThTeks0NXl2TnFoN0hsb0FxWEk2b2ZHR2tmRXJheW5JZExtS0NsWllBckJwdGt5dDRZR1RjVHoyMGM4K2R0TDFac3ZNVHYxc0VxZlkrdnF6N09wbVM5T3RhWko5K1BodzkyaTgzS3kxNnVac05PNzJ1bE4vdXQrZkxqYzhQVXNiUzB2UmROS3AxOU90V3pLK1ZEUnhVU2hEZ0JvbVNaZWpVQVhLWEZISmVKU3dxTW9xQmt3WkVSYU1DRE13UVpKV1JoTHpVRmFsaXB5aGtUcExLSmJDVUVaWjlKdUFBaXhUQWVpZ3Z3aENUSkRTRE5EUkV0Z1Q4S3NDOVAyTUJkaVdteEoyQTFDUlpYd0tpd0hOQjV4eHcxb0dDNG9LV09OQ3FEQlZXbTVZU0pBS0VUbGJ1VXBLQlppeHRPS01LcHB6VUNXNWdFb2RBSWowenN0M0xNZkU3cyt3dU9zeVRhZlphcWY4S2JhQjNTcWZaWUxFTE12QWJsUmUxZFM5L3RMMUgvc1B0aTVzM044YlF1MEc0NmxUcTgyQ3hJLzVDajd1QkN4bjdBZnNPSCtVUkhHZ21BODduNlpSRkp1Tk5qTGdNbURDemNJSVFzR0s0b2pYN3BsNkVrVmhHS1ZKck50dWJ0Y21tWUVKTThQV2xmdlZGRnVJREh4VFRFTk9SY3R4MEJIc0VMQVZjUnhldzRISVFqL3MxcHdhdGhPWUZacngxb1BEUVZqVStPbDhMYzYwUi8zeDNqQUpaK09FZDVpMWZoQjkrY09ua3htWVplRjR3SWNrZFQwM2E0ZUhCOWc0WTIwcFR1L1dxUlBjMTFDZVZBQ0tqZUU1OFo0QmMwWENRclpBVnczb09WQVlwU0Zxd2hBamhkUVFuNFdTbUp6UkhhNjlDMEZ0V0ZFYktCV2cwZENadVRPejJCVHdLWTlpb3lWVkFjcVRsTm9xelpGQVFqSHlKVzExUXNXU1FGQTh6NERObE02d3FLSVJuaGh5RlppV0dhbUFCSnlkZ3BjQUdncWZ0U0tMbEN3dXBWUkJoakl1MVFoTjFRN21LcUJZeUVIUjYyc3J5Mi8vOFZlYXZaV1lzd2xPc28zZGFnUWFlT3ZRZU43KzVGeVN1NWZJTDZ5MWk2UDlvLzdla3dRS3JmTlZZV0VjMVd3WVZ5Tkw4OTdLMHVDazMyazErUG41R0Z2R0FudlFXUkJiZW1FN1RiZlpDTVpEOEpRWDcyVzlkZ3RqeFhVZzFWeGFjSDBhUnA1dCtrR28yUzQ4bm9ZT002NjVscDNrL0V3eVJoRDZiZFdhRmpwcFdra1V1dHgxR0huS042VEJ6ZkVzM2c2MkxGN25nU2VWRlBuQk9KaEdmQlFPVGJWTnU4dVBtcVdISS8vaDBRVHJTVnJvKzhlanJhVUdhb1RqOVBCd012T2plcXM1T3UwUEU5MkNHM2I3QzVIVHBFWkJaQ0lmQUE1S0syQUxaT0FVbGtmNkNTSmRrVEJCdHJZcW9TSzh2Z05TWVFBcVVhSktBWUNSZWNXVlJBb3hBMWtxQXBTc3pCS1JRTHdjRmJFd3hwbXRraXEwTTk5OUFZU29CTnBJMENsUU5wSnM1aWloWGl6QXVTOHc3NkVBU2NvNkJYQXV1U2trd2tLdXFvRW1IQkhGWFdVcFN0VXA2aSt2YnhGZGRWdjZlWjRUUVJYN0ZDRGxRanZSSkdqSjlwVXJIMzduMiszZUdqU0F1enFOVDhhakJvd3Zkb2Vra3pyUk1zalJzQjArVEx4N0Y0dCt1K0ZPL0JDRzB6YTBHcCtvMUdNMEVpUjY0Ym51TkF4aGVtTStDNUR5MjVUdzF6ZTJScWZIc0xaeGtnVkoyb0lMd3M4cUdkaWhXcnpTajYxRHhnY2pvNFN2QUxSTUo0L0J6WUNlYWdhYUZDU0pZNW1wem10SDBISTl6OHdzUmtmbDBvd1dCREU4bG9abjE3RmNHSGtRWlpidHhBbVFKdjBrWFc5NHptcXZQZkdqWjRQWjZTUUVCM2hhdG1IT1pzRWdTR3FXZWY5d2dPbFRyelUvZW5xSUZzS0VwcnJyWFh1cDdMNGFwT3FJQXlQSzlNcElVTElxS2JxdnBGd1N5MUhJY0pSUlUwRW1DV0lrazdpUUNqWGo1Wmx3SG8wcVZFVGgrVmZtcUFnQk1WbytwWFlDTlBrY1dFcURBVm13WmZNODJSMHdqb05xaTJxckFrUVVhWlc3Q09SSi8waHFCS2hhUkJEcXJ4UkVCVEtocGJuS0xWR1pKQlB1T0tBeS9NbjZ6eDhKSVloa0dVcktLaXhDeVhRQjVuaFNTbWViN2M1blB2K0Z2WGUvQTI4YU9wdW1tUTMzUXRoRFYwMitjTkdRdXo2VzZkYWdmcTJ0bmNodWJPNXM4OHNaZkg3WW1JVHhsRjlhMVlMeHRObnVUcVl6T0VoUVgvZ3RhWnFhamdVRG02V3hId1J1bzBPVlJiVjVNUnhQMFJCNStodWF4NDBwc21pb2RTMEsrYm0vV0xmOEtCYlhJNi9WNEtGZ2tPUkY5Vm5PVCtMbmVaQ21FQ3V3bUR4UitRdGF2cW00YmhoWDEzc3ZYMXdEdmFYcER0ck96OUNpYzF4RXRuck5ac050MU90d0NjYVlFRm5SbnlYZnVuK1NwSEFXaytuZ3lLM1Z2LzdlZzVOcFloNSs0SWFSa3BXSW54cUJJd0tXRXlvcFE1a3NBKzl2TUlMaGxpTmxUWE9MTVZYSFNxa0FhcXpCZzFWSVJFWUd1bUpJWUZycFVzV1R1V0w3cTdnY2xjNVNxSEtjeDFrOWxVN2FDUlVVTFNSUWZWU3M4cVdVbVJVeWhXWjNuNE15WXdHQUlsWk5ocXJnR1FpKzdNVVBBTVdaN1JFeHplbFZTMVF1WnBHRVB3bFVTOHFnQ2kxQWxXQW40YjF1M3JoeDRmcTF2USsrQi9zT2Q4QzEzYWJscEhMOURvVWovR3VtYlRvbS9YdWp0cmJldkhwcmF0WW5RUUpkaDBwRmZFdU1Cc1Z4VFZoL2N6empwWkk4VG1kOEVRQ2NJaXRLc3lqeVE3ajFkbTNreDY1dHdvZnB6d0tZL0FKRzNkQkR1RGNhWDA5ZzJWUnE0cUFBelY1dWUyRWM4MWQvV3JIVWFxSWhhWm9tMFBXRUYzTmkzcXRLTUZXZysxaVFaaUV5VTdRRm50VlN1ODVYUHRXOEp0K0l3SjYyWERzSlF6N1FrNldPbHQrNmVxSGVxT3VPRnlUWlJzdlR1RzVnRzUwRmNkU3g1WGRxOEk0YVZ2VDJIL0NqdlNJc0VTSzFGV2tHWUQ1dEtGVW1OMlp6dmE2R2dDRFppM0NHVVdPdHluUFRRQldYUmJYa0kwZ0I2a1VKb2lUVlFGZEJRZW5NQ00rcURvbkl0SlZxUUtTcWZVRmZ3UnJIaXBja0tzQ2tVZFdVTFJEZEFvSFFWR2VlR0ZjcnlSa25nWktpeWdZd0tuaFpJbFNVL1phc00xQVpDbDZNS0JCK0pZNmRrblpVd0F3WTJNMnJON3JMU3c4LytWQTNITk9yZTdhTmhUN2phMHkwbXUwa1VENTZ4alJCY2FFMW1xMDhTV1pIQjlCaVhwSVJmbGJCM3lKTnA0SFRxT2RKQkYydmVaNDRHdERMekFLRllUUTZuZUV4NzNEQjJZQ0dkK28xZEJkbUZ6WmVubDZRNXZIK01CY1QxN0d6d3VCV05ReGR5M0E4ZStiRHRJT04xZkQ0Z0ZvUlIxaHRNQ2t4bmRBTlRNV1c1NkZ6WEIyaEpJYlY5NE9WdXQyMGJZOTN3OEE3eDVUTk1nMDYzYW8zTysxbXpiSHNJa1hWOEw1MGJNZXpHSXREZ1dXclhwdU9neTk4N3BYMDVQSDZqWmRuWmsxdWhET0l3QWlja2lVT1FjbUEySE1paHUySFBrQkpPZVFLajdNTXFDSTdIeFN2S2k0SFVTVVdJS0ljU0tVNmlrN3kxWVRndkJaRFFUYjBMcFNwUnBKMUxZRENzQ0VsTjg1RFFKa3Q4Rnh5RG1XVkFvdWx5T1hUQXZVRGNMNE53Qk9BcEdtWDVZVWtGWDRCbUxFSUN6UnpKdVZoZ2YrZkFNS0JDcmQ4NGVLZi91VmZ1WG43SnN5d0Q1dXBHVFZ1UVRWc1JtMk1Oc3dpR01LWDFndDM4K0tGUC9YemIveVYzNnkxNnRqYndkR0dXa2U1bm1RNTFBbVRZamoyTGNkSmlnd3V1QXdSTDUrUEIwTnNoWFd6aGtiTHFxNzFoMk5UNHlTQkR4REZLWWhoZkVHYUcxb1VSNGc0amxXWURyYXV4NVB3dUQrTjRFNFUvQnhEd0l2M2FCR3ZkVUptMk9CeWpnam9jTGxCSkYvTHdYanlKeUU2TDRhT1o3ekd5aW1FUFdxV0haNE9zY05lYnJlOGxud0pPUWhmdVh4eGFiWG5XZnJVbjY3VnZLZjcrMEdRSGc1SHQrcEd6Nk1OVkVOR2NhbUl4TThCNUNQcVNGQVVhQXFvUk5PNVlnTmRqaHB0UHhsVWxsc21EQTA1YmJtS2wzaFNzQ0FEL2poM0ZDaUc1NEhFNEt1V2Zrd1NjUW1rOEtKRG9Lb0FMeDFpVTdrUVZaVjdIc0FFNFN4UDBaK25WVFNjWUNvdFE4NDVCNmpFeE9XYU5GVkFMb09BT3BXU2tYN0pveFp6eCtvY3FQM3JHVkFxWmVUOFdiVUtQQkJVWEFVQ2FCQjRQWDU3NDg2ZFczQkYrRjBrdVlOald4WTNibG5PWDBQeDZ5QWF0cCthN1hSdXZiNzYwbWRialJiNFJYQkUwRlJzSHcwOWlVSS9UcUdKY0kwUVVFREhmS0RIa3d5SGZidFdnd3ZEN3hJWCtlbGtoaFVEL09IQllDVUJIOGZoVjhVd0Z0aXhzaXdmZXVBbnJ1QVJRVGdXbkFTK1d5K1lRdCtUaEwvZDVsVTU3R0tMSkMzOE9CdjRVUWpmSnNzbVlZako2ZFhjSUl5VzRhdG92SkNmWUpWSk13K3p5RFFHL0VZOVg0K002ZVhaT3F6KzhjbFJzODVYeTNjYmRoNU8wWkorNUVhMWxidVBkaHY4TWlaSHNaQjdYZUp4VjNLVDN5S2ZrK1I4WW9nNlU5cUk0U2lqVDAwakZaR2lkUE5aSkRsbFFvSUF6N0Rhd3BQcVFSYWlteExtOVFLckJwQjdCKzVJR2FvZjJ5bzQ0MW55Ujd2bms0SHpDUEVGS0VuUHc2ZGpYNENLQlEvbzFod1dpMU5MTVhxQ1ZQankrQ0tjTlp5NWtJRzY4cW9BWjBaNUtrSEZ5MXhLZTE2NkJKVWhFa2NUaWs2djg4Wm5YMTliV1FtakdPcUN2WkZwTzRadHA5eEhtbzV0dytnYU9SOFZmdldYZncyMjMzRWNyOTZZaHRFTWlwYWtOWXR2SG9qRDJJU3hoMGo1R25ndnBYM1hEcDQ5VFRVOWhDSG5oODA0T01NcEZwSVVlZ20xU3hOeHJkVWJXelhlTG9YempmMHIzYXBjdC9sTmNNd01jNmxabThLdGlWUHNNdEUxK0RhdzlWUjhlUDk1RWNWZ2tLTjh6WExhamVZNDRnYWhXYlBST1V4Q1AwcHA0MDE5UEJ1RlByL3NnTG95M1dxNDVtUXlUb05rR0Jid3UyRE5WM3JOM2QwRGJlWHFnMGYzZHlleGtodnJvd2lwZGxTVlNwQ0xtb1AxQmZGem9NeTJBRkw4L3dGQWxhdkNJcWlVNk03YzdKOEQwaThxbGtBNS96aERPTTFZTWMyNXNHRmNEYmlpVWROdGdWSmFpN095dGR6bXltYjVVOE1DbkUxQjRsVTNjQ0RES2k1bnBDc3kyZXlmV1gwSnRDaE1FaUJzUkJZS0tqU3BBRGlUdWNKVXdHRlNjbFFnYXdVV1Jsa2JoWlpZZGt3Q3I3dGZ1WHpod29XTFFaRE1ZT1NwVGR4RDhpbXZBdGFXajB2Q0lMZTZLKzd5NnUwLy9ZdGYrTlcvbG1xRm42VmpiQzNocVR2V09LSUJSdTloWmpCRUtjdWpYL25SeVRFZjZFVWZOQ0R6aVIvTWdxam1PcGJqWXNOS2U4NnZTdVcyYWZwVFg5d1BLTGs5aFJKRDhpWXZ3bVJKMW12WFI5TVpOcDVRZXY3WTBBUXJiTG5SZmw3VVovZnpvbGFyZGRvdFAwRXlyOWxZSlBKcHhLZG8wQU5NSXZnLzQ2bWZ4VEZ5UXN3bG1IZXRnT3VDUGJsdUdYWFAydW8xUG56M3JkN2FCWDh5UkZPVkRFVzZqTXhsVHZWUk1lQmxyTlVTb0FaWG1hRnpZeVZuS2xXbDB4eXo4NkJHWE5sdnhiemtMTk5NS0pDbVhpb21LcGZhVWtiS3VtZ3pBQnh1amk0QkV4SDVLczZPTUJENE9DVVlDYUJVeVFCQU9qSERDQ3IrZzBES1VKdktOZ2tTSUJFMW5SYjRubzh2d0x4WmM3bEtvMFJWRlVyVW45d29lMEZSbWFyV2Yyb2JpUVJXd2xsdUdjTUpaaHpNdHJjM3RuZTJ3akR3Z3lBS3d5TG5yaTZKRXArL1djTG1WSjlrNlUvOG8vLzg5cy8reFJ0ZityTzE5aExjQ1Q5TnAxSEVFVEVNdXRWZ2wvSytLSHlpa0RPRmx5UW5zTWJ5b2c2MGNjaW56YUhLaGUxeVkwcWZuZzhhd01vWGZKOHIzQnZYcXRYZHVOQ0RHSU9sWXhxTXB0TzFUbU8xMThJa2hJdUMwckxZNUk2aHoyYmN5OExKQ1VUTElSUkVvQVV3M2pYTG5JUncvbzFabkdEeGFGaEdmelRHRElTYkZHcWFIOFNlWjRNQVZtenN4OUFsZml3aENUVGJUUm9kTFF5NGVJcEFsWHg0RXNDZ3pjZE55VnFjR2Vvc2Jid29xTWlhYWxTcWdZeE1XZVk4TE5Dd29MQ2hCcGZaQW92Y0ZrSElXUmxMQ2dZemo0MFQvUzhuenJ3SUl0SU5yRkswYi9CNzVxNVBTVkdCTUpIbFM2WW9NS3J1ZVZDd1dJeEZHTmdhdHJkRWwvRXl1UkFIRHdscWhSU2V2TVphQmxXUEVBb3NSRXVnUENvc3kvSi9rUXB4bFVUR3A1UUdsZ3hnRTdMTE85RDVEWGdlZkNvcjRST1JkbEhBZTRqNFcrOFVJc0p1RkRya3RsdmRibys3VEJZMVlML2hic09meWJIbExYaHRGenRXZUJ5b0RFTUhTY1NKS0lPbXhmQko0Z1FvR056Q3RIUHhQTWxXcHU1a1BIVXNGKzdLVXJzUjBWUlNzMDNMbUV5bW5hYTkwV3VHU1FZRnh4eUFKY00yQU0za2JRbitvaXBMb3dqK2p4OG5JVy92WW5hQlJCLzRQcCtTU05OMnpabnhZejZvS1RVc08wbnp1bXRUUlExenlOZXhwbWFSNzZ5dlF0NjlsOTVNa2dqVGwwNHptMHlKUVVTTUxZQVNPUCtsWTlXeXpBUjJQTnowOER0TkpwMStUT2dTaUtFZ0NLUVhEYUc2eWdCVEFvaUlxakVBUkdxbFBxTThVUldVNHlnbW5TMmNLekRscG1MbkFVajFFT3c4UUg1ejI2OUE4VlJRWWhBd1EwU2hHVmZZaXBLZXdWbGxaL2s4VlMzOFFVQVNvVkdUUkdFcXBPQWhsRGxINGo4ZGhLUWFLQUhWMnBMTGl5QVpRZ0kvTkw5MS9lckx0MitoSDY3cllkUG1XcDVsd1gxM2FTL1N6TUZFeUxKWkdIYTJMdDc4ek9kMHc0S3pEUHZzUUllNC9kUnMyMGIxL0x5ZFlTWDBnSFFQMndDS1dVMSt1dTk4TVZPV1k5UEt6eVdnVXQ3Mmh5TmpUUDJaWlZ1MUduWUhMbCtWblJldWJiVThkekx6WGMxcU4ycFEvamd6b05adzZvVWpsaDlxQ2tRK0NRT01NNHc4OXRYVVp2Q3hMSDhXZ3c3N1d2Z3dBYmJpbklFNU5Cc2JXK3lEdTNVWDIzQ29QTFFBS3RtczErckxxL2JTUnViVTJOTHpFbFB4Ull5Qzg0TUJBWWp1empXVFBtbUpZZGtLWHhZU2RpcitIRnNBZFAxUDBFWVo0SE9BQ1VSMkltV1NvckJjRktVOXh4RzlaSndPQ0J4RmJqazRNZEFrVlVSQXBzUzhHdW1NME0rclY1UmxOODRJQ1lJc0c0V2NPVTl5S2FObGZNNk5SLzdlRFQ2dDBJdHRFRUlDTXVjRkFmTlM1MEQ2aUNCNWFHd1ZaMHFPVWljWGZsb3Z0cHc4MFUwNmZCQXhzb3B1cDMxaGN6UGdMNUVNNkRwZk9TYkdLazdTTUlpMUpNcmo4TlZmK1J2WGZ1WVhZZWFOVmdzQ3dXWVUzalQ4ZCt4RWVmVmU3c3NpQVVzTXgwUFVIZFd5RG13N2t6aUY2K0xZTG5hcElKWEhkV2pJWmo3MkRmQ0pETTh4M1hyTkQ3SDM1UnVGTVNxeklFUkQrYnNRNkkzaHJLMXY4akVlQSthRkJjRVcyNHdjbm94cHduZkNBbUxxZWQzUk1UWEJueDRQMzl4a25tS3FZVlpvQmg4VEt2S1dhOWw2anEwNHBoc2NMbHZMMmpVYjJxL1pmSEpCZ1JwWkRvVWtGVEF1UXp5SDUzTG5TY3Fid3dEVmc3UTVGa0NpeGFYQ2lPVm0zbUw1QldEZlhnQkZpeW81bkFBSUZYeGdMUmhIR1ZGaW9XRTFDQ0NkTjVDTmtUSm9pTFR0SEwwQzRhb3lTenhqYXI0aW9TUWkrc1FZazRyK0hEQmRFYWs4RWdsSTZqa2dYaTFyUWxMU3pNdk9ZVEZYOFMvakNxU1Jxb1VLbnVjZ0NSeEtpZlBJcndjWHNLSjhoWFFZUVgzWkVqbzNIdlF5VGFHc1NSREFrL0cyTG0zZWV2bUgvOUt2cDI0RDl0eDFIVXdRN0VKNU5aNGVCWjBLVTk1VzZZY1JONitRYlY1RVNUYWF6VEJBOHZKdEJ3b3A2czZYZ3FCWUVBU0M5bHpid2ZxUzhZdG9kQWFPaGlQYk1KZGFEWnZQVjRaTG5lV1Y5UzNOeE5xaUpYeWN1SWlUZUJiNGNITkdma3dIQmh0ZFUwZTlWQU9kSHhoMDRNM0RaNCt4OENUd0t6Q3ZZTnB0VTNjOFBwa01nMWNreWVid0VTc1FRNkRnbkNLakdnR2N5bGdGWmZZTFFDVTVFejdJeXJKcXRwU0ppbWF1M0NWVEFZV2hIZ2daS1lVTVdjcFNxVGdBamNZeHE1U2JWcm1LRXhSM1ZRSzJibzZYUnJFazRvcjVIS09RQ2w5aWNCQUhSaFhuVkJFaXBHVUdsY3BLTWg1WlRCSk1zNEJBZVlHazZqWlpuV1hPNGN5YlYybkZvV3loQUVYSWxBSlVqWmFwL0JLUXo4SWtVMURTbnlFa2lSM2Q0Y1QzdklZLzlmM1pMT0dyT2pJOVRhTEpoQSs3OC9wNkhrekg4WFI4N1UvL2NyR3k4L3F2L00wUXpnbmFMN1ljNndDdlBFTDA1VklJQXc2L0pZYUJRNy9qUEIvVG5ZbmdiN3RlellmNlM5UFJHOU0yVHdkOVNwRFhkVXpOY21jeHJ5Uml6a3huRVN4L285bUFqd09IZmhiT2F1MzI4c1ltTnNxOEIweXJrR0Z1Z25nU3AvQ2tvUEg0NHlaWU00SWt4eFJ3SFhNU1lQOU4zak5lRk9KWDhGR3Q1N3FURUo0L3BuSHk3SU8zWG12ejUxaEtGSkRGWEM0S0tHSFJGQVFWRnhGS1pBRVdFMEpNTVZScnRWeDI0MEtxc0RMVU1rN1B3Zk5XWDlVS0NjcFpxbFlaMGs2bDdnb0JFSDBvWWE3WkFKSldaMVZCaFRtRFJZemlnQlBkZEtZRk84Y3Z4QlVvRE1qSVFRcENDODlJbUhPT1hvRXF0QWpTelUvanZBRFZRaUJjcVVMRXFiVktUYVN5REU5cTBxaWVjUXlZSW9LRmdqdzd6cU5IL25Ec3owYVRNZXdoOUZ0K1JwMU1UazZuUjRjK0hCSVl5dUVZc3lEWERIdHQ1OEpQL2tJS0ZjMkxHZnhzeDRKcGg1QjUveFYyazArbjVMQ3Y4T1BSSnRSTEswdWR4ckNiaFdWREtlV0pIZW9taXZPMnJtMTdYZzJlU1d4WThMaWh4SlpsanNZenJBT2RUaHZtM3A5TzBDUk1CS2ZWNXJQSDJDUmtPUllsckJnaitFRHlvbkE0K21nUnBnTWRMV3hGK0w3VnlIR3c5K1lITXJHVHhpU0dKR3F1RytjWkREenMvdDMzMzNGbncrMG0xWXdTVktJU2tTNkNFbFdabUlQQ0NpekdsZURweGluekxFakZVS0lDSUZxb1ErRVV2YkxyQU5xRE10QWd6a2xsZEZuRS9QbmYrb2RJZ0JpeWx5SWx6T3RCUkttK09xaDVxOVJFZ1NBcStoSVB6VUNNS2l1TlB4ZktIcWxtblFkSkM5a1ovNHBHTlVKZ3NaM25iSWFLZ3BDUnN3elFrQ2xidlZpVUlMUkNyZEp5T2l2SWYrWlROR1VRWHJyV0gwK09wOU5SRUlUSmJOenZ4M0F3ZENPTDR5TExvOWswNTV1YUFwak9QSTdneS9NQjlEajBWcmJXK0JVN3k0OWh1SEp1R1BuR2dSd2JBTFpMQmdacUN0bkIxYkIwSFhwWmMvbHFqemlENTVFazhNU3hhUVFOVkZQWFlIR3h0ZUF2dFUwcml5SnNOR2RSRERQUnJHRVcxRWFqTVd4NXJkbENlMnRlNCtENEdBc09lb3RqaFBrV1JOMmEwM1FOTUFaemVGR051aDFGTVFoT3AvN1c2bEtjd0IzTDRLbGJPcjg3aThicXRsMmtNZXNxTXJ0NzRlYU5XN3N5VGFYVkFCbHhNZUpJUUZ3OEVYanhoNEd5SjZXeWxaUm5KZEdLQTQ4a2sxd0VVTTdKUUVROFUrYzRuQU9oVVl0QlZYK3BnVXhRUlF2ejUvNzJQMkNtNGlSdzFsVFZHa21mUTdIc0dVSzZVMFlKMG1BcFI1QmFKUGJ2QjV3SkZYK1JINUtNeTJJbktjNkZ4ZnJPUU5XRExhTXFMYWtTVk5hTEJaOUxzNlQ2WXpnRFZSd2dIR2o1SGg4ZW5ZUWgzUEhwYkJqbjZlaHczODBNZnpybWJSckh2bkRsaWorYStxTitodTFoRkpxNkdVZXhnVDJ4NWJRdjNseTU4OGJ5elZjR1R4L21JVndHUHZ5TDdhdjhlSWpmdmNFSmhweDNyWXFpWG5mNW5KZGxqMGNqK1Bwd1dYZ1pVemY4T0ZwWlhhRjNrcVVCSE8wb3drNDU0VFZMaXF4UnE4RVRBcjhveVR2ZEphd0tXQ2o0NHI0a2RpeHJFdkEycTYwYjNZYWQ4UFZtMlRSTVY3c04zcC9TTkxqMTNVNHpvcm9YMktSNk50WUU5TEpvdHR0eE1FUEhVYnZwdFl5YmI4ejRsTzhjeEZoVzltdEJ6TW82U0ZxbUJ0MjVlVzZsNlFJU1pmTWx4ZlRDUEtpT0JCRE1hUllaQ0UybFB3UkZwV2dZeDNiazUvLzJQMENEcXVJQzU1VGlMTTVXb2pIQ1NYd2QzdWRFdG1LdFFCVUZCcWRGZkFYQ29vS1NvVVI1WUR0WWxJYWdqQlBQRmFxa1ZmbWtKYjQ4VldtQWlrbzVrU2tPRlpVNm5RZFdjeVplQW12bW1WTm1FVlJLV3NOQzhIMCsyWDNxWjRVZis1NWpKbEUyMk4rdFp3WDhpK1hWbGUwclY5WTJ0a0FLazcreXRISzZ2eGVIUGx4d00wL2x6aDlNZndDM3VIdjFWdVA2UzZuWDFHc05aMm01aUVPVDVoc3JBaS9KZ3pERUhNRFVjUno0R3pFVVUyN3ZVNmZwaG11MjdWaXcvL0NDMGl5V3k0MTBkRFFEaXQ3ck5PRjR3RnFuUlZHcnQyRHRzWW4yTElPL3dEVzFNTW5ER0JZOTZiVzhGSkR6WjZ4TDNWYU9xWVA5QmhZV1BzVE15NCttcmpsbUVmTDJyYjYydWpJWURDQlhxMVo3L09qcHovL1puK3JuYnFMVGVLT3BsSTBvL0F1QXdWVHFobHpzcHhYeUhGUkRpa09wVEl1TVZHNUZjd2JuRlYyc2VGbVZ3ak9pQ2lLd0xIalRkd2ZGdVpMSUJsNlFaWUN6SXhoNGNhWG5TMFdYdFliWlVsazV6NUdsSWk4Q3E2VHZPWGVlSlN5a0t2NXpacDhDSW8reUNoVlQ1UWxJQ1FlVnU1aUpNeGlYNkFWZ2xqUkFwVW9NWTZvUUFTZUdDdFEwSE0rbXFWYkE4SGsyTDV6bmhwVUcvbExOcW5rT2RLYlY2VUh2cnQ2KzlWTy8rRXV0cGRWdXUrT1o1dW1UZTlGMEdBVlRMWjU1V1Z4TSt0RjAzTHQ4bzNIbmg5cWYrd2xqODNMVzYyVXVKa1VkMjFMTHR0a3VYWjhHUWNRZk02V213emRxQUluYTRmL1lsajBham1JK0FvQ3h3SzdYcHB1VDhScThIeWVqNmN5MGJFd0J4OVQ4eVJRK2ZiUGUxQzJQMjJIZHJQUDVNeTNNc3Y0czVrTWZTSmo2L3VFUXRpL1ArR3Erd1dnQ1Z4NUpUQXo2WEh5VFI5SjBuV0ZteWxWNS9lTlA3amVHKzllRGgrMDB3QnAwM3VLVmNsUEFwTkkwRHU4WkFLRm1BV0N1eDBnamcybkd5bHpBUEZZV0ZpaFJBalM3TEttdW5pOUFSVVY2aWRPWnFTcGdtcE5WYWl5ZExuYUdmM09nZlZMTUFWSks2RmhNU2dvZWNXVTNxM2FoUVNTVzI1K3FnN0s3RUhvV2tRbzRQVXMrcWxRSmtpQVZhaVhGUW12K0JKQWVLb1lvWFZydDh6QkhJVmRzSmh4UVZSbmlaVTlWQUMveGtTaE5zOUNPeHFQN1I0T28wR0tvbW1FTTkvZWlrOFAvNEdkLzdxVWZlbk5wYlEwem9kWHB1TFVhVERObUg5d2JmcGFzMEVmOTQzUTJ3ZmFkbjJXS1pxYm5HVXZMZXBITnBzTThtaWJUdm1sNHQxOTVyZFpvQktNQmgxVFg0UG56MDJpT0RkdU9mVEQybFdnS3pEZzJvSEN2WFJ1ZVBaOHhoaWloVEVrY1d6RGUvSEpaMm12RHFEdllQMkREN05iclVQMng3M05Jc0hqd3RTS1lPM3pBdU9aWWZPNGd5d2RUTkZMOTlyeVlCdkZLcXhIQ29VbXpwc09YQjZhYXR0bnJQUFZUTzAvcm52dlIwNlBQM2I2MnVkcnVacnpubGVndUZxdUZrVDBUTEVERkJTbXlYUUNWSm9FcVdnMzd2SGlaaGlTNHBxckVIREFXUURFSUJ4N0pRLzRVTEpaQWNlUkMzZjlqU1RISWdkckdreEFSeGFOU00xN2NyYXBSb0xJSlVpY3pTRklDWS9oSFFCT2tqQ3FJWThsQjZDVWZRUXJLWVg0aWxHMEJoa2hPSkNZSmFrcjlDVkJsU3N1Zk13a0U0VlVTa1ZrSmZCWkNJanhLak4zblFXU3E2L2NPRHlNRFRtMmlmb2R4K3VTVGRETDZVei8rRSszbE5hL1JnTDVDQ1hneFc5TWR6KzB1cit3K2VieTZlV0UySEhtMmEyQURHd1Y2bHRpYlcxcXJEUzljSzVKd1FpOS9wZDVxdDl2WVh3YlRFVHorbk9hY0xYQXdiVFErUHN5UDg2RTQzVWlZWk1PUFl0dmx0d0pwaEpIMGZkaHQ2TzRzaWpxTnV1czZFK3hKNDlpck5URTNMSG5IWmNFWE5zSDkxa00rRnFsTithdXJBbGwra21HbmExaTZZK2hEUDhZV0dTc2kxcWhXelpJbm1mVzFUbXVRNnllbm8zYk5mSFl5YW1CQnFkWGJqcjVxSjEzK1lOd01EQlNocko2RFAzR0FDRUp3cnVpOGlJcDgydGpSR3BSUkVKVFJjMGdBQjZzODQ1OVo1cy8vTFZoMzhKUFJKRklkOGEvU0FoeitNa3BpTVg1U0JPeEpSclFFbGo0SE5JZEFWMEgraFhSZVNsQUVuT2Vhck01TVlxSklTMVZ6RlZMbUw2YzgwNElXMDh2SUhHU0NudUdrWTJWVEFleUVkSm9VUXNhcmpKSVBrUW1POUNxWFo2bUZMUFZpT0prK0hFMndQWTBORjhiUUg0N0MvcW1UemRaNnkrc1hybEFpNHFPaWhNV1grbHBXdmRaWVdvWi8wajg0eXFNUXJrVzlWb2V5TlY5NjNYUjByNmFuVVRBYkhCVitzdXk2TnA4S05scmRwY2x3aUEwb21OR0tZNi9xMkh5bU4wbE0ybUMyQm0yWkJZSG5vSXdOcXgvQmF2TmFDdDg0eVFjSVRMMVo5N0RMaEs1aTRYTGxzMDVoeEtkeHpDTDFISG1wUEMrS2F0Z2I4QUs4aGxVaVRkS2NWeXpoNnNUWU52QWhoTHJIMzZtQXgycW5jZURISjZjRGRBNXJnNmRwKzVQZzJkTURmenJwSHo2cnIxOVBUSnVQR2FCZGxWSlFwQ0lISnNxQktrRmhTcWdNczhRWmdWc2lFaitqNG1oUjl2UUlaTjlZQXIwR1Zza3lLRFZub29CbHFEL2dyMGFWNnY3MzUvbWlBSWlqVG9XUmVKVXJTRFY5cEtqaXpYWVFwNGpZSnNsUkJLQlRWR2ZUVGxFRDVNVFNGVlJSWnBRY0ZGUXM1RVJRTVZWWEJjaUdoaThnSkRwUEkwc2srU2xRdGZFOENDdFVwUEtVV0RCK01LUGZ1bnQvd2hjN3hxbG14SVUxM04wL2Z2ZDlNOU9YbHpvM1hub0Z0Q0JWbnFDS28rcEdzK2sxMjdWV1N6T3MyWGpjN1BYTTNwSzJ0V1hYYkdqZStPUXdoRDh6Q1ZaY040MGlEVlpWMTd0THExZ2wwQ2srcllWWnhRZGZkRDhNb1lXdzVZWnV4cklMZ3VscE41b3BGZ3dvWlpaNWVqRktjcS9XZ0FmRjF4bzQ5blFXUUhjczI0VTdQZzFEUG9HY3BmS2d2T0ZaZkl4c3M5dnhYQ2ZrTit4TlRDaHNiekUvc0c3QXQ4SFVXKzUyWnVDQWlneDdHS2JZekdKUll4dXdzZlphazFrMG1QaXVidDVhYmV6VU1zZ24wcDJVajZTZGw2a2F1K2VHQzdDSUtZRjRZRVZ6SkZjb0ZSMzlmZVlSdzZWVGtBQTFPbVd5S015eUtIZVlhZ2J3SUUraVFkM0ZtWkVDNnJRSVZYdVlpMytrZ09HVWtqZ1hSUjQ1dHF5aEtxenNMdWZiZVhZb1dES3BtcXNvK2MrNFpNbkVKa2VlRnh3bkpTQUZVZ29vc1I5Q3ErZ1h1SUVlQlZpbW1nVGdXa1hQZ0JpWitmdzdEMkpGeWtZaGdyb2dyOGRIL1hmZXZadWI5ZUdUS1pycTh0ZEVvZDVZdHEzNjNyTW5rV1poNnhmRXljUVBwak1mbmtTUlptYVJZZU9JMEZ0ZlhiOTBlV243Z2xhckZXdHJldDJyTnoza2ZPOWYvV3V2MjdQOXFPdFk4Q0NTTU9TajZ2QXhiS3ZiN1haYTdjN1NrbUZabzhrNENHTmVqemV0dU1qNCtCTDltYWhlYjBDdk1TVmduclUweVhSc1I2M0E5ejNiYkRicU16N3dxR0VIN05oT2tNWllJdUM5bXhTc2pwakxwMzIwYnJmRld3VDhUVG9VV3dUQlQzNm5wbW43YVFxYmozRXozUTUyREdnZDVnbTJJbUV3YS9WNnc5Rm9NdlZQK3BNbkR4L3AvdWhxeDltc201aWdNY2ZPd0VncTJjbjVuQzR3TFJnVkFYV2xLMmNqemdFdEkvT3lQS3M5bFVvRHFPWkVjeUI1a2xSSkwxUmtYcEdiUDAvZnZjdzlzOEZTdW96SW44cFFPQlhIY2E0K2lxMUVDWFB1YzBDTmxYNlhHQ1plSUdQLzhFODhZcXFlVDRGeTJnQ2tKendKTTE0bFlCOVUyYkp4ODBhU0JESFIraEx4QWl4bU1ZWVM4eGJMK2ZSME9Kdk8rTEV4cmFFYkZyeUZhRGpMc0ZscjltckxXMGVUNE43VForKzgvKzBIQjQrZWpzZDNIdysrL2NmZi9kYnYvWXZYN2x4M20rMDBERTNIYUhSN3E5c1hkNmZEUnNkdHR1cllHazRHcDZsUmI4V0pnMzFyR211RzJWclo2RzVmaGtzQ3JZWDJRL3lXNWJhYnJWYXJpU21OVFN1VU5OWDVUQzkyaytoUXU5V0FaeC9EeDg1NE1SSWVPeTlWWm1tbjJkUU5ZemIxblZvZFBoSm9naWhLYWY4b0l0NTQ0bnFWMTF3WEc5dW01MENQeDdNQTdoUVdEU3dXNjcwV0ZnVzRaUEpTWW42ZHpYRWRlRjUxckFaUmNPWEdqZFBCS1J3cWhQNWcvUERKd2VIZWJzZE1lN1pXdDd3QW5wNGFHSkVjUjBGQUpSV29DRVlNWkpWNnFCSUs1b1J6SU8wNUVvNG5Sb2pkWWZFRkJRYW9KUEVxemEzcWIvNERZaXFORVdCY3FRNFZSREdUWE5WY0FvMGQ0aGdzbFlsVG1ZV0VmTFFkaFFWRFR4Tkp4a3MreE0vREdTellld2JxbVdxVnVLb3NwdXFRZktFa0dwNnlvQWdvaTRCdEhFc0tqclFzeFQ4MU5ZU1FzQ2g2eEVrcHpWTkpIaVZlblVzdVVXRStQVGpJc2ZLMzIyRVd3S2xwNkpxalcwV21HNmFiZDFweHZaVjc5VmwvSE0xbVJWTDR3MkNhYTkvOTZyZUs4YlBmKzYvL3kwZmZlK3VObi96cC9tUXl6Y2F2WE4xKzg5cGxYOCtQUjhOWjdGMWFXMzNsaXorMWRmdTFhei8wcGVVck4zWmVmdU9sTC83NFN6L3lwNWF1M2h4TVo2dVhiOXo2MGs5ME4zZTg3aktmaHg4UGpRS3VWR2JveG1UbU4ydjFvc2hnM1NFcXc4VG1rbjQ0UnJEZGJFQkJKK09KYVVPVExmamxtQ0hjQTZTcHg5ZlZtNkRIQ0dMT3RPcVlEM3JETmFaaHpMR1VWMjRzTlJwWXZpQU16N0ZIWWJ6Y2JxRlFIQWFPaWMxcDhoZi82dDk4Nys1N1djZ2xZNVpFUVJBZW53eWVQZHRydHJvTkxkeHBZdGRyeExvbEYyMUVoNmdUNWFDVm9GUlZMZWhVR0NYK09UQU4rbmtSL3R4VUpSVTNSc2lRZzYwU2tvdGlZdkpLbU1lUVpmN2MzLzc3YzM1bzFtSWVvSEo5K0NlUmVXR20wUS9vbXVxQlZNak1hZ0xnb0NhTUtuWm1KU1ZYQ0NwUTZzWEt6MmhVWFNWWldZV2syRWhwamhBSUF2OUNVSEZHQzlnSWdOSmpGU2VSREtSS2xWQldMZkh6VUZFcW5pU0JzLzYxaisvNzQ3R2UyckdaZFRxdWtVSjdzQlgwK0NtKzlVWlMwNU1rMXFQRXlPelowSjc0dXQ2czVlMVdhTGZmKy9vM0l5MmJoTVZHcngzV3JWZnVYTHkxc2VJNGJxUG12Yis3ZTN5US9Ka3ZmWkd1enVaV2UzbDFlWDJqMGV2Q0pEdU4rc3JXaFpkLytFY3Z2L0xHNXMzYmwxNzd6SjBmL3ZFM2YrNFg3My8wWVgvL0taeFVtT29rVG1oUURPaTVuV3NGVERnTVJ4eERLUzM0ODYxNkxVbFNHT0JhbzVuQkYwbFRpTkUwVFlQTEFQY1lrQlNLb1AwNk44bW01N2xoR1BDN1BYays4Y1BsUnAzUEtXdjZZT1ozbWkyNDgxRVVOa3c0WGZsbjN2eXh5Nis5OVA1YjM4RnNTYkIxaUJOc0FLSWczbjN5OVBqSkEvL3dXY1BXN2ZaU1lqZ1lMNnF5akNKWFpsWktrWlpqSkJtTGhyblNOa29lY2VxRnpBWCtjL2laTGN6a3lBaEhYRVhMR1NWangvOEZnSzdDdXYvSEMyZ1pWOVlDQ3lrWG1jc3hGM1lxTGxuRXNidzBFV21jVlJ2VjlHUDZqS3RFbUswYUtsZFI1cGtFeVpQeitRRCtPS21PRVJTVjVPSEFMUFFBTWJMbDVwQXAwakF1QkZVQmdSSjV2bXFDb2xOU254T2RrU21aNkltbWYzM3ZjS3BsTGNldWQxcjFsaDJNL1FsVTJQVDBPci9vbGRoNTBQZk5OTTh0TjlKclJkMTExK3F6bVcrNWpUZ0orTmJITEhhWFZ0LysvdHMvOXdzL3NiYlUwT0VhVzRaaGFaMlZqVTgrdnZ2WjJ5OXBPdDlCQ2JITGpUMytROWdxaVUwQkxMRWc2Yk8vOWhNLzViU1dwdkRsZzhpdytTd0FkRlVlYm9FeE5iQWZUV0ordFE5ZWpXWHFYcjAybVV3aTdESXhIM2pYTnB2NFBseWpJazNncTBCWlVUWk9ZdE54c0FmMVBNOFBJMnhYSVFtcWU3c0o1eDdTQUJrV2pnWnYwQlpGR21QWGR1WHk1Wi83bFYvNzFuZS9NVHJ1dy9QQnVvRnBFeVlKL0tYcExJb0t1N084dmx6NHk3YVd5cTB3Y0JRMVFSOTQ4WWRTbFlEOUFuQWk5aElEYWN1UmVNbmlFQUJRQ3JORmpRanBwQlNCQ0VaWmtDVlJZajYvNXNBQk5uK09GeUlwMXhKWnFoQ3lTQXRzeFlwUUVra1dvZUtJUTVXRkpwVFJrcWNRbHdWd2tpNHR0S1BNQmFuU3NLb2xPQ0ttSnNnWm9DQ0pwUkNWUU1wS3FzekVQMHNxR2dSaFZ1bXVUSWQ1NHhkQUlWVUpTY3NCZFFNS0xjbjF4LzNKZXllbnAzR2c1Mm5UYVVOdEp1TXdzQTNOcnVsT0RaWXRIQVh4T011c1p0SHU4UEozelhhWG5DUVlHMGJONUFmMVRNekJPUE1iSzk3cTFVdHZ2SHAxYzYzYnNKeXhsaWQ2WWRVN2VaU3VOSmQ0UFZEMVJKck5Kb2c0Wk9pWVZ1TXZSLzNDblpjLy8yZCs0UXMvOStlLzlFdS8rdVAvNGEvdFA3ZzNQdDRISHJyTzdCeStQVjlEaVo3QnM1OU8vVHpMb0l1VzQ0USszMUNHb09lWjQyQkR5ZWVOZVpWSDQwTnBvSy94Q2JNSlRQMHNTcnB3aDlCNG5kZitSNU93dDl5Qi94ck1KcWFoOXpxOW4vaUZYMnkwR2wvNzhoOXhwOEJuRVBnWVFocW5RUnozKzROSEg3NDcyWHM0TzNnOFBYaFFqeVp3ai9SbXQxTDZNMkRQMEZhaVN0WGhYUks1RGFuc0Z3QmRMblZOVVZSbjZqV2l5RkFjUlQyWUtiV2NCK2FaUHl1M21hUTZVSUtHTTRRbkpXUVpiMVZTZHNRa0FnQkpQQy9NbkFITGMzVE9BZElLUlo3aVo2dldzU3c3UldCYVVaQklNS0NzTWlWWGtmQ3NkRjNsQ1U3NS9NQUlWWWtWRG9qd0FNQ0FpWTFTektTUFRFcGNVYWlhS3hieWZpS3RHTWJ4bzlIcy92RmtONG5DekMveXJHTTNkRDBkRG1kajA5VGNXZ3I5Q0tMeDAzR2ExWFMzWGpodUFWOENUcXRyeE1HczFuUmRxejZOSnZ6RXBOLzNPc3NiYTcyL0F0Tyt2WjQ3ZG1oa3BsbWZ4UHdLelZxclBSMkZ2R3d0d2xvUVl6bC8xU2lveGdIVWVLS0ZNTW53UDB6UHZmM0ZINzMvOWp1ajR3TTRLaVRnYjR1aHlYckFWM3JBMCtGbURDN0h6QTlpdVBoNUVVWnhxMW5UWUtzTlBZbFRlaW04SVZXRGkwL054dlFvQ2ovSndLdnVPVkJBSUUvSE03anY4SG1tdm04V21xdG5mL0d2LzRiYmFMei84YnRIenc1NEI1K1A3L1BwVC9oTVVacjRZWEk0R0UrR285SGgzdWhndjdGKzJWN2JrdUVqc0VNeWNnb3dRa3IrQ01pUVBpTldDcUpVR29uUFFXVXVqcWtVSjljeVM1R1ZSUmxnM1pXNnErcXI0U2FJVG9oSlZDSS9VNC95UUtRQ0ZWSEhNd1lWS0F5T2NwRUpWQmc4SG9rdHl4QkRRVENRWEkyeDVBRVFVVHlxczZKWkVCYjdTYVFLQkdTV0tNeUhPU2VBbEQySFVFVkFqRmJvUlpScEQ0NUdiejg4T0NqeTNVRVFKT0hSb0E4YnJTVXdmblg0eHVOaGRGS1ltbWw3V2JUczVxUEUxcm9yVmd0bTNzWkdVYXU3bW1Ia1NXSjNtbzV0MkM3VlAwL3lZQWh2d3JwMmZlZU5OMjVoYTFaMzNGQ0hkWTlXRFdlWXB0WTBEbWZ5Z1pxRmxzbVlxWEFHVlVMMUNjZFNDbkJVWHYySm42NjFlb2Q3VHpXK2lRTm1GZ1llTXNjNWE3Z2VmKzdOSDF6bGVwWUJieGpGblJ0WC9TVEtVOTZtalhtVlJuMTFUZTRIOHhVR2ZHR2xIOFVyM1E1c09kUmc2SWZOT2pvRkg4bkhEaFk3NEwveWEzL0phWGJETFB6Nmw3L010eXZ4RjdsWnlxdVovS0VXSU0zMFdSakR5MXEvOXNyT1QvNGl2NmpHOXNyd1F1UTRTdU1WS0p3NnEyVk9NQUpJb0pBY0ZaUWRsNlFpSzZjRWRWaGxjRUFaVVZvZ3VlTE1sTElUN1ZBTUtpZ1ZCdGx5SnFiU1NnWWk1Z25XaWlPOXF6S0hBSHFtaEk5a01PQ2Z0OEdyQnVPTUlCR2tTYzVjUlN3TWlDb0REdndkTDV2QkZQS1VweTRnVWFCbzFWa1doOUs4NHlBTllVWGlLMUtYRURneUJWUzhHQ1h4Z1IvdHo4SUh3K25KT0lBandxK01SZEZ4TkVucmJqM3hJbXVGai9TZUpzZEhvWmNYMXVtaHQ3M1JqK3VhMStIUHB0dk96SS9zYnJPMjdHQ3NiV3pQK0pTVlBRc1NHTmIwTk1rR2NUMkxydXgwbnQ3ZmZmM21wV0ZjckZyV21ndkRDUy9BREdkcDVNZFZOeGJnckcvbFlNc3dTMC9FblpOOEJ2NmJ4dmJObDM3b3oveTVsNzc0RTdmZS9OSGw3U3QzMy8yT3pldVZPUXc4OUU5K3Q4cmlFQXJJUjRQaHovelVUM3o4eVgxc2F0TUVycm1HVFczZHJTR0NEZXVJcnlQV3BtSGM5bXFlWjV1V0djTnBTL05PQzFzUmVPZ0JkZ0YvNnFkLzJtejgvK242RDJoWmt2UThES3lxekVxZldkN2V1dDQ4Ly9wMXYzWmplZ1l6R0FlQUFBR1FBQ21Bb0lHaFNJb0FTT0ZRME9yc1NxU1dpOTF6dEVkSGxDaXV5Q1dYU3dNS0EySkZnc1RBVDQvdG5wNzJyNTkvMTk5YjNydTBsVm0xM3g5WjkzVVBqaFMzYmxWa1pHUmttTy8vLysvUGpJelUxdGUzdi9iMVA3U0dVOVFOMVVEUHduckFiRkRuSWhxTjBQMkhZSGJwK1ZlaWlvenowcndmMWhpTUJuNHhWQlFQelQxaTlJMWZwQk1ld2hhR2dYRElBaDJQZGxEbTVkNFB2OE1ZZmk4eVA4MkR3UDNBei8zaTB3MEUwcnRQRDZEcTBFRXhJaTJvUkZqQVI3TC83MFpaUG55V0tZUXc2bUsyWjFuMzBPRkFsSFpSaEU2NnpCOGV2RXhucVFSdENtRVoxQm5zcy95aFdMaVhaV1pSK2x5a3M4Q0VpN3hBL0VEeFJMcmpXWDNpRGp5M0I0TnIrblhUYmsrczZkVG5GdlNlTURraHkxbHR4RjVwTko3RytkRWlMWk16T3A1NjhXZ3NYOWJsZkZyYzJCS05kQ0tkekJlVHhVb3FsMWIzTHVVdVgwcXY1cVNWa241anZiQ3lsYjl5WTdXNGxVdWtFaWZ2SElpMjlka2Z1ZjdwNitzM3J1OVYrNzFjTmgreHJlNTRrdEtNa2NmUFJxYm4raCsyNEdsZ2JROUhJV3hSbU9YcE1EMDlZcG1IWmdORVpTT1JMSlkyYmoyN2NmWFd2ZGUveGMvcEtXOWEwTUluQVNHZkIzblpaZnVOWWdFSncrRUVLcDFJaUU4aTRmc3ppWS83MFpoRGJ5ZW1CenNWV1FCNmNSU2MxMlRDQU5Nekp6aUVLK1p6dWRWMVJaYXR3TG56bmJjSWhheDIwTTJvRUdsNkZsQ3c1emhPcHlieHZEZG96d2E5bURNVkZYMU9DeHV6RmxETDZjTTJsNm9NMzFRVzdXUXhDdFJHakNYdFluaytHajY2eWNyNkUvc3BSUC9CZHg3SEFBUHFBZlFnblFnU2lSMGhRbW1UTmk3dVgxSWwyRGR0WWp2OHBRRFhnaGtnK25zNlBPenc3emtyZGp6ZEpqbTQyQWdqMk10a25YTFJEd0pKMmpJSmdlMmxiZnBqbHl6WUxxcmtNZyswQlFrWUtoSG1wWDlLWjBzWFVEdWovRHd1aXBvb1NSRVpmaG9YYzRLSUU4eW1RTHM3bS9yKzFJbk9vdlBCT0RMdStrN2ZjWnJESC9yQzN2UFBGVnZlL0xEdWxMSzZZZkE4TGRFYWdXVkc2Y0FYajRyRkZ2UUdZYkNDS0VodDlKU2VFb3JTN2Z0WXhPd091ZjNqbDY1dEpUTkcvZUJ3SloxNno0cHVwUFd5QkpVN204eTg4VUtzdm50WDFQTUJDbU9CT3VaaVJQQ0ZqcUJVYWdyaVlhdFlFaHZTc0xlcHRlRkd1SjkyNGhNYjFzNy8yWC81aTA2M0VmSG45Rm9SZXFjTktVNFFHT1RaeUtVdjc2eS84MkRmZDJZdXZZNmJFS0NwQ2xRNDZuNWNiWXpwYlRuQlZpbExYdXhpVVI5TXRsWlgwYWhlcTRGbXZ2S3hsLzcwWC8zck1aNFhOZWt2L2RtZmhJaWdoOUVHcUhibURPT2JoaWpPUlVWZWxHUWhZV2dyaGF5WVN1Y3FHNFZMejRxNW9ycTZBM2tpTThEdTBOTkFzcnBSVStpUGJTTlFoSFhGUlVDVUdobW1VT3hQaHJEbjJKRU12R3lMKzlJdi9FMkdEcmFKczFBaW5UY3NnbWdGdnRFK2tybXdLeW5meFNmTUUvNkU4a1QxWWxFQ0hkdkhqbUhsaFNuTGs3QTlWQ0R0SXNMQ291eWZ4b20ydy9PR085Z21kak5Lc3N3VmZzTHFMei9ZamNKcE5qNXJiZGo3NkV4OFEzbkdaYWxReXVSS2VqSWxHWVlvSytKQzRsVTlydXZRMU1sRUxsMG9aQ3I1ZExtWXl1U1NVaklCVnJ1WGlUNXpmZFVYZU1maGRpdEtSdUZVSHYyM2tJUVlINDBLcUNDN2poQ096RHpHWHA4VWlRaEJKQjVFVnVLUlRUNXlSUk92YkpZemFseVB6dU1wZlJLTm5YYkdPOFdFeU5GcXFTREI0OG44L3EvL2s4elc1VWhjQ0p1QnFvZGRGUDVTeWtXZ2sxRUhodnZEUUhIODQ3TTB4eC9aVW5Uajl1ZC82UEQrZmJ2WEJER0hwaFU0ZWhjRGRzT0Q5VjNYMEdWZFZkdURJYjFrTS9EcDRkUUZ5RXdjRWt6cmY5RGpUcjRlcHhrMGFPckVjUlJGVVdYSnRpeUJpM3F1dGI2NU0zSE1kREo3V2p1cm5aeXp4NzJoQ3BpQ0QvdWZsZ2lmdzBVQUZ6SnQxNXBNVkQ0K05VY25EKy8wRHgvR0ZTTlJXS0ZXRVNoSjJBZ3FiQkJwazMzVGdLTXBpTkVtYXkzOTBPOUhleVpNcDVKb0orc2gxc3lMWFBpT2NsLzYyYi9KaXFQdEMvQ0ZlMmtqUEQxQ2VCaHRzM1RTV3F6Z1pZenhTSmFEUW9oaWxqVktWOEpvQjl0ZzVZUm5vUlRhUVhVS3QvQk5MYVo4NFJjS1ptVVNKYWNvT2U4c05mVGlxY0g0TFBHTkg0U3dlV3dQOVRXcFhuRFNlU3lxSlJVZ2VLTmlST0x6U0p4ekZqR2ZYZFdmQTYzc3JFdy9ScUd4SXJNQTVGU3pyR1EwVUlQeHk3ZTJPVjNRRlY1VE9KbHlVZDNvQWVvSVRWdjMyQmw1bElEdDZNSzA1dkhvWWowYUtmRFJGQi9OY1JFRkVLZnJJaVNscUV6TmkzVEczdFZDa2lhbTQ4U2d0Sk9SR3ZHLzl1WGZmSEQzenVXWFh3bmhpblBnaDFvZGZxRkJZUWV4Z0hqWTUyRmdhY3NEU1BMWkRSUFNIeXlkcWllSXozNzJDNFBocUxYL0tCYmpack1BUElRY0N4Q1l5RnlJUkx6SW9qMkNrQzdvUHVnTWlGMElBazNDY2NEbDZScEw0Qy9tdWtTdk9uUHA5UXB4bFZhcDkwUlVmKzVIdlVGTWt0OTY2NDFtcmRhc05ZbXNFOTZoWDJnOGNIWjhBdnpTNjl4STJYc3plb3pRc3F5MVp6NTE0N00vbXE2cyt0YUVrMlJvZDVhWC9zTW0wY1pGSUtWTFBjd1M2UnRXbjNKUkt4a3FXYnNwc095VUV5RVVJYnIwaWIwc25YRjMxbGRoZG5ZY3hVUHNYUnhJNGNNWVFoaG5OY0s1dzBxd1FEOWhRVFJsWWxuaXhjNkxDSDJITldBalI0T0hqQXg0M0dMaGREcVRabjFZUGFZbkcvZzRjUWFnbkdhMFJXYWpmakFaVjUvYzh3YmR1MS85M2RyOTl4SkpUWkMxT0JlcjZDckd6L0o5Z0hzUjR6Q1ljVVhVazNvcW9WUldVdVc4cG1qUVdIUnRXY1NKUWRLalVkdkQrTkhLY2pGNGVld09wVGNhdnZ1YnZ6V3ZkWlJKZjArVmR6THFnZzlnRTNJeEQ0TGhzZ3R6czJCaEFpRHpxRGRmeENPMDRCYS9XT2pSUlNvV0tZbUxFaDh6T0FBb1prY1dzK2pDV1VRN2tYbDdNYS9QWWtkbWREaDE5bEtxSlBDZHlTaUNsclhhZis5bmZxYjM4UDVzNWtveGJ2UDJKNkJ5MldpeWJxSWVDa2VZd1RoTVEvZ3dobjNMb1VUdnNBRWlxQ01INi9qbEQ3YTVHSGZ0WTU5c2QxcTFKNCtncUFuSHFEWkhMeC94UE4vQlB5QzVpSG9CWFp4aFV3M1FpOVRwamt1UERjSTExZUJsa3NUUzhtT3Fnc3JTbGRaRkVQejVMMzdNa0dOMzNudjcwWU1EN0lyRzZHRnpJSjcrQ0JmTXpLSVNBQU5kcWFRWGFGcU9zN1Y3dmJSWmVmRE9xNGR2ZmRQcEQyVTlJUmtwVk9ZalRhTkFMUWxqREtMVUx4Y1pNRjc0UnNtVUIvOHNUaHNzRXFiUUhxWUNMemJCM1Y5L3hIN3A0TEFvVmt2cUtUcVkzV3Bta3NkMjQwaDJLQ1FHNGFPUDVrSitrY2JrYVprekxBZnhpM09GaFM0RDZvUWE0NXVqTXFNTCtQcjlsak1jTkE0ZW43LzNkbThJWnk0YjhIdzJuK2RsTlprMG9DMGNkM0hubTY4bWs3bzl0ZUI3cWJJc0tjSlAvWldmSzVjclVaRkxhS3FxcGFaUllRQ2JLL0RBRGRpbUJIQXpIQVJBTTMyb1dpQ2g5aUptVXV1bzB6QWdNQjlJdEJiUnJvdXg5M3UxMWkyRkpwODQyQy9LcmlTdksyUUZYR2d6ZXc2eFNHa1k4SWdUaWNTQkpPb2pLRE9vY0VyQktkeEZkQnBFT3BDS0lES2xwMElYMGRrOEdZbFUxRWhDNVFSdTdpNjRvYitveFB4di9JLy84d2ZmK3RiTW5taUduaTlXT2hFbHU3WFRhemMrOCtOL2dWYTdKcDBlZGlQcmFOYXJ0SDBCZlZJbkxFTEpMTGEwc1RTK1MvMisvQ1lISTlxdG5mM0wvK1pYT29lSHVoUzNYSmNMbDRpbmF5S3hPT0ljdmJEUzhRTlpGQ3pUMU1SNFhCUjZVM05pdVk0N0t5UjFRMVVCMXNIRTNGeGRFZVA4cE5jQzYxNWR5VUZzUDNQN3N1MTVmL3pkeDBlTkh0Zyt1aHJxSEJJRWc0YUtoSFZEeFNsUVhhSlFFNXZGWENxZlU0MWtsQmZpUmlxN3NYUHRCMzRpSW9uVUJBYWVpN1pTd0RlMjZXLzVvZTBReEt3M1dLNndwU3dUOXBKU0oxSzc3SUV3Y0YvNitYQVNBY0VZNlF6SGREaWRqVVZaS1I4ZUVHNVNwU25HNGppVUZSbHVzandzeGdMTGRSRllBYWdmWXdUMEFVUzg0UUJLK3VIWGYvLytxNzk3OU43Ym85cTU3VG02cGdYQlRPRGpnV3ViM2JiZDYvRE9jSHA2NkkzR25WN1A5VnpQbTZFTTBNS2YvdWsvQytmUnNoeGUwVlJORlhtaURyN0lHU0o2a1dhMzBzMURuQXQ2SmVTVFlDdGdNaUE1aTZoTlZ4QXAvMnl4R1B0emxOdjM1c2RONi9FN3gydFhMNDFWWXhoUngxSFpXY1M3QzY0ZExGekxMOHBDVm82RG4xakVBU0l6NENNYW1TNFd3MGlrTlY5MC9VWExYM1Q4eU5DUFRIeklHSTI0R0hIVldHVFZpQ2VrbUJtTENWSDJ4TCt6OEE4UGZ2TWYvQS9UOFVnM3RBVllnK04rNVgvN3JiZis2Q3VQMzNoTlY3V042N2VRQ3gvV2JlRmdVR0NiVEdsUlUyZ2NFSnN2QjVtU0x2SXN2OE1JbWNab1ZFMmtCdDNtdUZrYjlBZlFGVDVnaVI0QXIwSk9Ka1NRYVptSHZwK3Bpa0x2enZGbkVPTVo2WHFBY0s1S0lyN0hsazBQU2ttU1A1L0ZZTzdpMGp2SG5XL2ZPWmdNaDU5NzZjYVZTbjVpVzZPcHcrYWZvY05STS9UQ0Jad0loemduN1lCallFOUg1ckNQNGpsUlc3dnh2SkVyMG5VeFVvQkxXYVdLWFlTUHRKQVZoeTNVR0J2VUMrR0h6a1U1YU9kU0ZYeDRQQXZjRjltTVNIYjlnMDdDTUw4c21hWGhDeW4wb2E1ZFJwY0ZzUXpZb3FTTEJOcExoWHlZa3o0c2xiNklleStUb0c5aWIvMzJ2MzMvOS81dDk4bmRTYWNkK0hONmNRcWNKZkNaV1pESnBPSEpRV1d6UlE4WDA2bVpGR09EVG51dGtCMjZOSEVqTHNUL3lzLyt4VzkrL1R0Zi92Vi84M3QvOEFjYnp6N1hIbzQrT0szV0xXZnN6Z1lqT3dLbmpDNmVMNEpvTktBM3p0SEVWMVREajBKeExwOUJnQ1NNUEVLbjdjK3RxZlhlV3dkM3YzTzBtVlJMbDhxUUoxRWtuTXk1Q0QrZnJVZjlxNm9vY0p3TmlFY2lrMFhFalVaNjgrakFYN1RkQlVvQXQrRWluQjNFaGc1aEI1NG9NVjNIU1F0OFVaZlRJa0FaamZpZWRWWi81N2QrKzQxZi81ZGYvL0t2WjNVbGs5UmhwZ0xmdTNuN3hVZFBubGhURTN6ZzBkdmZ2ZjdpeTNxdWdDcUdhbTdaYWZoQmxIVmsyS21VZ2NXdzUybWU1YWd2dnhrY01NTHNtRnhsOC83clh3VUFSNU94UUc4WGpvS284TFRBWlpnRkJ5K0VPQzJYUjQrRXhDWExnN3FuOVN0OVA5QmttdXdGd29OOGhxNjVuZ01WL3R5dFp5S3BOTlROZVhmNjlxUGp6bkQwK1pkdjN0cGRBNVZyRGlhc0NoUUlGR0h0V0F6alFKUGIvQ0NUSzY1ZGZTNVpXVDk2OHU0N3YvK2JicXRlckd4RkpTSk9WSm1MdG53b0xnaDBDWkRVTmlwRFJiSkFyU1BGRlI1RWdlREdTa0dnWkphWisrTFBBdTVzQjNYYzA4RFFTWGxwQStuc3c0NWtPWmNGc0NoMmhWbkR3QVR6SWtNb1pPeERxaVBjeFdnTU5zL2V1L1BncTc5TktPVG9OUmpUS1J3WWNHK2FvUXIxQWUyT25NZjdoNGVIQjVvb2dtQmJpMWlwVkloeVFtODBCbkZCNXRQVFk5czBRU1VmMzM5NDh1amVWLzdOYjN6bDMveWJQLzZOWC8vcXYvNVhyLzZyZi9HMTMvcTM5Nzc5N2Jnc3h4TkpOaDBMNmozcU1mK1NqeTZnNEFIUUFCUjhSbHdjWmwwVEpOdGRISC9ublQvOTUxOEpSSWtxVDIrbFhoaU9kVnVQcGFXNEU0MmFpM2wzRWVzdUlsRGhveURtMEV2ZDZmNE54QUF0R3ZqUkdUME90NUQ1dWVmUFpOZGQ1NFdVS210Q2pKOHZUdDk0NjdmKzN0Ly9YLzl2di9iTzcvOU9RWTdXcS9WeUtUKzJpRGZMcW5IcDZ1Vlh2L3IxeVlRbXE4ejkyYkEvZVBGTFAwSk9IbnFCald6SWhjUGhDQVB0UVhpNkhlWUxFK2szM0tCUEdKQW9xMXF2VXgrZUhzWUZBUm9FZklidUg4RlVNb1dId3pFMG9ONGlYWWloQ2ZSSkkyazZGazRNSFJ6bllEQ0ovamkybTg5a1ROZU5Cck5QUHYvTWovL04vOEpUVWd2WEJNMXZEY3dQanVxTlJ1djJwWTFuZGxaZDE1bmFhQiswRFRIZkQydktkT29zaUl3bm8rN1o0ZG5ERDZ4Mnl4MU4ycWRINW1DNGN1azZKMGxQRVU0MWV4cW9RL0NoS0w2b3ZZaFFUb3JSZ09HWHRaeStuOFlwMEFacGQvcWxFaGcwMlY1c01VRUpOMW1FdW90VXdJVUxTNGxMa1NDaElwMjlUR2VIVW1CNWtCM2JvZXFnUlI1WUtmQ2MvUDd3ai83Ri94SUxTRkdEWklPZXpJTzU2M3JRNWRBM29raXJxTUNwMm4vOGhBdjhlRHhlYTdSNVFiUzhoV2xaa2l4cXVoNzRRVDZwTlpwZDA3UUtoUndYNWF6eGROanYwVDBWMDNRbTAyR2pVWHYwcEgzMy9sZisyVDkvNzJ1dkRscHRiejZEaFlhOWpEcFR3TjJOMHN2bjBHb29PUmRkNzgrLzl0c1BkNVB4S3gvZmtmbW9GcHRIM2RrVmViRm5jSE9PR3dTTHRoK015RWVKMFJ2YXFka0wyQStPNkZQTUR1YU9DeDBZa2NVRmRqaW1MVHZlcGFSVzBTRm0zTXkwdi9Vdi91VTMvOGsvS3FlU1d4c2JoaUxwdXFacnlzejFuaHljTlpxdG0xc3JncEY2L2J2dndzR0QwL0Rabi94TFAvcUxmNGNYQk5hbDFMRTBvbXdRMk9ZeXNFMThFVHRrMnl5VlphUSt2L2pRS0N4M1VESDU5WjBQM3ZpR0RFWUJLMHJMdVFhQ0lNQWxCUjBuVnhIMGkrRU1oQTJ0bXppdUpFb0xkaEdkSEZaWlFvNkJhVlVLQlc4eG4zdnVacm40Mlk5ZmpSVXViMzNxaDQxY0x1cVl2dVBXaCtaNys5VmFxL1BjN3Zwemw3YWd4d1ltU0I5VkJtVlRVMWhBUitGY05uemhnQzRLS1lxbVpNc3YvT0JQYXZsY0ZMNHlIMmVralNwUGJjUTMvZ21vQkR1d2J0cGtpZUUrRENUcnBHVTZoYkIvd2cvVHU5d1hmdTZYa01UaXRCLy9ZWVZRWkFqbVpXYjhMNHNKZjVDRi9Wd2NSYnRaYno2TlB4VVpnZ1pMWXRBbmF0WTVlUExOMy9oWDQ5YTVSNjh4NG5JNVdFUFQ5M3lVcDJyZzRDcElZK0I1emROakxhR1hTamxSMGVFSlpmTlpVWWdsVThsbXZRRlZVY2pqT0NOOEdUUkFiQmdxUnJCY0x1YnplWnhOVmVWTUt2MkpUNzN5K2M5L2Z6R1RVQll6dTFaNzlWOS91ZnJXMjMvNEwvL1ZILzUvLytXOWIzNnJlM0xxOWp2MmVEU2JUT09CZC9lTko5WDNIdnlwSDd1K2trL0FFR1NpOHgyTjE0WG9KQklkTElLdUN4OGdRbldNeE5uNmMzUkxrSXZOWjRCL3NKRG9LaDRnTXFkMzVubCtPUjY3bklCWmlabTJkL2ZWcjMvNS8vcmZXc2VQaDhOSkpwZXRWcXZKVkZxUVpkT2VEY2ZtbGN2YjBKb1BIaDI4OGViYjBJV2YrdXpuVkYxYjJidml6OTFNdmhqamFmWHFjQmhDaXJuc2Q5YkpiSURZaDIxVEVnSC9hU3A5d3AwVVdBYjh5ckl5ajhYMlgvdWFJQ3JCUEFLdndmVm1paWpabmt2emtmazRFd1F5SnREd0NxM01FWkNhNG1LMjZ4RTlaSk1DMG9ZQk5nTDlrbFNrbkJSazh5dFdhcld3ZDNYbmhWZVN4ZkxjdGVjenJ6dTE3NTAwYSszTzFmWGk4MWN2d2EvdGpNYW9NK0VBRFhtcXZlbHFqKy9OWEZYUmtybDg3ZXorK2FPNy9VYmRNTklpTFJUK1BZRjZnY0M0UER5RUZYNlFGR0k0YkcvWU04c1RzRGhZS1d6N1VydXoxUEJJNUNXWUxqZW9uTEFQbDU5UXQ3T2l3eE5RMXFjWjJISHNpM0xSV2RsT3lzTDUvdm1kdDgvdXYzMSs1NzNYL3YxdlJOd3BlSUFrQ1lvcWRicDlVWlNnQmlWRkNsL3JCUzhucVlxS0lpL2kzS1hMVndWSmdNbFBKTFNVdElqUEhWRTJ6aHNkUVJSNmcvSFV0R1JWY1J3SDN0VmtPaTBXU2lBNTVWSXhtYUtIM1R6SERId0hHdGh6SFZrV1ZVMy8yRXN2ZDA1UHBNaDgvOTMzOTEvNzF0a2JiNXg4NHh0LzlMLzh3Mi8vaS8rUGMvY045L3lEUC9jM2ZrR01pUldKbCtPY0g0MVlrVVY3TmgrNjFPNnhHM1VqdkVzWFdyQkp0OENoMmQxWkJEWkhGemwzYUcrSUVXMXFiZWhLVW9aa3g4Wm50Zi94Yi8zeUI3LzNIeFE0RUxRU0tuaDVWQlFBcXVob09LNnNWdktGN01TY0ZvcUYrdzhmVHlibTl0YjZsZDNLYXJINDFqZGUvYU12Lyt1SGI3MW1HSWxzZVpXdWxMSStaYU5FWVlscWpCVDlzSUVJZDE1c2hybkRyR3pzbDJLQUFVU2tzTEw1OWpkK2o2TkZONkJHNlpvaHZIOW9EV0RJbmRHcUcvQjJvRkNnOWVGUWdhY1o4S0FBU3VEYmNRU2VCL1JuM293VDR0WjB1dkNjN1ZMeHlxWDFqc2ZQSkpVWHhjTFdwYjJYUHBYZDJKcmI1c3cyaDFOM3Y5bzhhVFRYY3BrWEx1L0JueG1aSm1rTGd0S0hDaG51d1dBeTZyZWFDb3hLbE92WHp2d2drcTlzY1BRR0VXUmt6V05jSll5aUZhelZNZnpROFdnWlNRSExFRGFlTXJIQUxvYXlQQkh1UytTcXNrQUhYeHdaUmloT3lhRWNVdkpGY1U4RHkvdmhOdXQrMmtaNnFOVGhFWEx6NlBGYmJ6ejUydStNanU3MlRwNk1HbWZ3K0ZBTXo4ZHMyd2tDdUVHKzQ5aXlvaENUcEpmV1JsTFpUTUpRZXAyZXFLa0E3bVE2U3FlU3dIRVE0V1ZKN0ErR1dpTFQ3ZlhoMVVFTitUTVBURmRSd084NWtLSjRYSlJsYVR3YVFYQXltUndYajdXYlRkQ2swV2lLWFdkbng3Rm9USlNWNnpkdTdPN3VlYTZ2Z0JvcGNpRkRUdU5mK0NzL2QyVmpRODlvY0tWR1FhVG5MN29nbUVSbkY5Ykltanl1OFpPcFl3N20weEUvSE1DdHBwZE9zdG5DNC9id0JjZThKTk1yVWpsVm5FenQxLyszZi84UGYra1hPWGRhTGhXcXRVYWhXSVR4VGlRTURKbGpPMUNqL1hZTGRDQ2JTVG53QUJhUlNpNk5VODBobmRia3hSZWVmL3U5OTRlZDlwMXZmdTN1dDcrbWFXcHhjNGNONTBWWEwzKy81MmU1bHczSGNnZkNVa0hST0MwVGFIbFRBVkwwemgvL1IwbVVjV3JZUmd3VlhYNUIxOFJpR0E1NlFUS3RHa0lYU1hBQVJrc1RoUFZjYXVqT29Ob1ZRYkJBM0JjTEtSN0hrSzBYYzlXei9ieXFlSHFaSmc2Z2lMaVlYZHU4L1BIUEZEWXZ1ZmJZbVU0Y3h6dHU5VTRCK256bXBXZHVBQjM5OFJqQVFvUXd6QUtxQmtzeUhJMlRSaXBaS1B1QmMvTDR6dXI2SHJ3dndoUHN6WkkrVUU2V1FpMUNQZGt2YXplTGZEUWdJYnlJUlh2eDg5OS9lNStsMGJINCt5aVVXV0Fpdy83cGg0U1NpZGN5SXpzWHhVUEJZMmVra2xseFByMkhhTnBwdlArMXI0NVA3ODFjSjVmTFRNZDJzOVZJWjlNSnd6ZzVQZ0dyeTZUVDdISkVWRkhWZENvMUdBd3hHSTVqQVg2S0xIc3UzZVVvbGNyMVdzMjByWFEyQzQwQzFFNG0wMTUvYU5yTzd2WW1WT2Q0YW5tdXZicFdXY3hwK1diVEJBSGhoNk5oTHB0T1pSTFRzYW1vQ3V4R05EcXo3VmtxbFgzODVIQnR0VFNaalBoWXZORnFna2hYS3VzLzlKTi80ZG96MTdxd3ExbDlHRVJINEJPVGNlZTg5ZjQzdnRYNDRFN3p3ZDFSYitDYUUrZzJhaURINjhsVVlXTmo0L0plOGVidGxLei90Yys5TkkzR3o2YmpyMzdsSzkvOGQvL082ZmNxbGNKME1zM20wb3NJVjYrMVV1bjBiTWJlUVNtTFlHdDhuSGZaeWkrN3U1dmppZG52ZEI4KzNpL2xVaXVWY29RWC91UHYvQUhkQzBKNzRCNkkwcVVYWHY2enYvaGZLTGtDQm8rNm1nMDdyRE1ieFhCckdaQ3dsQXMyVHNza0JCbzdscHQ5QjU3N0wvN3UzeDdzUC9RQ2lKK05UYWgyT0tsQU51d3NQSFI4U3p3dGt3TldReVkzRm9IL2VubXQvTUZwclQwMmVSNSt4UUsyR002cklmRXY3SzdteXNYQ0YzL0JMYTNSblJxY2tyRU4yRGp3KzVPSGQ5Nyt5bThkdnZlbU5SNzdnUzl5MFV0cnE1WHl5cVBUczVOcWphNnkwU0VVMkVIa1BVaUNJQ3N5U2xtOWRQTkgvOGF2NnF0cmM2Z0MyQnlXTjJReUZKaTRJQkNWWjVCYzdnb1J5WnErUkhDWS9OOS8rNEIrdzdERUtlMytFNEgxOFRKQ09jaENrcXlGTjNQWmg2V1FVb2U2bU5mdWYzRC9tNzhQeDVHbnlVZFdQcVZINDJpQVhqcy9uWmptdGF0WER2WVBYUnJPS0l5NHJpdFFFL2xzdmpmc0p4TkpJSDV0YldYLzRBaHd6MmJTdFhyOTB1VmR4M0xBV3hSWmVmdmRkMTk1NWNXejAwNjMwMTVkVzUzUFo1UHhhSFZ0QXdLZ2FXQTFudU82dzhGd01ySGdSR1pTQ1hCVFZWYTltWjlNYUtJcTZwbzJISmhzY1hUKzRZUEg1SUxOZzZ2WGIvN2lyL3hxY2JVOGNMeG16TzFIeFFkdjNmbjJiMzc1M3JlK05tZzJBOWVpaTNKOGZMVlNnY0pEMFM4OGYvdTk5ejhZRENFUlBud01kTUdmLzdFZnVYVHIxc1BUMDIvOC9oOVdzcWw1WktGQkoydjB4dmRCZnlqQmdvaEt2ejhzRmZQZGJoZGk2WHF3UWp4Y0YzTnNTZHc4RGhGUU5kT3hVN0lBVTJDazA3LzdoMS96bURNRDZhTEwxSkhJM2dzdi90VmYrNThEeUJyTi93bkhsdEpEcFVPQktUK2swNlFvK3FFQkQ4RjlnWTl3aTM1QUFwb25SLy9rYi85bGxSZWdOVnpiQXRheEs0QzFuUWVvTGpjUFFPamhUWExzMFZaZ0hid2RtdVg3YnV6Y2F3d2VWNXNDRnc4V3RPWU01UGJGN1RVWXVXZC84Q2VFblZ1K212Smw5UUoxQkpnWTJJUS9iNThkdmZuNy8rN2hhMThiOXpyK2JCYm5ZdXVsSXZqY2NhMSsxdTZRYmZtd25uUWRpb3RHQlo1THB0UFp0ZTB2L2VXL1ViaHkzVWNERjNSVGo1ckdXbytHSUNYRUxOMVkra2lnRGxoR1dXQ0hnTXo4TWc0S1U2Z3o2SGdXWVZVTlA5U0x5TS82a0dXaFRTTDQ5TXNPSXZ4SHJFN3I4UnV2anM0UEhuM3IxWlB2ZmsyY1d6UEhISTBHbHkvdENJSFhINDVpSEdkT0pvbTBBYTNRN2ZRZHgwMm1kTWQyVWRPdHpWWFRuSUxKQUsvUVo1dGJHdy92UHdJZG4wNG4yV3dXOHQ1c3RlT0M2RE9LS2ZBQ09FdzZtZXAwMmtaQ0wrWUxOaFFVK0pCdHg2R1A0anpHYkRRY2dTZVVTL2xtdlRrZVF4Wk1XUkhiclM0cURBRXJGb3Q4aEh2dHRkZWhJS0Z1Lzlvdi92THVwWTNtYUhKaXV0OTg5WnYvOEpmLzl1Ly9vLy9wK003YjFtaTBtSk5sVHlZTlZWWXk2ZVJrT2xsYlcwOW4wcjRMcTA0M1lPaE9Fc2JBOTM3bmQzNzMrT0hEbTljdW84TFJLQzlKaW1tNTI5dHJKOGZuZ1I4VVN6a3d1MzUva012blJxTXhETjM1ZVIzeURHa2JENmVIUjhjd0txVmNCam9NcFlLL3VTNjlSQWsrU1FoWmZQWHFOVkVTTm0vY0JvSlk1K05Ebko2RjhLSlhPRGJMbitVdkpkQWYyMHR4ZkVJY0dNbU1NL1BPNzc0RFRraGl6NlFLZEFiMEJoWVNISjA5aXpjSEx1bFpEZGdaRXBMWWFYZTBWOGhrazRsR2Z4U25WeVQ0TmtoWUZKNDY1d3k3d2FTbGx5OUZaSVVSYXpvUnd5YWRINnowMHZNZmYrWlRYOVF5MldHMzZWcG1ielN1TlZ1R3BtMnZya1ByVzdhOXJCenhMd0lkS2tYcm5qblQ2c1A3cGNwbUlsOUFJaU1UckVSODBZY3kwelZtb20xL01wRDhJQjk5MFFaYzFWK2l4dFBSN0V5c2M5Rm9HQTRpVnBURXltUmxoNEUxaE1HZEhRTXBoQ05tTmx2LzZPLzg5WHV2djlxdkhxWmtXdWpCODd4K3Q2dnBLbHc2Yno3WERHTU11c2JGZk0vaEhMZldiQU1SVUk3bzVLazVBV25YTlFWYVpnU0V4ZmhHclE1UEZHY3hRZGh0Ry9hZmdpZ0N0NG9rOWRwdHNDRFkwWGFuZ3dxQWw1K2RuZVZ5K2NGZ25NM2xadXpxQ1hTcm9nZ1lwcmdvWXBSTXk0RkdBY3FCR0VqRndjR2hhUTV6dVlLcWFwcWgvc1JQL3BsV3EvRjMvODkvNyt0ZitaMy84UC8reDROR25lbFE2ZzRNc0tJbzJWeStWQ3lYVjBwUWhPbVVjZm5xWmRmeHlxdnJVTlc2cXFUVG1YSzVITXo4ZkQ1THowRXdtV3QxZXRldjdENTVmRkJlcVVDL0dabzhHQXlnd3lsb01nUnlNcDRtMHltd0hVR1c0SmxBSHFBQ0pGV1JaS1ZaYjFtTy9kenRXNURNemMxdHlId21rMDJuMC9mZmZ1T2x6MzRCL1QxM3BoZ2VqdWdad1p3TkNZdkFHdEJXR0tjb0RSVUNiVDM5b1E4Q21yZXllZW5CZTI4dXBsT1BLWFhTbEZEN0JHNWFoV1pCU3AxM2FFVlVWbWlNZkJpTVlITThTY3ZTZHFYVUhBM0lBTTNwZ213K20rNzB1cVB1Y1B2N2ZzU3RQNGtiV1RZN2tLd1FUZ1JKQXU3eEhWZms5U3MzYjMvMmgvSTdlNjVyVDRiZ3BPTld0NjFLMGtxcEJGTk02NXl4NnVGQS9QcnpPYzJWTnljejIwcGtza2EyZ0VRVXlOcUhIS0hXcFJoRDZrZCtQeExJUDJCMWdIYi8yeGR1TzJtSXNHSElFWlpCbi9EQ0QxSXAwN0llK0FMS1o2UGg4UHpZNlRYdnZQcEhENzcrKys2NGc4SHlITG9nQ3hRNk5xejhBZ041QUVwYXlrS3pncWhJa3B4SjVZOE9qbUtBTTlRMHg2TS9kRjJIVXBjVmxWNzZadHFGUW5ZOG5DU1NoaWdDNFhTNUFKSWppdUtVV0xzQTgyb1kybUEwU1NSU3J1Tm9tZzdvSEJ5ZElBUDJvcEJLT1FmTFcydTA2WDdOSERSWVNFSmI2b1pwbWhBTXRCVjhsT2I5d1dNVHhNT2pvMWMrOWJGbnJsLzVyLy9yWC92Z3ZYZmRRUWMyQXNhYmd4SG5lQmxCa1ZkWDF0S3BYTGFRN2ZlR2hYd2FZaW5JZkwzUmFMWjdRUkRKWjlJcjVaSW9jVUpra1VxbkpoREU4ZGlkd2Q4b3dkNXNiMi9GdVdoQ2w0K096eXpiaFoyeGJRczFSUU1WbUNwNjZWSjBkYVVNZmMvSG9yS21zNWZRT3ppMzU0Rk91NFZpUHBYUVU2bk16V2R1eGdXdVhDaTBuang0NTQ5K1o3aC83L3lEdDAxNlZLSlZmWGgzYmszakN6OHljN200R0tOMWtEQlNJU1JDVGNoVUZ3M2lSd09Tb29Jb2x2YXVQM2pydFlWbkE5NEFMdExSYjBBbXNieEZ4QU1WRkNXbStha29HRjZmRmltSURVMVRqRVoyMXl2OXNTa0xmRXFCY3lRTkpoTllBMnZVbWpiYVJpckI2eG1DSHNrUWRHdzRGNFlxaFlTWUVDK3ViOS82MUJjdXZmeHBtTmRCdXo0WmpVQmxRWjhLdVR4NkR3RkFEcXNNc2ZHaDVFMXozT3RsOG1ValE0SVVOaWJVMnNzWTRaSTFtc25EMHhBbWh5Zm52dkJ6Znd0YjFDSEx5bEJ0S0Jla25LVWdzRUxvRUh3alFDajRJSHJ3blc5Lzk5OS91ZjN3N3RtOXQrMStRK1lEVVpBU0xDQUgrVEJ4VHBaQmVYbFY0TUdWUGQ4WGxiZ2lLcjBlcExtaEo5S1Q2UmlnQTIyRk5vVHVUa0Fha2duUURsNEFJT09JQTNRWUQ4ZzJlREFRRDBVUCtNRU5qZkZzYWhiVmtkWjlKdklRNHd3ZzJ0REJNTmZ5NGxvaGZYVGVBWVptZmdDSk9qK3ZRa08zMmozZDBEMXdlNHRlMjk0YmpIcjlnV1U3dDUrN0d0ak9sLy90YjJmU2lTdTcyNm9pNTNKWklCamNPcFBMcmExdFJmbTRvb2h3SGx6UEJmbkcyTU5kbGlWeGJYMWpPckUrK2VsUGYvREJIVGpaKzRjbnVlSUtGK1ZoOVZFMXVtY1o0MVVWcUlpaUNid2dWbXYxQklBdlM1QnBVWmFIVTJ2T2M0cXFtN2J0emViWlhCYmU5UDM3RDBDYnk4VjhGRjd2ZVgzUUcrenNiRlUydHM1T0RqTkpBK1BCeHlLVDRRQldzVk92K2FQdTJaMjNnMjZ0ZWZpbytlRE8wWnZmN0Q2NUp5cHFET0R0dHVSa2xzWXRIRUVhNHZBWFg2SDZvdEhGUjRjT01sS0hiMzZUQUVscW5TZ04zUUVpbkFMd1VjdDEwWWM4S2RxQXB2akhlZmpRT0p5OUs4MjV0QWJFajRqU2VDNXNHakllMzc5bkpJeHg2NHpYMDJJeXhWeHJGTW5jYXpvOXdTdGdaOGY0YWFuTTVlYy9kdXY3dnFUbGlvTk9jenpvalNkamVwbDlJakdiZVVUb1daVnhqQU05TUozVWp4L3F1cEZkV1dlMVpDM0Jmb1pZaUNPZGlhSWZDZXpvNVQvQi9lY0o3cXd5ZENRT1pBWFFvWWlRS2FKaTZRZi9qTDB0dUVYMGovLzVQOXQvNDZ1QWNTS1JuQXhIMEw4cjVZTGowcHUyQUhOWWE1NkxnWnBERTREOUtacThzN1dlVnVLbG5KRk1aS0hmRGc4UHdXTGNtYmV4c1FZNTVyaW80ODVVc0dORlJjZk5nMEFRNDY3cmk3STQ4MzNRQ1hCNlVCa3ltZ0owS0ZHNnlYakNDN3lzU0toa285bUVwQ2lxREUzdnVBNFVmN3NCdDNCQ0Y2Nmk5TmdsRkJiTWhLSHJ3MzUzcFZpb1YyditmREVGOTU3UFJVRjhmSERjQUhrd0xRZ1lMSGgvTUFDVXFYdGljYm9Xd01XajlISnNrQ0toM3FpWFZncXB0RDZkalBXRWJsbm01YXVYeHNQQi9wTURLSEtnWTI5M0Q1eEFFdU53VG1DWFVhWHAxSjdDRk5zdWpGazZsYmFtMXBXZGpmZmVmbjhlamFVem1jbG9ERXNGY0FVK3NXUkRWODVPcWdsRGg5bURzRlhyTGNNd2lzWDAyY25KcU4xT3BSSmdMekQyOEJjc3kwR0IxbVNjeWVZZ3ZPMW15NXBNWU4rS3VmVGpONzcxK0xXdlBYenQxYzJiejRsYWl0cEI0NGllb0Y4MjdteDg2VU9CaTBhS2Exc0hUKzQ3blJacUFiVk9ZODB1OVpQelNzQ0lnZUxqZEJMUFcvUU9IQXhIakJZemlFWlJsL0Ywc2wycDFJWkRuOTRPU0FnQkdldjFlNC91MzcvOXFSK0UvVVJwc0Jjb2hlbDRCaXY4TDFGS2JCdnB2S0tzWDMzbTl2Zi9jSEh2Mm5UWUc3U2FjT1NnQVdGYmZacERoUXJSMVY3b2R3RURJV2paWWhrQ3dScUZYVlIwMkJyOEVPZWlVekRrRW9MWkdaZVNRWE5tZmpuTUgyYW5ITlFqRitHaW5MQzMwRFY4SlBidDMvaGZPL3Z2Zy9OdWJxMGZQSDR5RDJnUlo5dXl3RTdBUHVDKzRaU1NMTkhMUlltWkUrR0RNVXBJVVZIVjRXY091eDFuUmxlN1JWN0FFSTZIWTVnQWRIU01GNGZEb2FiSk5HV2RQVHN6bndjZ3g5bHNqdG5TQ1BLZzhPRm9qSm9EOStnTDhDV0UwWGhLWmlUT2E0YUdUaStXVnFFdGNXb3ZtQ1VUQnZRNkhObkthdG15TFREN0xyaml5R3gxdXpGQlNHaGFOcE9CT1BYN2ZiQW04aGFpWUVvSktDK29XeEFEY0c2WUlDaVNsVkllWEdMWUgyT1FjUzQwRVAwd0MyYjE4OGFEUi91RlhBNEtxVkRNQU9pdnYvWWF5RlUrbjhmdzROU0twS1N6T1NBQnZySW9TYVBSQkx4YzE5VWg2SGc2RGFtRzRjcGtVcEFxbUlXREI0OWdER2Z6UmIzUnFxeXZ6R1lCM1U4UW9VMW5raUROZVhxbEJ5Z0d5bXcyTyt2WlZER2ZyVmZyMEFqcFRCWk9CZXhTUEJacHQ5cTBUSkxqanR1dFZGTDd6ci83alpYeVNselZ3K2NuR0VMWWFET055SWFXSE4vVlN6ZmYvZnJ2UmtDaGlOTUFFSlFUZ2RRN3MveG9EbGhnMmpBczIyUmFrTmdzVXQzQW4xam1UbkZsT0RWcGZlRUFyaTAzbXBpQkgxVWtyckYvTjVjcWNLcTJvQmY5MFJucGJJUXFZSjhLQ1ZHSmJYUnlMTTduVnplZS9jd1BiRHp6dk9mYXZVYlZzMjFBSGtZZVNHQ3NncHRhRTNmVTlpMnJVTmtVTkEwSFExcW9ERlk2QXpkVm5pVmN0SkZobU5wTlU4Uis3cGNwSFdnT3BZRHloSm5DUWlpRmFrVm5JN2cvK3ZxM3YvYi8rNmU3bC9aY0oraTJtc05CT3hxak5YZWdXZ0JHdXJ1Sm5sMHN5SytVUkRRZlJBV0pvTlR0b1psS0pLZkRRVktLcGZPcmQrN2RYMWtwemoxZjFGU29lUWdNOE9vNFZyNVFQRGc0a2tRaG13SGJtV0trb1hkUkdtZzZObGRXZ0ZxbjErblFsVVJGNzNaN2ptbk5BcC91VTQ3R1FDeGt3MGpxcmpOTEpBelhjVkVIZEJiTml4ZXBNbUE3Z0JjQVBScE5ZYml2WGQ2bE5VZG5YaWFkNG1KRTJPRk14MFVKbWhaMmREd3hvZWFuSTBpZ0JvaGJwbG1wbEFGUTJCWkQwMXdQcFNYaG85KzVjeGNzYW5XMWpBNVNGUlVPS05pL2tjb21raGtvYkZXSFZLTUhmSHM2MVEzVnRsd3V0cmg2ZFhNd21LRHpJYlF6ejA2bUVtank2a29PL0NwYktyZXExZFhWQ2sxWWNHZndIbE82RE4vZEFZbjI1MmdGak4rNFB6dytPb2JLOUtPUnplME5UWlVMaFp5MENHYUx5R2pRaDZYZ2hYZ3N4bG5EWHZYZU81eHI5ZzhmbXAxV2NYMTlBWm1DMWdxSEZBRWFoZENCM3dYNmhUZVNCMjk5RzV3ZG9DRVdBVkNRODBOMG5sREJsZ2hXakFTMGpHdGJYbVFCZ1ErWU9vZjI3bzZHcTdtYzYzc1RtUFQ1Z3E2d3pienEvc1ArK1lrd2Q3UHJ1eEZaSldDeE0rTXZ4TnF5SGl6K0ZMTTRhYXBRdXY3eHoxNTY0Uk96UmRDdG44R0pJWitOWkEvYWhwdUFRUTdhRWRmTmxOZml1b0hqUXNsQlVRenhGRWVNMHFsc3hNTVUrdWErOExPL1JDZTlrQWVrL1luQStvWHlrdUd4dkgvMTkvOHJMaFlrRXhrZjFNMGVZYnhsVGZFc0Q5U2kxV3FsMHBuUmFKREw1dEJOcXFvQWxJQ0NxcXErQzZVQXMrNjF1Mk43anVIams2bXNZN3V5cnBDdnNDQkdHSEwzVERyVGJyVmN5N3B4NHpyZ0MrY1NCRDFzRUF3c2RBOTZCS3E3VUNnMG15Mm9aSENQaEE3K21VVFZGY0FURkxsYVM2WkJIRkpRWjFDNi9XNC9uVTJEVGVxcUNsTUFzdVFITTNCOU5BcmVCVWdYVFVXak4yMUVOSGJWQk0zS1pQUHRUaC85cXl1U3BxbG9DMXhHTUMxYTdYWnFnbGJpRzlLUlRLWFliUFZFcHdPbWtUdzdQWWRQK2VhYmIrM3M3ank4L3lDYlNWVlc4dFh6aHF4b0J3ZVBZYzFRUTdpcVY2NWRocEFYUzNtb3JuYTdVeXhtSWNtMjdmYjdJN2pGbVZ5S1RMaXFRcTlYVmdxb05oUzVua2lCTGtOY0M5bk1ZRGhFcXp2ZFBoRFE2clIwV2ZLQ3lMalY0ZWF4S1FpQW9oV3pXY2YzRC9ZUHIxemFIUTVHeFhKNU1oNzUwK0c5ci8veCtkMTNaNk5ldnBpUHdBS2p3YlFBRTBNYncwSmxZL2ZzN0dqYXFNSXdJaFdLQmcxSEo5RHdoSElSZ1VVVVZFMVRSQ0dBSGc4Q1VaWWs4aVFwUjNzNHlTV1M5TENmeDU3UWprUmczVjNIVTZFZ3ZGbHU3d1pTQ0hzaHhPaWN5NU9IZ1U3QnpvRkEraGEwUHAyOTh1SXJWMS8rVEN3ZUh6U3FIT3dGZXhzaDhwcW1DUldTTG0rbEs2dmhzMGRNYkZFY0ZVbmJWREphUmQ5aG9lRjV1Qy8rbFYrbVRHRkNtUFpob0l3NENtMGxBczNGL3ZDZi9kTng0OER5bkh3dTMydlg2SzFCSWlqMUhMb0I1d1BXZ1NKQXpuRnRkTk5nMEVmRk1YYlFDNlpsUjZKOGZ6Q2FSM2pUaHRQcDJvNFhSRG1pNXV5UkxYQnVuRzVHVitLVEFCTTBMVm94R0F6UlpabHNoby9GUitNaFRQbDBZZ0lLZEhFZ0ZtMDI2cWdlQ0QrVUdSUi9OcHNPSjNBZkg1MXdIQytLY1ZBVWNNZVo1OExSaEdNQVhnUUpwSmZiMFN2eWVFaEdRa2ZkZkRqSG9FN3dnelZkQllnaDJtRDFkT044RGs4U0h1ZFVWUlRRS1BhOEcxUXFKMHZ5bzBjUGFUNVBKQ2JTM1NHeHNscnA5d1lnVGloTjFmVE56UldJSDhkSFliVlFFOGkvcXFrWXpVRi81RHAydnpzQUtHSDVVMmtqeWd1SHgrZkQ4VFNWTGFEQzd0VHFkZnVLb1FEWjZIaDZFYkUzZ3czd1hCZDFTTUo3czIzWWJ2Q1crY3pQSkJPd1A2V1Zjb3dEbnJ5aGJUZTdnOTNkVFh2bWdERWlmenFYQmMyVFFLRWtxZE9CSmpJY2RHTHQrSzNmL2UzQmszdW43MzkzKythekxwanhlTVFwR28xeU5MWjc0NFczdnYySHZtbEJtY1BlemhpM2diNGxIQkVTSW5DcklJMmxmS2JXNmFwUVJwNEZqUWJtaWM2QkhocFp0aUlySUxEb1FNclBMdTJyNlJTc1ZQbjZzK3pSRFlZby9KTjhVUlMvd0QwRDVJY0JpVWloeEhsRU5SSTd6NzE4N1JQZkwrdkd0TjhGUkpBZnhHb3dIdXJ4Mk5xbDZ6RUYyRU5na2tPSUovMU1iZ29ET3AyR3FrKy8rT2UrU0s0cVNScUZzQTdmRTNBVW1rdVhZK1ZZL0QvK28vOGhHdk4wSmNGSFpyUmNSeFJ3RjZBR2dBVUFGSlRVcHhtT1BPZ2pjS3lwT3J4VlFCYW5CaENSQ2Z3R0JObHhQQ09oWkhOWklDOVhLR0pFd2ExQkdKQUJqTFBkYmV1NlBwMmFkKy9lTlJKSmVKK3VCMkdtYTRqcm0rdFFvckFoQXMycm9ZQjJ3SldSWlNuTGVMRHYrOEF4Q2h3Tnh4Z3RLQ2NjQ0paRjB4bG8vQ0FYM09sSjlmeXNic2lDZ3JvSUhOaC9TbGQwV1lBVERkZFYwWFVJRzNyRGN4MGprWUQ1M3R2Wmd0dEVsMDNnRnMrallCVHdWcUhEMERXdytMMXVGM1dBQkQ1NjhQamExYXVjQUFPQzdvQ3JBaUQ1MDlFMHh2SDFlclZZS2tpU0FnRUQ1NXRNekZRNm1jNmtvYzdCZEdPUnhidnZ2ZzlDVWk1bXdVY0VManJxOUVpSnFwcG4yWjFHQitmdE5kdXU2d0tPcXFFTXVvTjJ1d3VRemYyQTdsSUYvbmd3eUdTU3JlNUFWaVVCVGZVZ0hSNmtORi9JTlJwdGRIaWowY3l4MnhFRWhzVkM1T1BEUVMrbGlFZnZmWGYvOVZmUDN2cVdyaW1KbFUzNEJYUkpwTEQyNER0ZmhiTkY0eDREam1jMC9nUU13Z2o2SFAycENWdzZvVUZ6djNKdGM3L1dua1dpY1ZycTNrYys5bjRSakU4YzVBdHdndDN5UmtOSno1WjJkc1ZFa3FZZnNWSUk1dVMrSWxEWk9CZEtaaHNoRmtOVmpXd005NHNJak96NjlXZHZmdXBMK1kxdDI1NzY5Z1NTZDNiNEtDM0o1ZXZQaCtJUmxzd09wdkIwaGpEOWhJVUQ3bDlnM0owUVQ3dnBkTFQ1WWFBRTJEd1lpTk4zUG5qeTVxdXliR0JJK0hnVVdoSjZUcEpKa2FBODVMUE1LUUNGZXZ2c3BnVU0zV2cwOHVDV0JvRnR3WjNscDZaSks4M3lzSWx5WlcwVm5ac3I1TTlPVG1Ha1VBSXlvS044K0NUUkNMUW0vSEpRZHFRUkN6THRkRG9kRitucUpJZzdER203MVRFdE01MU93aTBqalRLZlFlc1FDR0JxZEQxZ3J5QWxmaTlKWitmbnJodTRybS9iampXMVZMcklSUzRPUEFvUTRsdytVY3dtOVlReHNaenh4QlprYVRRY2dUNkJ1a3pIdzJSQ1F6a2N1eTVFVTE4V29HRXhBRHFmVDhjaXNWcTFOcDFPd0R6ZWVmTWRYVGM2YldDTHI1THZTTGRGTlZWNStQaGcyaDgyRytBemFqYVRBT3pvRnRoaWtVaW11RGl2Ry9BOTJnZVBudkN5QWcrMVdNaVpNRkx0UGd3bTFIT3ZQMmljMXZqNUhPZ0ZkSGd2MEJPYTUvdU5lZ05HRXRvWDVjTloxSFRsK0t4cVdXWStuVHc3T2dOd0hYK21hR3F4WERrL3EyR1VlVUVjRFljZ1lOREJRQ1Q0Yjc2WVV3eHQxTytEcXNtUnlNNW00ZDQzdnBvcDVBZnRoai91cmxaV1FTdXI5KzR3dzB2Y0hRRTJNMFFEVWlETEVUNitrVTJmOXdkNVRkbk9HNFBSWkFMT3lYRWl2Vk43TWJGcHJBVlJndUJEWWtqRGNySEhiMy9yeHN2ZkQ4N0tVQWdZMCtVVEJsSUdPSHpqRi84aFZPa1lTZ1lta1VnZlFqNjRWRHkvdG5Yams1L2J2dld5cEdwejE2a2ZQOW05K1h3OFNSZWdRb0g1TUlSVnByT0VwZElwdUMvOC9DOFQwTm0rNWNrK0RHRWQ2SUhPZURUMjJwZS9iSnNkU1lnYnVvUVJ4YWlJRWhreVhhZjNra2RnVXlFRXRBWlZJQ2txWFk3VUZPaVlZaW1YeWFYUlRWRFk0Qkt4V0FSOUFRM25XUGJqUjQrZ3RFRFFBVXFnaW8vSGtaOGVKb2hFZ0ZReUdmUTZhSy9USVFRc2dzaG8yRHM1T3NKWnA1YXp2cmFHbHFCWVpFYWZndkRZdGcwQXdTbUVlZ1pDNEZ6Q0VHdTZRZmU4aUJmQ0RrZkFvSExGSEZ6cTBXaFlYbHNaVDZlWmRKSk5TbGs4T2FybEMvUWU2dUZnQUc2V3ptYkFXL0RYN1hSQWRrZUR3WHhPR2gza1BwZlB3bTN0OTRjSUdOVHR6WjNHNmFtUzBMZDNkbTNIQlhNN1BqMUh6cGRlZk9IKyszZHZQWGRyYlcxbGF0SHNobmE3ZmVQNkZXRDk1UFJNMDluN1lVQmFJRXc4VlBVY3hYWnJqUURFRCs1K0pnMlhJSk9nWjNDeitXd0VRc2I4akxnaVIvMUZJcFdDbW1qVm0xRXVLc1k0c0FoRjFRTEhpd3Fpa1RTaVhKd2V3UVZTRnhGSUw5cTJzbEpDUjBHWFlDanJ0VHBzRWFpa1E1ZkplWlE1R285TjAya2RQbjc0MnRmTjF2blJPOS94MnMyOTNTME1BZWdmS1MrbWdRZ0tETzVBUDlBb3h1T3lKSHh3ZEg1cm8zUmxCYjJWT0czMjdKa1BweWpPeFd3b0pMcGNBY1REY1FWVHRaenBOSkhLNUxiMllERHBIdVJUcEZHcEYvOVBBOVBXb1piR0YvdlFCdkl3NFltcXFlem1NeTljZitYejI5ZHZTM295cXFqZmUveEZjY3RFSXZQWXdMSGNsMzZXdUh1NGRSSENHTnBIMGdXYkF5TWxSS0ovOE0vL2NjS1E1b0VEWCtYczdFeVU2VElpZERDamJ1RFZBWFF6MUJQb0Ixd3V3SDAyODVLR2NYQ3dmK3U1MjgxNkU3QUdhNGFBQVVhdUE0ZlFBYU9scTRlNk9oeU9nSWJwWklMQlJnYm9GUlFIaW9LKzFsUm80Z1ZLaHYxOTh1U0pZZWlpcUdDd29MK1RobTRrazhBeDZMNWwyY2xrMHJiZ3duUHdkSW5lNUdneUZvVElTT2pRcWJJaXJtMnU1M0labm84Vml5bG82OUhVUVhXYTdYNk1GMlJkTHhRTHZjRUFjclc2dW1wQnpZNG5KSUUwYXowR2svTG80UlBUdEtIZzY0MmFwZ0ZTM0tNSFQzWjNkekxwTkVRVlRBd2N2dDJtMVhjWGtZQ1A4NzBlT2REZHdTQllCRkNscUVOZ2U1UGhVQktoVHhjUEh6NEc1b2gwUVdiNlBYd1poZ2JmdWRsbzd6NXpNNUdscXgvd1RCY093VWFNeDZxMUJseUY4MW9kWFZNc2wzcWpvYTdwNVVwbE5CMkxpbWlCSFdWemVnSXBaV2MyUTRVbFdYUmRHK01IeVI5UHhwRDJzSDk4ZEc4a0twTWFzakxwQkJEYzZnem1FYllFY1Q0TGFacTUzckRYZ3l0c1dWUEF0RlFzNys3dHBOUFpicmNIbEtOQVFuMHNCbTBDSjJhalVHaVB4aDE0Mkh6MDJrWnhhNlBTbnBpVGlRVlFRVS9NYUw1Tm9LaWdpQTZFRDlaLy8rNjdWMjYrSktVempNb3dQVW8zczBpakU4d0ljUXgzVHdNMkx6NHNOOWd6Z3o2Wkd2eEdZd0lQbThzcDlNSzJEOEc3RE9HUnkvSlp2WW5RY3ovdzg3OThnZlNuaDFDRThrWVhHQU9vZG96aC9hKzkyamw4RnpTbTJXcjBlajJNS0xSUktwMkNUb1VTcGRuUml3WGk4SXZJdnNzU3JETVVTRGFmVVNURlNCZ2cwNkFTd0tkbFdtenVhQVRhQlVOb0dBYTBLVTVvMjFZdWw0VU93cm5CZXNGejRrSmNrYVNEZzROTUpnRUJBejBxNXd1Z3k1QVdsRk9yRXdMQVo0ckZJa3pFWURBQ1Y0RytuRGsyeWpRdE1HL3Q0T0FJbWhPZERqYWw2cG9EVmVsQVVweCtiL3p1dS9laEwxRk5tS05nQnVmUEhnOUhuQUFCbTJ1NkZzeTgwOU96VXJrSUJ4ZDlDOUNrMHlueVlyM2c3THdLR3cyTmQzNXlzcksybWt3bGZOK0cvUFQ2WGNmMlFlV2J6YllzS2UxR00xOHFaVUQ1ODNrME1LR0RoOHhRbWUyOVMyZVBEL3VqZ1dWYmhoamZLQlVhWitmUHZYUmJvelhsWkhjeGYrSGxGMDVPVHVGTTZ3cHdEa1U0aDlsY1FFRllkaTZWT1c4MWkrWDhZRFNHTm5FOWU5RHQxMnAxVlUraHIwQnlCb05CcjkvRFdmS0ZERXlqcXNod2krRkt3M29vOEhSVFdyODNCQ2ZFTHNlMmtxa1VRSUJod2w1QUNVcm85UFI4Mk91ajV3K09qZ2I5QVhURTdlZHZ3Y0JtczFsWmxTR1Y1SjdKQm1nYitoQXFDWjVQSVpVOHFMZHppbXg3OWtwVys5eW5QOTNwdHpyRE1RWVU2cC9tQXZpZWFxUm1QcjByQ3RxemZYWjAvZVhQd0tBUnZKNHEyUENIOE14Z3QveWlFRXJDMDgyTEVPcGhpdUJRQnRabG9EUkdnRmhweStQQ1pBcG81Zy84d2krVENMQkVSQzdpNUo3U0pyQWVpZHo5d3o5NiszZi9OUXdzZEh5MzEzLyt1VnVxb1dleTJmRmc1TS9td0RxY01ITTZCU1dnV2FMc1JpYSsyM1IxSEQ3bHZOM3V3SGI3Z1E4YmlpNER3VTBramJtL1FBVGt2dDFvUVd5QUp3QzZXQ3oxK24zVUJKS0RraUVEbVV3R1E0TEJnT0x2RFBvYjYrc3d3S0M4YUdRaGw0TW9RdlpBVEMzTGhlekN3OU0wRlVNRmxnWFhFSkF0cjVROW1tRVd0eTNibk5xbWFlR000RXZVWVRCSHZBZ1RWS3RWd2JJa1dUazVPSWE2Z2MxcFZLdlBQUE1NVEJEY1gxVEdjMmNRaGhzM2JoenY3eXZRdzZvS0FhNlV5eWhxT0psT1JuQ0xpVCtRbjJja3l1V3lPM01tcHVYWnp1cHFCVnlvdUxMaWViWS9qeVJTU2VpelhLVjhmblJ5ZEh3NkhJd2tnWjUwQnAwbjk3SGZ6NVhMZ0tLa0tGcENheng2ZU5ab0xUaW85bllxYWNpcWNseXRQbmZycHFLcng4ZG40TzdwWkFxK1VBSTlsMGs1cnJ1enRlR1BKMFBiZzZ1d3ZibmFhc04vVFlNbW9tbXZ2dm8xMUFyYURmVFNNaDJNT3grTmlrSVV2QTZPTENxUDRUZytQczJtaytDRXArZm5Bc2V0cmF6aUZIQ3NYM3Y5dTNBZTluWjNNRFM2cWtFRlhMcDhDYjBLL2QwYmpsYVNpYjV0ZFlhVE5DMTV3c21pOE9LdHl5azRNTjBoM1NXbWVXWTBNVWhWay9SYWtVWFVtUXhjMTlxNjhTSzdVUGtVaGhTV1lBMERpNUlOQ0xGTFVRWk05cUYwNEpPaGxGTG9RSGJUaWtYUVRGWVVRei83QU9TVURiRkZsUHZpbi90cFRwUmlFRy9hUjRZQ3YvakdKbjFIb3NmZmZmUDlQL2hOUTRVZndzUG83K3p1bVNZOUxhRW9LdEFEZjlMemlDalBGM04wT3FDdnFMSkE2d2pNb1FBNjdTNDBLNWc5dUQ1d0VvOUh5ZjJVUkpnMm1FNWtvYmxRME9XU0JBM2Q2L1pNeXdLMDRmSkNnMXEyRGRvTmdXRTNaYUdRSExCMjZCWHdwWHd1SzRtaTQ1S09nVDBCdVVSOXdLcEhvNm1zU3BDclZDcHRtbE11eXRtMm1Vd1lPQVhOYUpnRlVINHE2R3pFbDNqdVlQOGdYOHlJY1hpbHN1L1RxMCtoaEVEUHdqTUs5QjBRTldwM1lZNVFhMWduc2crdU14akNoVTAwMjYyTm5hMVNzWFIrZWk3S0VyZ3FSQm84ZUdwTzBYUE5WbmRqY3hOMno3SXNWSmlXOTNjZCtMS09iZmZhN2JWaTZjclZ5M3lVTHZqM1I5UEtTdkdkOSs0RXNlamFhdVdQZnY4UDc5MjUxeml2UnlWcE9EWm5qZy8zTHBQUWViVEZjWGYzTnZZUGorN2RmMnlOYVk0a1NFaVN2UnpQczAxRDVHaVdqaEFmamtmRlFoN1VTd0J6a3VSMnQzdjQ1R0NsWElRRkFIMkN1a0c3WU9WUzBxSlJhM1lHMDBJeFAvTmNsQVlaeHJHYm14VzB0OTVvZk94akwwRmZOQm90ak8vaHdXRTZSY0Z5ek8rKytSYms0ZXIxYTBZeWRWNnRKbFcxTlRaaDNUdG9pQ0ZseXBWZzJubis5ak1uMWJwUEw2b2piRHF1RFJVQkJRTTJDM3QwL1lWWE9MZ3VwSmhKTlRNc1B2MUdJR2lTV21jN1diWmxZQkNuZ0dLWDZTSDRLY0srS2JBWUEzcjRZZjhVOE1zVnhibm5tTm5WVGJxYkExNUUycGtJRE1uSWJQYmtXOTk0OU0zZnlhUlZRQTJ1cEVsdkhiZmg5TkJNaHZrQ2ZCRWFHcVVFbmdlNnpXNU1jdlJhSU9BK0Z0dmUyWUdqaVM2SGNvS2ZDRFYvZmxiRGdMWGJmWFRjREJDWWVmU1VQbDJ5VkhHVW5raW80UEg5WGo2ZlI5ZmpqRkRKcURrZ3huSHhiRFlUekFMYmR1bnVLeDhENFlGcm5FcW1mSnBhTUFlWWdIZFVDWHdtbWM3TWdybGwydlI4aGFxbU1tblg4MUVnekFMVWZ6cWhRUGZPNW40Nm00YU5WalY0dCtRc0FJdWFTck8wUVdiU3VjeU1acVRSVExMdG5TMVJWbWxaaldpVVhuVkVTelh4T0YyL053Q0w1UVFSakptUHh0NSs2MTFWU3pUckRhQXFtVWkxRysxSUZGZzN3YVFnRzdidGlXSWNpTkdoSkJMR1FwUWhPOGZIaDBlMXBwS0FRY2dMc2Jpc0d4SFBLMmVTVUxmckFQNWF5VGZ0VW1WRlVYQm9mREoxYU5WU2tNbDYwNXNGVjY1Y3FaU0xjL1RDakRDelFHUyt3T0J3SEE5OWoyRkZYMEtEZEp1dEQ5Ni9oNjdmMjFpck45dWowYmhVTHRuV0ZDUldNdExzaWVzWTJnTGRKU2tTK0QzSXgvSEJVYkdVQjl2R3FidTlicXZaV2Ftc3RPRGk5SHYzN3QzWE5lWGxqNzM4d1FjZkNMRW9LSDRxQ1hmYTZJeUd6YzVJRVFWNjk1akF3MUxDQ2NnYVJ0NlFHNlBKSE00QnphNXh3ZGVnbFAyWk8yN1ZzeXZyVWlyOVVXZ3lIVXNSU21UWXhKNm5RRWVnN1dVeVJaaUtaeEg2cFJqajc5RDZvVkNRTldCWjJFMGpraC9heTEyN3ZOdmFmMXgvZktmKzVQN0RiMy9WR2pRVzhKS200eWV2Zit2cnYvNVBxNC9lOHgzM3laUEhxZ292bjFZR1JCVndORGlaYTgvbWN4OUVBN1F5b1B2R05CdE9Fc1FuQjRjcksyWFFkOXV5b0VqZzRzQnFpeFFrdUhUSlpGcFZOYkNGUk1vQXBHQWZRTUVMeGVKNE5PbjF1c1BoRUNRN0xzQlZjc0FOUUtjNFB0NXRkOUFTUUFmZjRPVjBZUmx1WExDUUZCbENPWE45S05TMTlUWEFQcHROVHlZWVRSUDlDMzBQalE3OUNocFFLbVpkRiswZ2NnL2prNitVVEF5eU82TkpMRFJMQjBJckZvb1p5T1FzRXUxMXVybDBBbGpKNUhMb1BaQzZzN1B6VWlFUFBZM2FRcnBnUmtDeFlCTUFidGozZ3ljUDAxbHM2aXViNjBUUEJtUGJCRE5PcnF5VWF1ZlYxZlVLdFc0OGhNUW1VeG5WVUNkVGk2NkhtTk5LTVUvUE9HbEtkT2Fsa29xYWhBUFFUK1V5a2s2dWNEcXBpWXJrQkJDL2hETzEwcmxzcDlNVkZndEZrRmZXMW1EOU9wMjJJQ3VtWTZsaVBDbHkrZlcxTVJ4c3k0VHJYejA2clZacng4Y25NS09wWEdGN2U2ZXl0VFdaVEpMSkZMd2RDSU1RRjFxTlpybGNndTFGUzRIeWc0ZjcxbVFFTXBPRDA1cFBveXU0T0RlYVRPdjFldURQaHFNeEZFY2NXT2E1ODdQVG16ZXVQN3ozWU81QmFYaHBuTS9RbXIxZU5QQW5qcithRkxPbHRXR25scUgxQ0t5UDM3Nys4TFRxemdKWmtGdzJaUkt5T2V6VUIvWEdsWTkvUDVzK0Ewd2lBS09FVFlKa21JQkFHdVlqZ2JhWGVmQzlUQXVGaEgzQ0hDeVI1VmdHOGlyeEUwb090NUpNandhRGxDYmEzVjZ2V20wZjc1OS84SDc5M252dG84ZEpIVDBwZ0YzQUpUNDVQcWZIcUdmQm9OOHZGTEp4RGw2ZEg0bk9kVldmV2c2WktsWWdVSzdLQ21BRW1nNm9vWU5jeUxYajlRYzk4bWk1S0MvQUtJT1lXSEFRVzYwMjRBUWkyR2cyNlVhMzc2ZVRTYkFnUTArZ2hwUEpLR0ZvOEZaVldlOTB1NGFoeC9tNGJtaXVZK2Z6UlNGTzF4bUJlNWdhcU05Y3FSRG5oZkY0REFHREJRZjNoWnpCSndOR081M09aRXdFZzY1VTZqUm1qbVhYNm0wY0MzbW9ySmNoM1hSeHlUS1BRQlFPanNhajBaVnJWeVJaQUtkQ2UzdlE0cEZZcFZLQ2JvTVBDaG5lM3QwQzhrRG1Jc0Y4OTlMV1pHakNmNFhCbWRHOTVNWDVTUjFHQTI3Y3NOMEJlelpTQ1VtUTNudjN6dXBxMGZVODJBUDBkaXdHSlRjYjkvdTZBUitHRmpuSTUxSXdkUEFRK3QweHZDUDROOFZpYmdKdTNoL0NzSXFHdW9pQyszS3FKSGtZdVNoNVVKWDFEYysyR21lMStTS3F5SHF6M1g3M3ZUc1lDMFVFdGFSNUNGRS95Q1NTOEgxQm44YlRTZlg4UEpOS3duczBKTEhmYVJaTFpkUUhLc3ozZkVtU2UvM0JaRHgwYlJ0QW45Q0ZkSE0yTVZkV2lzekFMbURUWUVEaDJNRFpXQVR6WnFOWk1ORHJlZ1F1ZFNFUDllUUhpMmFuSnd2eG5DcGp3T0hYZVpQQmJNSHhjLy9QL1prLzllYWpBMnRpUXdkQjkwSHNGN1NxUG4vNXVZOXpkTm1OS0FWOUV6NmZZcFRnRzM2STFvVEorQTZubHkwM25uNkkyN0JFRmo3QzhzTnQ5cjBNM0dheGdGNVUwUEZHRWt3NmtVaGhrTUFKMEdIUTF5TE12eEJYRXhxOExwcVlDaDlmMVl4RW90Vm9ueHdER1dNdUxrQzhBVjlvQ0dTRjFvZFpCRXNtMllCdnl2UXJWUDdCNFFGR3JWWnIzTHQ3SDZ5aldtMUFUeFR6QlQvd3dPVzc3VDdvTWlnanFBWFVxZWZUWkdCZDE5RDEwTHRRU0NxOTVHUU9pOVJzdG92RkFpMWZGRjBZUmdMZUowUnJPSnAwdXgzUEFSU24wUHlnTk9QUkVBTUp0TUFKamd2MEFERXNieWFkSFk5SHBVckpjVUJVUExnS08zU1ZMUWxaZXZlZDkyQ2pqazdQdHJlMjRDa2lRL1c4WVJnS3ZEU01EVnBFVStkbjZCVllLMXBYRVdkaHZUZjNYQ2VWU0Z5N2VjMHhSeWVuWjhta0FlVzlzckp5Zm55TTdGd2MxZ1BNenI3OTNMTkJSRUIzZ0FwQmtBSjZKVWFVcnAvNE01eG9ObCswZWdOVmw2SDFsUmgzY2xZOU9EeDY1WlZQVDBkamVPRkF0bU9hbVdJK29XbTBPS2x0ZzF3eGg4UzdmLzlST1pzQ3BUUVM2djcrSVNxSDBibCs2d2JvSDZSUlQycUZRdTdvNUdSc1dqVFpNeEtoVndrSW9qMWhyOTZiejF1MTZuQThTU1hUaDRjSERueFkyNFlBZzlnOGVid3Z4MkxWVmh2YzhQVHNQR3VreHBNSmJGb2t4blVIZzlYMUZkamVWcmNuY0x5VzBHMVFVcytEOFlFekU0OXhFOXNzRzVLZUtneTc5WVNlYlBZSGFqenl3bWMrOWRXdnZVRjNNYUlZUmFLYzhNVUV5U2hmdVRZbk5CTGM2WGVwdmIvM2c2OWxKRXdCdUNuQ3REaHQvaDhFQ0FEVVFpZ0pIMmJqbnJsNnZiaTJkdnpvVUV0cmNJeWdwREhHa0ZjVVorZ3Fjay9OTVJ3MW5vL0tBZ2RWeDR0eG11VTVEekw1WERxZElVRGdtRVVNVXJHZ3BYaUFBSm9MM2UvMThLT3pBSkx0T2s2eFVFaENlZnVSWnFzWllnakt5Yll0ZUhlZUQzYk8wN1huV015Z2xYeFZuQUM5S0N2S1lERDJQSWVlaHFPYmdvRnVxTkRhOEJSb1BuaGNtbmsrZkVySE1XZnViTkNEeHFYSlZTS29vemNEOFlENFRVMGIrUUVTeUNTdHllYzQ0L0drMWVqbWdCNURSNmNOK29OY050czRQWU5aaDJBa2tnWkljTDVZcElzdDg0QXUyL2x6RUMxVlUzUk5SWDY0NXREUW9BRVF2R3IxRFAyU3ppUlF2V3J0ck5lYndsNWR2clF4OS8xMnAxdFoyNERWS3BVTHJXWnpQQm1NK3oySUhRL2NDWHl0VnMxbE1qQmY2TW5qMCtwNlpXWHF1SFRGZEJGVFpBRjA0cnhhdjNmdlhxOC9TcWQwdU1LMVZzZTBIYkNNazlOcVpXMHRuVFBPVHMvQnQwVkpQamcrNlEzNnpoUnEzZDNkM2ltdHJzVGd2MnJ4UkRiWGJYZlZaTEkvbkVMSXlWcE9wNXU3bTBNQVZ4RVgzT0wrdmNlWlFoNGdrdEJuaGpGcXRqUkpSTS9QUFMrYlNzZGhyeld0UHhoNXJuZjEraDR2eVhCYnlUanpISHJqdVJzM1VScmdDd3Y1NlBDd1hxOEZjSUo1bmwxSGp4VlZvVG5zUTVkRi9hbVJ5alZibmR0WE41LzBCdld6SmpvSzBBUHFZVmh5cGZXVnk5ZWpna1RRQkRBWmZBbWhNTVRzK2lNb2Y1aUliMEk0UlFpeWhIU2tMQlU2eThBaTRVWExjQ1BrTG1FSzI2YUFHUGZ5eHoraGdEU0FoR29HUE9kZXQzTjhlb1RSVGFYUzRMY2dHT0Iyd0RTVUFicHBNclVoNG5PZkNERzROVUIvZG5xV3phWFJiRCtZUVg5REdhTmNTUlNBYkhRTk1Bay9DWDJBWFloekhOQk1GL0xRY1JocGVEL0lBbGRTVmZUUkVDU2lUN2VpZ2dCa09rNHZJNDMyZS8xdWR6Q2RUcnU5ZGphVGhzTEdlU1JKZ1phRnVaeEE1NHpIRURDWWdzbHdVbDZ0d09tRUt2VnBYUy9nS282elFPM1JTcXRpSEIwRWFRR0lwNVBwenM0bWJBaWJFMG1USW0zWDNkclpTaVlUb05IZ1NLREZhQnlvTFZoKytGRVZGYndkRkF3K01xd1d1Z1VhT3BOTm54eWRRNlh0N3UzT0krQzNBVXJHc2FQUk5ES1BiZTV1ajhiandQZDduZllBZ3RqdEFrdUZZaG05d1hIelJNS3diVk5YVkNpVjRXaTR0N3N6blpxQmJXbUdXbTEzSnBiMXBVL2RudlFuRVlFSG1WWmtDWmp6TEpmblFRMTgwSjd4Y0lMQlRxUVN2WG85cldzd2FzL2V1b1doVlJLNklQS09PWDd3K0dCcmI4L1FGV2dyeUQvTVdzUng0N0lDNmloS1ltODRRdmRDa29maktVWkJOM1IwVFdUdUowbWU0VEtMY2xJZkRDZWVhOFhtaTF5cCtQb2I3L1M3dllTQ2NwSVFMWXkwT1oyZ0ppaXExbWdLOFRnOCtuNi9uODVrd2NjRWptdDBlMnRwV09kME5EQTFXWFFXZks5Mi91TS8rZU5mL3NvZlJQd1lLQU82QlZCb1Y0K1A3cjV6L2NYUFJFV2VjTW1BR3NLVHJnblM1aEt6bEk3QWdFdi9ZYUFrbHZvMGlZN0VKeFFObGoyOGtobVdRRjhSN3NYYkx4NDhmTHpnNW5ENkZDRnkxdWlQUmtOemFwNmNuWUl1enhjQVh3S2tCVkk3R0pvQkxmWkJLblpyYXgyNkVsWU1KQWgwa0JhRHBTZjhKMEFEWUF1V1REZWVnbmxjZ0NUSC9MbC9kbktXU2htVzdhQ1Bpb1VjcEFodUt6b0l2QWd3b3FsVGtwQk1wUUFzZHFsNy91alJQdFF6VkRqb1RTYWRBdEdIM0tVeXFaT1RjeGdLZUprUUVrQWttVWpTTlVwNmd3cmRwSVRMYU5zZWRrOHRrMTdjRzR1Q3E2QVZVSmxnSTQ0RlA4TGYzdDRZREFjUVRGaWgwNU9UYkM1MWRIQ0MvaTJWaXZDMTc5eTVDeXpDTEFCUG85RUVYWVhpa0ZLdk55SGU1OVZHTEFwTlJ5K256dVlTcFZKdVBEYXp1U3l3RG5FQVFRRHgwTFUwREJRVXAyTlphSHkzQ1huWWdVRVlqc2Q4bkZkVVdvbG9PQnlMb3RvZkRDQ1N1cUpVcS9WQnZ3czNqaTZZeUZxMzFZWHZQSjA2VVVuS1pLRTF5Q0IzTzMzWS9ORmdtTkcwVnIwSnhRSHRFY3g4MUFZTW00dk96eHZOQjQvMm9kb1BqcUR2VFEvSy92SWxhQmtJSitTd1VGbkQyUm52bU1teWVueDAvT2p4RTZnTVJkUGE3V2FqVnNzWU9nUlBUeVNnenNDMXdEWW1wdDN1OWk1ZnU3eFdLYVFTcVRqb0VNWitFUmtNUjRzZ29OZG56NElrclFQc3dUU2hpalJQQVJ3QXRZcEVWdzJsMnVyQ0lzN3RjVFpmT205MENwcDA5ZmJ0Yjc3Mnh1YnVjNEVnZ2szQ05NVVc4YjBYUGhHSG1mMGVURjZFQzZRaU1BaUhDdnhwSHNiUkdkNlpwbWV3cDBQd3Z3VDc4dnVwV01CSnYzYnRtaldlQ0xLYzBLVmlLaldjQWkwMjdLb3N5R2ZuWnhCRWFDbERUOUw3SFNLZ2hnb09Ra2NEMERnY0toK04vTTUzdnVNSHZxNFo5S0NOckF5SFEzTXlSWS9CNmFkTEVGMDRYblJ0RHQwTjZxL3FFdkNLZExvdEp3ckFHVGhEUHBlQUlTYzNRUlNId3o2THczZFFZQkNndklFUFdaSFk3VDk2VmhxZUpUMXhzSWpBVUl3bjAxZ2tCbktmZ0c1V1paQjRLTjlaTU5ObHliS3RmTDdBdzF5QUgxZlBVQlJRT3hxUFROTkV2V0g4WVJ4dzFHUmt5WktHTnJPckt4TE1RZ3Irbk9lRFo0R0dxYW9DZzE2cUZET1piTDNlVm5XdHNyb3lHay9nNVdZeUtmVE0ydHJhNmZFNVNLbWtxSEZKV2x0ZlZWVTltSHNTUmowSUgyL3o0RjF3NUJRWlFCNkdKcDNKeFNMa1N3QnFxRW1tbUh2bnpsMklDRnc5QVlZckdxczFXMHFDbnROZHFheW9raENMY0VZeWMzNWVYY1FXNVhSK09CaWl6RE40K2Q0YzlMcmFhbVVNSXlxS3UzdDdNRmJOV21Oa09wVnlDWFFlbytPNnM4bHdNTFZzSEo0d0RFbVZhclc2Q05VaVNmbDhxZFBydEJxTlRxczE3UFp1WHJwa0J6VC9qSmJFa2FYQmNBek4xWUYxYmJkY3Vzd2NQSGx5a0JRRjI1dlpuZ2ZveTJJYzVEQXFpTTNSa0FFcEN2Vm5KSkl3SUJpMjgzWW5xOFNUbWVKWm81N1Q0bktxY0g1dzhQMmYvamdmanowOE9QNVAvczUvZDNoOGY5cnJRbE05dnZQR2xSYyt3OGxDU0R3d3NJVFlrS213cEF2QXN4RHVYZ1lDQWJ0QUVoNGFwckIvaEdWS21NclMyQmUzczcyRFptL3Q3SnlmTmpRNHFmTll2OSsxVEF2K0QzaUZQL05wZWlEeGxqa3RjMGhQVXZQZ0ZiUEF6MlJ5Y0E2aHB4VlJBZmxHRDRCK1lGeEJ2VEpwUTVWRkhPTDdBYjJET1E1ZkVYU0NDRWJVZDgzeDJBSnBkMENRYUxHb09lUTB4b01pUzJLODNlNld5eXRnaHpUdkZOSzdtSU91bU9ZRTZFQzVkRUZURW5WREE0RUcrQ0dUQ1NNQlJpUkpFbW8ybTlHbEdHZzFTWXpsQ3psUVpJNm5aeFJBbUczVFkyT01KQUdzRi9JR3QzZzhITis0OFl4dFdydVhkZ2VEWVl5UDJJNmRTaWM4ejBaN0s1V1NFSmRBN2VKeHNieGFnbTFKNkhyMXZGWXA1NERDL1VmN3BYSUpyaGhVT0ZoUnU5TURsWnFPekVHdlR6Ti9hS1pVdE5jYm1uQ1pvU3dNbUF1UmFpSUk1VUptYzZzQ3JDY1NLU05wOU51dDJtbjkvc1BIc0E4dlBQOGMydFhyOWpjMlZxR2lQTWRyZHpycFhCcEZuUnllVk52ZGRDb3R5bUtVaTZhRUNGeFZXTVNqV3ZYbXBUMDVrV2czbW1kblorTnUvK3JlcnE0bnJqeHpyZGZ2SjFOcDJERzRRc2ZIcDBBRXhEZ0laamhybEl2dEh4eU1CajMwUTdmZGdYb0dEbmcrQnRiWEhrM2FYVnBHYlgxOVpSNk5sc3RsZng0MDZ1MWVxd3RrQWZXUUdhaXFqYlZLc2J3UktQcHdQSVJSSlJlZVp0UVF0a0JEQUxJNEh5c2wxZU5HTjZZbFlxNmw2VktuTi9adDh6TmYrR3c2UG9zS2llZCsvT2VxWndmalpzMmRqTGlZdUhiOUZnNWpzTVhQZ3QwalpWaGRncGNGeE9rVUxNOUZXQ3B0U29TbzRFQ1c4dUhGbVRBZ3NremhydTFkT2o4OWkzQnp1RnllN2NubzhVNFBIdGhzSGdDRnhWSVJKQldNWlRBWVFKdUN4b3IwZm95b3FzbUFzTWRlZUFJT0FJTlFLQlFjMjBtbFU5UHBXRmJpOEhaQUlrQklNRUpRMVBDcVNMZlI4cmowOERhb2RpcWRwbXZxM1I0TVpEd3VxUnFKUnh4QkVHcXdyWVhjYk9acnVnWS9FbTJIOHdBRGtzNWszbjNuZlpCUmVwVUtyUTBMaldLQ0dLREhKMU1Ub0FkVldDd0N1amZBWnRpalJaQXJrQ2ljZ2hlZ1FVVHdUdmdRNEk4UWxYdytoMitNUFF3OEJ2dGcvMkF5bnRLZHBrVUViQmhVdmxadjZnbWoyK21SRGZmbnNDRlFqU3VWQ21yMTFwdmZYVjFmUjVOcjFYb3VseHoyUjZCazdSWmt0WWg2d3FWNDg3dHY4WkY1THFuMWhsTUlUemFiZzRDaEQ3TjV1cDIraUlDRGlLMVc4KzAzM2xJTXJWcXJiMjZzbFZkS0dKRkd2ZFZ1dCtIV3h5VkIwNVJCdTJPNzh6Uk1nNmFESzZEM2s2Qm4wY25VbW84bTFpd1NzMmF6WWk0bnhMbWtwaWN6YVNnU0NKNm8wSnhIS0ticHhQWmNCOWk1Y3ZVS091ckd6UnYzNzkrREM5aHJ0U1ZCeEluUWFjUThPUjV0TEpZTGxYSTVsNkZuNTk5NzcyNG1sd1Y3aEtJQk93TFN3UElGSTFlNjl1THAvdU5VZnYxTGYrMVhyM3ptQjVWVTd1VCsyeEd5NURSZEZJWVVCUW9ZL2xpazN1MmpWamYzZHIveTVnY2JPbXhtcHRYcmwzSzU3WjFkMWU5T2t6czdMMzJtZW40d2FWWG4zdXpxSzUrZmN6UzVkWW52ME8ya0xjSTRTNklwTjVRU1N0Vkh3aklIaG8yaEhqOS9JZ3MybUF4UTRKNS85dG1ra1hBc0Q4N3F4Sm9LOU1US2ZIVjNvNURMelVGSmJRc1lnaXFWSmRsZjBFUUEwRCtjQUtDSFF3R05aVHNPSEN4SVFyUFJLcGFMSUQ5TW13TzdIczBBU3lUaHYyY0xxU3VYdCt1MU5tcnMwNHRhb25OZ041dUY5Y0I1VTZrRUh4Zm9Qck5DRit5aEZNazNaSS9od2FqVjRJMmwwMkNUTkNkbkVhU1M2U3dxTnAvTGlnWTJBaTl3QWI4MHhzRTlBQldHWkNZTXRkTnNnUXBCblk5SEE5aVRSVEFmakliZ0h2MU9YNURFWVkvV1owdWtVdEM0UjRlSDhBWEpGWi9SOUJoVVlESWFONXB0UmRFZ1k2Z2VSQXZxQ3I3MTZkSHgvdjVCcmRaUWRiWFQ2WTVwVGRZa3BFTGdGNUt1b0puajBiUlF5aDhmblVHOFlXRzJkM2ZpZ2dSbHI2WFNpcW9iU1ZxTkhtMlJSSVdQUzU0L0E2eHJvTFMxQmgrbDVXNHFhK1ZFS3Yzd3dhUDVQT0w1MFhaL0lPc0dyTTNtNWhvMGl6dWVtcU5Sak9kODI1blpkb2IzKzdPWWxzbkRVNFFkemllTjZYanFCZ0g4MEdLbEhPTjQ5Qmcwcm1XN2xkVXlUZDU4OUJBb3RLeHBxOVdTRmxHbzlqUXNWYjJCNFVOQUo5UFNSYlBBQmFLamtYd1pVcHdYZVA2OTk5NGZESWZuMVJwbzE0Ly90Vi9kdXZYeEgvdVYvOHV0TC83UTVZOS83bU0vOXA5d21aU29hWlZMMTJZeDd2anVXeEdhNkVGcm9RWkJBUEVHM2NUbXBWTHU0ZEVwZXRnY1Q5Wkx5V1JoNC9EZ3laV2JOMFIrYmc5NnM4ejIxcTJQMVd1bjV3L2V2ZmJDWitMSjVKeDROelE3RUlJUFF5cHA3REFXZmdQSVM2WkRPaDJCbm13S2NiNzhVSmIvblFEdFRvSGIydHdxcmxVczE1SGovRHR2dnllSzlJcVNzZW53SWdlcnl2TmlzOUdRSkJrNEEyM1FOWGFYcDVBQjkxVlZ0ZDhiQUpuZ0d6Z0x4aHNhTnhhSmdtSFBJejVRUHZjWDA2a0xmQU9YclhZTDZnU2tFN1FCNk1wbXMvQnJnd1ZkbzREN0NBbVRwVWk5M2tsbEREaHFGbHQwZ1V4bk1wbk5aQng2UU5TQ0s0bW1CM1F0aFlodnA5VWJqOGNRUW83ZUh6Ti8rT2p4MUxUcDJ2QmlMb2dnN25heGhGT014OE5ST21PRTk3SEIrRTNMenVReWd4RTlZb3NleUdaeVo2ZFY5SThPNzF1RDBZQjJseFMwRmg0Q3JUa0JCN0dMajA0WFo4UzkzVjNIQnRnODdNcm5zdGlienVpeFJTQ0o0dVdybDBaRG9yQ3lLZ041VUNLMjdWNjZ2SHQ0ZUpST1owSDN1KzEycTlsZVcxL3Y5WHZnTm9QQkJOUWlsODBvaWdUbisrcTFuZUZnZk8vK2d4YXRJcWJEcFlGZGxVVU9tbll5ZFJZQmV6TWV6UVRtVFZncmM0Z3VtUEhLYkQ3SFdjcndsOVBKVnI5Znh4bGFuWlZTc2RYc1FGQWh6NTduMkxhbEovUityM2YwWko4dW52bCt0OUd3WGFjejZNTjRRdXhERUlSKzBYZ3lhWUFVblZiWHlnVlZVODRiclc2dkIzLzBNei95VTUvOG1aOWZ1WFl6SXNTaDhoVGdFaDRYSFVjdzI5aTdubC9kMjcvM3BtK1pTRUk2N0JpQ0NuSS9nVThvYkJZS2YvVGVvNnVsRkUyc2l2S3htVlBZMmpXQ25zY1p0cExldXZYUytmRmozL1lxMTI1K0ZPaGhBSEtYN0J5QmZURXNmd2pvcDdOb0tDQkc0a0pSZkgwRTk3U0R4Q1lhNFpRNDN4djBJalBmSEk2Mk4xYU5aRG9BWk5BeC9zSTA3WHd4MzJsMklBUDBLRUFzQ2hST3h5WXdCeFZPajNoeVNLR0xHQ2c3VGJ5ZlRrWFQzQk02ZE5ZWUF4OWJ3UGk2emd5U01KMllMaTFNNU1YQlBrRXc1clR1TTdnNHFBN3NPL3hZdUlaZzlHQkg4QWd4L01BdUxiRVVqOFg1dUtLcDhIZFJZNGdaYko3cnVoQnlxQ1JWbFpLR2V2L2VBemlvRW54YlVTNFVjNUNOZ043WmIyRTdtVFRRZGxYUmJRZU1KUTYzTEp2UGFJcVJ5NnlBNWlPUHBxa2craTRjU2xIUURiMVJhNENBN2U3dEFvV082MnFxZlBYNkZkZnh3WlBPejgrM0wxK1pqTTEwS3ZudzRTUElIaENaTGFUdHFkVnV0aUVQKy91bk05YzdPVG1CY29WbEUwVjVaM3U3MFdwaWx6V3hzdG4wY0RTRUlNbHc1eVVKcnZPZDk5NmplWnQ2b3RjYmpIdERLTnBTcVF5d29LcWFMQUp6MTY3dkpwUDZrOGZIWitlbk85dWJIcjFFTStBNHdRbGlocUtjbkp4NU1CbHpIendiVE9iSjRiRWd5ckN4ZTVmMkxNZStmL2RlT3BIQjJTYkRFUnppbWVlYXRnMnE1bmpPY0dLQzNjSkNFaERZbmM1UVlXTDRBSHRzb2x2Z0xnLzZJK3lHbXZpNXYvdi9YQ2dLVUFHZXNLQXBLQVNxOEF2eEdNY1ZON2ZUSytzUDMvajZZZ1lGSHdWMGdCT1Voc0c5bEUvZlB6NHQ1ak9QVDV0ckthbFFLcDlVcStWOFFWSVV3VzRQcGNwY0VQWnVmWUtMU3pwWUswcUZlMDlGMDJkNWtqQlFNaVd3czFOdEw1S0o1clA2WEJ3UXhrS3NVd1lLTEFmOVFJVVVSNFBoMUlGYm5aZ000YU5EOXcxQmI0SklaTkNmd0FmTnBOT3hXQVQ5Q3NEREJJTnJRalBTNVVoTm4wNG5VSXJNMTR5NWpvY09BZGJSWUxwbkZ5QU85NFh1RDFta2R4WFVFZjBLcHo0dWlvUGhDTldCQ01GYjBoSTZIK05NY3dnRmc1ekloazQzaktSbDB3dWFYY2ZDcVdFS21yV0dOVFhKTll4R1p1NU1NN1JFUWg0T2grc2I2NDdqcTZxY1I4aUIzb09sY0RoZE1JK2tVcWxPcHc5U1lTU1VSREoxZG5LK3RibTJ2ckU1N1E4LzhjblBERVo5cUR2b0lkTTBqWVFlaThhT0h4MkRBS01hRUVvb2FXQWROTDNmN2F4dmI2TG5NdW5zZSsrK3QwNHprQmVEL3RCSXBJS0EzdU5sVzFPby9MMnJsdzcyejRnbUdRWmtUNGZFQWk2eE9YaDVNcGxrVDNVVmpvL1BBQUpEMThuWm1KaHdrOUJSSEJ5WGFNeTBwcGV2N0VIeHp6eDRoRTRCL3BKS1UxK2dxaWZlck5ab0oxSkpBNTVBcDFkY1hZRzBwNUxKdytNekdCa3dUeWhnZ0w3YWFNSVh5dVd5TUFEbFNwazhIMDJaK1M3dG5DL0FpK0RIUThwR2t3bTZIY01rQTR6UTFyU0NGVDFjVDZDZkx6QllocUpCdDlFajZCd3Z4b1huUHZIOXovM0lUL29rRU1Rc21GeUVlbllKTFdBSTZjWEtaa3hTVCs1OEIwSUVPS0kwVVZiQWU5SHdSRUlyYXRxM0hoeHZwUFdvN3hqWmxVNnp0cjU5bVY5WVFOVkl6RVdGdUE0L2loWEpnSHp4K1dnSUVYc1JHSm9aanBmZkllakRvOWcvRTVEbElmQmNsM2tqM0pXZHJVS3VzSDk0Q244RG9La1VDL2xzWG82TDdvSmUzakR6L0lrSlowdWk2ek9xUEJ3TVZWbDJhRzNSZ2plYmlZSVFvMGZGcUZCUkZLdm4xVVF5Z1M0UkpKamoyQXdtZ3RiSlFIUGlsdU9nL3hSWkFyRkcxOHVpQXBNTlFFOG5zQURSWklKZVZRREtnanJSeEhGNmtTRVBSVDZQUmV5cERacUUvb05PakhFeGphNFh6U2UyeGNjV2RQM2RDNkRUanc3UFlHMHcwb0h2aFJkSlZVMGZEVWRQSHU5RDVXTVU0ZjRDa1hROUp5NDh1dnRBRnVQTlhoT0FhRFFhbGRVS0tBZTZ5N1hkbi9vTFA5WHQ5bmtwQmd5aEsrQjR3ZUhEK0tHcUlQZWdjQS91M2FlN3NCbTlYZ08ycEhhM25VNXFnRkZDUzVpVzJ4dE9mRENHT1loY0RJNDQ3RWEzMDI2MXVuRStZaVJocS9UeHlGUTB1ZDF1cHBJSm1BNVNxbURxanBQTzBJSjdkRWxrc2FEWDhDbFNOcGR4UjZQeFlGd3VGR2UyQ1Q4ZG5Dcm16czRhRFNqdndLZDMrNnFxQnNWa0dIcTVrSHZuM29OaW9Wd3E1UHJqMFhoaXdyaEJlUTM2dlc2N0c0bEZoK01KZkREb2VKQVRhQkRvODYyMXRVNi9CeFhyMHhDUktTZDhzR3ZuNit1VmExZjJNb2tVWWNDZllXaHZmdm96QzU2ZXFBeXhRemtwc2d6RXJobVN3R3JjdVY5N2VCZGFEWERIY0tQOGc3UHFzN3NiQjlWMlBxVzllMURiSzlKZFJqMFBEZHRaV2QvMXVrOEN0V1RHQ0VKaG1jQW9uWWJBdVl3aGtmWmRwRk9tRUxxVWRRbGo2TnVMSFRTUk4weGpYL1FPemJCa1NvU3hFbm5CbnZ1R3FwYkxKY2pJMnRvS3VDazl1a1l2NVlFZkUvV2NlVnlJd244QmNZVFNCbWg4YUE0Vk1KT0hmZUIvb0JLaGh3aDRPQldBRlkvSDZYM1I5S2cxb3JRdUFIa3dQcWt4ZEtoam11V1ZFdENReitWQmpEYzJ0NllqVTB0cWwvWXUxZXZuc21KNG5xMGJoSGVZRHNhQ0RORGlkcnN0YXFvSDF1bDZ0U1lSNGNnaWdJdVpTTURONWNGNWlzV2lJUEcyQllNZzA4eEJVZWkxZTlET1cxc2JuVjRQN0FJUzIyazBpUUJZTGxvaGF4aE5EbExSNy9UeXhRSVg1VUQwRHc3M0IyTjZaa2RSNlJvT1dnS0pMYThVUkpIalk5Rk9zdzVQK3Q3ZEI5MU9mKy9xMVZ3dUtVdktjTmhQR0ltcnQyNXNYWHNHT2tTSUErcndDK2FTSktZeWFUQTNiQmNMMmNuSXZIZi8vc2JXdW1QUmd0M3dPaktwMUhneWZmam9ZU2FiUFRrOWhRb3VGRXRvNmVwcWVUSWEramJORzRQeGNRUDN5ak5YaTdta0QvVVRqWnpVNjlsY0NwVzNobmE3MTRkb3dSc0J5NnkzTzJBQlFOaDBTa3ZYODBRT05HODhoVlBCSnJGR0Q1L3NBNFFXUFg0K1RSa0pVSFA0QTdUWU1ndExOTERGM1dHbDZlSDBTR3o3OGs0MmFmRFIrWGYvK0J1M2YraEhueEw5RUhzZkJod1pYaTZKUm5adXZPQzRWdlh4QjlBWHdBTWMvZjVvaWlIVEU1ckJjMCthdllVZlZGSXlHUHpNWHdCQ2hxNEVnK1pZWDUraGxMQTBwanMvY2lVUm4xQ2RMZ1BPdE54aXY4c3RmSWViVDdNeWxMUG5OWllKWVFidSs3L3ZFLzN1Y0cxOTVmanNkSE45QXdpYlRDZnc3aGMwY0xIWnpJMUhvcjEySzhvdFJJSHVadk9pQUFrZDlQb2crSjQzZzlKMVhSdHFHNkFIaFlCM0FtN3F1VE9BRlpaQnBFczBjL0NRS1MxU3dHVXphVVdWZEVOR2Q1eWRWM0g2WWpFUDF3K01xSmpQdzNDRHBrTmxLNUlDRmdGTENNWS9ZTk1HSjZQcFlOQ0hkVzIxK3ZNNUxUd3BTeUxVS2drYlRVbWdpL3VXT1FHVmh4WENtT1h5bVVJcGg0NEdML0puWHIwSmJ4dGw4M29pbWNtbVVkZnFlUXZOcEtudDJSeFRVSkZPcDBVemZFMHpWeWg0SnF3Um1nQWVGWW54VVpRTUJBMEhkRUhkbWs2dTMzem0vT3pNOThsRndTZFhvT2RmMzNqOTdZMnRGZmdGTkhrUXZteWgvT1liYjdpMm5jN2xRSUtoRzlxdHp1N2VObGdIdkFxbzgzZmVlUjljQzE0MVRRV2RCYmVldlFISEI1S2pTRUlxa3dMUXg3YnpoUi8rL01uam8zd2hGWXNFaTFnVTZhZW50ZXA1emFlSEMrYUI2elU3MEJjYlVESG4xZW9uUC9VcDVEazlPWUg3RHNVdjhMU1VpS2JKcFlUS3dhRmF3T2c1VjY5Y2dVZHgvZnBWOE1sdXR3ZU9EakdETWdJUUlPU1FRSHEwa2R3cm40dkhFa2xqTVkrZW5wMWRmK1oyK2ZtUExRayt3WWNnUi9nS2Z3bFdERlBnUDdIb3pzMFhVTHZUQisvN2JPNEpVTkh1RFRmTDVjWmdsTlBsZDQ5YnhZUXFSZ010bVIzMis0WFNpanM4QmFCR1VwSXBlSUlya3gwR1U2cFhpR05XL3ZJYmdlU0wwdG5KUTFnVDJRcXJRWUYyaFJ5R2JkQlhpSDlPRStKSlZZTlhDa2l0YjRPWXhybTRrQ3ZtalZRQ1doeUZ5VHkvbU0xcEFmVkNwdGNkeGdVb2J6b2NqUVBPd3Z1amFCcFVKdEFQeE9NbzE2VmJENUlrbzR2Z1hobWFmT1BHcldxMUJsampPTENJMFhoNmNuSUtEK0hlM1h1YUliOTQrL2JqaC9zNGNEZ2FlMzRBUTAvdkxPZDlmSTFHRm9ZVHVFUTM4SnlNREdBMzZXeXFYTW9CMXJiclE3VFFaTWdhM1FtV2FXNVpLZ3ZlYjVMd0tYS01ub3JrR1RsUlVXRlZpUnZ3UFdpTkVDZVh6K3E2Z1VJZVAzNlV6V1lnSjVEYmVxME9aWm5PWmZXRTBXcTJVYVZtdmFucmFxbGNSdlBXTjdlOG1kZnA5ZEdWS0I0MmJXdG52ZG5vTE9ZejlKdWhjSjV2cDVJWlhZT3ZrRWdsRXYxZS85R2p4Njk4NmhYTlNKeWZuZE5VSXNPd3pXa3lCUTlCVUhVZGJOQzJYSXdMakE5cTIyaEFTVWY2Z3hIOGdYcXpCOWtvNURPcUpwb3dXOTVzWjN1cjNXakRaU3FVaXBQeEZBakZXSEJjck5mcnhqZ0pwQVJVdTFhdnJaYkxOQUhibStVTGVVbVIzV0J1VGllU25zUlJVQkJsdUdLNVZNVDNzcGtNdmJaNmFtS01ZQkEwaFJhMUE5UEgwR0pBa1Y0b1pESENLMnNWYVBxdGw3OXZScVBPL3NQaFg4WXZ3Z1hVb2x5TVZzTFFFa2YzM2daUFk5TU9Jb0JITWcyaGpVeHM1OTU1ZTd1VUFVT2x4eWRpOFd5eE1Pc2R6aEtiVGt3a1RJWVBheThwQ1NHYWNQdGhsTTRRSml4VFdRamhUWEtDSHdnSjJadlFQandONGI0STk3bFhQdDFwZDB1bElvUTZuYzNTclovQndIVG85ZitPWTlNdCt0RUVSTERYNlF1eTRLTHp3RlJzSjFnc0ZHQ1huVHRrYnhnQXV1Y1hqVTJoSUhPNXVDQ0MrNkpKTkhscXZ2ams1ejRWZFdjamsweHR3SzZVRDdyRDBrcXAzeDVvaHZyY3JWc3JLMnQwSDRyanpPa1k5TTZmbzQvb05iWTBjVzFCVDNLQXE5QnpQUUtzNnlLaEc3MHVVUlNZY2xBT0tGMUJwbWRIZXIwUnJja295b1BlQVBxKzArdWd1ekhHY0JhaFl1TWlMeXZxNmNrNWVzWklwejNIQlV1R0xnTVJoMnhVcTlYMWpRM2I4YS9mdkk3ZUl1czBtOE9rNVBKNWNJQkdyYkc1dlFMM1lqQWFJNlZlYjVJV3BEVW80M1MvVFpRZVAzaDA5Y2ExVHFQZDZZeGJ6VHBOYmdHSDZROXExZnJZbkw3ODhZLzFlejB3UHlpUi9hUFQxZFVWOU52Qi9nbUlUNDZ0eWFycmlVNm50N1c5QWJXYXp0QkM4bHZiMjRQQlpEWmZkSHFUT1QxVXliYzd2UVprVDlWQlJZYWpLUVp2TXAxQzM5RDBqa1VVckk5SEMrTmN2OWVCSXdTN0NvMEhveFRoNkQzSm5YWmJGZ1hRSTg5eUhqL2VQejg2VXhPSjNXdVhIajU0R0FJSGFoNW1HYmdrWkxCbG5GT1EyaFJObFZFTDIvbHJ6NGJhblVHY0FlZkRRRnNobUphU0FBZmc4czN5N3ZYOTk5NllPVFlYalZuZXJKelBEVTFMay9nZTNWTDNSb1AremxyWjhTUEY4b28xYm1pTCtWaXJCRlFJVlllZGdoVklYK0RmcE93WllLSEh3eE5kblBLQzdOT0g5aS9qWVFnekxvOWtnZHZlV2krdHJ5cWFsazJsUVVWZ2dSU05GbHdQbkJsZG80STJpM2gwSzFXU2dUVkFEVXI2MHRWTGZYcUNrMDlEUTFqMFJDazZIUm9VTWttck5JcGlNcW5BdFpKbDBhSEhvbW5ac0s5LzlldDVZaGQwUjBkV05WajIxZlUxK0pTRmNoSEU3dnJObTRCVWpJdkFBNXZSRXRsempsdG9oZ0VjSElCMHp1bU9KaGVqNTBmcGNTRjZNaWdDeFVPWFVGd1hLa3JYTlRoYkcrdGI1K2ZOVWptRFZuVmEzV3ExWGl6bWhMZzRHazFCSG1CVkoyTnJFUW5Hd3hIbytDS2cxOG9KQXBmUTRmQk5XODNXOXU0MlJoUVdZYjRJVmxiejdRWmRmdFUxdFZHdm9lV2xjZ1dhbGVlakVIZ29yVXFsckdzU3lBRE9XS2tVSVZTb3Q2UWxTcFcxeW1ySjh5S05ScjFUYjZoOFhCVkUyRFMybUI4OVhMZS9mNVJOSnVEL29GR3lBcU5xVmpEcXJnc2prRWpvSGx0SjNUYk5Rcm5Dc2VtdllKUTR1dDhkV05OcHJwamMzTnFZV3ZaZ01DcmthWjFIazYzTWdXNTgvb1VYVEd1aVNrS3pYdU5wbmU0WkJCWDlQeDBOZEZvU2dwWXAxVFdGajhWS2ErVlVLbm45MlJ1ZVAzdnQyNi9Qdk1XdGx6K2RLbFFVUFZOYTMvMVRQLzgzMTNkdlFtNGZ2UCtPSnN1d0JJbTE2OC8rbWIvZzhVczhoV3AzQ1h1NmQ3T0VGRXZFQmxSZm1CQXBybTdvMmZ6aDI5OWMwTlNoS0FoU3VWaGMwR3hDdnp1aUsvUlpJYkpXcVFTTGFMbXlOamg1Vjh0c2p1TUdtMEo4Y1NMOFVNRVVRdmFDZnpySE1zTEl5a1hHajhTV0hBYUJKVi9FV2FXNXZKR0ZnMy9sbVJ1MjdjSVVxWVkyNnZabFZZekxhbS9RaDBVZTlTY0pBMHhBZ0g0U1l2UzAvOTBQN3NaNFRwQkVxRTRpeExvQjFnRUZMTXMwNHhRZWZpekd3emdvQkoyb3B1bVNJa0wxd3J5Q0lBTDlJSkdOYW1ON2R3ZHlNcGxNcXFlbnc5RUlwcm5kN2d6NlBYL21UTVpqc0hZNE9tY241NEJGdmRid01Lb3pNSXNaNkRVMEs1eFJ3SGM4SHFGQW5CQUdKMWZJUTVMZytzQWlOZXV0emEzVjBYRFNhblYzZHRZeEFnbU5lL1R3Nk1xVkhUQzFicWNIUnhrTUdMWUZib0JJMW1aZXlCYmhOYkxKM0FOSkVscjFGblF0ZkR4d0RQUVhPQko2SzUweVBNZDc4T2dKbkZxNDlacWg1OUk2SEY0UVBqMGg1ZktsaC9lZWlEQWZtcEJJMHZQZGdpQy85Lzc3bktTc3JCVzNkdGVCOTI2N0J6NkRUb2IyNEtMUi9ZT2pDRnBYaFNrWUpPbXVFRjA3QW9kRGs2ZVQ2Y3l6VzIwSUdPZGFWbmtGL0FRT3J1bDZDekFOYTJyajI5QlZXQmd3UGRmMklCdXVaWU1iV1ZNclg4eFprOGtybi83VW5RL3VyeFdLNDA0dmlNekhwb25lUHF1ZUw0TFpkREs2OS82ajIxLzhzNW0xdlMvKzVNLzgySC8rZjNydUIzNzBFei8rNTUvNXdnOGxWcmZYYnQxZXZYbnIvTTY3cXBIL3hFLzk5YzN2KzF6QVhnZENBeHVpakg0SVJVdThmU1F3V0lXNElwdGZYTi9wdEdxajZnbGFCRldTU3llaFRiWDRZbWc2QTR1ZUo5a3FhSUpxQ0tKQ3N6KzZKMEY2MjRtaGYxQTBRZmNqRUErL3dnalVPOXU3VEtJdjFJaVNXQVpFTDNCK0FmUmxuSFp6bi92MEs3cVJnc2FDYVI0TlJyeElqK3FoTnpsQmhCd054K05FZ2dqeFBJaEFLcloyTm9rZis4SFVkY0FhTWZ6SmNQb3JuQjcyZkR2MEhHd2lpQVRBT3ZPQVE3cEdENlVDcE9Lb0dCZUZEck10KzhiTkd6QUNjQ0todjJtQWZYOHc2TkZLNmo1Tm9ILysrZWNQRHc1Um9TQ2dhWStQOTQrQjgzUTY0MWcyWE43TnpTMG85YjI5UGMvekRjT0FsS0VvMk81dXB3UHlEWTR1U01LVGgvc08zSU5xTFpOUFEwckFhN081QXMyc2xOWHBjQVR1RWVmNHFPL0hCUjRrQnd6N2k1Ly80c3lhbHlybFNxN3krbmZlZ0tOS04zMkRCY1FwbnkrQWxjR1U5UWREd05HY21qdGJhNWxjNWovOCs5L05GektxSWdleldiczlRUGxnMzVsOGJ1YUEvaTY0QllpOTMra05FeW45OXUwYmtjaThXbTJ4bXpZeE1LdENNUXZ5TUJwTjJIM3IyT0hSNlNJeXQxeTdrTTVNQmtOQmxXRm1VMmtEdlE3Zm11ZUZuYjNMRzJ1VjJublY4ZnlrSWxYV0s3QzZhNnZsaEtHZm5KNmk4NEd2Q1MxdE9kOVlLV1BrODltc3R3amdhTkhOcWNnOFplaWNFUGNzVXhJRURER013OGQvNUMrLzlCZC9kdk9GbHhNYjJ5N2RyQXJBT0djWVk5Z2dERm1VZStiN2YrRDJEL3hwSVZ0ZzVDSDBSL0dIWCtJVnRISHg4NzJCMG9FOGdoYXg2TmphNVdjZXZmTzF5TlNDcllKaXg2a3l5UlFxYk0vbWZkTzFKbllwcDRKQWxzdVZYdjFKV2xhSFdwbXQzdlNoaGw2ZWltMHVMUWZiWk5WaEoyS2JSR3BDYXhPbXNMQUUrdExIcG54Y3BWeVNETTN6UFI2R240djErd09YRm4yTjhpTE5FWS9IdUZHdkI5MGFpWE9hcWtRbGNjSEZrcGwwdTkzT1pOS1NMRVBCRTFPa202TVllaVV1eG5HeTRYQW8wdktEQzZpeGVyMjJ0Wm9jamN6SjFKSHBSY0h4UXJHazBoT053QkRkb29PVTAzVXh4NHJUOWRjSUpIMUJTK2RDVEJZZzBDaGM0T1B3VVBPRkhOaUZLc3ZnL2RBY2NDaEJaOEZod0w4ejJTeVFBVG8wblU3bjgxa3N3aHU2RGtJTjZqUWVqWFhvNFdUYUQyYlFyUDMrRUc1MExwOHBWeW96Y0xCWWRMV3lCUVpYV1M5YXR2dkJuVHUvL0N1LzVFem1uVjVMVXpWSnBDZFQ2ZjZBWlNVTlVIUWVZRVg4Nm8ycm9LZmRUdi9KL21FeW5ZWmlqdlB4OVkzS3c0ZVBXNjFPb1ZnNE9UN2VQeml1cks4cnNqcWZSelozMWxINXd5Y242VFF0Q0FPN05ScVAxdGJXbXMxMm9aZ25jeERuVlVXTHh2akxsN2JoVWR5NSswRFg5VXdtUlJxTExzamszMzduemMzMXplcnhHZnlyamUwZFNEZkVIRVVGaS9uZEIwK2dweENRaUhGZFdhM2N1WHYvNXJNMzRXZHJ1aXJFbzQ1cjc1K2M4YUt5VWltZkh4L05GdEdQLzlndnZQS1hmZzdnSmkrU3NRK0NBMDJ5d0hEZ1EybzF5c1Y5aGh0Z0JKdVVnYUwwSVN3eEdDRW5VTG5Vd1FRMy9KQ2Z5REpUM2JGZlZOUk1aZmZKZC82SUF5T0ZPblJkVFVza05BWCtEUHEvTzVrSVJDQ2xKT2htS21FMkhpcVpuVWxjSTgxTnhZVmFuS0lBOHZMTXl3ajloMXlLMVpMVmdRa0o4clBkRk9oUUZtY0ZVRWJ1NDdlZkYrSlNIQngzWWdvOG5Ea0Yya2szRXREM29xcGdiTm9nd1N1VkowK2VySzZ2M1AzZ3dkUXlvZXhoak5kV0s0UCtnRnpQZ0ZaQjhqd1h4UktaUWNmNWNHWHBWcXRsV3FxaURzWmp4MW5RUldoNnZrbFVOSEcraVBRRzVuQThVQlF0UWpQYTQ5Q2prQzRnRTJvZUJhSWFFaVRIOSs0L2V2TEpUNzhzQ1Vva2lFQXhaVXVGYnE4TFp5dncvYlcxMVZpVW01b1d1d0gwS0ovUFFzekFvR3hyQWdNRHZrcExkTWRvd2lQVU02d0w2RmFjNXlFVi9WNDN4c2RzeHdZaFh0MEE0NisrKzlaNzBUZ0hrckN4dVY0dWxxN3NQUFBnMGIxZ01kTU5IVm9hOWdQT3pKWHJXOU9wSGZIbkpsdTZLS0VuRG81T2dKVHhhT3JQM0lTUnVIUG5IanFoVkN6NnJudTRmNkFsazFldVhaWlVjVEVQWUNrRDlpd2lYQjNmWDNpZWs4blEwZ2JUOFFRMWcyWGxCUTQxaDRPcnlzcWdOL3prOTMzYVNDcUZsVlVlakw4L2VIajNrUkFqWDNGN1oyZi8rR2pZN2MxTXh3dmN4L2NlZVJCMElISVIzZHBjblpnZ1FTYWs2TmF0SyszT01NN0ZBYTloYjdTK3ZZMGM5bVRZSGt4KytELzlyNTc3aVora0ZSd3Z3TUN3VG1nZ29ERGM0aTlVaUFoTUhNS3NERVgwdTRRVWJWRUNTdy9qYkl2aTRWRnNNMXVvekJieitxUDMyUll0TmJlMXR0WWREc2ptTGlJZ3JqTXlPL0ZDcm1CTmg2TFY4L0pYL0NpdDVrTFpMMHFtc2xpNStBb3RET0prZWFKMEkybVo0U0tFR2VuRHpGS1lGdjV3ejc5d0cyUURGQkM0QVFMaTRDR2FDdnBMeEVQWEh0NTdrRXlveGRWS1lNMHN6eUZyVEpOaEEwVlRvRjNKcVVSL2dQeDRIaGh0NE0wVVZSSHBPZGNZRU1hYXpOSFUwQVV2Z3BXeUYrblBaOEhyMzNtdEQvWFAzakJoYU5yaGd3Y0FIL3hYa0h1b0tNYzJaUmwxZ0x4aHNEeDR2bkNDNHdLM3RWcjg0TjZqZy8yRFJyMEJ4NkdZeTkrNzk5QklhdUJPY0lXVENYMDhvc3ZidG0yQ3VNdFNYTkZWUGdZaDRsRU4zNXVEQmNGbm9PdXRFM015TmowL3FLeXVEZ2JqazZQamRDYTV1clo2ZVhmN3AzL3FwLy9oLy9TUC83TmYvS3VmL3R3bjMvejIreE96QTMwRWk1Rk5KekUyYUV5NzN0bTdlblV4bjlWT1c1V045ZnJaT2RUcWRBcDNvanVlanVBR1FEMm5jOFVuSDl6MTU5SFZqWTE1Sk9oM08zQTI3dDY1SCtINGJMN2NiWFZnMmU3ZHZmLzVIL2dpK0JMd2pyMTBKM1pPYnpxWXpXWWI2eXZCSW9henRCcWQ2dUV4WE9mZWNNeEZPVDJSQ0FKUEV4YXZmZWVkWjI4OWt5OFZuaHdjQjdZcmFkQW1rd2hkVjVHYWpYWi9NSVpyMk9zTjBXOTdsM2J1M2IyM3NyRUdHL1h3d1FQVHREN3hnei96NGsvL0RQeFd3c0VTQ0FTTlVMOFRqSlpSaEJBeDlFV3hpOEN5VTRScDc2VXVoNGlBdDRSa0doOUdkMWcyd2lYSjFkcnUxZGI1NGJoeERwbWRCUUZsWGdSb2xEY0xQSDhPaGJJd3g3bDB1cnhhNmRZZVo3VHNTQ3N4YThIcUV3WjJYdnBsSlpNYUo5eFRDa3NNZitqc1ZDOVdxekJPTllYSllqL1k0QzVkdnN4emtaUDlKM1FIMVBVWFhNUzJIRGlBbm1QQ3djK0FNYlBGSFAzWmJHMXIrNjIzM2s0bURReE03YndlUUFsSElzUEJHQXlZcmtLcWNpNmZoZGpBZnpLblU1OWVEUWgzU29PeEpoZHphdkx4T0xpdklzbXRSZy8yRjdaVjFmUk9vOTFydFNiOWZyM1Z5T1h5WVBQSlpBSjgrdkRnYUgxN2F6d2NCM092M3hzbGszb3lrWFFuOVBZVzIzRnVQbk1kcm1DVEhwV25xL3R3Zit2bjU0V1ZBdWdLNnJhNXZUWWRXM1MzeTV1aDJjQVFmT2hHczRGbW8yZFRxU1RhbFN2a1FLWGFyVGE5Q2srUmtQUG82QWdIZnZEQmc4OSsvNmZSb25mZmY2ZFdxNkhDc0R6dXpEMDhQSUdOS0JVemtSZ0g2TXM4WjVxT1ROZjk2R0hjY3JrTVNLMXZiY0JZb2Fwd1dVQWV3TzhOWFJwMGgvVnFjekEwYVJBaUMxQzF5bHFsM3gzZHVmTkJJcW5EaHQrNWM5OFBmRm1TZFZXRitxaWVuai8zM0UwOWJXQjQzbmp0TzhmVjZyUFBQUmZsdUZUS2dJazZmbndBK3A0dDVqUlpmdnM3Yis5dWIzZjcvZEY0QXNWZnpCZWdUWHg2bmlDR1hnL20vc25KcVcyaUg4VEhqdzkrNEdkK3FYejlZNi84eGI4OG8wVlJ5UWpQUTk2Q3dKRHlGRHBQdzNJUFF3MGhpWVVselZnS0JiNG9BYWhFWGpJTFlUYXlEVWpITmpFZFpJRFNXYnZ5M05HOU4rYVdTZk94elFrR1VSSmc1R251OFNKWVFETkZBM3Q5Zll1dTNIV09wZkpWTTY2dzg0UW51Z2pNc0VEUzJJay9ER0VOcVFwSVpVSkNweVdBVTR6K3dtT2dmVjk0NGZhZzAxYzBIY29tbFVnYzdoL0ptZ3dGbUVubnA2YVpTV3JUd1NDM1dvNUdvRCtFazdQelZEclo3UTdBb1drV0lhRUJzR3VOeG1QTG5BSko5R1FkUGJRTGhrMXlMZEZ5ZVRQcXQwVUVkZ1BnYURUYlYyOWVLeGJ5anVkb09raDFCcURmWEMzY3ZQeGNzOXNGdnNIcFhkdW5sVnNFVkp5RFVzYUJGclN5YlJsSkF5bWJXOXVqNFlROXJ5UVZDbG5JR3g4SFl3bUdnejdOY0pTa3ptRFVxRGVQajArSlBOajBBb3hzSVl1ZUJ5Nmg3Z1gyVGxOME4wUU84Z25YRTVRSElCNlB4Ly94UDM1Rm9NVWw1Zi83ci8xMzlyQWpxUWFVYXo2ZmhsODRNUjAydWR3R0thSnFFRSt6WTdISWVOQ2Z4MkxBNjBzdnZ2RGc0V05vTHpqc3JVNTN3YVlZUWFjSUFyK3hzWGwwY0x4M2FRdGs2ZEtWSGZqSjhNemVlZlBkWkRxVnplVWE5VHAweW1RNkxaVUxxUEJvYW5mYUxWM1I5ais0aTI0YjIyNzE5TlFjOVN1ckt5c3JXUmhFNkIwMDlzcU5LM01QN3VnY1BvNUR5eTZZbG1QdDdHN1hhdzB1enZmNlBTZ2d1b0F6QXllTi9NS3YvYjl1L1BDUHJ0eDRKbGcrNDA4amp3Z0RLRENBZjFLWEJKd1FJT3p6TklUNW9Sa3Z0R3FvVjZQd0tSbW8yV0VFTGtwa0NqbE1RMkRsc0krb0tNV3RhOVg3Yjg1ZEY0ZkI4SUtNNmV3OXNxQTBydStYVS9yMjluWitiYXZkNzJRV2xwZmFkT20xTG5Rc3NNb2lyTVR3bHlyeFlXQ21JUHhqTVpZai9CQzNwa3FGT2FMYzVkMGRNSFJvQlNobUkyVWtFdWxPdStQYWRpNmZtcnZVajdBOXJtV2ZIcDBMVXVUK3ZmMXNKaFZaMEl2MTROU0tjUUdhQWpUR2R1Q0JhZEROUURSVUk4MnNEdUFLeldxTnV1YzZRSCtuM1Y3ZkFOV205NlJXejgvemhUeWtBZmtWU1FDaEg0Nm5oYlV5MkJSNE5zZ1BXR3k3M1R1dlZTOWR1cVNvZXJmVFdWK3ZRQkxtSE5RQnZYNlk1M2xVYkRnZXBaUDBpZ0dNQnozNE0rakRZaWhxQWtSOHRWS0NzMFZ2b2xScEVRRlVoU2RXdzAzR2t5aWJFUVRXUHA1TVFOZzhkd1kzWVgxdDUvajRuRjZHTWZmYm5UYjYxN0ltV3NLb1ZJcUtxdGFydGNGd2pKNUV0NkhVbWUxZXZuWUZuWGYvd1VQWW9ubXcwRlFkU2haYWYzdWowcXEzRVZuZjJlcDFoc1ZDRmx3SWpNVno2SW9oeDhmZzlEOTg4QWppZGZQV016QTdqVVl6a1VpY25wN3dnclJTekhJTU5JVnNBZUI0OU9EaGFHS3RWaXE1VkRJV1YzeHJ3a3U4cU91YjhDMVdTMmZWV21XbDJLdDM0UCtoSjkyWkR6Y3BsYVJMcGJvS0RGa1k4R0krSjZuWi8vSmYvd2RqYTVzNVU0c1FvSVFKQWk2RERySGJEekh5ZnhDK1p6OWlTL2QwR1pCRWdDT056clE4RXlYS3dJU0REa0VpZGhqWlFxNjhOamg1TUhjc2xFTHFOZ29sS0tEeWNEK0NtWjlQYVpYMXl0clYyL3Z2L1ZGT3oweTBsVG5CbGZHbXNDQVcyRW0vSjFEYWh6V2tsTkRVVUJMK1NWckRyd2kzdDdlSFlSREZPRHc1UkdoR05TK1dTdmwrbTFienFiZTdEL2NQQ2tuTk1aMEl6MjFXMWdoazlFNDh1MWdvemkyMzFlK2traW1OM3BhWWRXZ1pBaGdKTTVHa3Q5N2hETysvK1hhNzNiSnNDNmZPNVhOUWVPZ3F6M1p2M1g2MjIrNXFtZ3AyZ1FwQm9UWWI5ZEZvU0pjVTQvVEVlOEpJc2N2U1FidERkMC9Cb2NFNjdueHczMGdZS0VyUmxjckt5c043aitLS0dKbEg2N1dxRUJjT2owN29SWHl1bGN2bllURU1JL0hHZDk2TUJFR3owWVFUTE1yZ1dqbWdPWnRLb1o2T1o5TU55M1lQUkNVeWoxVnIxWHk1RUhqTzZmRXBwUFQwOUJRbnNoMnJkWFp1cE9qZUxRaERLcG5JNTVMRDRYVDM4dTUwUEc2M09qQUlYWmkrUWduVVlHdDdkWE9qWW84bmhXSW1tOHQvOE1FSEFIMWNFdXJuVlRESDhrcGw3czkycnU2NWxoWG5CUFRQM2J0MzBhaGl1YWlJMHNIK01aUURmQW1jcU52dHJxeXZ3RmZCMElBc0dpa2R2T3Z4a3llMjZ5V1MyWVNoNmltUy8xbmdDckk2N25UR2NDMlN5ZVpnQUFSRG16ejd6TTJkN1ZXb1RNOFhybi95QjMvaVYvOXVQSS9xa1VyQXlOTTNEVDlUbHd3WElUZ1lXdGd2KzNrYUtKMVNDSEJQczN5WWk4VkRBV0pxZlpsQ3BSUGM2QXVDSFFJTjJRSDZSR0cxdExVM2JwOEUxb1NMeFYzaXlRcWNiUytZdzZNUW94RlJpRzF0Yk1qNXl1alJ0N1RNdWlVbGFUb0FDbHpXOXVuUGg0R3F5RDUwWm9xd1U1TnFvc3FFdGFPZExIQTNybDZEdmdUUjduZjcxcGhlNkFVZU5leDFibDY3dFBBamp1czJPcDFNS3JGYUxJMUg0NUUxN2ZiNmZKeEhHVEFJMldSaU1qVmRVSHpkNkRSYmNabldEd2g4ZjlBZndGV2lWWE10MTVxWU1BVzJUVE5EVUhHdzkwUXlDUnBReUdjNzdhNnEwK3AyOENnQlFiU2N2WVkxSW9vQ3pEVDRkMzg4TE9YeXlYU1c0eUlnNk1lSEovMWUxL05jc0thVGszTkFCRzNhMkZpRmZjOFY4dWcrU0IzUGNRRFRvRGRHQ3lWQnlCZ2FMUFdjUktMZTdyUnUzcndCNmdMcGFyWHBEVkJ3TGVJeERwSUJGWnd3Nk5nNHJVanNkZnREMnpSYjllWjRiUFlIZzdXMUZYTTh6V1ZwMFhTNHVZVmlia3hMZDRESTBmc2ZXYzNwbHZPdzE4dGxjLzE2ZXpnYW5WUnJzRWlHcExYcXJVS2x2SE5wYnpEc0hEN2VMNWJLNERlbzU5blpHU3hnS3BYKzVqZS9sYzdrVE1zRVNwNDhmcEpJSkdHNElFNnFUbXZ2cEhUOWcvZnZnblJCM3M1T3ppQ21PRFdNYmJQV0txNnZ3WmtmanVIUTBBdUIvTVVjSW5MOTVzZmFwckQ3MHVkLzd2L3hENjU4OW5POFJndnRZcXlYZUdmL2hBQ0dCdm9RZUJnY2FCZmhJd3dNS296eVVtQ0FZOElTSGhUK2dxNGlPY3hKa1FzNVl2K3NOSW9SMnBITURxYkQ1RXhoOWRKdHEzbXljS2MwVDhuejBycU8ra2ZuQzlkejVFZ2tsYzhWMTYrT1JrMXRlT2FsZGx4ZUNnOUZXSjdtVDRTd2JmaWxzN0g2NEplZFBLeE9XQlVTZVhnUk4yN2NHRS9waGN0d3M4eUpDV3lBa0FCNWtVVndmbDZIc25IOTJlRjVUZGFVUnFQVjd2Ykdwa21vNGpsUmxCR0g0bXpXbS9saVZxZW5jdnFBSUtnMkZKdHQyNWxjNnZZTEwzYk9teEV1MHV2MzZTYkl4b1p1Sk9qR2tCQ0hvbzNGZUxBVDl0ZzFVUi9FSlUzbEkxSElGVlNWQXdSd3NXd2hVeWhrRGc4UEZGbHB0VnFEQVJHbldyVzZ2Yk1KdzUwdkZvQURubzhERUdEam1Vd3FuVTY1dG5uOStoNDBYRUtUVXJtTXYxaWswOG50N2ExNnZUVWU5VE81ZElTTDVYS0YydWtwVkdhdWtJWHNnVDFqVUUrT0R1RktweklwY0I2NHZPQmRsM2IzVHF1MVJFS0ZpdFVNT2NyUm14YlpqTkVZM2VWbHM1SGhLcGZLT2JRQ3JrNWhkU1VXbCtxMTJzcDZwVDhZM1g3eDV1cldScXZSR1EzN0R2UTZ5Qk1IVGJHQTN3QVRkM1pXWFNtRGRFWER4K3B5RkRMRDRhQ1F5MEZpcDVZTE5wTE9KaDQ4ZUxCYVdZbUR3TVc0V3FOZFBhK0JpMG4wOHRmSXdmSHA1czVHYjBDTFQ4RkNyKzY5K0tXLzlTdTNmL3duS3MvY2drY0tpb0FSWG1LQmtNQWdnSlNMRy9Xa0RTbHArV0VaZ096d1E0ZUVpY3N2K3FVU0VNTGlBT01MT1dCYkpFTTRraFd6NUNBc0ovMVFFUUFjMjE3RWRXUHR5dk1xUFMzaGcrdEN2U3F5U2s5NVJtTUtIN1VudzBqRXYvWHlGL1kvK0dNandrM1RtM1FZSy9naTBQWXlpaGdybjZvUm5valc1V01KK0taVExzOGU3dU11WDc0TW1FTFZnWWNJc2ppWlRNR2w2QVpOczdOL2VLVEthbTg4aVhEUjgycU41Z2J3WENxUlJHdkFXSWdwZXJTeSswYTVjbkIwQk5lVFhtNEt2N3ZYQTZNcDV2TzAyQ2NmM2I2MDIrL1Erd1Z3VHRoN2psYUw5anU5VHI1UWhGQnhVY0UySGFESHNxYnhlQnhNQ0dTR0YrSnNWcURUR3c2c3FYbDRkQUFvZDFxTmZDNERLZzlibEUybjRkRENVTGplVEZQa1VYL0FDYnhIdHpEb2VUOVZrU1ZhN21iTTh3SnNFV29ObHhwK2dra0w5STE5ZjJabzlJQTVTVVk2Q2M0QU4rT2xsNTkvOCt0dnJLeXRueDJmb2kzd09QTzB0RXdlQjFhclZVamkyY2w1dDl1SFp6R2QybERud1R3Q0x4YUVCOTJweXlMT290Q0x3VGdvbEtsdEpYWDFqVGZld25rWEFUay82QzY0RzYxMkh6TFphalpjOUsvdlE0KzBtdTJkM1ExYVpjU0RhZzYyZDdmUHoycXduSVZpZ2ViaE9oN3lORnNkQUVjV0pSc0d5SEhoNmVxcWNub0dQMHJVRTNxMVdnZFFOTTFZTFpkLzhqLy8rMS84cFY4Q3p3TkpvNnZEU3pBZ1FsRzR6alRnYk9BWmVwamxaMG9YV3hmcGxDTU1UeFBwRTRvTW12cVJZcCtHc0FTbXhKL3VKbVN4S08xQlpBNFBtUWtEZ3lVN1JGYlRPOWRXOXA3TkpGTytNNVYxQTlJeG53ZFRlNnJHb25DejRxSlUyYjFlZis4UHRjeU9vNlRwZUZZNzFKRitMczZMZ0creU1tSHppTTZFYVpTUm5SVzdQcFJLYm1Ocks1MHdRRFNnWXVrQlBQWnNrVG14TXBrTWZNcDBOZzNmY1d0elhaR1VkcmZ2QURTV1JZdjhSZVpRUXREaUl3QW9NcXVVSzZwRzRGTTBKWnZOY1RHYWZCSVgrV1F5WlR1ekYxNTZ3UnBQWUloVlRVVnBBaDkvZFA5Qk9wOHprdWwwTnVYUlNyejBCQnpOK2NXUjhUaUFDL2N4azgzU3JGMjZYaFlaRFFlWmJFWlM2TkdreTVkM2RBVnNwSlhNWk01UHpoZDhWT2VGNGFBUExZNXk0STZ4Uyt3V3NBajFmSDVlaFNTallLaVNPVnlpZWFUUmJwdVRDYlE0VUF0TENvRUVnWEk5ZS92U0pqMmVMVXVsMG9vQVoxamt3YkxnVFVKK1ZpdHJFaDhmak1ZY0Y1TnBmUzg0Z2xFd0pTT1pRUDVXdFFiOERrYjBMcWVFTGx1OVhxUFZhL2NISzZ1VmNybVl5ZVZQVG12d2QwR2N1cTN1cmR2UG9kT2JKOVhEd3hQSXpmYnVUcmN6Mk5uWm9qbEJyaWRLOU1EYjV1N215ZUVaTEJMa0VHcGxaYVVvaUJLcU9yRWNZS0tTVFFXbUY4em1UdzZQVW1td29keGdOUEJuUWFxMGs3NThuUmwyTnVSTFZDQWdSaGVlMlpBellzRkN1SSsyR0RMb2x4MXpjUmlFQW1YUmg2VXN3aUxvTWliTEdtcng4RU00Sml5eFVwaGFaMXYwT0R3cmtESXh3Tk5XbUJFZmVwV0Fsa2h2N09XM2J5anBQRDJwd0V0bUVCMzB1c1cwemtYbmxjM0xRM3NZNyt3SCtSc3pYdmlJTkxKZlFqWTdINHE2MkhFUlB0eEZNVG9mUzRKMnorZnlJdDE5WERoMFJXakJjMUdaaTJaMHBYNWU4MTB2SmdxWHRyWU5ReTRWQzlZSXd3d1pwN2NlWUF6eTJaemowbUovUENkME9sM29UaHdPRGpCZkJKUHhDSzJqbTFEemFLNll6ZVF5bXFMenNVV01GeDQrZkRpUCt1c3JGVnI0SGhqcWRvZURZYXZUMnR6YTZQY0hJQkV3a0RMVXN3UTRTVEF6T2ttUk0raVBDNFhzSElMbFF0N01sZFU4VkNuRVpnVFB3VFJuUVVCMlVOSEhrNG1tMFVJeDNUYXRzVUVQaTFpV1RNN1FBcFJEWm90YUtySUdEeFdFQkwyaXFscTMzN2RNZWppdzErbWZudGZCbUVHdjBLSm1xNDNtQUNpZ1dCQUxXUkxSSXZnWXNpekJGY2F1VkZJZjlYcVN3SjAzMnAzUkNHeWsyeHV1RmJJd1paekk5VWJUVWpGYktLUm5BV2RaRnM5SE5FT3YxMXI1UXE3VDZpUnkrVVE2VmE4M0pTRytkMlUzbVVwOTl6dHZha21ERTJKd0ljeXBCVFFQYVFYd0djVC81UFMwVWl3dWdvQ1Q0T2hIQ3FVTVBYaWJoeFNkd2VzUVpYcndLaWFVdnZDZi9zMG9XK1kzREV2dmxJMHhHM3RDTG0wK3hjeEhRcGlFRENFc3drRDUyVGFsWUlOMUI3Qk12eXhjN0wvNFdaNHAzSTFJcUZQWmgvTFFEeGtJK3FXc3JNaklndVBqaVZTaXNxWGxWMWV1dmJqN3NTL2NmL0JXOCt4a2Q3VWtLZUxWNTcvdmZQK05wQ2hQRTJza0oyRUlDL3h3bXdJcmRCa1FvYW91b3dqaHFZakNjWi83OUNlVGNhN2FvVVV2Ukk3UGFoTDgwL0VFbWxnQlhNV0VNUjBPczluVXVELzBBcjgvR2NOMERvWUR6L1ZTeWRSME9xMkFyVVpqbVd5NmVsYUZRUWVBK3IwQlpBQkdnR1lleldkUW5wUEppSjRDY1QyUXBYd205L3JyYnhSTEJkdWE2Ym9TamNTSG85Nk1Ib1VlQXVpQnY0QW5rQ3NVMEZtT1pVZGp2RzE1NTZmbkhCLzUxS2Mvcm1zYW5Na0J2TFBKZEhPelFwUGphUjNxZVlIdUdRRVlzZE9UczFLcEFNZGdZMk1kb3Jid0E5T21TV09hcm1kemRFRkc0amw2ZVlFb0xZSUZxRFlFa2w2UUpBbUdvWU5jdVRZdG5nNTNGWVZiMHhIMDY1TW5oOURsaXFhQmJNRGhCdTRoaExCZzkrN2VoN1daVHFib2xwU2hkdnNUdWtEcE90VmFzNXpQYzNLODJ4dGxNbWtTMFhtazMrL05nOFhaZVEyOGErZnk1ZkdncjZwaU1xbkhPQkY2SVpkUFBiajc4T1l6MTEvL3pwdWpidS9TcGNzNGhLMjlFejA5cmQ2Ky9VeXQydFFOR2RTMjJlbUI2dWJ5UlJFTVVwRVNCajBKTU83MExuL2lSMy9xNy8rYVQxaW4wVVVpRFMraUJLbndsd0lEQUtHUE1mZmxoM2F6U0JpQVNSeUx3QjdVVzI2UllsNFdkSUgxaTBQd0hlYi84S284SUVVNW1EWm5lK2dUSGt2SFVBWnluRVBJaGp3Sm1XTlJLWkdTTWhrbGsxbTkvTng3cjcvNjZOR2p5NXRySzVYVmhhck9hbmU0eExZdHFNak1UQWNaR2pxT3ZsaUFFbjVhRS96Z1E5bVc5VnltczJPNHRmVjFMaTZDakVaanRPN1hwRC9LclZZbWRGOW5taW1tTWZpRHdUQmZMdFJQR2s5T2oyM1BCY3JCZ0IyWEZxUkYreVJWTnVsdGhwUDFqWFVmaEpxdWNNY2xWWWxCaHkvbXBtbkIvK3BVRzNCcUwrMWVhZFhxK1VLbTNlaU56RWtxbVUybURYcGh0QzVnZ0tBNGFUWVkxTG9ndzZNYkRZZUpUQXE5UHBwT0wrM3NqUWZqcVdXeENRdGdMTFFlZHlLbGdtc0ljWkRWSk53R21FYjRyQi83K0F0ZzdZZjdCMkJLZzI0L0ZoZDB1S3ZROGp3dEUwSWNTZGVIbzVFZnpHaGF2aXluTTFsWkVCVlZmdmE1UzUxdUw1bE96V2Flcmh2enlHd3hDeXJybGRwNUF3d0kzZ0tNeWFEZmQySE9GZ3Y0RnVsa3hyU0p4WjlVNjRZa0JORVkrSXdObWhmbGlpdkZacmNMeHdPRUNxaDljTzl4c1pEVEU4YlowZWw0T3JsODQwYXYxMm5YbXU3RTd2Vjc1WlVWY0x4MnV3ZDREYm85dWtrTEx1ZjVzN21MK2tOdEI4RXNrU0MraHpIelo1Rmc1cFZYaW1OekFxV1F5YWJRU3gvN3ZoLzgxSC8ySzdONWpDMk1RYUNrMGIwQUFvTmZ1TVhZQjZVc0ZUL2hJTXlNZVBoekVaNW1JTmd6SllweWtNUktZeGhhUnNJb2hWQjM0ZytRUUU2QzJqSlFjdmloWXk3S3BkTG9ROHlhdGlscFdRa3RtYTdzM0hqL3UxOTc5UnZmakM1bTE1NTkvc245ZDhwUzFFNXV6eUJVd0VDWWovMUNobGhDbVBhMGVBUlVnWnA4a1puT1RUQzdlZXNHYU16RU5OTlpBL28xVnlxaHQzdU5wc0J6NXRnYWQvdjAvdThGbkMzaDRQak05VDFvTktBSGgzZDdHS1E1TkxUdnpyelpiRERvRmd2RlhxOEgzUThPRFlVS1d3dzExRzYxUlZIMDNGbHhwWlJJcDN2MFlNYzZITkFmK3BFZmdwZjI2aCs4eWkzOGIzN2oyNFZTUVJDSXhlUUxXVGFweTNmTktUdzJtcGtvYzZsVTZuai8xSE04eTZHM0pOQ1ZUZFBxdG9lOENJM3IwQk94OUdaUVdzSU9WQ2RmS0lDWjBMTWRJcTIrclNtaXB0S0NaUDMrRUIwQUhnOFFjWHdNeENidzNPRm9YRm5OWmRNNnlESElQVnlIUnExNWRsVE5WOHBuUncxTlQ2YVRTZGlKY3JHMHNyS2lDWEt2Mzg4VjhvSVloeWFPY3JGZ3ZoaE9wNWxzcnQzcFlteUIxbmEzTitnTmZGcEdhOTdwRGpSTmt5UzZvVHpxZFErT1QxZFd5ckJENFkwMlNHQ3YyMDFuTSsxV0o1WFNKWm9GRmxNMC9mejA1T1RvQ0QwTUF3dlBXQ0hKbE9nZGtZa0V6TUpnMEx0OGFRL3B4NGVIcHVWYy9lUVA1YTdlcEZsaWFDcnBPRGJrQUFHMmFZVERGTVFZOEdnbnZoa00yWCs0d2RReTI4Y0N4WmJnbytNUmFDOWxZVC80TUJrSXJRVFR0TmpCZkFKV0lNdEpVRVA2aGJCUUtuTWphY2ZGOVVyYWhTMDZoTVVvUDZGM1lXUUw1ZTJiSi9mZWZ2M2JyNy85M1RmT1Q4NXVicFowVlozSStWQ3gwejgxa0IzekZOSlVaNHF6SEd3Zmk2QXZzQkZtNHRiWDFvRnl1bm80Q3hybkxYaHVnaVJaWTR1TExUaEp6R1Z5UmtLajVhRG8rZm5KMkRKeEhEM3F6dEhrVzBBdG4wL0pDcjJPN09TODNoOE02UWxSVmVlNHFDSUowSFl1UGNNNm4weW5DZDBZOW51eUtpVnphVFlIT0RlUEJKUEplR1ZsOVozMzdyejQvSXR3Vk9BSHc3ODhQNnU1cmdXUExaMUpFcjR0MnpUTlJTeFdMSlg5WUFFTE1Cb1BYM3pwT1VVVXA5TUpuQnM0ZWFEdU0zOTI4K2JWeG5sN052TmxVZkE4T3g2bjY2SFJSVkRNcFlJWlBWbENiOFd6NkIwVjZDQlJGR3h3R3piTFlJcDBjeUpMeXRidXBtblp6ejN6YkNaWE5NM3AxS1NYRlhNaW55VXhIc0NvQ3lKdjJ6YllUdmlna3hzNDZFa2ptVW9hS3JnK3FKc2tpV2dkeE5WSUpNQzFBSWs1clkyc0Qzdjl3S1Y3VldsTlNlUXprOUhVQlQyZiswSThOaHlNKy8wK0xhYkhMUzVmMllWZlVjamxkQzFKdDhKbXM2bGxGd3I1VHF1OXQ3VzF0Yk5oanFaQmhOWVdQdGcvUUl1eXBlcy8vS3YvRmIzSlpEbm9HRlpDRWh0WkJOcTgrTkM0UDQwamhDcWN3UkhIczRQRFFEc3Y0cFNkSVpnTys1TUZBMFJNR2dCZVl2UWY3bDNHS05PSFloQ21QQzJSbVFzazREdjhJTEJJK0JkSjVJcnIxNTQvUDdqWFBhMmlxMFErc3BtVElsckZpc3VVZVNrajRVSGg3MFdFQld6UWFVaDJpSDJGS2FUZFZ3cDVkQndxQmY2dGFtcno3Qnhvem1WVE04ZE41ck8wcE8yWUp0bEZZaHo4MGFubDBDMVllbzRKdmhQc1p5U1R6RFE2bldlZXZRbkJyS3hXSUxrUVlPeVNSUW0wQjhaOU52Y3JLeFh3QVhEWlhxZkg4d0xRRCtscXQvb1FCc3VaYm05dkdhazBocEJrWXpHWDQrTHB5Ym1xYWQxdXp6QVNMamlCWmNKNTJOcmVPanc0enVVeXNPeXhpQS9mbXBjVlBaV0NTd0F0dmJXOWlsWlU2RzNvYUJiOHpoN3NBTWdWNkxXaUNKRGVHQWVNaXBJaUp3MEQ4Z09ENExKMWdOSHdRakhmYXJadTNMd3NDandjY2N0eUh0eTlaMXYyZURRYVRVWm5KNmRRUzVWS3FkTnMyNVlKS0Q5NnVOOXN0T1pST0xIQmNBQ1puZHk0ZVEwK0FPREpsdHlRUGNjcGxRc3pTQjdOUEE2U2V0S2syWnFHck9rcjZ5djlUcTkyZklJUlFDKzFPejM0QTZoWE9xVlBwbFprd2NOMXo1WHk1VXJoZ3p0MzU5RVlYZXlDeitETUpENTJmSHkwVWk3dkh4eE5IUlBhNTVudit6Ti83ci81dFJtYi9SK09NUXRzaEVtVlVpQmNFYWlXT2NKbFJURkNpTFA5cEd0SlNiTkEyQ1dJNEQ4OGpoMFpSdGdlZGxpNDlXRmdzS1hmais1Q1dsam1VcXBZSUdMMGRHT1pqRy9LaSs4WTZXQktESXRCWmpXZEtlMWV2Ly9hNzgzZCtYZzB2cnF6cG5Mem1iRUI4UTV6b1d3NjRDTkFwd1FtZ21FSVkrRTV3a3pjZXFsTUw1WUI5WFJkT0dTZ0hFREplRGdTZFkyUHhRaUNVZDRjVGd4TmlVZGowRjdEQ1MxbkIvdU96RHk4TGRocFNRUUlvQWg3L1FGNGp1ZTU0VVFyS09aTGwvWTZ6VTYzM3djN3lSZHo1dFRPcitUbnJ0ZHNOdms0MzJxMlUra2tEaHgyT2xCMThIUUJkL0RYVkRvTk9qTWFUbkU2VkxuYkJuWUJ2bkd4VUppTXg5Q3krL2NmY1l1RnJDY2YzM3NBUXcrSGJ6Z2Nad3NaRExJN2MzbE9BQ21IL29PQ0w1UkxzcW81OENHNnZYQnBZR2h5UmRFOVB3QWd3SzBoSk03VWZMeC9vbXR5THA5cHRyclQ0U0NwSitLeXJNVDRoNC8zZ1Ztd25rYXptV2F2Q29UZ3I2K1VnQW5idFNFemhVSnBNcG5RSzlrMHJYcmVrRFFOQkF3OTY4QVRCK3NQNWtLY282V21QRy9qeHZYNzl4L3M3OE1ET2sxbk11ZzMxNS9CNzY4MzI1SW9nQk5Da20vY2Z2SCt2WHV4eGR3Mm5WYTdEVWFrU05KR2VTVVNMQXhEZzdteEorWnpMenpuV2JOME9wM0tyMjk4L0pPa2lTZ1F3bG1FZ0lZdlNnM0JRRWtYQTg5K1FvQ0dnQTRCRThhWFlhbDJRN3pTRVNRZXlMREUrNThNeTBUMnd3NmhzTnk4U0w4SWJOZXlMbUhBdWZCQkNqTXpUR1NlQ2dqaWVpTGxUa2ZOdzBkSTlXZmVqY3RyaTVodVNha2x6ciszckRBd0VhWTIvSWx6c1F1cEVlN1dqZXNSTitDakVWNFFSRm1rK1RDanFTN3hHT2FZUDRleTFETkpYUlFjays2U0t0RllBeTRnY0JPSnJwVkx4WHhTMWd6NGNHa280MTV2T3JHbTFnU0dEVXlBblM4RzNLK3NWR2JPYkF5MGprZlF4UFZxUTVNbGNKNTZ2UWx1VUN3Vm9YZW40MGswSGxOa1pUU0NMR25CbkZaUExwWHlnZSszMnpUeGk0dnhkRTA5RWltVWMwL3VQKzRNaHFLaUR3YjkzZDF0T0pkUDlnOWhEZEE4bEErTm15MmtJVG11NllCbmE3bzJIb3dLbFRLOGlEa0g3MEJjK0hOYUdvRzlnSGM0SEIwZm42VFRkTjkrSG9sZHYvR3NIRWwxV2cwNEk4aTF1clVCcDJSTWo0M1NsR1pvNHMyTk5kdnhScVBwU3JsUVBhK0MvalZwUGxuTU1QUkxsM1pPVHM5UkxpMTlpd084R2JDT1ZzQW56a0pRVkxsMmR0SnVOZER0U08vMGVnbGFhUEx4eHNhR1packZRaGFlUXlhWEhuVGFydTJBNldYekdRaExvOUZNYS9yNjVqclBjNlArNEtSZXhRaW5NQnJ3aUxydFJEYTk5L0hQMHN1b3FhdHhxcWQ0cEFnTkxnMDMvUk5tTHpDSUQwMFVZNkQ0RUZqaGdSL0JHUXNmMldSSkYra1VvVGpMejNnL3RrbllFRnNldytMaEhpSVRMQ3pUdzJPWG0rRk9pckhyUDh1amwwS0kvMWhzYmUvV3BOOFkxczhqd1R5YlRxeGsxRURKMjFHZXhCeG5RRTVHYkhCaUtpZ3NDeTV3ak13Yks0TlNrWWVLQjl4ZmV1a0ZWYWRWR2tHeU9aNkQ4NVRNcHJFSEhpVEFNUjRSM1lVZVJSV3N5VFNYVE1MeTdwK2Y2d25Oc1QxQU9Gak00WlZpdERSZDJWcGRlL3prUUpJa25DT1IwSDMyaXNreHJWY2YxVlFsbVV3eC9zQVBSME9BS1pGSUh4NGN5S3BNRDF1dzl3a1Bod09aWG5RUnBXZDhaaTQ0RldvT1BsTTdyeFVyUlpoK3NBc29NMnRzN2wyNXBHdkdwRDhHdUd2bkRSaStack4xNmZKT0xBcUNJN3UyNjlndTdBdzhSelFiM0Jka2JlcTRZQmJteElablVxdlhnWFdVRDBrbzVyUDFhajBTNHcwOWtUQ1ViRDc5MWh0dlhMdDJPZkM4OXo2NDUxaFdQcGVEZFlLSWdxTkRrVmNxWlRpbXNEYmdGY1BCRUQ3M0FCNzNlRExvOS9nWUQyYURucDc3Y3k0V2d4eWlIOEMvYld1YU5EUlVHNGVnL0tTUmdBOE5WWTI2RFlmRFZESXR4bm55cWhleFlqbEhUWkRpd0RkWTR0SFJDWHhpMnpGYnpVWkNsY2REc3owY0NRSU1FbXhiMEt5ZVAvLzVIMXlJQ2tBUlVtUWE2RENFc2RBM3BNRm5vNzRrT1BobEVVWnF3L0FVOTJHZ3cwSjQwTFV3SEFsNUNUT0FEVEhzTEFORlVENVNtUVZnYWVISnczMHNRdkh2S1Q4OEtnekw5RkJLY0pydnpVeVJXSnl2QVBIdDA3azVBck85ZHVPcUl2SkR6Z2hZR1UvTG9nUFpxY011K040R0lWRFoyTTFCRTRxNkNzT3EwbnFjTXlOcGRKdXRHQlJ3SWpVZURqR0VhanF0SmZXWXhFZjhCWFRrZWlFTjBOUjdBMFVXREYzSGVieVpyeHZhWkRnMkVucEMwYXF0bHVlekJYVjFvMVJhaWZxUlpyTUJCaS95Y1hjR3lFNmcreDgrZXJLeXRoS0w4STFtQStwV0V1SGhjYTdyUUdZbWRIdVN6K2V5OVBvTmp0N1poTEVmRHlleXByUWJyWFFtVlNpdFFJN2dIMmJ5K2RKS3dSNmI3ZTdBODJlQ0NMR0M0ZUdKV0VHQlI2T1c3YVpUS2RleWZIcWcxb2FrUVZvR28vRnB0WXBpa1hsOVk3VmNLU1oxSmFIcGwyOWNmWGovc1RucFhyOTJhemkxYXFkbmtLSk1Pam1nV1paZXZsQ1llVzZ3b0dmUGdtQ0dub1hEbWsybFlRTTFSUU1iS1pjTC9SSFJkOGdZaUNlYjVlOWo1SUFYSUo2NEg5eVZidSs4V3NzVnNuRStmbnBhWmU3Ky9ObnJWMVJSaWlJcEx0TFZnbXJMOFJ3NHJ3ZUhSNjFXRzhSUzVQbmVZRENabXRlZnVWYXRWOGZqTVlaek1CaUljZm1sUC8zVEVTRjh6UXY5QTg4dzJVemhzbEZubC9rQWJScG85cUUwTnVyNHNGOEdrV1VxQzRRTTdFV3RHWkNZWVNBd0xwNiswVFE4RzRXbEJXRmZ5TUJ5aG52SUg2QTk3RkE2aEowc3hIRW9MUjlpbW5wb0dYbWFoeEtYZ1VybkpXbjE4bTF2T295NEUwa1FOemZYWmd0K0VoRWo2RloyU25hcUM3aXpyYkFMbm42UUZPYmhMbTl0UXFkQ1owY0ZXaFhEbWZsazJlZSs1OWdxenlkemFZOGVZWTYxem1zTFBxWnovSnR2dmZuS3k5ZTVoUmpFb3pNSEFOVmM0dnFEVXFtSVBsa0VQbnpJVHIrbnFqSllMSlFXampXbjVpSzZxQlRMdzhsa2JXMTEwaDlOcG5hOVVmLzBaMTZ5aDlOVU5ybSt2Z2FmRGdRYmxCUTFvVVZrQU5zNDlCajVjM0VrZ1lyQTUwc21BQWhhd0Q1WU9JQWRuQWNJaENBNGpqZVpUTkdldGZXdFpyTzZtRWNnZnZBUkZYaXA5SVJnRENRZVB4aE5zS042bzJNbzZ0N09ubU5QVlZVNk96c05aZ0hjV0FPZXdNTW4yN3ZiY1prdkZJdU9hVmtUczk1cWdtZTMycjN0N1hXTUJBWVk5VWtaR2xBRnh4ZEd4TGJkdFMyNDR1WHo4M3E3M1NVbHdoQTJENEIxZG5tUURjZ1VJdWZQUUwxQWNsQlYzVEJnamlCK2FGbTJRTFlpeWtIRGlFaC8vNzMzRHcrUFRrK3E4RWFnL21FcWFXbWthSFJpVGsrclp4SThIdmpjY1Y0U3BlTE9OU21wMlhCcXpvNlQ1VlUybkNIQ2dSVldEVGI0aUM2MzhTRU9RMHFmTWdITGxCamk0Q204S0xBamxpa2hoR2dqVEFnTENnUHlVWnhsb1lMQ0hYUXNUazJPYWJpZkltUkF3dDFSOW14dHFNN0RDS1VUdmduNEYvR25BYnRSN2dJZGtkKzhxb2t5TjNlVDJXeEdsNGQrM0tIemZIZ2FxZzl5aDBlamtLZm5vRk12VTdsUGZQdzVYb3k3SnEwNDZ3WVdGNDBWOGdXQjR4VmRpOFVXSUMyS2JzeUNHY2o5MGVHSmJLalhrMUtHM3BnVmJiWDZhbElyWnRPMmFVSFhqY2ZtUEVydmI2aXNsUnZOcnUvN3NBeGdFNW9zazA0ZER0V2s0Vm9lWFVxbk5laEtsZkxxL3Y3QjN0NHVMOFNuVTB0VTZCSWU5Q2pRY0hweWxpdm1hWDNHQ0lkTlZMUGI3Z0laM1c3WGMyZVFhQzRlVHlRUzhQYkFZdnM5V3RlejM2ZFZNVFkzTnhiQkFoMTZmSEw4NU9DdzAybG5NamtvZm5yeXpac05PbDBqblFBNXp1VlNJTis1VE5xeHpXNTdVR3Qya2hsZ3pqUU1wVm12VFVjV1NGMkVveldOWFl0V0dvT3BhTGJiVU9UcGpBNEhkSFZ0eFRMQjRSMmNzVGNjSGgrZjh4d3RwOVBwOUlnUXNtdEQ4TmRoYVVSYUZ3NnlTMjg2Z1dCTUprTTQ5clpOZDZEWXE2bm1rTWwycDZOcEd1aEx2OXVsOVNJZE41dElvZ0x3SHFDOGZGcnNsOTc5RFNjZW8xcklaamMzTmdBQVNFRzNWYjM3N1ZjYmQ5NU01OHVjQXFuQXVNNm1yVk5KVFVZZzIyeDRrWk9RZlJFUEV3aGc3SThGUWh1TEwvT0VtU0VTVEVFUzlKWkZzVy9rdU1pT0Qxb2Eza09sTWxrU2hURHo4cVIwTWtDZk5ta0hrSWRzN0l0dFVwNVFvN092RUpZWDRLUThsSXRLd1o4UWwzTVZQWkZCVDJTVGhzaEh1MTZVMURzN0dSV0lQT3pBOENoRTJjbVhzaEJ1UUx1dngwUkJWcFJoYjdpL2Z6eWRqb0VYTGFGUFI2WVgrT0FrNW1nTUw4RXdBRmFyMm1nWE04bTRMRDQ4T0MwbTAwQlNUb3M2dGc4elA1cE9aRkdwdDlvam1yaWlRdTlCWTRIc3JtOXR1cTZiU21XNlBab1NDSWhDdmNDUFM2WVRzcWcxYWcwOWxVUmRBQ0I2THBadTFzYnA5WkV6Z0dNS2xnbjBPSllOc3dXbGNQL3V2ZDBybDFkV1ZpQkY5RjQvMStYaS9QSGg4ZnBHT1pWS29ibTlWaE1Db0FONm10N3JEOUlwZXEwQUc0RUZ2Y1NtMVRrOE9nRmVBVFZWVmNTNEFOL0RTQm5kN25CM1ozdlk2L1RibllTVzhLT0xCM2Z2d2dLQU9uUFJSU0dmZ1JtaGw0N012Qnk4R25wcnJDVEc0NHVBWGtWRXo1aUxVcS9YUit2ZzM4S01RS21qMDBGTjRCdWcrcWczbEgwdWx3T0NzWjFRZFpIamNWU283SGhCUUFhNE5JYXF3aytZakVhRmZMRll5SS9ndlFRMENTT3ltQXVDQU5kSWxlVVhucnVOOXVMVDZmWmN6ODFDUkUxVFU1VFR3NGNQdnZaN3IvLzJiM3p3Ky8vdTlLM1g5cDc3R0s4bE1kZ01lUVFIRnNmWjJEK0wwVGJUOUtIZVk4aW0vZXdBRm1Qb1dLWUNNWFFZZlZIYXhUZE5KR2JSNWVjaUxQT0crMWc2emNqOU1BdWxFK0JwTDNYRE1oUFZCZUhpL1BSaGV5Z25BekxNZWl6bUMyb2dxaGorb2lIYjg5aDRSZzJrVFBSTlIxR2hGS09BeHJIVUR3UDNUQ0hYcWpXRFNHQlBuV3dtQzgvcjlQUmMxbVFGUkVRQ1ZpSVlWVkdLdzJaR25TQmZMc0RuT3p6cmRtdzN1NUUybTcyeDUzclJpTzE2bXFvT1J5TU1CN2cyVUE2Q0JEVTJjOTJUMDFQZjk2RC9vSi9BTWVhTEFHclNkaHlaaTZZU0dqMWlPUjVQcHRNY3ZZc1lxbFEyRERpUkhJWVo3RndTSkxpbllONzBUaXhKekdiemtrTHZxZFExRlZiZWNoeXdtbnIxdkgxZWUzSjhETlVPQ2dadG1DL2w0UUp1YmtMTUhKd1hnamVIZW01MVQ4NXB4ZXBzSm5WK1hrc2JlanFUaGhJVDR0RW5CNmVxTG9IdWdHVkhaUkcrcVdNNytVcTVlVjY3ZWVONm9aeGZYOSs0ZCs4UkZESVlSVEJmQ0JLZkwrVEJ6SHRkZW1FT3FzL3hoSEthMGNuem9QaWdZbk53ZDlLUndCU29TQVRzRXlDdU41b3dDSmMyTjJmT2JHTFpzU2luR0RyZ0RvdXFLclRHSmRTT0E3b1R6UEpsdWovdGVRNEs4SDFmaWd2WHJseUp5OUpvUEpRbFpUeVpORnR0SUI3dFF1ZlV6azdsR04rb25oVXpLUXp3K2NIakc1LzYvRHhDMStORDlVYkRqNEpvNkduMFE4WkRlR1l6VzBLRU1OU0VVQXNEcFpJUHV0eWk2emxzRngwYmZyTzhkQVJGMkpuQ1ZNckFkdEdIOXVIenRCZzZPSXl3Nm9UN1AveGVIc1ppN0pzbFhPQVh2MEUwNmk0NGJ4NVR1SGxPaytzMlBSRzBETjk3NE5PQTdhZEozS2QyTnNCSVpqR3hYS2xVRzQzVnJkVmNJbk55Y2pLeFRTZ2t5NXlzNWZQK29CLzgvOHY2MGliSGpmUk00aUp1QXJ6Skl1dnVxdTRhcVhXNU5kSm9kMkxHdXpNUm5nOWVPK3pZL2VZdjluN2JDRWY0aC9sWE9HSmpkeTNOaktUcGxqUmQzWFdSeFpzRWlZc2dBSEtmTjRHcWxzSlpMQ0R6elJPWlQ3NzV2Q0NZa09XRkMwSml1UTV0cXlLSjhyY3ZMOTg3YXI5NmZSZUdjUkJ0RW01YnIxWmhCVUFsby9Qb1dmRHRGbXMzYllya3VpdHZDWjdqT3NzcEdNWm9CTFhVNi9jM2NYQ3czemx0TmYvdmwzL3d3b0MrRmZJRG1NdUxtUU85Q014SjlDMW1nQ0dGUHNYa3dlVjRub3NDc2ZSRFE2Tnp0K3ROUzVWTFFzRXd5N0FIYlN3WmRua3hud053Z2U4VndkeHBxek1zQThuZXdkR2ZYbjVmcTVXQWtGcWxEdHhjWDEyUEp1UHppL00vZnZXeXVkY3MyemFaTHNHNjNxcEhmZ2pWNWNHRzRRcVN1UHZqbDErWHE1V0QvVzVSVm9hRENZaTRJQXVkZzNib0JtQVluLy9GUjVpdnM5a0NNeG04QmFEQnZCWEZJclE4S2taWFF3ZjZudWZRc3hYMCtEU21lcnRSUXlHMHV5d1NZZkIzdTcxMmN6Q2UwTjVNcjE1aWNMNzc0WFZJQ2RLaVRBOFU3WGU3bU42NERucmxXQmdvS3RsRjdYYVRkdUwzUEpnVHNGSVlYTGpiZnQ4WkQ1SGw2S05QTVFyc1Rrb0dMM1pnYVlqVVUycmkwMHpBU0FtTFpNZmN5ekpSa0FneTgyUkZzRVFBSGpMVE1VOVBDYkl3Q3pBWktYWHlzMXhadmtkSGhiSEZJVTlOVENRdlA0c2tCeStWOTNCa2pua2pqdk0ydTRaZVhNR0tpek14c2dNUlZCWlQ2ZlJQdEpJaTN6bmh2L3p5RjZrb0RpYUxhQk1PZXdOdkUzYjI5N1FDUGE0TGE4dHovTXZydDFwUlRLSnRzRnJ2QkFGUTZMUWJocXBiNFBXV3ZvNlNGVVpGS2RhQUNOMXdoaE9RZ1FLOXY0RDJqa1BGV0pOQlBNSUlKdG9LUWxYVmFqYTRxWGgrL3ZUcTZ2YjZ0bWZ2dFk4NjNmbmRLT0V3SDV4eW8yWlpKVkFCTkxoL040VHlPemc1QUZzQUYxaXZRMVZSWVp0aVFxZUZMWFE4RjBkcjE0WEZBSFhvcm1FeHU1SWlRTVdydXJaeWxrbThBYXNCcWdBeVpJZStoT1dNYTBhTFlQTjFEZzVFVVlIRmNuSjg5UHFITitrbWxzVGkrWHZudmR0NzFkQ2creWREZXRxSEx3cDd6ZXBpdW5TQzFYNTNqeXNJbnVzTytrUGZkNU1rWFcraVNrMjNOR1diY0Y0WVlZYUQ0UWpRN2x2YVJScDFZUW9sYkE5MUFMdGkyMnRnRm90ZGdpbFgxbFFaYUVZN1FkaWdIV3pWdUwyN1cva0IyQ0JHT2s1aWhTeDlxV1NZZTYyMnBocHYzNzQ1Mk44UG94QThwOWxzenAxRjJTNW4vVXhQb21vR3JxVmF0aGVMNWEvLzduL2ErMGM1OHBnRDgvZ1JpdWlUeVJrc0VHU29vS2lIVSs3UDBNTFNzK0lZdWtuYk1oRSt1WnlWVHFTRkpEaXd5RHpKbzI1bmptWVl4VkFodVVPUzdNZ0FULys1eXoxWjBvemlrMk1wb3gyM2pMYkpqcWZuMXZPa0xDZkxuK1drNDd0czVJUWtwSi81MUdXeEdFVldvKzc1bTUzdjFqdk5jcDBXWDFVVUorUEYzdEgrTWc1UG5wMEpzbVRaQmxsTmdxQ1U1T0ZvMWh0T3BzdGx1b05SYTNwWUVPZzcwWElBaXJJT3dhZWhuelJOcjFacnFES0tOcDkrL2tJV2lueFJiSGU2cTlVU05xdUlZWWpESkZqYmpiSWl3ZlFrL0lIYmxHdGxLSFZOVjBGTzBPUTRqb0ZDREgrOVdVL29XNkswZ2xwQ1g1SEJ2OTI1RjBGNWR3NjY5SlFLdmV0R3BVVkY0RDc0K1BsczVvQUIrK3dKR05xWUdqeDRIZm1CWDJ2V0hkQXpqak4wRTlZRWdGNnJWMEhyZmNlQlhkbnIzVzI1M2VkZnZCaVA1bnV0bXU4dVg3L3RUV2RMdmtBZ1Z0UWlTbE9WNHRuWi9tRzdEdXNiZlByaStjOG00em5yY0dvdFp1bkR5RzFoTjJJT0lHTkt6OGxRQ1Q3TVhFbWlqUmdNczFhcmdKNkJ0MEJsd1B5bGRoYnBoYlUxUUhtN2ZYWjZxc3F5WVpZa1dRcURkYnBMTWZOdHl3SnZSUDhjSEJ5T1JzT3FYYjdyOTA5UFR6UlZCV2Q3L3RHbnYvNm4veFV6YURJRnpCeURBS00zdTF3SFptRE1OQ3dsZXdEYVF3Nm9xa3hmaytKa21pc0xzeFNNZTJkcGtZc3VsV0dWRlVkYTlxY09RcVJrT1NqOXc1bGlmdVFva05lUXk2a2lDcEdVeVgvaXVHaGIyTEI3a1EvRm9BbEFOMElQSmVjUmRJSVlGeTVValhLNGNvdDhldkxzYWJvVDJvMDJLQWNuQ0RmRGtlKzVFdjFRV2pvK1Bmais1YVd1U3FQK25idHl6TEsxbk0wMFJXczIya3E4dXhrT29vUitqTE5jZVlQSmRES2Jnb3FnQWtXV0kvcWwwam9Nd08xaGJ0RXV6QWVIQjc0ZjFLcFZFWXhFRkV1V1hsSjFXeEszQzRjVHNQaUtIajFuWmdMeUFQVFNXWUs1d0ZDZXpoYmRneTV3WEszWDV0TzVYUzdUY3kreTdQcGh1ZEdHU1YxcFZBeFQ2L2NIN1haOXpWNzBSMVlnL2I0SjFjWnBzb1VXQkNNQ282RDdMVkVFZFJ0SHNDeldpd1c5SzdQWHUwZFA4YnlJaElxaDNOemNZa0dRVlFtNjJDcWJNRG5zY3RXWkx5dGxFeVFiUEtUZGFvNW5NeWhnVXk4NllDZHhpazRMMTJHYTdoSjZ1UU00REV3ZXVoZUpqb2Qya0RVTnl3c1dPdG82aytkaHh4d2VIcFFzek5nUU0yRXluaFFFZmpnY3NXMk9ZN0JCakpjazhVZjBZZ0xrZ0NrOFczbGUxYWE3dEdCeVdFSHNTbmsyR01rQ2IrcjZjREpwTlJvVzdaaXczai9vdGk4KzYzNzZDL2FWTHR3REdETHR6ajZFMzNmZ1lYaGlhQ0tZNUpxVU9SS3hFSUdINE15VUx5UjVFb1lwK2pBUFR2a0Nrc2ZTakdBVlBxWmg1OHova0lvY0ZmY1l6QTFXOHZ4SStoUEg4SXdUYXdiTmFXbys2czRLcHRXRFZaTWxBL3B4WnBHVVdQaXJMMTVJSlYycDFjWmVCTzZwR2JLRTRWaXYzYVVEYmRwdDFubFJ4SkRvc2dxV3N2YVQ4V1RtanVhcmxWZUk0LzVnZ05XMklBaFluYUhVUVZ3MmFXcG9waURSdlVVTWE2VmNCcVkzTWIyaUs2YjNmSzdwWm1KQ0R3TUdYcmlFR3ZmOE5GaHZ3d0FNOUhZNDZkL2Z5MFVKNjNXbjIvYmRRRlZsQVNOcUdZQXZHQTdQOGFBUVFKVW93TERrc3Q4cjBYTzg5RlpBSGl6Qjh6MkUxbUhvQjZGWk1qSFRjSm1OUmdNakFZM0xjU0FWSW5ySm9wZDJ4Q0lQWmk4QkZzQ2xMR3V3SllwRk5GeVlqY2RidXJ2UEx4MFhEVVkvalVhTGRyZTlta3hkZi9YczRrUVZGRDdkUnV2NHVOdUdZcjc4Y3c4TGlFNWJ3SEtMcFFPREZSZExQVTNkajM2bURRa2h4TUlWQmZTbE1zWURGMEkwU2VBTlhVUGZ6QmNPbWczSkx0M1d5amJvZjdDT3NUd2RIaCtoaDBEL3NKcmFkdFdxVktyVkNtME5nclVqam5oaU84WENkbmM3R0NpcUpvbksvbUczcUdxLy9zZC93Y3dtVkRKc3NsRm1rQ0tYZWVuREZDNTBJUjF6RWsxQnhMRjhFT2ZwS1JWZFIxNGVTZWplVSs1b0NqQkU0ZndUcFU1RjVsNldtMXlXTEpOUXhpem1YVmwwUUNXME1ES1lzb0l6SWZ2TFhINW1aZUdmTVNrS1pFZldEQlNWdFpta1dXdXpheFQyajQvdko0NG9TczE2Q1RObGZuM25PdFAxZG1lYnBkMHVBVk5leE5Gb05nV3FkbUYwOGY1RnZWbXpGYlZpVjB1VlNzcngxYjFHQW95blNiSk5tcTA2M2JJc2c2R0dVSmt3THFNb2xBVFJwWTAvNmQxdUlMdXNDYnp2ZXJxcFd5VXo5Tnl5YVVSSkFmeEg0Z1JEVlc5R282b2k4Nkh6Mnk4KytQclZWYmpaS0lyYTZYUkhnMUd4S0E0R3cxcTFocWtEOVl4SmVQMzJXbEZBa1hjaGUwdVpDTmJNaTFYYVZyZEVkNzRMNmVIeElTYlBKdGswR3ExdHVzVnliNVpLdEJFQ2JZS3dsZWtGOWlyQSt2Nkg3NjhXcnNoem1JS2djSGExck10Z0ZKdURvMzNIOFo0OE9SMzFlbmJkY2hZclFlTWpYRmdRNzhSdHZhRTJtcFhqczVQVmFHN3I1bkxsQzlBWE91MTdDbzNPdmpURkhNUDFndExEMWlpZ3NvUzkvd2Y5dnNIazM2eURJSEFjZXFNcUxnZEVxMW12QVlTcW9oVzJXNkJmWjV2aVkxbkVySWFTWDhlYjI3ZHZ1NTJPNHpwU1lmdjAvR3pzT1BWR2M3Snd1dnRkZzV6cE8vT3p2L3pyd2dQYzJmQXpUSkFQOWJKN0o5UUEwb2cwRml3dWExSW15ZUhPeEVnRkVXV2g5Tmw5SEVxVHNYRktTSVZTYk9iSkVFOUJwR01lU0ZsdDlLRnlzMWJrRWlxSVBHeitVN0dVZ1NWbGN2Sm1FaFppNGx5T0UwUDVUNlpZMWlxSUhncENmWTk5Z0FCVktIVEs1YXBsOEpFL3V1NVBRcjlzRmcyWVBaYnRKNFYvK3ovLzdzVmhUZEN1ZS9lLytzMWZHa1hOYXRXTWNrVXY2VXZmVzY2Q1lCdmdBbWJqaWFuS1YzZjllSmNTYVVrUzEvV2JyUWJZQWtEUENWeWN3QTRrK3hsd3hCR2pXN0xzWHYrKzMrOWpNR0hXdFNvMjJuWHhaTjlTeGNuVVd3UittaFlzTFJXMFdxbGFwaS9nVmJuUmFLNjhBRHpIODF6TXFPWEN3YktUeGlrWUxhNEZDMXJKc2dJdktBajBmU2VHYWJuMHBTTC82dXZmcjlkT3JkYW1sK2dhQnFvR2d4ZkVnaUR5bzlINHZuZXZHZnJ0eloycWljMTYvZTcyMXZGY2VoQ2d3SXRGd2JDTVhtOHduenVWbW5seWRqaWlGeWVsUC96NXJpZ3JvQnZ4T3IyL20xUnE5cmZmdkpKMVRWU0tBRUs5WHA3T0Y1WmxYVnljK3o3OTJCeXpEcVlHbERySDArNncxTlRzYmd4WG1OUFBvK2kyRWJBT2F4VjZIVEdyd0hkV3E4TzlQYXlBQm0zQ1E1YUFicG02WVFadXNOZnR1djQ2Z280b1cwbWFtSmpWMGNZc1dhN3JBcWFLSWg4Ly83ejU0cGRvQ2ZvejAyb01ub1FUNXFjWWVOZ3ZUbW40Mllkc01TQ0RVakJKZnFBekNiTUFHazVKS1FQTHhEQktzTXZ2dmoreWlUd3Z6UmlJOHl6Wmg2VmpFNEZWOWpBQkhpckpNN05zbE9oeHpsQjY1bUhIaDVZeUdmdC9jRmtCdVJTcEhxck9MQW9xVnZqZGkwOVNWZG01L21EaXZMM3FnNFp1dHJ2NVpCYUZia1BWQVZKWWpVOS9kalozM1lLaVFDZUJ2L2F1YnBMdGRqbWFBQ3ViYUEzdExvZzdVemZ2QjJONkhqQ2lCd0lEYVBnd3RHeFRWeFNNZEFCV1FPOEhsdEJXL0lGbUhPM3Y3elp4cTFWSGRRdlBOMVE5akZiUFQrb2ZIcmF2YitlV3JWNittZjcybCtmMzgraTdQM3hiVk1YcGRHWlo5RndYYVhBdUZZc3lGZzBRRytBQVpMZmRicXlXeStsa2JwUlVUVmNhclJyUDc3NzU2dmRhY1RlZHVxZFB6ekRwb1dQcjlmcHlQdnYrdSsrVHphYWtHMWFwZE52ckFTWDkzajBBaWZucExoeEZMS3E2b212YTRINEl3czBKL0dReStlR0hTOWYxQko1K3hsVklZR0p3aHdjSGhpR1c2OFpubjMzeTNiZHZvekQ1N1BQUC8vMzNYOE1tR1UvbWQzMFVXd1R0aHZtTFhzZlNpSHpvY1pDVzdPNE5GaWhBSElnaFRHTjlpWlB6bzhQcFlnSFl3ZHFRZVU3U1ZGR1c1clBwY2JlckdoWkEzdDd2M043ZUxKZUxxbWxNbkVXbjFicDgvZWJKazVOVkdIN3cwWWN3TnJaUjJEeDlXcnY0aEdDVTRSb3VIL01zUkJveEF6SEo0TElwd1pKa2drZmM1eTRERll1bkR3R1FnRTZNQVVJbW96dVpMQkdUa1MxTUJiSzZFUDBqcERLOW13ZHpENVgvQ0hnbXBWT1doRDRaQjBFUWlqTFgyM2xzNXFjR3dyRzZLSjYrSzRBWDJSNHVNdnZnbnp6QzMvN3FSWldQcHVPbG9HblBPKzJiNFJpNnJ4QW5ZclNwNjNKc2FOMUsxVjM1cjc2N25EcHp0QTcwZHpvWTZZYmM3blNIZzhsd01BWUR3U0FlSHh5RVVReWFyZXNhalNOUUtZanp4Unl0VURVTm94NnRReHBnOUFVN3B0c1lhRk4wVlJSbCtHMUpxcGZNeVdnQnBnQUZKbkNjWnFqOVBzMm84LzF1NytxcVZLdUE2WTlISTJoSDMvTXZ2Mzk5YzN0YktobjFka3RTWkZnYUlBT1NMSUliM0Y3ZkRQcTkyUFV4Y1AzSjVINDRIL2Y2eTlXcTNxekRWbzdYWWRteVZGMmpOM0RUN1NONjcvRmtOTnVzMTMveHljZkx4YkxiN2F3M1FhMVJUYlpROHh6TTM5Q1BQQzh5VGIxcTJSdDZSN0hXYUZWclZRT1Q0WWZYMTFIZ3QvZWFSYWdNVkM4b2J5OHYwYm1hYmtCNVl4U3dzcW1LQXUwTkhRQWtvZkZrUlRBZlBCdElJOW9aRkR6dDdQVDB6WnVyU3RrdUZvdDJ4WXBpMmlzejhIeGQxWUN1OVNhZFRTWXc4ZDM1bkRidDRlbFdMSnI2aDVmZmFxWFMyemR2SkZCNVZlbWNYSlNmZll5UnBsSFBISUVtOXpKczVNK3JNRVRTWFJyRVF3Q2lnaVpCOUM0dGcySitabzR5czltUVR5ZEVFdXdJaEN3cXkvdG9ITEpJT3RFQmlmTG5ZOWdIZjBqL3p0R2N5Y1FzTlFXWVl4RVBsSVhBUjR0Sm5qeUxZL09CWFFaYmJQSmlzN1psbTRVd0FZWHdMNmhhOGUvLysrOVNKekJqNzVORDVlZjEwcGY5aFduU04zeWJOQkYxdFdPSTlXWkZOV3RmL3Y2UGpWYkZVTXpaYkw1M3NDZXFLcFFWOEYxdk5VL1BuK3ppMUYwc2IvcDl1MnhEdjRPL2duWnV0N1RwYmhENGJNdHN1dThBS3d0MTY3cXV5Q0FGQ3RDZzYycmdnbnNIb3o2NHFIYzFjWmJRaU1JTzVrQlJON3dvQXArb05scXp5ZGdQWEV3YnpCVllsbUNyODhrMGl0WlNka2RQMFQwL21FUHB6ZWdIMURCaTk0LzJSTG9GU0srbGhnR2dLZktyUDczYUpha0dyU3VJWDM3MVIzZmx3ZUFtSHJWTlB2djRBNDZUams0T3h6TW5qRGVZT0xCYnhxTVpDQWtVc3dDcnNkdUJZVnR2Z3ZpWmc5RVU4SVhwdkZ3RXUxU1NKZW5KMHpOTU5jZnpDdHU0RUVSMnlZU2VSdi9HRVQzNGd2cEpqZk04ZlFVQnZnTHVnTjZuWUFxRW9aRzJaV0hGdXJxNVFScmJMdEcrREY2b3F5b3ViYmRObDU3YmJqU0NkYUtweXYzZDdkSHhTWWdaSW91YUt2Y0dXTTlXc0NWQWxpN09Ud1JKa2F6MjNvZWZvb0ljcVlUQmZMemhIdkNXUVoyTzdKOGwvUTlZenc0TVVvK1lBV3BaOEVjT3VWa2xKQWZQWUdpamZDU2psWndTWi85MDNRZ2pJV3JORWxJaWNwbUh5cUV6V3pteUFrbEt2cXdJNFBreGd2YVVaeDlNQUFJeVphZFpTSmtSb0F3VXBBd2d1TlJ3a2dnZm5aNFduTXZmL1BZTHR3K2t1WWZ2SC8zd2VsRTc2QlFMU1VIaWU3MlJ2OWwwT2swdzE5RjQ0cTBqaklGcTZGaldGd3ZZV0dtRnZXYm96ZHRMMGRTYjdXcFZzM3cva0hoZUtkRExDMkRFb2phb01XZ3hUQU1NY01SZUpJMDFIUXM2T0k4b0VwczNERVdNNDZwR0J0WTJpclNTRG1hbGlKeFNsRUYxS3BVSy9VSXQ1ckNZK0lFbmlXS3QwZktXTTFtZ1J5OGw2TTRkRmhCNjNnSEVZRHFaS0xLSXBxcVMyTzhOTU5PNmUvWFFXODhYRGxUajBlRSt1cXpXYm1vRjNqSkFqYmpUc3hPN1pxVmNZbWdxMm50OWRZTVdGaVVoOUNKTk5TSS9ERENsTnB2cGZENlp6TjFnSmNoaXRWYTV1cnFEdWJybDRuZ1gvdXpGMldMdURuckQxNjkrUUxMbno1K3FVQ0dZeVp0RTExVFltaGhaWEQrUWdGbUVKUS9YeTR0c3g2RWRQUW9FVTc2NzErNzNoMWdNd2ZGb3o1OENEOUsxV001aEJtaGF5VFFzc0NKT0tLNTk3K2preEFzQ3JTaWc4ekNUVGp1ZEFFdHFSSzhUOU1LUVYrU0Q1NS9iVHk3WUdOUG8wdGhuOTFYb24xUXNPMFBHZ0VBSHB1d1oxREtYSitBSW16bDRXVk9SamtXeFBPUmhja3JQVGo5MWtEQ3MwWDZtT0xKdFVRbU5CRml5RkZpbUgrZkwvRmxOZWZnaE9zTXVpZW1jU1ppUUJJUnVOSjZhbGtuekZGa3BMQXVUMFptU0N2L3BzeGRlSUx6OTArWGszcDk0NHZVaXFZbzdnOXY5NzFkdkZGSFJ1ZTFuSDcrMzRRVEh3MGlJeXlERTJNZ3kzZitxTkdxdkwyOXdPVkVRYzV5U2NvWFJhRkp2MXdWRlNlTFlNTFJxaFg1YnZmVDllcTJteUhLYzBCTlVFWHZyTHh4R3V0MXNCaXNQaW0vdGVoY0hIUmxsYlF1NnhDZWJIU2RLN21iejR0bFJ5aGV4VW14Mlc5dTJzZUFzRnl2TXBWWjN6MXY2Z2VNTWFJTWtyMlFZQU5BQ3V0MlpsY3dTdEYxM3Y2M3dITllvL0cyNTdkTW5SOFB4YlArb014blBmSG9waU4vcTdxK1czcllRKyt2MVl1WDNlOE5ORW9OSXlBVU9iZllDdjlGdWxPelMrKzlkU0h4QmtPUnl1VXgzVjNhRit6Nm0waHkyNVhnOEJlbTZ2aDU5OWY5ZTlmdWdXTHRkdWhXbEloUnVyZE5BeUlPOTNteXdHN0QwVFJsMU80Z2czZFZOZElOZU1ZbHVhRFlhSUdhQkgreTEyOHZsRXF0aURlcmRNSWVUQ2JSK3liU2ZQajNmYkdNVlJuYWF3bVJ4M1ZXajJRYkFXNVlPS3hmcUE0VjNEdmRoRGZoWVRsMy9WLy93ejVKbG9US0dWR3BVUHV4TUNhTUpUSkxGWlRIa3FHMDVVSElIZk9YQW9RUDU4L1FFMnZ5RGJIU2dZaW1JK0VjaEMxR3g3SnlGc2pCTEMzRW1lWEJaSG5KNWRsWWkvYVA0eDZUd1pDMGhDY1A1WXo1V0tpczd5MFVoRnNpQzdFTUpoSXZqWTlPeVY5dWlVZEtsa3U2R20zYTlPblBjRDUrY3ZOK3BQRHRwQ1VKOFA1MFZkRnMyclVxMURKYXBhSHEwU2Z1OS9tcnBGRVhaTUxYcjJBYWpBQUFGSVVsRVFWVDJZV2Q0ZDQ5T0wxZXJ5NVZiWTl1ODdIVmIzV3JWQzhJQnZTU2o1Szk4Tmd6QU9mVVFGblYzdFJLTHhaSlZVa1I1TXAxSXFvcmx3RTh3cnBneVVoaW5uQWdkd3hWMVNTcnd2dWRWOXZiYWh3ZnQvVDNhM3RFeTFKSis4dVFNQk1GWk9vb3FBMjU3blk1R0x4R3hzVnkwdXExK3Z5L0R0RTFwRTNmVExObjFDbGlTdDNBbFNRRzcyTysyYjI1NmlxYUZibEFVZU5qS3M4bE10elEwRFBwOE9CclBad3ZYV2Q3MUI2V0tkWHQ3Q3hzVUNJTWR1VjV2YUp1QVRaTEdXS05TUU45eHdLaVhnaWh1ZDdEYTVUOTk4OTEwQ3ZNN3VCL2NaOCswMERWamtIaU9mcW9OakViMGRKY3N5ekJTNlFvNUx0bEVzbFRFVXVpSGEvcmxWN2tTYjNkMVd6VjFFeXB4TUJ4dW9yVkFUOXR6dFdibHp5Ky9rWVdDSm9xN3RDREkydGZmdkV5M2llZjc3My8yWHovOG0vK0JFcmNFa3A4Q0tuY1B3b2ZZREJGTUd6SU5DVDlGWlIvNlozQ0RpSUp3QkxDSFR5YWlMT1JuUklQOCtUbUxnYU5DVUF5bG9YSXlWc0ZtVGU0ZTUyVG1XQ3hPZVRzUXBLUXMrN3M4cEJqZnVTeC9obS9HZldnT1VqM3NRM0pHNnhFdEhIVDM5azZhUzhkekFsOHVLUWxmVk1TdDU3ai8rdVVmTUpCZjN3M1NWT3ZQUGJ1bVE4TzVvM2xFUCtEWTNkMzF4L1RLcXc4cUZUc0l3OTdkSFZUcDBmbXBYaks1SGRSUVhHNDJwS0lFcXUzU3JzSjhRRDlWanNVaXZmZ1hTdzlvTzFvQWRmakZKeC9CamhRTHNZN0I1dm1LYlVxaWZEY2V5YVlDYkkyblM4Z1ROMnlibkNwdUJ3dHdHZllxVE9vdXRvdXFvdFJxOWVsNEtnbzdOT1A2NnRxZ0I1WDlhc042OWZWMzA4a1NuV2FXeS92bkorczBIVTZtWVJDY1B6dWJ6cWF3UktIT1crMUs1NkRSN1RaMTNiTExwY1BqMXVYcnQxQ1RGNmRIcDhlSHFxSWRIUjFFVWZMOTYwc28wVXliQXJqb1dIZ3dZWW9TZmUyS0lOaWphWnJwTmdVTHgzUzI3VXF4aVBZSDdIc3VjdUF3S2ozWEZZSzZJMGdjaGoxUmc2SEcwbzUxVDVHS3A2Y25IQzlHbXdURnN2ZFhKa1dPRy9XSGRyazZuQzNDbFNlSXZHTHFQbWo5Tm1tMTJtTm5LU3FLR3dibnA0ZHpaNFVXdnZqdGYydTgveEVxSUNoa0VIam5FTTVFUkMyWWtpY0pSell0NFpCaGpra29WWmFTc002Z2htQ0dJRGpteHovTG5EbVdoc0dmSXZMWUI1ZEZzdU9QNUt5VVBBUTlqU0JLZTR6TlhIYVBFMG16R1ByUFd3Y3ZQdVJGMzJjeHpMSGZ1MUtRd00wa2p4N213T0ovL3Q2Sk8zQkh5K1hGMDg1OWYrWDZybGJZalZlK0xNbTdkTGZmYmozNTRLeGFyczl2ZWw5OS9WSXkxQURxMnZlMW90UnFONkRYVnl2MzVzMVZHSzd2eHNPMTUrbUdxSmdheDRtdlhuMmY3TUJZdHh6Vy9kRUUxWUswME1zanFhdTNaNTEyOW11ZHZiSzZDVDAwc2wyMkJvNjdobkdITmhWNG1KOFZ3MUJWcFZRcVZVcm1hZ205R2dWYnZranZvVS9YNjdSa0dZTzdIaThXb2pncDI5WjhOdlk4ZituNDdzSzVINDQxMkk5Sm9XU1hpNnBtR3NZY0hIOUUzOFREeUpaRWZyVjAwOEsyZno5Y0o4Rnk1WUU0V1phQnlmbmR5KytCdm90blA3T3JaUWNNVHhLZ202SEpwN01GeUJJQUFTckMrSWdBd3dPOUIxV2ZmVTBMZ0FGdEFESHNZRmpnTThmQmpBSkx3UVZtWkIxUlNVSy9OeWV6Q3QyT0RxSml4Q0o5TGNadjRsalQ5Y1BqSTlDdzQrNWVtTVRqd2JCVHE0ZCsyR28zZVYwVFJLblZxa05Eb29lRGFOM2E3OEFtQncyTHQzSFpNQVIrQzdQYkM5Yi8rZS8vb2RROVFIdlF6eGtZVVJIT1ZHVUdBdVpoTTQ1aGhjNlVMa3RMZm9BRk9mSUVORlNaSjRjNkhFSHpJZnFkQkM3Yk9ZUENkSGlNL2FsN2hIaGVJQ3NzZ3pzRUQzVmtqdHFlTlk4NVNrbHpNc3VYaFI5cWVTd1dEajRLVU1MSHZBK3VVUGovMTA0WkRRUnJ0bm9BQUFBQVNVVk9SSzVDWUlJPVwiOyIsImltcG9ydCB7IFF1ZXVlIH0gZnJvbSBcIi4vUXVldWVcIjtcclxuaW1wb3J0IHsgUmF0aW9uYWxOdW1iZXIgfSBmcm9tIFwiLi9SYXRpb25hbE51bWJlclwiO1xyXG5pbXBvcnQgeyBTdGFjayB9IGZyb20gXCIuL1N0YWNrXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQXJpdGhtZXRpY0V2YWx1YXRvciB7XHJcblx0cHVibGljIHN0YXRpYyB0b1JldmVyc2VQb2xpc2hOb3RhdGlvbihjb2RlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcblx0XHRjb25zdCB0b2tlbnM6IHN0cmluZ1tdID0gY29kZS5tYXRjaCgvXFwofFxcKXxcXGQrKFxcLlxcZCspP3xcXHcrfFtcXCtcXC1cXCpcXC9cXF5dL2cpO1xyXG5cdFx0bGV0IGk6IG51bWJlciA9IDA7XHJcblx0XHRjb25zdCBvdXRwdXRRdWV1ZTogUXVldWU8c3RyaW5nPiA9IG5ldyBRdWV1ZTxzdHJpbmc+KCk7XHJcblx0XHRjb25zdCBvcGVyYXRvclN0YWNrOiBTdGFjazxzdHJpbmc+ID0gbmV3IFN0YWNrPHN0cmluZz4oKTtcclxuXHRcdHdoaWxlIChpIDwgdG9rZW5zLmxlbmd0aCkge1xyXG5cdFx0XHRpZiAodGhpcy5pc051bWJlcih0b2tlbnNbaV0pKSB7XHJcblx0XHRcdFx0b3V0cHV0UXVldWUuZW5xdWV1ZSh0b2tlbnNbaV0pO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuaXNPcGVyYXRvcih0b2tlbnNbaV0pKSB7XHJcblx0XHRcdFx0bGV0IG9wMTogc3RyaW5nID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRcdHdoaWxlICghb3BlcmF0b3JTdGFjay5pc0VtcHR5KCkgJiYgdGhpcy5pc09wZXJhdG9yKG9wZXJhdG9yU3RhY2sucGVlaygpKSkge1xyXG5cdFx0XHRcdFx0aWYgKCh0aGlzLmlzTGVmdEFzc29jaWF0aXZlT3BlcmF0b3Iob3AxKSAmJiAodGhpcy5wcmVjZWRlbmNlKG9wMSkgPD0gdGhpcy5wcmVjZWRlbmNlKG9wZXJhdG9yU3RhY2sucGVlaygpKSkpIHx8XHJcblx0XHRcdFx0XHRcdCh0aGlzLmlzUmlnaHRBc3NvY2lhdGl2ZU9wZXJhdG9yKG9wMSkgJiYgKHRoaXMucHJlY2VkZW5jZShvcDEpIDwgdGhpcy5wcmVjZWRlbmNlKG9wZXJhdG9yU3RhY2sucGVlaygpKSkpKSB7XHJcblx0XHRcdFx0XHRcdG91dHB1dFF1ZXVlLmVucXVldWUob3BlcmF0b3JTdGFjay5wb3AoKSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0b3BlcmF0b3JTdGFjay5wdXNoKG9wMSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW5zW2ldID09PSBcIihcIikge1xyXG5cdFx0XHRcdG9wZXJhdG9yU3RhY2sucHVzaCh0b2tlbnNbaV0pO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2Vuc1tpXSA9PT0gXCIpXCIpIHtcclxuXHRcdFx0XHR3aGlsZSAoIW9wZXJhdG9yU3RhY2suaXNFbXB0eSgpICYmIG9wZXJhdG9yU3RhY2sucGVlaygpICE9PSBcIihcIikge1xyXG5cdFx0XHRcdFx0b3V0cHV0UXVldWUuZW5xdWV1ZShvcGVyYXRvclN0YWNrLnBvcCgpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCFvcGVyYXRvclN0YWNrLmlzRW1wdHkoKSAmJiBvcGVyYXRvclN0YWNrLnBlZWsoKSA9PT0gXCIoXCIpIHtcclxuXHRcdFx0XHRcdG9wZXJhdG9yU3RhY2sucG9wKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgcGFyZW50aGVzZXMuXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpKys7XHJcblx0XHR9XHJcblx0XHR3aGlsZSAoIW9wZXJhdG9yU3RhY2suaXNFbXB0eSgpKSB7XHJcblx0XHRcdGlmIChvcGVyYXRvclN0YWNrLnBlZWsoKSA9PT0gXCIoXCIpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIHBhcmVudGhlc2VzLlwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvdXRwdXRRdWV1ZS5lbnF1ZXVlKG9wZXJhdG9yU3RhY2sucG9wKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb3V0cHV0UXVldWUudG9BcnJheSgpO1xyXG5cdH1cclxuXHRwdWJsaWMgc3RhdGljIGV2YWx1YXRlRnJvbVJQTih0b2tlbnM6IHN0cmluZ1tdKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0IHN0YWNrOiBTdGFjazxudW1iZXI+ID0gbmV3IFN0YWNrPG51bWJlcj4oKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLmlzT3BlcmF0b3IodG9rZW5zW2ldKSkge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2gocGFyc2VGbG9hdCh0b2tlbnNbaV0pKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgb3AxOiBudW1iZXIgPSBzdGFjay5wb3AoKTtcclxuXHRcdFx0XHRsZXQgb3AyOiBudW1iZXIgPSBzdGFjay5wb3AoKTtcclxuXHRcdFx0XHRzd2l0Y2ggKHRva2Vuc1tpXSkge1xyXG5cdFx0XHRcdFx0Y2FzZSBcIitcIjogc3RhY2sucHVzaChvcDIgKyBvcDEpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgXCItXCI6IHN0YWNrLnB1c2gob3AyIC0gb3AxKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIFwiKlwiOiBzdGFjay5wdXNoKG9wMiAqIG9wMSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBcIi9cIjogc3RhY2sucHVzaChvcDIgLyBvcDEpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgXCJeXCI6IHN0YWNrLnB1c2gob3AyICoqIG9wMSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0YWNrLnBvcCgpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBpc051bWJlcihjb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAvXlxcZC8udGVzdChjb2RlKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgaXNPcGVyYXRvcihjb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAvW1xcK1xcLVxcKlxcL1xcXl0vLnRlc3QoY29kZSk7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIGlzTGVmdEFzc29jaWF0aXZlT3BlcmF0b3Iob3BlcmF0b3I6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIC9bXFwrXFwtXFwqXFwvXS8udGVzdChvcGVyYXRvcik7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIGlzUmlnaHRBc3NvY2lhdGl2ZU9wZXJhdG9yKG9wZXJhdG9yOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAvW1xcXl0vLnRlc3Qob3BlcmF0b3IpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBwcmVjZWRlbmNlKG9wZXJhdG9yOiBzdHJpbmcpOiBudW1iZXIge1xyXG5cdFx0aWYgKC9bXFwrXFwtXS8udGVzdChvcGVyYXRvcikpIHtcclxuXHRcdFx0IHJldHVybiAxO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9bXFwqXFwvXS8udGVzdChvcGVyYXRvcikpIHtcclxuXHRcdFx0IHJldHVybiAyO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9bXFxeXS8udGVzdChvcGVyYXRvcikpIHtcclxuXHRcdFx0IHJldHVybiAzO1xyXG5cdFx0fVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvci5cIik7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZW51bSBUb2tlblR5cGUgeyBQbHVzLCBNaW51cywgTXVsdGlwbHksIERpdmlkZSwgRXhwb25lbnQsIE51bWJlciwgTFBhcmVuLCBSUGFyZW4sIEVuZCwgVW5rbm93biB9XHJcbmV4cG9ydCBjbGFzcyBUb2tlbiB7XHJcblx0cHVibGljIHR5cGU6IFRva2VuVHlwZTtcclxuXHRwdWJsaWMgdmFsdWU6IG51bWJlcjtcclxuXHRjb25zdHJ1Y3Rvcih0eXBlOiBUb2tlblR5cGUsIHZhbHVlPzogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xyXG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xyXG5cdH1cclxufVxyXG5leHBvcnQgY2xhc3MgTGV4ZXIge1xyXG5cdHByaXZhdGUgdG9rZW5zOiBzdHJpbmdbXTtcclxuXHRwcml2YXRlIHRva2VuSW5kZXg6IG51bWJlcjtcclxuXHRjb25zdHJ1Y3RvcihpbnB1dDogc3RyaW5nKSB7XHJcblx0XHR0aGlzLnRva2VucyA9IGlucHV0LnJlcGxhY2UoXCIgXCIsIFwiXCIpLm1hdGNoKC9cXCh8XFwpfFxcZCsoXFwuXFxkKyk/fFtcXCtcXC1cXCpcXC9cXF5dL2cpO1xyXG5cdFx0dGhpcy50b2tlbkluZGV4ID0gMDtcclxuXHR9XHJcblx0cHVibGljIGdldE5leHRUb2tlbigpOiBUb2tlbiB7XHJcblx0XHRpZiAodGhpcy50b2tlbnMubGVuZ3RoID09PSB0aGlzLnRva2VuSW5kZXgpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuRW5kKTtcclxuXHRcdH1cclxuXHRcdGxldCBpbnB1dDogc3RyaW5nID0gdGhpcy50b2tlbnNbdGhpcy50b2tlbkluZGV4KytdO1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VG9rZW4oaW5wdXQpO1xyXG5cdH1cclxuXHRwdWJsaWMgZ2V0Q3VycmVudFRva2VuKCk6IFRva2VuIHtcclxuXHRcdGlmICh0aGlzLnRva2Vucy5sZW5ndGggLSAxID09PSB0aGlzLnRva2VuSW5kZXgpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuRW5kKTtcclxuXHRcdH1cclxuXHRcdGxldCBpbnB1dDogc3RyaW5nID0gdGhpcy50b2tlbnNbdGhpcy50b2tlbkluZGV4XTtcclxuXHRcdHJldHVybiB0aGlzLmdldFRva2VuKGlucHV0KTtcclxuXHR9XHJcblx0cHVibGljIHJldmVydCgpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLnRva2VuSW5kZXggPD0gMCkgeyB0aHJvdyBFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTsgfVxyXG5cdFx0dGhpcy50b2tlbkluZGV4LS07XHJcblx0fVxyXG5cdHByaXZhdGUgZ2V0VG9rZW4oaW5wdXQ6IHN0cmluZyk6IFRva2VuIHtcclxuXHRcdGlmICgvXFwrLy50ZXN0KGlucHV0KSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRva2VuKFRva2VuVHlwZS5QbHVzKTtcclxuXHRcdH1cclxuXHRcdGlmICgvXFwtLy50ZXN0KGlucHV0KSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRva2VuKFRva2VuVHlwZS5NaW51cyk7XHJcblx0XHR9XHJcblx0XHRpZiAoL1xcKi8udGVzdChpbnB1dCkpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuTXVsdGlwbHkpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9cXC8vLnRlc3QoaW5wdXQpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLkRpdmlkZSk7XHJcblx0XHR9XHJcblx0XHRpZiAoL1xcXi8udGVzdChpbnB1dCkpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuRXhwb25lbnQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9cXGQrKFxcLlxcZCspPy8udGVzdChpbnB1dCkpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuTnVtYmVyLCBwYXJzZUZsb2F0KGlucHV0KSk7XHJcblx0XHR9XHJcblx0XHRpZiAoL1xcKC8udGVzdChpbnB1dCkpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuTFBhcmVuKTtcclxuXHRcdH1cclxuXHRcdGlmICgvXFwpLy50ZXN0KGlucHV0KSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRva2VuKFRva2VuVHlwZS5SUGFyZW4pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuVW5rbm93bik7XHJcblx0fVxyXG59XHJcbmV4cG9ydCBjbGFzcyBQYXJzZXIge1xyXG5cdHByaXZhdGUgbGV4OiBMZXhlcjtcclxuXHRwdWJsaWMgcGFyc2UoY29kZTogc3RyaW5nKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0dGhpcy5sZXggPSBuZXcgTGV4ZXIoY29kZSk7XHJcblx0XHRjb25zdCBleHByZXNzaW9uOiBSYXRpb25hbE51bWJlciA9IHRoaXMuZm91cnRoT3JkZXJPcGVyYXRvcnMoKTtcclxuXHRcdGNvbnN0IHRva2VuOiBUb2tlbiA9IHRoaXMubGV4LmdldEN1cnJlbnRUb2tlbigpOyAvLyBpcyBhbHJlYWR5IGFkdmFuY2VkIGJlY2F1c2Ugb2YgbnVtYmVyKClcclxuXHRcdGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuRW5kKSB7XHJcblx0XHRcdHJldHVybiBleHByZXNzaW9uO1xyXG5cdFx0fVxyXG5cdFx0dGhyb3cgRXJyb3IoXCJFbmQgZXhwZWN0ZWRcIik7XHJcblx0fVxyXG5cdC8vIGFkZGl0aW9uIGFuZCBzdWJzdHJhY3Rpb25cclxuXHRwcml2YXRlIGZvdXJ0aE9yZGVyT3BlcmF0b3JzKCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGxldCBjb21wb25lbnQxOiBSYXRpb25hbE51bWJlciA9IHRoaXMudGhpcmRPcmRlck9wZXJhdG9ycygpO1xyXG5cdFx0bGV0IHRva2VuOiBUb2tlbiA9IHRoaXMubGV4LmdldE5leHRUb2tlbigpO1xyXG5cdFx0d2hpbGUgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5QbHVzIHx8IHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5NaW51cykge1xyXG5cdFx0XHRsZXQgY29tcG9uZW50MjogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLnRoaXJkT3JkZXJPcGVyYXRvcnMoKTtcclxuXHRcdFx0aWYgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5QbHVzKSB7XHJcblx0XHRcdFx0Y29tcG9uZW50MSA9IGNvbXBvbmVudDEuYWRkKGNvbXBvbmVudDIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5NaW51cykge1xyXG5cdFx0XHRcdGNvbXBvbmVudDEgPSBjb21wb25lbnQxLnN1Yihjb21wb25lbnQyKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0b2tlbiA9IHRoaXMubGV4LmdldE5leHRUb2tlbigpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5sZXgucmV2ZXJ0KCk7XHJcblx0XHRyZXR1cm4gY29tcG9uZW50MTtcclxuXHR9XHJcblx0Ly8gbXVsdGlwbGljYXRpb24gYW5kIGRpdmlzaW9uXHJcblx0cHJpdmF0ZSB0aGlyZE9yZGVyT3BlcmF0b3JzKCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGxldCBmYWN0b3IxOiBSYXRpb25hbE51bWJlciA9IHRoaXMuc2Vjb25kT3JkZXJPcGVyYXRvcnMoKTtcclxuXHRcdGxldCB0b2tlbjogVG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdHdoaWxlICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTXVsdGlwbHkgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLkRpdmlkZSkge1xyXG5cdFx0XHRsZXQgZmFjdG9yMjogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLnNlY29uZE9yZGVyT3BlcmF0b3JzKCk7XHJcblx0XHRcdGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTXVsdGlwbHkpIHtcclxuXHRcdFx0XHRmYWN0b3IxID0gZmFjdG9yMS5tdWx0KGZhY3RvcjIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5EaXZpZGUpIHtcclxuXHRcdFx0XHRmYWN0b3IxID0gZmFjdG9yMS5kaXYoZmFjdG9yMik7XHJcblx0XHRcdH1cclxuXHRcdFx0dG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdH1cclxuXHRcdHRoaXMubGV4LnJldmVydCgpO1xyXG5cdFx0cmV0dXJuIGZhY3RvcjE7XHJcblx0fVxyXG5cdC8vIGV4cG9uZW50cyBhbmQgcm9vdHNcclxuXHRwcml2YXRlIHNlY29uZE9yZGVyT3BlcmF0b3JzKCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGxldCBmYWN0b3IxOiBSYXRpb25hbE51bWJlciA9IHRoaXMuZmlyc3RPcmRlck9wZXJhdG9ycygpO1xyXG5cdFx0bGV0IHRva2VuOiBUb2tlbiA9IHRoaXMubGV4LmdldE5leHRUb2tlbigpO1xyXG5cdFx0d2hpbGUgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5FeHBvbmVudCkge1xyXG5cdFx0XHRsZXQgZmFjdG9yMjogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLmZpcnN0T3JkZXJPcGVyYXRvcnMoKTtcclxuXHRcdFx0ZmFjdG9yMSA9IGZhY3RvcjEuZXhwKGZhY3RvcjIpO1xyXG5cdFx0XHR0b2tlbiA9IHRoaXMubGV4LmdldE5leHRUb2tlbigpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5sZXgucmV2ZXJ0KCk7XHJcblx0XHRyZXR1cm4gZmFjdG9yMTtcclxuXHR9XHJcblx0Ly8gbnVtYmVycyBhbmQgcGFyYW50aGVzZXNcclxuXHRwcml2YXRlIGZpcnN0T3JkZXJPcGVyYXRvcnMoKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0bGV0IHZhbHVlOiBSYXRpb25hbE51bWJlciA9IG5ldyBSYXRpb25hbE51bWJlcigxKTtcclxuXHRcdGxldCB0b2tlbjogVG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuUGx1cyB8fCB0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTWludXMpIHtcclxuXHRcdFx0aWYgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5NaW51cykge1xyXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUubXVsdCgtMSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dG9rZW4gPSB0aGlzLmxleC5nZXROZXh0VG9rZW4oKTtcclxuXHRcdH1cclxuXHRcdGlmICh0b2tlbi50eXBlID09PSBUb2tlblR5cGUuTFBhcmVuKSB7XHJcblx0XHRcdHZhbHVlID0gdmFsdWUubXVsdCh0aGlzLmZvdXJ0aE9yZGVyT3BlcmF0b3JzKCkpO1xyXG5cdFx0XHR0b2tlbiA9IHRoaXMubGV4LmdldE5leHRUb2tlbigpO1xyXG5cdFx0XHRpZiAodG9rZW4udHlwZSAhPT0gVG9rZW5UeXBlLlJQYXJlbikge1xyXG5cdFx0XHRcdHRocm93IEVycm9yKFwiVW5iYWxhbmNlZCBwYXJlbnRoZXNpc1wiKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5OdW1iZXIpIHtcclxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLm11bHQodG9rZW4udmFsdWUpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IEVycm9yKFwiTm90IGEgbnVtYmVyXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fVxyXG59XHJcblxyXG4vKlxyXG5cdHB1YmxpYyBzdGF0aWMgZXZhbHVhdGUoZXhwcmVzaW9uOiBzdHJpbmcpOiBSYXRpb25hbE51bWJlciB7XHJcblx0dmFyIGRpZ2l0UGF0dGVybiA9IG5ldyBSZWdFeHAoJzAgfCAxIHwgMiB8IDMgfCA0IHwgNSB8IDYgfCA3IHwgOCB8IDknKTtcclxuXHR2YXIgc2lnblBhdHRlcm4gPSBuZXcgUmVnRXhwKCdcXCt8XFwtJyk7XHJcblx0dmFyIG51bWJlclBhdHRlcm4gPSBuZXcgUmVnRXhwKCdbJyArIHNpZ25QYXR0ZXJuICsgJ10nICsgJ3snICsgZGlnaXRQYXR0ZXJuICsgJ30nKTtcclxuXHR2YXIgZmFjdG9yUGF0dGVybiA9IG5ldyBSZWdFeHAobnVtYmVyUGF0dGVybiArICd8XFwoJyArIGV4cHJlc3Npb25QYXR0ZXJuICsgJ1xcKScpO1xyXG5cdHZhciBjb21wb25lbnRQYXR0ZXJuID0gbmV3IFJlZ0V4cChmYWN0b3JQYXR0ZXJuICsgJ1t7KCBcXCogfCBcXC8gKScgKyBmYWN0b3JQYXR0ZXJuICsgJ31dJyk7XHJcblx0dmFyIGV4cHJlc3Npb25QYXR0ZXJuID0gbmV3IFJlZ0V4cChjb21wb25lbnRQYXR0ZXJuICsgJ1t7KCBcXCsgfCBcXC0pJyArIGNvbXBvbmVudFBhdHRlcm4gKyAnfV0nKTtcclxufSovXHJcblxyXG4vKlxyXG5leHBycjogNHRoT1JERVIrO1xyXG40dGhPUkRFUjogY29tcG9uZW50MT0zcmRPUkRFUiAoKFBMVVN8TUlOVVMpIGNvbXBvbmVudDI9M3JkT1JERVIpKztcclxuM3JkT1JERVI6IGZhY3RvcjE9Mk5ET1JERVIgKChNVUxUSVBMWXxESVZJREUpIGZhY3RvcjE9Mm5kT1JERVIpK1xyXG4ybmRPUkRFUjogZmFjdG9yMT0xc3RPUkRFUiAoRVhQT05FTlQgZmFjdG9yMj0xc3RPUkRFUikrXHJcbjFzdE9SREVSOiAoUExVU3xNSU5VU3xlbXB0eSkgKExQQVJFTiB2YWx1ZT00dGhPUkRFUiBSUEFSRU58IE5VTUJFUilcclxuKi8iLCJpbXBvcnQgeyBSYXRpb25hbE51bWJlciB9IGZyb20gXCIuL1JhdGlvbmFsTnVtYmVyXCI7XHJcbmltcG9ydCB7IENvbHVtblZlY3RvciwgVmVjdG9yIH0gZnJvbSBcIi4vVmVjdG9yXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgTWF0cml4IHtcclxuXHRwdWJsaWMgc3RhdGljIGF1Z21lbnQoQTogTWF0cml4LCBCOiBNYXRyaXggfCBWZWN0b3IpOiBNYXRyaXgge1xyXG5cdFx0aWYgKEEubSAhPT0gQi5tKSB7IHRocm93IG5ldyBFcnJvcihcIlRoZSB0d28gbWF0cmljZXMgKHZlY3RvcikgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiByb3dzIChlbGVtZW50cykuXCIpOyB9XHJcblx0XHRsZXQgcmV0OiBNYXRyaXggPSBudWxsO1xyXG5cdFx0aWYgKEIgaW5zdGFuY2VvZiBNYXRyaXgpIHtcclxuXHRcdFx0cmV0ID0gbmV3IE1hdHJpeChBLm0sIEIubiArIEEubik7XHJcblx0XHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBBLm07IGkrKykge1xyXG5cdFx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBBLm47IGorKykge1xyXG5cdFx0XHRcdFx0cmV0LmVsZW1lbnRzW2ldW2pdID0gQS5lbGVtZW50c1tpXVtqXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IEIubTsgaSsrKSB7XHJcblx0XHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IEIubjsgaisrKSB7XHJcblx0XHRcdFx0XHRyZXQuZWxlbWVudHNbaV1bQS5uICsgal0gPSBCLmVsZW1lbnRzW2ldW2pdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKEIgaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuXHRcdFx0XHRyZXQgPSBuZXcgTWF0cml4KEEubSwgQS5uICsgMSk7XHJcblx0XHRcdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IEEubTsgaSsrKSB7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgQS5uOyBqKyspIHtcclxuXHRcdFx0XHRcdFx0cmV0LmVsZW1lbnRzW2ldW2pdID0gQS5lbGVtZW50c1tpXVtqXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IEIubTsgaisrKSB7XHJcblx0XHRcdFx0XHRyZXQuZWxlbWVudHNbal1bQS5uXSA9IEIuZWxlbWVudHNbal07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH1cclxuXHQvLyByb3ctbXVsdGlwbHlpbmcgdHJhbnNmb3JtYXRpb25zXHJcblx0cHVibGljIHN0YXRpYyBtdWx0aXBsaWNhdGlvbihuOiBudW1iZXIsIHJvdzE6IG51bWJlciwgcm93MjogbnVtYmVyLCBtdWx0OiBudW1iZXIpOiBNYXRyaXgge1xyXG5cdFx0aWYgKG4gPCByb3cxIHx8IG4gPCByb3cyKSB7IHRocm93IG5ldyBFcnJvcihcIkNvbHVtbiBpbmRleCBtdXN0IGJlIGxlc3Mgb3IgZXF1YWx0IHRoYW4gbWF0cml4IHNpemUuXCIpOyB9XHJcblx0XHRjb25zdCBtYXRyaXg6IE1hdHJpeCA9IG5ldyBNYXRyaXhJZGVudGl0eShuKTtcclxuXHRcdG1hdHJpeC5lbGVtZW50c1tyb3cxXVtyb3cyXSA9IG5ldyBSYXRpb25hbE51bWJlcihtdWx0KTtcclxuXHRcdHJldHVybiBtYXRyaXg7XHJcblx0fVxyXG5cdHB1YmxpYyBzdGF0aWMgcmFuZG9tU3F1YXJlKCk6IE1hdHJpeCB7XHJcblx0XHRjb25zdCBtYXRyaXg6IE1hdHJpeCA9IG5ldyBNYXRyaXgoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCkgKyAzLCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KSArIDMpOyAvLyBtaW5pbXVtIHNpemUgM3gzIG1hdHJpeFxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IG1hdHJpeC5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IG1hdHJpeC5uOyBqKyspIHtcclxuXHRcdFx0XHRtYXRyaXguZWxlbWVudHNbaV1bal0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwIC0gNTApKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG1hdHJpeDtcclxuXHR9XHJcblx0cHVibGljIHN0YXRpYyByYW5kb20yKCk6IE1hdHJpeCB7XHJcblx0XHRjb25zdCBudW1iZXJPZlVua25vd25zOiBudW1iZXIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0ICsgMyk7IC8vIGJldHdlZW4gMyBhbmQgNyB1bmtub253c1xyXG5cdFx0Y29uc3QgdW5rbm93bnM6IG51bWJlcltdID0gW107XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgbnVtYmVyT2ZVbmtub3duczsgaSsrKSB7XHJcblx0XHRcdHVua25vd25zW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjAgLSAxMCk7XHJcblx0XHR9XHJcblx0XHQvLyB0b2RvOiBjaGFuZ2UgYmVsb3dcclxuXHRcdGNvbnN0IG1hdHJpeDogTWF0cml4ID0gbmV3IE1hdHJpeChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KSArIDMsIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpICsgMyk7XHJcblx0XHRyZXR1cm4gbWF0cml4O1xyXG5cdH1cclxuXHRwdWJsaWMgbTogbnVtYmVyOyAvLyByb3dzXHJcblx0cHVibGljIG46IG51bWJlcjsgLy8gY29sdW1uc1xyXG5cdHB1YmxpYyBlbGVtZW50czogUmF0aW9uYWxOdW1iZXJbXVtdO1xyXG5cdGNvbnN0cnVjdG9yKG06IG51bWJlciwgbjogbnVtYmVyKSB7XHJcblx0XHR0aGlzLm0gPSBtO1xyXG5cdFx0dGhpcy5uID0gbjtcclxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzW2ldID0gW107XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyBlcXVhbHMoTTogTWF0cml4KTogYm9vbGVhbiB7XHJcblx0XHRpZiAodGhpcy5tICE9PSBNLm0gfHwgdGhpcy5uICE9PSBNLm4pIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm47IGorKykge1xyXG5cdFx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tpXVtqXS5lcXVhbHMoTS5lbGVtZW50c1tpXVtqXSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRwdWJsaWMgYWRkKHg6IE1hdHJpeCk6IE1hdHJpeCB7XHJcblx0XHRpZiAodGhpcy5tICE9PSB4Lm0gfHwgdGhpcy5uICE9PSB4Lm4pIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBkaW1lbnNpb25zLlwiKTsgfVxyXG5cdFx0Y29uc3QgcmVzOiBNYXRyaXggPSBuZXcgTWF0cml4KHRoaXMubSwgdGhpcy5uKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCByZXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCByZXMubjsgaisrKSB7XHJcblx0XHRcdFx0cmVzLmVsZW1lbnRzW2ldW2pdID0gdGhpcy5lbGVtZW50c1tpXVtqXS5hZGQoeC5lbGVtZW50c1tpXVtqXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cdHB1YmxpYyBzdWIoeDogTWF0cml4KTogTWF0cml4IHtcclxuXHRcdGlmICh0aGlzLm0gIT09IHgubSB8fCB0aGlzLm4gIT09IHgubikgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGRpbWVuc2lvbnMuXCIpOyB9XHJcblx0XHRjb25zdCByZXM6IE1hdHJpeCA9IG5ldyBNYXRyaXgodGhpcy5tLCB0aGlzLm4pO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHJlcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHJlcy5uOyBqKyspIHtcclxuXHRcdFx0XHRyZXMuZWxlbWVudHNbaV1bal0gPSB0aGlzLmVsZW1lbnRzW2ldW2pdLnN1Yih4LmVsZW1lbnRzW2ldW2pdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblx0cHVibGljIG11bHQoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIgfCBNYXRyaXgpOiBNYXRyaXgge1xyXG5cdFx0bGV0IHJlczogTWF0cml4ID0gbnVsbDtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXMgPSBuZXcgTWF0cml4KHRoaXMubSwgdGhpcy5uKTtcclxuXHRcdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHJlcy5tOyBpKyspIHtcclxuXHRcdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgcmVzLm47IGorKykge1xyXG5cdFx0XHRcdFx0cmVzLmVsZW1lbnRzW2ldW2pdID0gdGhpcy5lbGVtZW50c1tpXVtqXS5tdWx0KHgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICh4IGluc3RhbmNlb2YgUmF0aW9uYWxOdW1iZXIpIHtcclxuXHRcdFx0cmVzID0gbmV3IE1hdHJpeCh0aGlzLm0sIHRoaXMubik7XHJcblx0XHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCByZXMubTsgaSsrKSB7XHJcblx0XHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHJlcy5uOyBqKyspIHtcclxuXHRcdFx0XHRcdHJlcy5lbGVtZW50c1tpXVtqXSA9IHRoaXMuZWxlbWVudHNbaV1bal0ubXVsdCh4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICh4IGluc3RhbmNlb2YgTWF0cml4KSB7XHJcblx0XHRcdFx0aWYgKHRoaXMubiAhPT0geC5tKSB7IHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgZGltZW5zaW9ucy5cIik7IH1cclxuXHRcdFx0XHRyZXMgPSBuZXcgTWF0cml4KHRoaXMubSwgeC5uKTtcclxuXHRcdFx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgcmVzLm07IGkrKykge1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHJlcy5uOyBqKyspIHtcclxuXHRcdFx0XHRcdFx0bGV0IHN1bTogUmF0aW9uYWxOdW1iZXIgPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRcdFx0XHRcdGZvciAobGV0IGs6IG51bWJlciA9IDA7IGsgPCB0aGlzLm47IGsrKykge1xyXG5cdFx0XHRcdFx0XHRcdHN1bSA9IHN1bS5hZGQodGhpcy5lbGVtZW50c1tpXVtrXS5tdWx0KHguZWxlbWVudHNba11bal0pKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRyZXMuZWxlbWVudHNbaV1bal0gPSBzdW07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHRwdWJsaWMgdmVjdG9yUHJvZHVjdCh2OiBDb2x1bW5WZWN0b3IpOiBDb2x1bW5WZWN0b3Ige1xyXG5cdFx0aWYgKHRoaXMubiAhPT0gdi5tKSB7IHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgZGltZW5zaW9ucy5cIik7IH1cclxuXHRcdGNvbnN0IHJlczogQ29sdW1uVmVjdG9yID0gbmV3IENvbHVtblZlY3Rvcih2Lm0pO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGxldCBzdW06IFJhdGlvbmFsTnVtYmVyID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0XHRzdW0gPSBzdW0uYWRkKHRoaXMuZWxlbWVudHNbaV1bal0ubXVsdCh2LmVsZW1lbnRzW2pdKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmVzLmVsZW1lbnRzW2ldID0gc3VtO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblx0cHVibGljIHRyYW5zcG9zZSgpOiBNYXRyaXgge1xyXG5cdFx0Y29uc3QgcmV0OiBNYXRyaXggPSBuZXcgTWF0cml4KHRoaXMubiwgdGhpcy5tKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0XHRyZXQuZWxlbWVudHNbal1baV0gPSB0aGlzLmVsZW1lbnRzW2ldW2pdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH1cclxuXHRwdWJsaWMgZGVlcENvcHkoKTogTWF0cml4IHtcclxuXHRcdGNvbnN0IHJldDogTWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLm0sIHRoaXMubik7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdFx0cmV0LmVsZW1lbnRzW2ldW2pdID0gdGhpcy5lbGVtZW50c1tpXVtqXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9XHJcblx0cHVibGljIHN3aXRjaFJvd3MoaWR4MTogbnVtYmVyLCBpZHgyOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLm0gPCBpZHgxIHx8IHRoaXMubSA8IGlkeDIpIHsgcmV0dXJuOyB9XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5uOyBpKyspIHtcclxuXHRcdFx0Y29uc3QgdG1wOiBSYXRpb25hbE51bWJlciA9IHRoaXMuZWxlbWVudHNbaWR4MV1baV07XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbaWR4MV1baV0gPSB0aGlzLmVsZW1lbnRzW2lkeDJdW2ldO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzW2lkeDJdW2ldID0gdG1wO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgbXVsdGlwbHlSb3coaWR4OiBudW1iZXIsIHNjYWxhcjogUmF0aW9uYWxOdW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLm0gPCBpZHgpIHsgcmV0dXJuOyB9XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5uOyBpKyspIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50c1tpZHhdW2ldID0gdGhpcy5lbGVtZW50c1tpZHhdW2ldLm11bHQoc2NhbGFyKS5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgYWRkUm93cyhpZHgxOiBudW1iZXIsIGlkeDI6IG51bWJlciwgc2NhbGFyOiBSYXRpb25hbE51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMubSA8IGlkeDEgfHwgdGhpcy5tIDwgaWR4MikgeyByZXR1cm47IH1cclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm47IGkrKykge1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzW2lkeDFdW2ldID0gdGhpcy5lbGVtZW50c1tpZHgyXVtpXS5tdWx0KHNjYWxhcikuYWRkKHRoaXMuZWxlbWVudHNbaWR4MV1baV0pLnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyBhZGRSb3cxVG9Sb3cyKGlkeDE6IG51bWJlciwgc2NhbGFyMTogUmF0aW9uYWxOdW1iZXIsIGlkeDI6IG51bWJlciwgc2NhbGFyMjogUmF0aW9uYWxOdW1iZXIpOiB2b2lkIHtcclxuXHRcdGlmICh0aGlzLm0gPCBpZHgxIHx8IHRoaXMubSA8IGlkeDIpIHsgcmV0dXJuOyB9XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5uOyBpKyspIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50c1tpZHgyXVtpXSA9IHRoaXMuZWxlbWVudHNbaWR4Ml1baV0ubXVsdChzY2FsYXIyKS5hZGQodGhpcy5lbGVtZW50c1tpZHgxXVtpXS5tdWx0KHNjYWxhcjEpKS5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHQvLyBhIHNxdWFyZSBtYXRyaXggaXMgYSBtYXRyaXggd2l0aCB0aGUgc2FtZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1uc1xyXG5cdHB1YmxpYyBpc1NxdWFyZSgpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLm0gPT09IHRoaXMubjtcclxuXHR9XHJcblx0Ly8gYSBkaWFnb25hbCBtYXRyaXggaXMgYSBtYXRyaXggaW4gd2hpY2ggdGhlIGVudHJpZXMgb3V0c2lkZSB0aGUgbWFpbiBkaWFnb25hbCBhcmUgYWxsIHplcm9cclxuXHRwdWJsaWMgaXNEaWFnb25hbCgpOiBib29sZWFuIHtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoaSA9PT0gaikge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tpXVtqXS5lcXVhbHMobmV3IFJhdGlvbmFsTnVtYmVyKDApKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdC8vIHRoZSBpZGVudGl0eSBtYXRyaXggb2Ygc2l6ZSBuIGlzIHRoZSBuIMOXIG4gc3F1YXJlIG1hdHJpeCB3aXRoIG9uZXMgb24gdGhlIG1haW4gZGlhZ29uYWwgYW5kIHplcm9zIGVsc2V3aGVyZVxyXG5cdC8vIFtBTElBU0VTXTogdW5pdCBtYXRyaXhcclxuXHRwdWJsaWMgaXNJZGVudGl0eSgpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzLm0gIT09IHRoaXMubikgeyB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBzcXVhcmUgbWF0cml4LlwiKTsgfVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm47IGorKykge1xyXG5cdFx0XHRcdGlmIChpID09PSBqKSB7XHJcblx0XHRcdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbaV1bal0uZXF1YWxzKG5ldyBSYXRpb25hbE51bWJlcigxKSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCF0aGlzLmVsZW1lbnRzW2ldW2pdLmVxdWFscyhuZXcgUmF0aW9uYWxOdW1iZXIoMCkpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0Ly8gYSBtYXRyaXggaXMgbm9ybWFsIGlmIGl0IGNvbW11dGVzIHdpdGggaXRzIGNvbmp1Z2F0ZSB0cmFuc3Bvc2VcclxuXHRwdWJsaWMgaXNOb3JtYWwoKTogYm9vbGVhbiB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XHJcblx0fVxyXG5cdC8vIHRoZSBjb25qdWdhdGUgdHJhbnNwb3NlIG9mIGFuIG0tYnktbiBtYXRyaXggQSB3aXRoIGNvbXBsZXggZW50cmllcyBpcyB0aGUgbi1ieS1tIG1hdHJpeCBB4oiXIG9idGFpbmVkIGZyb20gQVxyXG5cdC8vIGJ5IHRha2luZyB0aGUgdHJhbnNwb3NlIGFuZCB0aGVuIHRha2luZyB0aGUgY29tcGxleCBjb25qdWdhdGUgb2YgZWFjaCBlbnRyeVxyXG5cdC8vIFtBTElBU0VTXTogSGVybWl0aWFuIHRyYW5zcG9zZVxyXG5cdHB1YmxpYyB0b0Nvbmp1Z2F0ZVRyYW5zcG9zZSgpOiBNYXRyaXgge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xyXG5cdH1cclxuXHRwdWJsaWMgaXNVcHBlclRyaWFuZ3VsYXIoKTogYm9vbGVhbiB7XHJcblx0XHQvLyB0b2RvOiBjaGVjayBpZiBkZWZpbml0aW9uIGlzIHZhbGlkIGZvciBhIG5vbiBzcXVhcmUgbWF0cml4XHJcblx0XHQvLyBpZiAodGhpcy5tICE9PSB0aGlzLm4pIHsgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgc3F1YXJlIG1hdHJpeC5cIik7IH1cclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDE7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgaTsgaisrKSB7XHJcblx0XHRcdFx0aWYgKCF0aGlzLmVsZW1lbnRzW2ldW2pdLmVxdWFscyhuZXcgUmF0aW9uYWxOdW1iZXIoMCkpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0cHVibGljIGlzTG93ZXJUcmlhbmd1bGFyKCk6IGJvb2xlYW4ge1xyXG5cdFx0Ly8gdG9kbzogY2hlY2sgaWYgZGVmaW5pdGlvbiBpcyB2YWxpZCBmb3IgYSBub24gc3F1YXJlIG1hdHJpeFxyXG5cdFx0Ly8gaWYgKHRoaXMubSAhPT0gdGhpcy5uKSB7IHRocm93IG5ldyBFcnJvcihcIk5vdCBhIHNxdWFyZSBtYXRyaXguXCIpOyB9XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gaSArIDE7IGogPCB0aGlzLm47IGorKykge1xyXG5cdFx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tpXVtqXS5lcXVhbHMobmV3IFJhdGlvbmFsTnVtYmVyKDApKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdC8vIGEgc3ltbWV0cmljIG1hdHJpeCBpcyBhIHNxdWFyZSBtYXRyaXggdGhhdCBpcyBlcXVhbCB0byBpdHMgdHJhbnNwb3NlXHJcblx0cHVibGljIGlzU3ltbWV0cmljKCk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKHRoaXMubSAhPT0gdGhpcy5uKSB7IHRocm93IG5ldyBFcnJvcihcIk5vdCBhIHNxdWFyZSBtYXRyaXguXCIpOyB9XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdFx0aWYgKCF0aGlzLmVsZW1lbnRzW2ldW2pdLmVxdWFscyh0aGlzLmVsZW1lbnRzW2pdW2ldKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdC8vIGFuIG9ydGhvZ29uYWwgbWF0cml4IGlzIGEgc3F1YXJlIG1hdHJpeCB3aXRoIHJlYWwgZW50cmllcyB3aG9zZSBjb2x1bW5zIGFuZCByb3dzIGFyZSBvcnRob2dvbmFsIHVuaXQgdmVjdG9yc1xyXG5cdC8vIFtBTElBU0VTXTogcmVhbCBvcnRob2dvbmFsIG1hdHJpeFxyXG5cdHB1YmxpYyBpc09ydGhvZ29uYWwoKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBNVDogTWF0cml4ID0gdGhpcy50cmFuc3Bvc2UoKTtcclxuXHRcdHJldHVybiB0aGlzLm11bHQoTVQpLmlzSWRlbnRpdHkoKTtcclxuXHR9XHJcblx0cHVibGljIGlzUm93RWNoZWxvbkZvcm0oKTogYm9vbGVhbiB7XHJcblx0XHRsZXQgZm91bmRaZXJvUm93OiBib29sZWFuID0gZmFsc2U7XHJcblx0XHQvLyBhbGwgbm9uemVybyByb3dzIChyb3dzIHdpdGggYXQgbGVhc3Qgb25lIG5vbnplcm8gZWxlbWVudCkgYXJlIGFib3ZlIGFueSByb3dzIG9mIGFsbCB6ZXJvZXNcclxuXHRcdC8vIChhbGwgemVybyByb3dzLCBpZiBhbnksIGJlbG9uZyBhdCB0aGUgYm90dG9tIG9mIHRoZSBtYXRyaXgpXHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuaXNaZXJvUm93KGkpKSB7XHJcblx0XHRcdFx0Zm91bmRaZXJvUm93ID0gdHJ1ZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAoZm91bmRaZXJvUm93KSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHR9Ly8gaWYgY3VycmVudCByb3cgaXMgbm90IHplcm8sIGJ1dCBhIHByZXZpb3VzIHJvdyBpcyB6ZXJvLCB0aGVuIG1hdHJpeCBpcyBub3QgaW4gcm93IGVjaGVsb24gZm9ybVxyXG5cdFx0fVxyXG5cdFx0Ly8gdGhlIGxlYWRpbmcgY29lZmZpY2llbnQgKHRoZSBmaXJzdCBub256ZXJvIG51bWJlciBmcm9tIHRoZSBsZWZ0LCBhbHNvIGNhbGxlZCB0aGUgcGl2b3QpIG9mIGEgbm9uemVybyByb3dcclxuXHRcdC8vIGlzIGFsd2F5cyBzdHJpY3RseSB0byB0aGUgcmlnaHQgb2YgdGhlIGxlYWRpbmcgY29lZmZpY2llbnQgb2YgdGhlIHJvdyBhYm92ZSBpdFxyXG5cdFx0bGV0IHByZXZpb3VzSWR4OiBudW1iZXIgPSAtMTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRjb25zdCBjdXJyZW50UGl2b3RJZHg6IG51bWJlciA9IHRoaXMucm93UGl2b3RQb3NpdGlvbihpKTtcclxuXHRcdFx0aWYgKDAgPiBjdXJyZW50UGl2b3RJZHgpIHsgY29udGludWU7IH0vLyB0aGlzIGlzIGEgemVybyByb3csIG5vIHBpdm90XHJcblx0XHRcdC8vIGxlYWRpbmcgY29lZmZpY2llbnQgbXVzdCBiZSAxXHJcblx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tpXVtjdXJyZW50UGl2b3RJZHhdLmVxdWFscyhuZXcgUmF0aW9uYWxOdW1iZXIoMSkpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRpZiAocHJldmlvdXNJZHggPCBjdXJyZW50UGl2b3RJZHgpIHtcclxuXHRcdFx0XHRwcmV2aW91c0lkeCA9IGN1cnJlbnRQaXZvdElkeDtcclxuXHRcdFx0fSBlbHNlIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0cHVibGljIGlzUmVkdWNlZFJvd0VjaGVsb25Gb3JtKCk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKCF0aGlzLmlzUm93RWNoZWxvbkZvcm0oKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdC8vIGVhY2ggbGVhZGluZyBjb2VmZmljaWVudCBpcyB0aGUgb25seSBub256ZXJvIGVudHJ5IGluIGl0cyBjb2x1bW5cclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRjb25zdCBwaXZvdFBvc2l0aW9uOiBudW1iZXIgPSB0aGlzLnJvd1Bpdm90UG9zaXRpb24oaSk7XHJcblx0XHRcdGlmICgxIDwgdGhpcy5udW1iZXJPZk5vblplcm9FbGVtZW50Rm9yQ29sdW1uKHBpdm90UG9zaXRpb24pKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHB1YmxpYyB0b1JlZHVjZWRSb3dFY2hlbG9uRm9ybSgpOiBNYXRyaXgge1xyXG5cdFx0Y29uc3QgcmVzOiBNYXRyaXggPSB0aGlzLmRlZXBDb3B5KCk7XHJcblx0XHRsZXQgbGVhZDogbnVtYmVyID0gMDtcclxuXHRcdGZvciAobGV0IHI6IG51bWJlciA9IDA7IHIgPCByZXMubTsgcisrKSB7XHJcblx0XHRcdGlmIChyZXMubiA8PSBsZWFkKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IGk6IG51bWJlciA9IHI7XHJcblx0XHRcdHdoaWxlIChyZXMuZWxlbWVudHNbaV1bbGVhZF0uZXF1YWxzKDApKSB7XHJcblx0XHRcdFx0aSsrO1xyXG5cdFx0XHRcdGlmIChyZXMubSA9PT0gaSkge1xyXG5cdFx0XHRcdFx0aSA9IHI7XHJcblx0XHRcdFx0XHRsZWFkKys7XHJcblx0XHRcdFx0XHRpZiAocmVzLm4gPT09IGxlYWQpIHtcclxuXHRcdFx0XHRcdFx0bGVhZC0tO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmVzLnN3aXRjaFJvd3MoaSwgcik7XHJcblx0XHRcdGlmICghcmVzLmVsZW1lbnRzW3JdW2xlYWRdLmVxdWFscygwKSkge1xyXG5cdFx0XHRcdHJlcy5tdWx0aXBseVJvdyhyLCByZXMuZWxlbWVudHNbcl1bbGVhZF0ucmVjaXByb2NhbCgpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgcmVzLm07IGorKykge1xyXG5cdFx0XHRcdGlmIChqICE9PSByKSB7XHJcblx0XHRcdFx0XHRyZXMuYWRkUm93cyhqLCByLCByZXMuZWxlbWVudHNbal1bbGVhZF0ub3Bwb3NpdGUoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGxlYWQrKztcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cdHB1YmxpYyBkZXRlcm1pbmFudCgpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHQvLyB0b2RvOiBpbXBsZW1lbnQgYW4gb3B0aW1pemVkIHZlcnNpb24sIGxpa2UgQT1QTFVcclxuXHRcdGlmICh0aGlzLm0gIT09IHRoaXMubikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJEZXRlcm1pbmFudCBjYW4gb25seSBiZSBjYWxjdWxhdGVkIG9uIGEgc3F1YXJlIG1hdHJpeFwiKTtcclxuXHRcdH1cclxuXHRcdGlmICh0aGlzLm0gPT09IDEpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudHNbMF1bMF07XHJcblx0XHR9XHJcblx0XHRsZXQgcmV0OiBSYXRpb25hbE51bWJlciA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm47IGkrKykge1xyXG5cdFx0XHRjb25zdCBtaW5vcjogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLmVsZW1lbnRzWzBdW2ldLm11bHQodGhpcy5jb2ZhY3RvcigwLCBpKS5kZXRlcm1pbmFudCgpKTtcclxuXHRcdFx0cmV0ID0gcmV0LmFkZChtaW5vci5tdWx0KCgtMSkgKiogaSkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9XHJcblx0cHVibGljIGNvbnZvbHV0ZShrZXJuZWw6IE1hdHJpeCk6IE1hdHJpeCB7XHJcblx0XHRpZiAoa2VybmVsLm0gIT09IGtlcm5lbC5uKSB7IHRocm93IG5ldyBFcnJvcihcIktlcm5lbCBpcyBub3QgYSBzcXVhcmUgbWF0cml4LlwiKTsgfVxyXG5cdFx0aWYgKGtlcm5lbC5tICUgMiA9PT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJLZXJuZWwgaXMgbm90IGFuIGV2ZW4gc2l6ZSBtYXRyaXguXCIpOyB9XHJcblx0XHRjb25zdCBzeiA9IE1hdGguZmxvb3Ioa2VybmVsLm0gLyAyKTtcclxuXHRcdGNvbnN0IHJlczogTWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLm0sIHRoaXMubik7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdFx0cmVzLmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0XHRcdGZvciAobGV0IHRpOiBudW1iZXIgPSAwOyB0aSA8IGtlcm5lbC5tOyB0aSsrKSB7XHJcblx0XHRcdFx0XHRpZiAoaSArIHRpIC0gc3ogPCAwIHx8IGkgKyB0aSAtIHN6ID49IHRoaXMubSkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGZvciAobGV0IHRqOiBudW1iZXIgPSAwOyB0aiA8IGtlcm5lbC5uOyB0aisrKSB7XHJcblx0XHRcdFx0XHRcdGlmIChqICsgdGogLSBzeiA8IDAgfHwgaiArIHRqIC0gc3ogPj0gdGhpcy5uKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cmVzLmVsZW1lbnRzW2ldW2pdID0gcmVzLmVsZW1lbnRzW2ldW2pdLmFkZCh0aGlzLmVsZW1lbnRzW2kgKyB0aSAtIHN6XVtqICsgdGogLSBzel0ubXVsdChrZXJuZWwuZWxlbWVudHNbdGldW3RqXSkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgaXNaZXJvUm93KHJvd0lkOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm47IGorKykge1xyXG5cdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbcm93SWRdW2pdLmVxdWFscyhuZXcgUmF0aW9uYWxOdW1iZXIoMCkpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHByaXZhdGUgcm93UGl2b3RQb3NpdGlvbihyb3dJZDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm47IGorKykge1xyXG5cdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbcm93SWRdW2pdLmVxdWFscyhuZXcgUmF0aW9uYWxOdW1iZXIoMCkpKSB7IHJldHVybiBqOyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG5cdHByaXZhdGUgbnVtYmVyT2ZOb25aZXJvRWxlbWVudEZvckNvbHVtbihjb2x1bW5JZDogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGxldCBhY2M6IG51bWJlciA9IDA7XHJcblx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5tOyBqKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLmVsZW1lbnRzW2pdW2NvbHVtbklkXS5lcXVhbHMobmV3IFJhdGlvbmFsTnVtYmVyKDApKSkgeyBhY2MrKzsgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFjYztcclxuXHR9XHJcblx0cHJpdmF0ZSBjb2ZhY3Rvcihyb3dJZDogbnVtYmVyLCBjb2x1bW5JZDogbnVtYmVyKTogTWF0cml4IHtcclxuXHRcdGNvbnN0IHJldDogTWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLm0gLSAxLCB0aGlzLm4gLSAxKTtcclxuXHRcdGxldCByb3dPZmZzZXQ6IG51bWJlciA9IDA7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tIC0gMTsgaSsrKSB7XHJcblx0XHRcdGlmIChpID09PSByb3dJZCkge1xyXG5cdFx0XHRcdHJvd09mZnNldCA9IDE7XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IGNvbHVtbk9mZnNldDogbnVtYmVyID0gMDtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubiAtIDE7IGorKykge1xyXG5cdFx0XHRcdGlmIChqID09PSBjb2x1bW5JZCkge1xyXG5cdFx0XHRcdFx0Y29sdW1uT2Zmc2V0ID0gMTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0LmVsZW1lbnRzW2ldW2pdID0gdGhpcy5lbGVtZW50c1tpICsgcm93T2Zmc2V0XVtqICsgY29sdW1uT2Zmc2V0XTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBNYXRyaXhJZGVudGl0eSBleHRlbmRzIE1hdHJpeCB7XHJcblx0Y29uc3RydWN0b3IobTogbnVtYmVyKSB7XHJcblx0XHRzdXBlcihtLCBtKTtcclxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzW2ldID0gW107XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm07IGorKykge1xyXG5cdFx0XHRcdGlmIChpID09PSBqKSB7XHJcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDEpO1xyXG5cdFx0XHRcdH0gZWxzZSB7IHRoaXMuZWxlbWVudHNbaV1bal0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gZWxpbWluYXRpb24gLSBtdWx0aXBseSBvbiB0aGUgbGVmdCAoRSpBKTsgUm93LWFkZGl0aW9uIHRyYW5zZm9ybWF0aW9uc1xyXG4vLyB0byBtdWx0Kihyb3cyIG9mIE1hdHJpeCBBKSBhZGQgKHJvdzEgb2YgTWF0cml4IEEpXHJcbmV4cG9ydCBjbGFzcyBNYXRyaXhFbGltaW5hdGlvbiBleHRlbmRzIE1hdHJpeCB7XHJcblx0cHVibGljIHJvdzE6IG51bWJlcjtcclxuXHRwdWJsaWMgcm93MjogbnVtYmVyO1xyXG5cdGNvbnN0cnVjdG9yKG06IG51bWJlciwgcjE6IG51bWJlciwgcjI6IG51bWJlciwgbXVsdDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpIHtcclxuXHRcdGlmIChtIDwgcjEgfHwgbSA8IHIyKSB7IHRocm93IG5ldyBFcnJvcihcIkNvbHVtbiBpbmRleCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbWF0cml4IHNpemUuXCIpOyB9XHJcblx0XHRzdXBlcihtLCBtKTtcclxuXHRcdHRoaXMucm93MSA9IHIxO1xyXG5cdFx0dGhpcy5yb3cyID0gcjI7XHJcblx0XHR0aGlzLmVsZW1lbnRzID0gW107XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50c1tpXSA9IFtdO1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5tOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoaSA9PT0gaikge1xyXG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50c1tpXVtqXSA9IG5ldyBSYXRpb25hbE51bWJlcigxKTtcclxuXHRcdFx0XHR9IGVsc2UgeyB0aGlzLmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmICh0eXBlb2YgbXVsdCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzW3IxXVtyMl0gPSBuZXcgUmF0aW9uYWxOdW1iZXIobXVsdCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAobXVsdCBpbnN0YW5jZW9mIFJhdGlvbmFsTnVtYmVyKSB7IHRoaXMuZWxlbWVudHNbcjFdW3IyXSA9IG11bHQ7IH1cclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIHBlcm11dGF0aW9uIC0gbXVsdGlwbHkgb24gdGhlIHJpZ2h0IChBKlApOyBSb3ctc3dpdGNoaW5nIHRyYW5zZm9ybWF0aW9uc1xyXG5leHBvcnQgY2xhc3MgTWF0cml4UGVybXV0YXRpb24gZXh0ZW5kcyBNYXRyaXgge1xyXG5cdGNvbnN0cnVjdG9yKG06IG51bWJlciwgcm93MTogbnVtYmVyLCByb3cyOiBudW1iZXIpIHtcclxuXHRcdGlmIChtIDwgcm93MSB8fCBtIDwgcm93MikgeyB0aHJvdyBuZXcgRXJyb3IoXCJDb2x1bW4gaW5kZXggbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG1hdHJpeCBzaXplLlwiKTsgfVxyXG5cdFx0c3VwZXIobSwgbSk7XHJcblx0XHR0aGlzLmVsZW1lbnRzID0gW107XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50c1tpXSA9IFtdO1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5tOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoaSA9PT0gaikge1xyXG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50c1tpXVtqXSA9IG5ldyBSYXRpb25hbE51bWJlcigxKTtcclxuXHRcdFx0XHR9IGVsc2UgeyB0aGlzLmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHRoaXMuZWxlbWVudHNbcm93MV1bcm93MV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHR0aGlzLmVsZW1lbnRzW3JvdzFdW3JvdzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDEpO1xyXG5cdFx0dGhpcy5lbGVtZW50c1tyb3cyXVtyb3cyXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdHRoaXMuZWxlbWVudHNbcm93Ml1bcm93MV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMSk7XHJcblx0fVxyXG59IiwiZXhwb3J0IGNsYXNzIFF1ZXVlPFQ+IHtcclxuXHRwcml2YXRlIHF1ZXVlOiBUW107XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHR0aGlzLnF1ZXVlID0gW107XHJcblx0fVxyXG5cdHB1YmxpYyBpc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMucXVldWUubGVuZ3RoID09PSAwO1xyXG5cdH1cclxuXHRwdWJsaWMgZW5xdWV1ZShlbGVtZW50OiBUKTogdm9pZCB7XHJcblx0XHR0aGlzLnF1ZXVlLnB1c2goZWxlbWVudCk7XHJcblx0fVxyXG5cdHB1YmxpYyBkZXF1ZXVlKCk6IFQge1xyXG5cdFx0aWYgKHRoaXMuaXNFbXB0eSgpKSB7IHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGlzIGVtcHR5XCIpOyB9XHJcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZS5zaGlmdCgpO1xyXG5cdH1cclxuXHRwdWJsaWMgcGVlaygpOiBUIHtcclxuXHRcdGlmICh0aGlzLmlzRW1wdHkoKSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJRdWV1ZSBpcyBlbXB0eVwiKTsgfVxyXG5cdFx0cmV0dXJuIHRoaXMucXVldWVbMF07XHJcblx0fVxyXG5cdHB1YmxpYyB0b0FycmF5KCk6IFRbXSB7XHJcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZTtcclxuXHR9XHJcbn0iLCJpbXBvcnQgeyBQYXJzZXIgfSBmcm9tIFwiLi9Bcml0aG1ldGljRXZhbHVhdG9yXCI7XHJcbmltcG9ydCB7IFF1ZXVlIH0gZnJvbSBcIi4vUXVldWVcIjtcclxuaW1wb3J0IHsgU3RhY2sgfSBmcm9tIFwiLi9TdGFja1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFJhdGlvbmFsTnVtYmVyIHtcclxuXHRwdWJsaWMgc3RhdGljIHRvUmV2ZXJzZVBvbGlzaE5vdGF0aW9uKGNvZGU6IHN0cmluZyk6IHN0cmluZ1tdIHtcclxuXHRcdGNvbnN0IHRva2Vuczogc3RyaW5nW10gPSBjb2RlLm1hdGNoKC9cXCh8XFwpfFxcZCsoXFwuXFxkKyk/fFxcdyt8W1xcK1xcLVxcKlxcL1xcXl0vZyk7XHJcblx0XHRsZXQgaTogbnVtYmVyID0gMDtcclxuXHRcdGNvbnN0IG91dHB1dFF1ZXVlOiBRdWV1ZTxzdHJpbmc+ID0gbmV3IFF1ZXVlPHN0cmluZz4oKTtcclxuXHRcdGNvbnN0IG9wZXJhdG9yU3RhY2s6IFN0YWNrPHN0cmluZz4gPSBuZXcgU3RhY2s8c3RyaW5nPigpO1xyXG5cdFx0d2hpbGUgKGkgPCB0b2tlbnMubGVuZ3RoKSB7XHJcblx0XHRcdGlmICh0aGlzLmlzTnVtYmVyKHRva2Vuc1tpXSkpIHtcclxuXHRcdFx0XHRvdXRwdXRRdWV1ZS5lbnF1ZXVlKHRva2Vuc1tpXSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5pc09wZXJhdG9yKHRva2Vuc1tpXSkpIHtcclxuXHRcdFx0XHRjb25zdCBvcDE6IHN0cmluZyA9IHRva2Vuc1tpXTtcclxuXHRcdFx0XHR3aGlsZSAoIW9wZXJhdG9yU3RhY2suaXNFbXB0eSgpICYmIHRoaXMuaXNPcGVyYXRvcihvcGVyYXRvclN0YWNrLnBlZWsoKSkpIHtcclxuXHRcdFx0XHRcdGlmICgodGhpcy5pc0xlZnRBc3NvY2lhdGl2ZU9wZXJhdG9yKG9wMSkgJiYgKHRoaXMucHJlY2VkZW5jZShvcDEpIDw9IHRoaXMucHJlY2VkZW5jZShvcGVyYXRvclN0YWNrLnBlZWsoKSkpKSB8fFxyXG5cdFx0XHRcdFx0XHQodGhpcy5pc1JpZ2h0QXNzb2NpYXRpdmVPcGVyYXRvcihvcDEpICYmICh0aGlzLnByZWNlZGVuY2Uob3AxKSA8IHRoaXMucHJlY2VkZW5jZShvcGVyYXRvclN0YWNrLnBlZWsoKSkpKSkge1xyXG5cdFx0XHRcdFx0XHRvdXRwdXRRdWV1ZS5lbnF1ZXVlKG9wZXJhdG9yU3RhY2sucG9wKCkpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG9wZXJhdG9yU3RhY2sucHVzaChvcDEpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2Vuc1tpXSA9PT0gXCIoXCIpIHtcclxuXHRcdFx0XHRvcGVyYXRvclN0YWNrLnB1c2godG9rZW5zW2ldKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0b2tlbnNbaV0gPT09IFwiKVwiKSB7XHJcblx0XHRcdFx0d2hpbGUgKCFvcGVyYXRvclN0YWNrLmlzRW1wdHkoKSAmJiBvcGVyYXRvclN0YWNrLnBlZWsoKSAhPT0gXCIoXCIpIHtcclxuXHRcdFx0XHRcdG91dHB1dFF1ZXVlLmVucXVldWUob3BlcmF0b3JTdGFjay5wb3AoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghb3BlcmF0b3JTdGFjay5pc0VtcHR5KCkgJiYgb3BlcmF0b3JTdGFjay5wZWVrKCkgPT09IFwiKFwiKSB7XHJcblx0XHRcdFx0XHRvcGVyYXRvclN0YWNrLnBvcCgpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIHBhcmVudGhlc2VzLlwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aSsrO1xyXG5cdFx0fVxyXG5cdFx0d2hpbGUgKCFvcGVyYXRvclN0YWNrLmlzRW1wdHkoKSkge1xyXG5cdFx0XHRpZiAob3BlcmF0b3JTdGFjay5wZWVrKCkgPT09IFwiKFwiKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBwYXJlbnRoZXNlcy5cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3V0cHV0UXVldWUuZW5xdWV1ZShvcGVyYXRvclN0YWNrLnBvcCgpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG91dHB1dFF1ZXVlLnRvQXJyYXkoKTtcclxuXHR9XHJcblx0cHVibGljIHN0YXRpYyBmcm9tU3RyaW5nKGNvZGU6IHN0cmluZyk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGNvbnN0IHA6IFBhcnNlciA9IG5ldyBQYXJzZXIoKTtcclxuXHRcdHJldHVybiBwLnBhcnNlKGNvZGUpO1xyXG5cdH1cclxuXHRwdWJsaWMgc3RhdGljIGdyZWF0ZXN0Q29tbW9uRGl2aXNvcihhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gYiA/IFJhdGlvbmFsTnVtYmVyLmdyZWF0ZXN0Q29tbW9uRGl2aXNvcihiLCBhICUgYikgOiBhO1xyXG5cdH1cclxuXHRwdWJsaWMgc3RhdGljIGxlYXN0Q29tbW9uTXVsdGlwbGUoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIE1hdGguYWJzKGEgKiBiIC8gUmF0aW9uYWxOdW1iZXIuZ3JlYXRlc3RDb21tb25EaXZpc29yKGEsIGIpKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgaXNOdW1iZXIoY29kZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gL15cXGQvLnRlc3QoY29kZSk7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIGlzT3BlcmF0b3IoY29kZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gL1tcXCtcXC1cXCpcXC9cXF5dLy50ZXN0KGNvZGUpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBpc0xlZnRBc3NvY2lhdGl2ZU9wZXJhdG9yKG9wZXJhdG9yOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAvW1xcK1xcLVxcKlxcL10vLnRlc3Qob3BlcmF0b3IpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBpc1JpZ2h0QXNzb2NpYXRpdmVPcGVyYXRvcihvcGVyYXRvcjogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gL1tcXF5dLy50ZXN0KG9wZXJhdG9yKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgcHJlY2VkZW5jZShvcGVyYXRvcjogc3RyaW5nKTogbnVtYmVyIHtcclxuXHRcdGlmICgvW1xcK1xcLV0vLnRlc3Qob3BlcmF0b3IpKSB7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9bXFwqXFwvXS8udGVzdChvcGVyYXRvcikpIHtcclxuXHRcdFx0cmV0dXJuIDI7XHJcblx0XHR9XHJcblx0XHRpZiAoL1tcXF5dLy50ZXN0KG9wZXJhdG9yKSkge1xyXG5cdFx0XHRyZXR1cm4gMztcclxuXHRcdH1cclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IuXCIpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBldmFsdWF0ZUZyb21SUE4odG9rZW5zOiBzdHJpbmdbXSk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGNvbnN0IHN0YWNrOiBTdGFjazxSYXRpb25hbE51bWJlcj4gPSBuZXcgU3RhY2s8UmF0aW9uYWxOdW1iZXI+KCk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmICghdGhpcy5pc09wZXJhdG9yKHRva2Vuc1tpXSkpIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKG5ldyBSYXRpb25hbE51bWJlcihwYXJzZUZsb2F0KHRva2Vuc1tpXSkpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zdCBvcDE6IFJhdGlvbmFsTnVtYmVyID0gc3RhY2sucG9wKCk7XHJcblx0XHRcdFx0Y29uc3Qgb3AyOiBSYXRpb25hbE51bWJlciA9IHN0YWNrLnBvcCgpO1xyXG5cdFx0XHRcdHN3aXRjaCAodG9rZW5zW2ldKSB7XHJcblx0XHRcdFx0XHRjYXNlIFwiK1wiOiBzdGFjay5wdXNoKG9wMi5hZGQob3AxKSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBcIi1cIjogc3RhY2sucHVzaChvcDIuc3ViKG9wMSkpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgXCIqXCI6IHN0YWNrLnB1c2gob3AyLm11bHQob3AxKSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBcIi9cIjogc3RhY2sucHVzaChvcDIuZGl2KG9wMSkpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgXCJeXCI6IHN0YWNrLnB1c2gob3AyLmV4cChvcDEudG9OdW1iZXIoKSkpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBzdGFjay5wb3AoKS5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdH1cclxuXHRwdWJsaWMgbnVtZXJhdG9yOiBudW1iZXI7XHJcblx0cHVibGljIGRlbm9taW5hdG9yOiBudW1iZXI7XHJcblx0Y29uc3RydWN0b3IobjogbnVtYmVyLCBkOiBudW1iZXIgPSAxKSB7XHJcblx0XHRpZiAoZCA9PT0gMCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJEaXZpc2lvbiBieSB6ZXJvIVwiKTtcclxuXHRcdH1cclxuXHRcdC8vIHRvZG86IHBvdGVudGlhbCBmb3Igb3ZlcmZsb3cuIFdoZW4gTWF0aC5zaWduIGJlY29tZXMgYXZhaWxhYmxlIGluIFR5cGVTY3JpcHQgdXNlIGl0IGluc3RlYWQgb2YgdGhlIG11bHRpcGxpY2F0aW9uXHJcblx0XHRjb25zdCBzaWduOiBudW1iZXIgPSBuICogZCA+PSAwID8gMSA6IC0xO1xyXG5cdFx0dGhpcy5udW1lcmF0b3IgPSBzaWduICogTWF0aC5hYnMobik7XHJcblx0XHR0aGlzLmRlbm9taW5hdG9yID0gTWF0aC5hYnMoZCk7XHJcblx0fVxyXG5cdHB1YmxpYyBzaW1wbGlmaWVkRm9ybSgpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRjb25zdCBnY2Q6IG51bWJlciA9IFJhdGlvbmFsTnVtYmVyLmdyZWF0ZXN0Q29tbW9uRGl2aXNvcih0aGlzLm51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvcik7XHJcblx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKHRoaXMubnVtZXJhdG9yIC8gZ2NkLCB0aGlzLmRlbm9taW5hdG9yIC8gZ2NkKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBlcXVhbHMoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IHJuMTogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIHJuMS5udW1lcmF0b3IgPT09IHggJiYgcm4xLmRlbm9taW5hdG9yID09PSAxO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3Qgcm4yOiBSYXRpb25hbE51bWJlciA9IHguc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdFx0cmV0dXJuIHJuMS5udW1lcmF0b3IgPT09IHJuMi5udW1lcmF0b3IgJiYgcm4xLmRlbm9taW5hdG9yID09PSBybjIuZGVub21pbmF0b3I7XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyBsdCh4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3Qgcm4xOiBSYXRpb25hbE51bWJlciA9IHRoaXMuc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gcm4xLm51bWVyYXRvciA8IHggKiBybjEuZGVub21pbmF0b3I7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBybjI6IFJhdGlvbmFsTnVtYmVyID0geC5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0XHRyZXR1cm4gcm4xLm51bWVyYXRvciAqIHJuMi5kZW5vbWluYXRvciA8IHJuMi5udW1lcmF0b3IgKiBybjEuZGVub21pbmF0b3I7XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyBsZSh4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3Qgcm4xOiBSYXRpb25hbE51bWJlciA9IHRoaXMuc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gcm4xLm51bWVyYXRvciA8PSB4ICogcm4xLmRlbm9taW5hdG9yO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3Qgcm4yOiBSYXRpb25hbE51bWJlciA9IHguc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdFx0cmV0dXJuIHJuMS5udW1lcmF0b3IgKiBybjIuZGVub21pbmF0b3IgPD0gcm4yLm51bWVyYXRvciAqIHJuMS5kZW5vbWluYXRvcjtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGd0KHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBybjE6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yID4geCAqIHJuMS5kZW5vbWluYXRvcjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IHJuMjogUmF0aW9uYWxOdW1iZXIgPSB4LnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yICogcm4yLmRlbm9taW5hdG9yID4gcm4yLm51bWVyYXRvciAqIHJuMS5kZW5vbWluYXRvcjtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGdlKHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBybjE6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yID49IHggKiBybjEuZGVub21pbmF0b3I7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBybjI6IFJhdGlvbmFsTnVtYmVyID0geC5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0XHRyZXR1cm4gcm4xLm51bWVyYXRvciAqIHJuMi5kZW5vbWluYXRvciA+PSBybjIubnVtZXJhdG9yICogcm4xLmRlbm9taW5hdG9yO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gbXVsdGlwbGljYXRpdmUgaW52ZXJzZVxyXG5cdHB1YmxpYyByZWNpcHJvY2FsKCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGlmICh0aGlzLmRlbm9taW5hdG9yID09PSAwKSB7IHRocm93IG5ldyBFcnJvcihcIkRpdmlzaW9uIGJ5IHplcm8hXCIpOyB9XHJcblx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKHRoaXMuZGVub21pbmF0b3IsIHRoaXMubnVtZXJhdG9yKTtcclxuXHR9XHJcblx0Ly8gYWRkaXRpdmUgaW52ZXJzZVxyXG5cdHB1YmxpYyBvcHBvc2l0ZSgpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKHRoaXMubnVtZXJhdG9yICogKC0xKSwgdGhpcy5kZW5vbWluYXRvcik7XHJcblx0fVxyXG5cdHB1YmxpYyBhZGQoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcigodGhpcy5udW1lcmF0b3IgKyB4ICogdGhpcy5kZW5vbWluYXRvciksIHRoaXMuZGVub21pbmF0b3IpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgbGNtOiBudW1iZXIgPSBSYXRpb25hbE51bWJlci5sZWFzdENvbW1vbk11bHRpcGxlKHRoaXMuZGVub21pbmF0b3IsIHguZGVub21pbmF0b3IpO1xyXG5cdFx0XHRjb25zdCBuMTogbnVtYmVyID0gdGhpcy5udW1lcmF0b3IgKiBsY20gLyB0aGlzLmRlbm9taW5hdG9yO1xyXG5cdFx0XHRjb25zdCBuMjogbnVtYmVyID0geC5udW1lcmF0b3IgKiBsY20gLyB4LmRlbm9taW5hdG9yO1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKG4xICsgbjIsIGxjbSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyBzdWIoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcigodGhpcy5udW1lcmF0b3IgLSB4ICogdGhpcy5kZW5vbWluYXRvciksIHRoaXMuZGVub21pbmF0b3IpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgbGNtOiBudW1iZXIgPSBSYXRpb25hbE51bWJlci5sZWFzdENvbW1vbk11bHRpcGxlKHRoaXMuZGVub21pbmF0b3IsIHguZGVub21pbmF0b3IpO1xyXG5cdFx0XHRjb25zdCBuMTogbnVtYmVyID0gdGhpcy5udW1lcmF0b3IgKiBsY20gLyB0aGlzLmRlbm9taW5hdG9yO1xyXG5cdFx0XHRjb25zdCBuMjogbnVtYmVyID0geC5udW1lcmF0b3IgKiBsY20gLyB4LmRlbm9taW5hdG9yO1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKG4xIC0gbjIsIGxjbSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyBtdWx0KHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIoKHRoaXMubnVtZXJhdG9yICogeCksIHRoaXMuZGVub21pbmF0b3IpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcigodGhpcy5udW1lcmF0b3IgKiB4Lm51bWVyYXRvciksIHguZGVub21pbmF0b3IgKiB0aGlzLmRlbm9taW5hdG9yKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGRpdih4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKCh0aGlzLm51bWVyYXRvciksIHRoaXMuZGVub21pbmF0b3IgKiB4KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIoKHRoaXMubnVtZXJhdG9yICogeC5kZW5vbWluYXRvciksIHgubnVtZXJhdG9yICogdGhpcy5kZW5vbWluYXRvcik7XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyBleHAoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcih0aGlzLm51bWVyYXRvciAqKiB4LCB0aGlzLmRlbm9taW5hdG9yICoqIHgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKHRoaXMuZGVub21pbmF0b3IgIT09IDEpIHsgdGhyb3cgRXJyb3IoXCJFeHBvbmVudGlhdGlvbiB3aXRoIHJhdGlvbmFsIHBvd2VycyBub3Qgc3VwcG9ydGVkLlwiKTsgfVxyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKHRoaXMubnVtZXJhdG9yICoqIHgubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yICoqIHgubnVtZXJhdG9yKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIHRvTnVtYmVyKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5udW1lcmF0b3IgLyB0aGlzLmRlbm9taW5hdG9yO1xyXG5cdH1cclxuXHRwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLm51bWVyYXRvci50b1N0cmluZygpICsgKDEgPT09IHRoaXMuZGVub21pbmF0b3IgPyBcIlwiIDogXCIvXCIgKyB0aGlzLmRlbm9taW5hdG9yLnRvU3RyaW5nKCkpO1xyXG5cdH1cclxuXHRwdWJsaWMgZGVlcENvcHkoKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcih0aGlzLm51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvcik7XHJcblx0fVxyXG59IiwiZXhwb3J0IGNsYXNzIFN0YWNrPFQ+IHtcclxuXHRwcml2YXRlIHN0YWNrOiBUW107XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHR0aGlzLnN0YWNrID0gW107XHJcblx0fVxyXG5cdHB1YmxpYyBpc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhY2subGVuZ3RoID09PSAwO1xyXG5cdH1cclxuXHRwdWJsaWMgcHVzaChlbGVtZW50OiBUKTogdm9pZCB7XHJcblx0XHR0aGlzLnN0YWNrLnB1c2goZWxlbWVudCk7XHJcblx0fVxyXG5cdHB1YmxpYyBwb3AoKTogVCB7XHJcblx0XHRpZiAodGhpcy5pc0VtcHR5KCkpIHsgdGhyb3cgbmV3IEVycm9yKFwiU3RhY2sgaXMgZW1wdHlcIik7IH1cclxuXHRcdHJldHVybiB0aGlzLnN0YWNrLnBvcCgpO1xyXG5cdH1cclxuXHRwdWJsaWMgcGVlaygpOiBUIHtcclxuXHRcdGlmICh0aGlzLmlzRW1wdHkoKSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJTdGFjayBpcyBlbXB0eVwiKTsgfVxyXG5cdFx0cmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcclxuXHR9XHJcblx0cHVibGljIHRvQXJyYXkoKTogVFtdIHtcclxuXHRcdHJldHVybiB0aGlzLnN0YWNrO1xyXG5cdH1cclxufSIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuL01hdHJpeFwiO1xyXG5pbXBvcnQgeyBSYXRpb25hbE51bWJlciB9IGZyb20gXCIuL1JhdGlvbmFsTnVtYmVyXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgVmVjdG9yIHtcclxuXHRwdWJsaWMgc3RhdGljIGFyZUxpbmVhcmx5SW5kZXBlbmRlbnQodmVjdG9yczogVmVjdG9yW10pOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IG06IG51bWJlciA9IHZlY3RvcnMubGVuZ3RoO1xyXG5cdFx0aWYgKDAgPT09IG0pIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdGNvbnN0IG46IG51bWJlciA9IHZlY3RvcnNbMF0ubTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDE7IGkgPCB2ZWN0b3JzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmIChuICE9PSB2ZWN0b3JzW2ldLm0pIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBkaW1lbnNpb25zLlwiKTsgfVxyXG5cdFx0fVxyXG5cdFx0aWYgKG0gPiBuKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcclxuXHR9XHJcblx0cHVibGljIG06IG51bWJlcjtcclxuXHRwdWJsaWMgZWxlbWVudHM6IFJhdGlvbmFsTnVtYmVyW107XHJcblx0Y29uc3RydWN0b3IobjogbnVtYmVyIHwgbnVtYmVyW10pO1xyXG5cdGNvbnN0cnVjdG9yKG46IGFueSkge1xyXG5cdFx0aWYgKHR5cGVvZiBuID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHRoaXMubSA9IG47XHJcblx0XHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcclxuXHRcdH0gZWxzZSBpZiAobiBpbnN0YW5jZW9mIEFycmF5KSB7XHJcblx0XHRcdHRoaXMubSA9IG4ubGVuZ3RoO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzID0gW107XHJcblx0XHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuZWxlbWVudHNbaV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIobltpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGFkZCh4OiBWZWN0b3IpOiBWZWN0b3Ige1xyXG5cdFx0aWYgKHRoaXMubSAhPT0geC5tKSB7IHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgZGltZW5zaW9ucy5cIik7IH1cclxuXHRcdGNvbnN0IHJlczogVmVjdG9yID0gbmV3IFZlY3Rvcih0aGlzLm0pO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHJlcy5tOyBpKyspIHtcclxuXHRcdFx0cmVzLmVsZW1lbnRzW2ldID0gdGhpcy5lbGVtZW50c1tpXS5hZGQoeC5lbGVtZW50c1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHRwdWJsaWMgc3ViKHg6IFZlY3Rvcik6IFZlY3RvciB7XHJcblx0XHRpZiAodGhpcy5tICE9PSB4Lm0pIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBkaW1lbnNpb25zLlwiKTsgfVxyXG5cdFx0Y29uc3QgcmVzOiBWZWN0b3IgPSBuZXcgVmVjdG9yKHRoaXMubSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgcmVzLm07IGkrKykge1xyXG5cdFx0XHRyZXMuZWxlbWVudHNbaV0gPSB0aGlzLmVsZW1lbnRzW2ldLnN1Yih4LmVsZW1lbnRzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cdHB1YmxpYyBtdWx0KHg6IFJhdGlvbmFsTnVtYmVyKTogVmVjdG9yIHtcclxuXHRcdGNvbnN0IHJlczogVmVjdG9yID0gbmV3IFZlY3Rvcih0aGlzLm0pO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHJlcy5tOyBpKyspIHtcclxuXHRcdFx0cmVzLmVsZW1lbnRzW2ldID0gdGhpcy5lbGVtZW50c1tpXS5tdWx0KHgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblx0Ly8gW0FMSUFTRVNdOiBpbm5lclByb2R1Y3QsIHByb2plY3Rpb25Qcm9kdWN0LCBzY2FsYXJQcm9kdWN0XHJcblx0cHVibGljIGRvdFByb2R1Y3QoeDogVmVjdG9yKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0aWYgKHRoaXMubSAhPT0geC5tKSB7IHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgZGltZW5zaW9ucy5cIik7IH1cclxuXHRcdGxldCByZXM6IFJhdGlvbmFsTnVtYmVyID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHgubTsgaSsrKSB7XHJcblx0XHRcdHJlcyA9IHJlcy5hZGQodGhpcy5lbGVtZW50c1tpXS5tdWx0KHguZWxlbWVudHNbaV0pKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cdC8vIFtBTElBU0VTXTogZGlyZWN0ZWRBcmVhUHJvZHVjdCwgdmVjdG9yUHJvZHVjdFxyXG5cdHB1YmxpYyBjcm9zc1Byb2R1Y3QoeDogVmVjdG9yKTogVmVjdG9yIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIik7XHJcblx0fVxyXG5cdC8vIFtBTElBU0VTXTogbWFnbml0dWRlLCBub3JtXHJcblx0cHVibGljIGxlbmd0aCgpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRjb25zdCBsZW5ndGg6IFJhdGlvbmFsTnVtYmVyID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGxlbmd0aC5hZGQodGhpcy5lbGVtZW50c1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbGVuZ3RoO1xyXG5cdH1cclxuXHRwdWJsaWMgZGVlcENvcHkoKTogVmVjdG9yIHtcclxuXHRcdGNvbnN0IHJldDogVmVjdG9yID0gbmV3IFZlY3Rvcih0aGlzLm0pO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdHJldC5lbGVtZW50c1tpXSA9IHRoaXMuZWxlbWVudHNbaV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH1cclxuXHRwdWJsaWMgdG9NYXRyaXgoKTogTWF0cml4IHtcclxuXHRcdGNvbnN0IHJldDogTWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLm0sIDEpO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdHJldC5lbGVtZW50c1tpXVswXSA9IHRoaXMuZWxlbWVudHNbaV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH1cclxufVxyXG5leHBvcnQgY2xhc3MgQ29sdW1uVmVjdG9yIGV4dGVuZHMgVmVjdG9yIHtcclxufVxyXG5leHBvcnQgY2xhc3MgUm93VmVjdG9yIGV4dGVuZHMgVmVjdG9yIHtcclxuXHRwdWJsaWMgbWF0cml4UHJvZHVjdChtOiBNYXRyaXgpOiBSb3dWZWN0b3Ige1xyXG5cdFx0aWYgKHRoaXMubSAhPT0gbS5uKSB7IHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgZGltZW5zaW9ucy5cIik7IH1cclxuXHRcdGNvbnN0IHJlczogUm93VmVjdG9yID0gbmV3IFJvd1ZlY3Rvcih0aGlzLm0pO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGxldCBzdW06IFJhdGlvbmFsTnVtYmVyID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgbS5uOyBqKyspIHtcclxuXHRcdFx0XHRzdW0gPSBzdW0uYWRkKG0uZWxlbWVudHNbaV1bal0ubXVsdCh0aGlzLmVsZW1lbnRzW2ldKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmVzLmVsZW1lbnRzW2ldID0gc3VtO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcbn0iXSwic291cmNlUm9vdCI6IiJ9