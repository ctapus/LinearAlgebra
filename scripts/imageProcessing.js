/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/exercises/imageProcessing.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.5.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-05-04T22:49Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.5.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( _i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.5
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2020-03-14
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
					dataPriv.get( this, "events" ) || Object.create( null )
				)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px";
				tr.style.height = "1px";
				trChild.style.height = "9px";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = (
					dataPriv.get( cur, "events" ) || Object.create( null )
				)[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script
			if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			if ( typeof props.top === "number" ) {
				props.top += "px";
			}
			if ( typeof props.left === "number" ) {
				props.left += "px";
			}
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./src/exercises/imageProcessing.ts":
/*!******************************************!*\
  !*** ./src/exercises/imageProcessing.ts ***!
  \******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../structures/Matrix */ "./src/structures/Matrix.ts");
/* harmony import */ var _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../structures/RationalNumber */ "./src/structures/RationalNumber.ts");
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




function imageDataToRGBA(imageData) {
  var imgR = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
  var imgG = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
  var imgB = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
  var imgA = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](imageData.width, imageData.height);
  var idx = 0;

  for (var x = 0; x < imageData.width; x++) {
    imgR[x] = [];
    imgG[x] = [];
    imgB[x] = [];
    imgA[x] = [];

    for (var y = 0; y < imageData.height; y++) {
      imgR.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
      imgG.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
      imgB.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
      imgA.elements[x][y] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](imageData.data[idx++]);
    }
  }

  return [imgR, imgG, imgB, imgA];
}

function imageDataFromRGBA(rgba) {
  var imgR = rgba[0];
  var imgG = rgba[1];
  var imgB = rgba[2];
  var imgA = rgba[3];
  var width = imgR.m;
  var height = imgR.n;
  var imageData = new ImageData(width, height);
  var idx = 0;

  for (var x = 0; x < width; x++) {
    for (var y = 0; y < height; y++) {
      imageData.data[idx++] = imgR.elements[x][y].toNumber();
      imageData.data[idx++] = imgG.elements[x][y].toNumber();
      imageData.data[idx++] = imgB.elements[x][y].toNumber();
      imageData.data[idx++] = imgA.elements[x][y].toNumber();
    }
  }

  return imageData;
}

$(document).ready(function () {
  var canvas1 = $("#canvas1")[0];
  var ctx1 = canvas1.getContext("2d");
  var image = new Image();

  image.onload = function () {
    canvas1.height = image.height;
    canvas1.width = image.width;
    ctx1.drawImage(image, 0, 0);
    var imgData1 = ctx1.getImageData(0, 0, image.width, image.height);
    var rgba = imageDataToRGBA(imgData1); // duplicate

    var imgData2 = imageDataFromRGBA(rgba);
    var canvas2 = $("#canvas2")[0];
    var ctx2 = canvas2.getContext("2d");
    canvas2.height = imgData2.height;
    canvas2.width = imgData2.width;
    ctx2.putImageData(imgData2, 0, 0); // convolute

    var canvas3 = $("#canvas3")[0];
    var ctx3 = canvas3.getContext("2d");
    var kernel = new _structures_Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](3, 3);
    /*
    kernel.elements[0][0] = new RationalNumber(0);
    kernel.elements[0][1] = new RationalNumber(-1);
    kernel.elements[0][2] = new RationalNumber(0);
    kernel.elements[1][0] = new RationalNumber(-1);
    kernel.elements[1][1] = new RationalNumber(5);
    kernel.elements[1][2] = new RationalNumber(-1);
    kernel.elements[2][0] = new RationalNumber(0);
    kernel.elements[2][1] = new RationalNumber(-1);
    kernel.elements[2][2] = new RationalNumber(0);
    */

    /*
    kernel.elements[0][0] = new RationalNumber(-1);
    kernel.elements[0][1] = new RationalNumber(-1);
    kernel.elements[0][2] = new RationalNumber(-1);
    kernel.elements[1][0] = new RationalNumber(-1);
    kernel.elements[1][1] = new RationalNumber(8);
    kernel.elements[1][2] = new RationalNumber(-1);
    kernel.elements[2][0] = new RationalNumber(-1);
    kernel.elements[2][1] = new RationalNumber(-1);
    kernel.elements[2][2] = new RationalNumber(-1);
    */

    /*
    kernel.elements[0][0] = new RationalNumber(0);
    kernel.elements[0][1] = new RationalNumber(0);
    kernel.elements[0][2] = new RationalNumber(0);
    kernel.elements[1][0] = new RationalNumber(0);
    kernel.elements[1][1] = new RationalNumber(1);
    kernel.elements[1][2] = new RationalNumber(0);
    kernel.elements[2][0] = new RationalNumber(0);
    kernel.elements[2][1] = new RationalNumber(0);
    kernel.elements[2][2] = new RationalNumber(0);
    //*/
    //*

    kernel.elements[0][0] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
    kernel.elements[0][1] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](-1);
    kernel.elements[0][2] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
    kernel.elements[1][0] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
    kernel.elements[1][1] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](2);
    kernel.elements[1][2] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
    kernel.elements[2][0] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
    kernel.elements[2][1] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
    kernel.elements[2][2] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0); //*/
    // const newRgba: [Matrix, Matrix, Matrix, Matrix] = [rgba[0].convolute(kernel), rgba[1].convolute(kernel), rgba[2].convolute(kernel), rgba[3].convolute(kernel)];

    for (var i = 0; i < rgba[0].m; i++) {
      for (var j = 0; j < rgba[0].n; j++) {
        rgba[0].elements[i][j] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
        rgba[2].elements[i][j] = new _structures_RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);
      }
    }

    var newRgba = [rgba[0], rgba[1].convolute(kernel), rgba[2], rgba[3]];
    var imgData3 = imageDataFromRGBA(newRgba);
    canvas3.height = imgData3.height;
    canvas3.width = imgData3.width;
    ctx3.putImageData(imgData3, 0, 0);
  };

  image.src = "data:image/png;base64," + encodedImg; // Other ways of doing it

  var imgSrc = $("#imgSource").attr("src").replace("data:image/png;base64,", "");
  var binSrc = atob(imgSrc);
  var img = Uint8Array.from(binSrc, function (c) {
    return c.charCodeAt(0);
  }); // reverse

  var binDest = "";

  var _iterator = _createForOfIteratorHelper(img),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var i = _step.value;
      binDest += String.fromCharCode(i);
    } // String.fromCharCode.apply(null, img); // throww "Maximum call stack size exceeded"

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var imgDest = btoa(binDest);
  $("#imgDestination").attr("src", "data:image/png;base64," + imgDest);
});
var encodedImg = "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";
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")))

/***/ }),

/***/ "./src/structures/ArithmeticEvaluator.ts":
/*!***********************************************!*\
  !*** ./src/structures/ArithmeticEvaluator.ts ***!
  \***********************************************/
/*! exports provided: ArithmeticEvaluator, TokenType, Token, Lexer, Parser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArithmeticEvaluator", function() { return ArithmeticEvaluator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TokenType", function() { return TokenType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Token", function() { return Token; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lexer", function() { return Lexer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Parser", function() { return Parser; });
/* harmony import */ var _Queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Queue */ "./src/structures/Queue.ts");
/* harmony import */ var _RationalNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RationalNumber */ "./src/structures/RationalNumber.ts");
/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Stack */ "./src/structures/Stack.ts");
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var ArithmeticEvaluator = /*#__PURE__*/function () {
  function ArithmeticEvaluator() {
    _classCallCheck(this, ArithmeticEvaluator);
  }

  _createClass(ArithmeticEvaluator, null, [{
    key: "toReversePolishNotation",
    value: function toReversePolishNotation(code) {
      var tokens = code.match(/\(|\)|\d+(\.\d+)?|\w+|[\+\-\*\/\^]/g);
      var i = 0;
      var outputQueue = new _Queue__WEBPACK_IMPORTED_MODULE_0__["Queue"]();
      var operatorStack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();

      while (i < tokens.length) {
        if (this.isNumber(tokens[i])) {
          outputQueue.enqueue(tokens[i]);
        } else if (this.isOperator(tokens[i])) {
          var op1 = tokens[i];

          while (!operatorStack.isEmpty() && this.isOperator(operatorStack.peek())) {
            if (this.isLeftAssociativeOperator(op1) && this.precedence(op1) <= this.precedence(operatorStack.peek()) || this.isRightAssociativeOperator(op1) && this.precedence(op1) < this.precedence(operatorStack.peek())) {
              outputQueue.enqueue(operatorStack.pop());
            } else {
              break;
            }
          }

          operatorStack.push(op1);
        } else if (tokens[i] === "(") {
          operatorStack.push(tokens[i]);
        } else if (tokens[i] === ")") {
          while (!operatorStack.isEmpty() && operatorStack.peek() !== "(") {
            outputQueue.enqueue(operatorStack.pop());
          }

          if (!operatorStack.isEmpty() && operatorStack.peek() === "(") {
            operatorStack.pop();
          } else {
            throw new Error("Mismatched parentheses.");
          }
        }

        i++;
      }

      while (!operatorStack.isEmpty()) {
        if (operatorStack.peek() === "(") {
          throw new Error("Mismatched parentheses.");
        } else {
          outputQueue.enqueue(operatorStack.pop());
        }
      }

      return outputQueue.toArray();
    }
  }, {
    key: "evaluateFromRPN",
    value: function evaluateFromRPN(tokens) {
      var stack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();

      for (var i = 0; i < tokens.length; i++) {
        if (!this.isOperator(tokens[i])) {
          stack.push(parseFloat(tokens[i]));
        } else {
          var op1 = stack.pop();
          var op2 = stack.pop();

          switch (tokens[i]) {
            case "+":
              stack.push(op2 + op1);
              break;

            case "-":
              stack.push(op2 - op1);
              break;

            case "*":
              stack.push(op2 * op1);
              break;

            case "/":
              stack.push(op2 / op1);
              break;

            case "^":
              stack.push(Math.pow(op2, op1));
              break;
          }
        }
      }

      return stack.pop();
    }
  }, {
    key: "isNumber",
    value: function isNumber(code) {
      return /^\d/.test(code);
    }
  }, {
    key: "isOperator",
    value: function isOperator(code) {
      return /[\+\-\*\/\^]/.test(code);
    }
  }, {
    key: "isLeftAssociativeOperator",
    value: function isLeftAssociativeOperator(operator) {
      return /[\+\-\*\/]/.test(operator);
    }
  }, {
    key: "isRightAssociativeOperator",
    value: function isRightAssociativeOperator(operator) {
      return /[\^]/.test(operator);
    }
  }, {
    key: "precedence",
    value: function precedence(operator) {
      if (/[\+\-]/.test(operator)) {
        return 1;
      }

      if (/[\*\/]/.test(operator)) {
        return 2;
      }

      if (/[\^]/.test(operator)) {
        return 3;
      }

      throw new Error("Unknown operator.");
    }
  }]);

  return ArithmeticEvaluator;
}();
var TokenType;

(function (TokenType) {
  TokenType[TokenType["Plus"] = 0] = "Plus";
  TokenType[TokenType["Minus"] = 1] = "Minus";
  TokenType[TokenType["Multiply"] = 2] = "Multiply";
  TokenType[TokenType["Divide"] = 3] = "Divide";
  TokenType[TokenType["Exponent"] = 4] = "Exponent";
  TokenType[TokenType["Number"] = 5] = "Number";
  TokenType[TokenType["LParen"] = 6] = "LParen";
  TokenType[TokenType["RParen"] = 7] = "RParen";
  TokenType[TokenType["End"] = 8] = "End";
  TokenType[TokenType["Unknown"] = 9] = "Unknown";
})(TokenType || (TokenType = {}));

var Token = function Token(type, value) {
  _classCallCheck(this, Token);

  _defineProperty(this, "type", void 0);

  _defineProperty(this, "value", void 0);

  this.type = type;
  this.value = value;
};
var Lexer = /*#__PURE__*/function () {
  function Lexer(input) {
    _classCallCheck(this, Lexer);

    _defineProperty(this, "tokens", void 0);

    _defineProperty(this, "tokenIndex", void 0);

    this.tokens = input.replace(" ", "").match(/\(|\)|\d+(\.\d+)?|[\+\-\*\/\^]/g);
    this.tokenIndex = 0;
  }

  _createClass(Lexer, [{
    key: "getNextToken",
    value: function getNextToken() {
      if (this.tokens.length === this.tokenIndex) {
        return new Token(TokenType.End);
      }

      var input = this.tokens[this.tokenIndex++];
      return this.getToken(input);
    }
  }, {
    key: "getCurrentToken",
    value: function getCurrentToken() {
      if (this.tokens.length - 1 === this.tokenIndex) {
        return new Token(TokenType.End);
      }

      var input = this.tokens[this.tokenIndex];
      return this.getToken(input);
    }
  }, {
    key: "revert",
    value: function revert() {
      if (this.tokenIndex <= 0) {
        throw Error("Index out of range");
      }

      this.tokenIndex--;
    }
  }, {
    key: "getToken",
    value: function getToken(input) {
      if (/\+/.test(input)) {
        return new Token(TokenType.Plus);
      }

      if (/\-/.test(input)) {
        return new Token(TokenType.Minus);
      }

      if (/\*/.test(input)) {
        return new Token(TokenType.Multiply);
      }

      if (/\//.test(input)) {
        return new Token(TokenType.Divide);
      }

      if (/\^/.test(input)) {
        return new Token(TokenType.Exponent);
      }

      if (/\d+(\.\d+)?/.test(input)) {
        return new Token(TokenType.Number, parseFloat(input));
      }

      if (/\(/.test(input)) {
        return new Token(TokenType.LParen);
      }

      if (/\)/.test(input)) {
        return new Token(TokenType.RParen);
      }

      return new Token(TokenType.Unknown);
    }
  }]);

  return Lexer;
}();
var Parser = /*#__PURE__*/function () {
  function Parser() {
    _classCallCheck(this, Parser);

    _defineProperty(this, "lex", void 0);
  }

  _createClass(Parser, [{
    key: "parse",
    value: function parse(code) {
      this.lex = new Lexer(code);
      var expression = this.fourthOrderOperators();
      var token = this.lex.getCurrentToken(); // is already advanced because of number()

      if (token.type === TokenType.End) {
        return expression;
      }

      throw Error("End expected");
    } // addition and substraction

  }, {
    key: "fourthOrderOperators",
    value: function fourthOrderOperators() {
      var component1 = this.thirdOrderOperators();
      var token = this.lex.getNextToken();

      while (token.type === TokenType.Plus || token.type === TokenType.Minus) {
        var component2 = this.thirdOrderOperators();

        if (token.type === TokenType.Plus) {
          component1 = component1.add(component2);
        } else if (token.type === TokenType.Minus) {
          component1 = component1.sub(component2);
        }

        token = this.lex.getNextToken();
      }

      this.lex.revert();
      return component1;
    } // multiplication and division

  }, {
    key: "thirdOrderOperators",
    value: function thirdOrderOperators() {
      var factor1 = this.secondOrderOperators();
      var token = this.lex.getNextToken();

      while (token.type === TokenType.Multiply || token.type === TokenType.Divide) {
        var factor2 = this.secondOrderOperators();

        if (token.type === TokenType.Multiply) {
          factor1 = factor1.mult(factor2);
        } else if (token.type === TokenType.Divide) {
          factor1 = factor1.div(factor2);
        }

        token = this.lex.getNextToken();
      }

      this.lex.revert();
      return factor1;
    } // exponents and roots

  }, {
    key: "secondOrderOperators",
    value: function secondOrderOperators() {
      var factor1 = this.firstOrderOperators();
      var token = this.lex.getNextToken();

      while (token.type === TokenType.Exponent) {
        var factor2 = this.firstOrderOperators();
        factor1 = factor1.exp(factor2);
        token = this.lex.getNextToken();
      }

      this.lex.revert();
      return factor1;
    } // numbers and parantheses

  }, {
    key: "firstOrderOperators",
    value: function firstOrderOperators() {
      var value = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](1);
      var token = this.lex.getNextToken();

      if (token.type === TokenType.Plus || token.type === TokenType.Minus) {
        if (token.type === TokenType.Minus) {
          value = value.mult(-1);
        }

        token = this.lex.getNextToken();
      }

      if (token.type === TokenType.LParen) {
        value = value.mult(this.fourthOrderOperators());
        token = this.lex.getNextToken();

        if (token.type !== TokenType.RParen) {
          throw Error("Unbalanced parenthesis");
        }
      } else {
        if (token.type === TokenType.Number) {
          value = value.mult(token.value);
        } else {
          throw Error("Not a number");
        }
      }

      return value;
    }
  }]);

  return Parser;
}();
/*
	public static evaluate(expresion: string): RationalNumber {
	var digitPattern = new RegExp('0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9');
	var signPattern = new RegExp('\+|\-');
	var numberPattern = new RegExp('[' + signPattern + ']' + '{' + digitPattern + '}');
	var factorPattern = new RegExp(numberPattern + '|\(' + expressionPattern + '\)');
	var componentPattern = new RegExp(factorPattern + '[{( \* | \/ )' + factorPattern + '}]');
	var expressionPattern = new RegExp(componentPattern + '[{( \+ | \-)' + componentPattern + '}]');
}*/

/*
exprr: 4thORDER+;
4thORDER: component1=3rdORDER ((PLUS|MINUS) component2=3rdORDER)+;
3rdORDER: factor1=2NDORDER ((MULTIPLY|DIVIDE) factor1=2ndORDER)+
2ndORDER: factor1=1stORDER (EXPONENT factor2=1stORDER)+
1stORDER: (PLUS|MINUS|empty) (LPAREN value=4thORDER RPAREN| NUMBER)
*/

/***/ }),

/***/ "./src/structures/Matrix.ts":
/*!**********************************!*\
  !*** ./src/structures/Matrix.ts ***!
  \**********************************/
/*! exports provided: Matrix, MatrixIdentity, MatrixElimination, MatrixPermutation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix", function() { return Matrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatrixIdentity", function() { return MatrixIdentity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatrixElimination", function() { return MatrixElimination; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MatrixPermutation", function() { return MatrixPermutation; });
/* harmony import */ var _RationalNumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RationalNumber */ "./src/structures/RationalNumber.ts");
/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector */ "./src/structures/Vector.ts");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var Matrix = /*#__PURE__*/function () {
  _createClass(Matrix, null, [{
    key: "augment",
    value: function augment(A, B) {
      if (A.m !== B.m) {
        throw new Error("The two matrices (vector) must have the same number of rows (elements).");
      }

      var ret = null;

      if (B instanceof Matrix) {
        ret = new Matrix(A.m, B.n + A.n);

        for (var i = 0; i < A.m; i++) {
          for (var j = 0; j < A.n; j++) {
            ret.elements[i][j] = A.elements[i][j];
          }
        }

        for (var _i = 0; _i < B.m; _i++) {
          for (var _j = 0; _j < B.n; _j++) {
            ret.elements[_i][A.n + _j] = B.elements[_i][_j];
          }
        }
      } else {
        if (B instanceof _Vector__WEBPACK_IMPORTED_MODULE_1__["Vector"]) {
          ret = new Matrix(A.m, A.n + 1);

          for (var _i2 = 0; _i2 < A.m; _i2++) {
            for (var _j2 = 0; _j2 < A.n; _j2++) {
              ret.elements[_i2][_j2] = A.elements[_i2][_j2];
            }
          }

          for (var _j3 = 0; _j3 < B.m; _j3++) {
            ret.elements[_j3][A.n] = B.elements[_j3];
          }
        }
      }

      return ret;
    } // row-multiplying transformations

  }, {
    key: "multiplication",
    value: function multiplication(n, row1, row2, mult) {
      if (n < row1 || n < row2) {
        throw new Error("Column index must be less or equalt than matrix size.");
      }

      var matrix = new MatrixIdentity(n);
      matrix.elements[row1][row2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](mult);
      return matrix;
    }
  }, {
    key: "randomSquare",
    value: function randomSquare() {
      var matrix = new Matrix(Math.floor(Math.random() * 4) + 3, Math.floor(Math.random() * 4) + 3); // minimum size 3x3 matrix

      for (var i = 0; i < matrix.m; i++) {
        for (var j = 0; j < matrix.n; j++) {
          matrix.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](Math.floor(Math.random() * 100 - 50));
        }
      }

      return matrix;
    }
  }, {
    key: "random2",
    value: function random2() {
      var numberOfUnknowns = Math.floor(Math.random() * 4 + 3); // between 3 and 7 unknonws

      var unknowns = [];

      for (var i = 0; i < numberOfUnknowns; i++) {
        unknowns[i] = Math.floor(Math.random() * 20 - 10);
      } // todo: change below


      var matrix = new Matrix(Math.floor(Math.random() * 4) + 3, Math.floor(Math.random() * 4) + 3);
      return matrix;
    }
  }]);

  function Matrix(m, n) {
    _classCallCheck(this, Matrix);

    _defineProperty(this, "m", void 0);

    _defineProperty(this, "n", void 0);

    _defineProperty(this, "elements", void 0);

    this.m = m;
    this.n = n;
    this.elements = [];

    for (var i = 0; i < this.m; i++) {
      this.elements[i] = [];
    }
  }

  _createClass(Matrix, [{
    key: "equals",
    value: function equals(M) {
      if (this.m !== M.m || this.n !== M.n) {
        return false;
      }

      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          if (!this.elements[i][j].equals(M.elements[i][j])) {
            return false;
          }
        }
      }

      return true;
    }
  }, {
    key: "add",
    value: function add(x) {
      if (this.m !== x.m || this.n !== x.n) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new Matrix(this.m, this.n);

      for (var i = 0; i < res.m; i++) {
        for (var j = 0; j < res.n; j++) {
          res.elements[i][j] = this.elements[i][j].add(x.elements[i][j]);
        }
      }

      return res;
    }
  }, {
    key: "sub",
    value: function sub(x) {
      if (this.m !== x.m || this.n !== x.n) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new Matrix(this.m, this.n);

      for (var i = 0; i < res.m; i++) {
        for (var j = 0; j < res.n; j++) {
          res.elements[i][j] = this.elements[i][j].sub(x.elements[i][j]);
        }
      }

      return res;
    }
  }, {
    key: "mult",
    value: function mult(x) {
      var res = null;

      if (typeof x === "number") {
        res = new Matrix(this.m, this.n);

        for (var i = 0; i < res.m; i++) {
          for (var j = 0; j < res.n; j++) {
            res.elements[i][j] = this.elements[i][j].mult(x);
          }
        }
      } else if (x instanceof _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"]) {
        res = new Matrix(this.m, this.n);

        for (var _i3 = 0; _i3 < res.m; _i3++) {
          for (var _j4 = 0; _j4 < res.n; _j4++) {
            res.elements[_i3][_j4] = this.elements[_i3][_j4].mult(x);
          }
        }
      } else {
        if (x instanceof Matrix) {
          if (this.n !== x.m) {
            throw new Error("Mismatched dimensions.");
          }

          res = new Matrix(this.m, x.n);

          for (var _i4 = 0; _i4 < res.m; _i4++) {
            for (var _j5 = 0; _j5 < res.n; _j5++) {
              var sum = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);

              for (var k = 0; k < this.n; k++) {
                sum = sum.add(this.elements[_i4][k].mult(x.elements[k][_j5]));
              }

              res.elements[_i4][_j5] = sum;
            }
          }
        }
      }

      return res;
    }
  }, {
    key: "vectorProduct",
    value: function vectorProduct(v) {
      if (this.n !== v.m) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new _Vector__WEBPACK_IMPORTED_MODULE_1__["ColumnVector"](v.m);

      for (var i = 0; i < this.m; i++) {
        var sum = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);

        for (var j = 0; j < this.n; j++) {
          sum = sum.add(this.elements[i][j].mult(v.elements[j]));
        }

        res.elements[i] = sum;
      }

      return res;
    }
  }, {
    key: "transpose",
    value: function transpose() {
      var ret = new Matrix(this.n, this.m);

      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          ret.elements[j][i] = this.elements[i][j];
        }
      }

      return ret;
    }
  }, {
    key: "deepCopy",
    value: function deepCopy() {
      var ret = new Matrix(this.m, this.n);

      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          ret.elements[i][j] = this.elements[i][j];
        }
      }

      return ret;
    }
  }, {
    key: "switchRows",
    value: function switchRows(idx1, idx2) {
      if (this.m < idx1 || this.m < idx2) {
        return;
      }

      for (var i = 0; i < this.n; i++) {
        var tmp = this.elements[idx1][i];
        this.elements[idx1][i] = this.elements[idx2][i];
        this.elements[idx2][i] = tmp;
      }
    }
  }, {
    key: "multiplyRow",
    value: function multiplyRow(idx, scalar) {
      if (this.m < idx) {
        return;
      }

      for (var i = 0; i < this.n; i++) {
        this.elements[idx][i] = this.elements[idx][i].mult(scalar).simplifiedForm();
      }
    }
  }, {
    key: "addRows",
    value: function addRows(idx1, idx2, scalar) {
      if (this.m < idx1 || this.m < idx2) {
        return;
      }

      for (var i = 0; i < this.n; i++) {
        this.elements[idx1][i] = this.elements[idx2][i].mult(scalar).add(this.elements[idx1][i]).simplifiedForm();
      }
    }
  }, {
    key: "addRow1ToRow2",
    value: function addRow1ToRow2(idx1, scalar1, idx2, scalar2) {
      if (this.m < idx1 || this.m < idx2) {
        return;
      }

      for (var i = 0; i < this.n; i++) {
        this.elements[idx2][i] = this.elements[idx2][i].mult(scalar2).add(this.elements[idx1][i].mult(scalar1)).simplifiedForm();
      }
    } // a square matrix is a matrix with the same number of rows and columns

  }, {
    key: "isSquare",
    value: function isSquare() {
      return this.m === this.n;
    } // a diagonal matrix is a matrix in which the entries outside the main diagonal are all zero

  }, {
    key: "isDiagonal",
    value: function isDiagonal() {
      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          if (i === j) {
            continue;
          }

          if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
            return false;
          }
        }
      }

      return true;
    } // the identity matrix of size n is the n × n square matrix with ones on the main diagonal and zeros elsewhere
    // [ALIASES]: unit matrix

  }, {
    key: "isIdentity",
    value: function isIdentity() {
      if (this.m !== this.n) {
        throw new Error("Not a square matrix.");
      }

      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          if (i === j) {
            if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1))) {
              return false;
            }

            continue;
          }

          if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
            return false;
          }
        }
      }

      return true;
    } // a matrix is normal if it commutes with its conjugate transpose

  }, {
    key: "isNormal",
    value: function isNormal() {
      throw new Error("Not implemented");
    } // the conjugate transpose of an m-by-n matrix A with complex entries is the n-by-m matrix A∗ obtained from A
    // by taking the transpose and then taking the complex conjugate of each entry
    // [ALIASES]: Hermitian transpose

  }, {
    key: "toConjugateTranspose",
    value: function toConjugateTranspose() {
      throw new Error("Not implemented");
    }
  }, {
    key: "isUpperTriangular",
    value: function isUpperTriangular() {
      // todo: check if definition is valid for a non square matrix
      // if (this.m !== this.n) { throw new Error("Not a square matrix."); }
      for (var i = 1; i < this.m; i++) {
        for (var j = 0; j < i; j++) {
          if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
            return false;
          }
        }
      }

      return true;
    }
  }, {
    key: "isLowerTriangular",
    value: function isLowerTriangular() {
      // todo: check if definition is valid for a non square matrix
      // if (this.m !== this.n) { throw new Error("Not a square matrix."); }
      for (var i = 0; i < this.m; i++) {
        for (var j = i + 1; j < this.n; j++) {
          if (!this.elements[i][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
            return false;
          }
        }
      }

      return true;
    } // a symmetric matrix is a square matrix that is equal to its transpose

  }, {
    key: "isSymmetric",
    value: function isSymmetric() {
      if (this.m !== this.n) {
        throw new Error("Not a square matrix.");
      }

      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          if (!this.elements[i][j].equals(this.elements[j][i])) {
            return false;
          }
        }
      }

      return true;
    } // an orthogonal matrix is a square matrix with real entries whose columns and rows are orthogonal unit vectors
    // [ALIASES]: real orthogonal matrix

  }, {
    key: "isOrthogonal",
    value: function isOrthogonal() {
      var MT = this.transpose();
      return this.mult(MT).isIdentity();
    }
  }, {
    key: "isRowEchelonForm",
    value: function isRowEchelonForm() {
      var foundZeroRow = false; // all nonzero rows (rows with at least one nonzero element) are above any rows of all zeroes
      // (all zero rows, if any, belong at the bottom of the matrix)

      for (var i = 0; i < this.m; i++) {
        if (this.isZeroRow(i)) {
          foundZeroRow = true;
        } else {
          if (foundZeroRow) {
            return false;
          }
        } // if current row is not zero, but a previous row is zero, then matrix is not in row echelon form

      } // the leading coefficient (the first nonzero number from the left, also called the pivot) of a nonzero row
      // is always strictly to the right of the leading coefficient of the row above it


      var previousIdx = -1;

      for (var _i5 = 0; _i5 < this.m; _i5++) {
        var currentPivotIdx = this.rowPivotPosition(_i5);

        if (0 > currentPivotIdx) {
          continue;
        } // this is a zero row, no pivot
        // leading coefficient must be 1


        if (!this.elements[_i5][currentPivotIdx].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1))) {
          return false;
        }

        if (previousIdx < currentPivotIdx) {
          previousIdx = currentPivotIdx;
        } else {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "isReducedRowEchelonForm",
    value: function isReducedRowEchelonForm() {
      if (!this.isRowEchelonForm()) {
        return false;
      } // each leading coefficient is the only nonzero entry in its column


      for (var i = 0; i < this.m; i++) {
        var pivotPosition = this.rowPivotPosition(i);

        if (1 < this.numberOfNonZeroElementForColumn(pivotPosition)) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "toReducedRowEchelonForm",
    value: function toReducedRowEchelonForm() {
      var res = this.deepCopy();
      var lead = 0;

      for (var r = 0; r < res.m; r++) {
        if (res.n <= lead) {
          break;
        }

        var i = r;

        while (res.elements[i][lead].equals(0)) {
          i++;

          if (res.m === i) {
            i = r;
            lead++;

            if (res.n === lead) {
              lead--;
              break;
            }
          }
        }

        res.switchRows(i, r);

        if (!res.elements[r][lead].equals(0)) {
          res.multiplyRow(r, res.elements[r][lead].reciprocal());
        }

        for (var j = 0; j < res.m; j++) {
          if (j !== r) {
            res.addRows(j, r, res.elements[j][lead].opposite());
          }
        }

        lead++;
      }

      return res;
    }
  }, {
    key: "determinant",
    value: function determinant() {
      // todo: implement an optimized version, like A=PLU
      if (this.m !== this.n) {
        throw new Error("Determinant can only be calculated on a square matrix");
      }

      if (this.m === 1) {
        return this.elements[0][0];
      }

      var ret = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);

      for (var i = 0; i < this.n; i++) {
        var minor = this.elements[0][i].mult(this.cofactor(0, i).determinant());
        ret = ret.add(minor.mult(Math.pow(-1, i)));
      }

      return ret;
    }
  }, {
    key: "convolute",
    value: function convolute(kernel) {
      if (kernel.m !== kernel.n) {
        throw new Error("Kernel is not a square matrix.");
      }

      if (kernel.m % 2 === 0) {
        throw new Error("Kernel is not an even size matrix.");
      }

      var sz = Math.floor(kernel.m / 2);
      var res = new Matrix(this.m, this.n);

      for (var i = 0; i < this.m; i++) {
        for (var j = 0; j < this.n; j++) {
          res.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);

          for (var ti = 0; ti < kernel.m; ti++) {
            if (i + ti - sz < 0 || i + ti - sz >= this.m) {
              continue;
            }

            for (var tj = 0; tj < kernel.n; tj++) {
              if (j + tj - sz < 0 || j + tj - sz >= this.n) {
                continue;
              }

              res.elements[i][j] = res.elements[i][j].add(this.elements[i + ti - sz][j + tj - sz].mult(kernel.elements[ti][tj]));
            }
          }
        }
      }

      return res;
    }
  }, {
    key: "isZeroRow",
    value: function isZeroRow(rowId) {
      for (var j = 0; j < this.n; j++) {
        if (!this.elements[rowId][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "rowPivotPosition",
    value: function rowPivotPosition(rowId) {
      for (var j = 0; j < this.n; j++) {
        if (!this.elements[rowId][j].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
          return j;
        }
      }

      return -1;
    }
  }, {
    key: "numberOfNonZeroElementForColumn",
    value: function numberOfNonZeroElementForColumn(columnId) {
      var acc = 0;

      for (var j = 0; j < this.m; j++) {
        if (!this.elements[j][columnId].equals(new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0))) {
          acc++;
        }
      }

      return acc;
    }
  }, {
    key: "cofactor",
    value: function cofactor(rowId, columnId) {
      var ret = new Matrix(this.m - 1, this.n - 1);
      var rowOffset = 0;

      for (var i = 0; i < this.m - 1; i++) {
        if (i === rowId) {
          rowOffset = 1;
        }

        var columnOffset = 0;

        for (var j = 0; j < this.n - 1; j++) {
          if (j === columnId) {
            columnOffset = 1;
          }

          ret.elements[i][j] = this.elements[i + rowOffset][j + columnOffset];
        }
      }

      return ret;
    }
  }]);

  return Matrix;
}();
var MatrixIdentity = /*#__PURE__*/function (_Matrix) {
  _inherits(MatrixIdentity, _Matrix);

  var _super = _createSuper(MatrixIdentity);

  function MatrixIdentity(m) {
    var _this;

    _classCallCheck(this, MatrixIdentity);

    _this = _super.call(this, m, m);
    _this.elements = [];

    for (var i = 0; i < _this.m; i++) {
      _this.elements[i] = [];

      for (var j = 0; j < _this.m; j++) {
        if (i === j) {
          _this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
        } else {
          _this.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
        }
      }
    }

    return _this;
  }

  return MatrixIdentity;
}(Matrix); // elimination - multiply on the left (E*A); Row-addition transformations
// to mult*(row2 of Matrix A) add (row1 of Matrix A)

var MatrixElimination = /*#__PURE__*/function (_Matrix2) {
  _inherits(MatrixElimination, _Matrix2);

  var _super2 = _createSuper(MatrixElimination);

  function MatrixElimination(m, r1, r2, mult) {
    var _this2;

    _classCallCheck(this, MatrixElimination);

    if (m < r1 || m < r2) {
      throw new Error("Column index must be less than or equal to the matrix size.");
    }

    _this2 = _super2.call(this, m, m);

    _defineProperty(_assertThisInitialized(_this2), "row1", void 0);

    _defineProperty(_assertThisInitialized(_this2), "row2", void 0);

    _this2.row1 = r1;
    _this2.row2 = r2;
    _this2.elements = [];

    for (var i = 0; i < _this2.m; i++) {
      _this2.elements[i] = [];

      for (var j = 0; j < _this2.m; j++) {
        if (i === j) {
          _this2.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
        } else {
          _this2.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
        }
      }
    }

    if (typeof mult === "number") {
      _this2.elements[r1][r2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](mult);
    } else {
      if (mult instanceof _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"]) {
        _this2.elements[r1][r2] = mult;
      }
    }

    return _this2;
  }

  return MatrixElimination;
}(Matrix); // permutation - multiply on the right (A*P); Row-switching transformations

var MatrixPermutation = /*#__PURE__*/function (_Matrix3) {
  _inherits(MatrixPermutation, _Matrix3);

  var _super3 = _createSuper(MatrixPermutation);

  function MatrixPermutation(m, row1, row2) {
    var _this3;

    _classCallCheck(this, MatrixPermutation);

    if (m < row1 || m < row2) {
      throw new Error("Column index must be less than or equal to the matrix size.");
    }

    _this3 = _super3.call(this, m, m);
    _this3.elements = [];

    for (var i = 0; i < _this3.m; i++) {
      _this3.elements[i] = [];

      for (var j = 0; j < _this3.m; j++) {
        if (i === j) {
          _this3.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
        } else {
          _this3.elements[i][j] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
        }
      }
    }

    _this3.elements[row1][row1] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
    _this3.elements[row1][row2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
    _this3.elements[row2][row2] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](0);
    _this3.elements[row2][row1] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_0__["RationalNumber"](1);
    return _this3;
  }

  return MatrixPermutation;
}(Matrix);

/***/ }),

/***/ "./src/structures/Queue.ts":
/*!*********************************!*\
  !*** ./src/structures/Queue.ts ***!
  \*********************************/
/*! exports provided: Queue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Queue", function() { return Queue; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Queue = /*#__PURE__*/function () {
  function Queue() {
    _classCallCheck(this, Queue);

    _defineProperty(this, "queue", void 0);

    this.queue = [];
  }

  _createClass(Queue, [{
    key: "isEmpty",
    value: function isEmpty() {
      return this.queue.length === 0;
    }
  }, {
    key: "enqueue",
    value: function enqueue(element) {
      this.queue.push(element);
    }
  }, {
    key: "dequeue",
    value: function dequeue() {
      if (this.isEmpty()) {
        throw new Error("Queue is empty");
      }

      return this.queue.shift();
    }
  }, {
    key: "peek",
    value: function peek() {
      if (this.isEmpty()) {
        throw new Error("Queue is empty");
      }

      return this.queue[0];
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return this.queue;
    }
  }]);

  return Queue;
}();

/***/ }),

/***/ "./src/structures/RationalNumber.ts":
/*!******************************************!*\
  !*** ./src/structures/RationalNumber.ts ***!
  \******************************************/
/*! exports provided: RationalNumber */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RationalNumber", function() { return RationalNumber; });
/* harmony import */ var _ArithmeticEvaluator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArithmeticEvaluator */ "./src/structures/ArithmeticEvaluator.ts");
/* harmony import */ var _Queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Queue */ "./src/structures/Queue.ts");
/* harmony import */ var _Stack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Stack */ "./src/structures/Stack.ts");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var RationalNumber = /*#__PURE__*/function () {
  _createClass(RationalNumber, null, [{
    key: "toReversePolishNotation",
    value: function toReversePolishNotation(code) {
      var tokens = code.match(/\(|\)|\d+(\.\d+)?|\w+|[\+\-\*\/\^]/g);
      var i = 0;
      var outputQueue = new _Queue__WEBPACK_IMPORTED_MODULE_1__["Queue"]();
      var operatorStack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();

      while (i < tokens.length) {
        if (this.isNumber(tokens[i])) {
          outputQueue.enqueue(tokens[i]);
        } else if (this.isOperator(tokens[i])) {
          var op1 = tokens[i];

          while (!operatorStack.isEmpty() && this.isOperator(operatorStack.peek())) {
            if (this.isLeftAssociativeOperator(op1) && this.precedence(op1) <= this.precedence(operatorStack.peek()) || this.isRightAssociativeOperator(op1) && this.precedence(op1) < this.precedence(operatorStack.peek())) {
              outputQueue.enqueue(operatorStack.pop());
            } else {
              break;
            }
          }

          operatorStack.push(op1);
        } else if (tokens[i] === "(") {
          operatorStack.push(tokens[i]);
        } else if (tokens[i] === ")") {
          while (!operatorStack.isEmpty() && operatorStack.peek() !== "(") {
            outputQueue.enqueue(operatorStack.pop());
          }

          if (!operatorStack.isEmpty() && operatorStack.peek() === "(") {
            operatorStack.pop();
          } else {
            throw new Error("Mismatched parentheses.");
          }
        }

        i++;
      }

      while (!operatorStack.isEmpty()) {
        if (operatorStack.peek() === "(") {
          throw new Error("Mismatched parentheses.");
        } else {
          outputQueue.enqueue(operatorStack.pop());
        }
      }

      return outputQueue.toArray();
    }
  }, {
    key: "fromString",
    value: function fromString(code) {
      var p = new _ArithmeticEvaluator__WEBPACK_IMPORTED_MODULE_0__["Parser"]();
      return p.parse(code);
    }
  }, {
    key: "greatestCommonDivisor",
    value: function greatestCommonDivisor(a, b) {
      return b ? RationalNumber.greatestCommonDivisor(b, a % b) : a;
    }
  }, {
    key: "leastCommonMultiple",
    value: function leastCommonMultiple(a, b) {
      return Math.abs(a * b / RationalNumber.greatestCommonDivisor(a, b));
    }
  }, {
    key: "isNumber",
    value: function isNumber(code) {
      return /^\d/.test(code);
    }
  }, {
    key: "isOperator",
    value: function isOperator(code) {
      return /[\+\-\*\/\^]/.test(code);
    }
  }, {
    key: "isLeftAssociativeOperator",
    value: function isLeftAssociativeOperator(operator) {
      return /[\+\-\*\/]/.test(operator);
    }
  }, {
    key: "isRightAssociativeOperator",
    value: function isRightAssociativeOperator(operator) {
      return /[\^]/.test(operator);
    }
  }, {
    key: "precedence",
    value: function precedence(operator) {
      if (/[\+\-]/.test(operator)) {
        return 1;
      }

      if (/[\*\/]/.test(operator)) {
        return 2;
      }

      if (/[\^]/.test(operator)) {
        return 3;
      }

      throw new Error("Unknown operator.");
    }
  }, {
    key: "evaluateFromRPN",
    value: function evaluateFromRPN(tokens) {
      var stack = new _Stack__WEBPACK_IMPORTED_MODULE_2__["Stack"]();

      for (var i = 0; i < tokens.length; i++) {
        if (!this.isOperator(tokens[i])) {
          stack.push(new RationalNumber(parseFloat(tokens[i])));
        } else {
          var op1 = stack.pop();
          var op2 = stack.pop();

          switch (tokens[i]) {
            case "+":
              stack.push(op2.add(op1));
              break;

            case "-":
              stack.push(op2.sub(op1));
              break;

            case "*":
              stack.push(op2.mult(op1));
              break;

            case "/":
              stack.push(op2.div(op1));
              break;

            case "^":
              stack.push(op2.exp(op1.toNumber()));
              break;
          }
        }
      }

      return stack.pop().simplifiedForm();
    }
  }]);

  function RationalNumber(n) {
    var d = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    _classCallCheck(this, RationalNumber);

    _defineProperty(this, "numerator", void 0);

    _defineProperty(this, "denominator", void 0);

    if (d === 0) {
      throw new Error("Division by zero!");
    } // todo: potential for overflow. When Math.sign becomes available in TypeScript use it instead of the multiplication


    var sign = n * d >= 0 ? 1 : -1;
    this.numerator = sign * Math.abs(n);
    this.denominator = Math.abs(d);
  }

  _createClass(RationalNumber, [{
    key: "simplifiedForm",
    value: function simplifiedForm() {
      var gcd = RationalNumber.greatestCommonDivisor(this.numerator, this.denominator);
      return new RationalNumber(this.numerator / gcd, this.denominator / gcd);
    }
  }, {
    key: "equals",
    value: function equals(x) {
      var rn1 = this.simplifiedForm();

      if (typeof x === "number") {
        return rn1.numerator === x && rn1.denominator === 1;
      } else {
        var rn2 = x.simplifiedForm();
        return rn1.numerator === rn2.numerator && rn1.denominator === rn2.denominator;
      }
    }
  }, {
    key: "lt",
    value: function lt(x) {
      var rn1 = this.simplifiedForm();

      if (typeof x === "number") {
        return rn1.numerator < x * rn1.denominator;
      } else {
        var rn2 = x.simplifiedForm();
        return rn1.numerator * rn2.denominator < rn2.numerator * rn1.denominator;
      }
    }
  }, {
    key: "le",
    value: function le(x) {
      var rn1 = this.simplifiedForm();

      if (typeof x === "number") {
        return rn1.numerator <= x * rn1.denominator;
      } else {
        var rn2 = x.simplifiedForm();
        return rn1.numerator * rn2.denominator <= rn2.numerator * rn1.denominator;
      }
    }
  }, {
    key: "gt",
    value: function gt(x) {
      var rn1 = this.simplifiedForm();

      if (typeof x === "number") {
        return rn1.numerator > x * rn1.denominator;
      } else {
        var rn2 = x.simplifiedForm();
        return rn1.numerator * rn2.denominator > rn2.numerator * rn1.denominator;
      }
    }
  }, {
    key: "ge",
    value: function ge(x) {
      var rn1 = this.simplifiedForm();

      if (typeof x === "number") {
        return rn1.numerator >= x * rn1.denominator;
      } else {
        var rn2 = x.simplifiedForm();
        return rn1.numerator * rn2.denominator >= rn2.numerator * rn1.denominator;
      }
    } // multiplicative inverse

  }, {
    key: "reciprocal",
    value: function reciprocal() {
      if (this.denominator === 0) {
        throw new Error("Division by zero!");
      }

      return new RationalNumber(this.denominator, this.numerator);
    } // additive inverse

  }, {
    key: "opposite",
    value: function opposite() {
      return new RationalNumber(this.numerator * -1, this.denominator);
    }
  }, {
    key: "add",
    value: function add(x) {
      if (typeof x === "number") {
        return new RationalNumber(this.numerator + x * this.denominator, this.denominator);
      } else {
        var lcm = RationalNumber.leastCommonMultiple(this.denominator, x.denominator);
        var n1 = this.numerator * lcm / this.denominator;
        var n2 = x.numerator * lcm / x.denominator;
        return new RationalNumber(n1 + n2, lcm);
      }
    }
  }, {
    key: "sub",
    value: function sub(x) {
      if (typeof x === "number") {
        return new RationalNumber(this.numerator - x * this.denominator, this.denominator);
      } else {
        var lcm = RationalNumber.leastCommonMultiple(this.denominator, x.denominator);
        var n1 = this.numerator * lcm / this.denominator;
        var n2 = x.numerator * lcm / x.denominator;
        return new RationalNumber(n1 - n2, lcm);
      }
    }
  }, {
    key: "mult",
    value: function mult(x) {
      if (typeof x === "number") {
        return new RationalNumber(this.numerator * x, this.denominator);
      } else {
        return new RationalNumber(this.numerator * x.numerator, x.denominator * this.denominator);
      }
    }
  }, {
    key: "div",
    value: function div(x) {
      if (typeof x === "number") {
        return new RationalNumber(this.numerator, this.denominator * x);
      } else {
        return new RationalNumber(this.numerator * x.denominator, x.numerator * this.denominator);
      }
    }
  }, {
    key: "exp",
    value: function exp(x) {
      if (typeof x === "number") {
        return new RationalNumber(Math.pow(this.numerator, x), Math.pow(this.denominator, x));
      } else {
        if (this.denominator !== 1) {
          throw Error("Exponentiation with rational powers not supported.");
        }

        return new RationalNumber(Math.pow(this.numerator, x.numerator), Math.pow(this.denominator, x.numerator));
      }
    }
  }, {
    key: "toNumber",
    value: function toNumber() {
      return this.numerator / this.denominator;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.numerator.toString() + (1 === this.denominator ? "" : "/" + this.denominator.toString());
    }
  }, {
    key: "deepCopy",
    value: function deepCopy() {
      return new RationalNumber(this.numerator, this.denominator);
    }
  }]);

  return RationalNumber;
}();

/***/ }),

/***/ "./src/structures/Stack.ts":
/*!*********************************!*\
  !*** ./src/structures/Stack.ts ***!
  \*********************************/
/*! exports provided: Stack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stack", function() { return Stack; });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Stack = /*#__PURE__*/function () {
  function Stack() {
    _classCallCheck(this, Stack);

    _defineProperty(this, "stack", void 0);

    this.stack = [];
  }

  _createClass(Stack, [{
    key: "isEmpty",
    value: function isEmpty() {
      return this.stack.length === 0;
    }
  }, {
    key: "push",
    value: function push(element) {
      this.stack.push(element);
    }
  }, {
    key: "pop",
    value: function pop() {
      if (this.isEmpty()) {
        throw new Error("Stack is empty");
      }

      return this.stack.pop();
    }
  }, {
    key: "peek",
    value: function peek() {
      if (this.isEmpty()) {
        throw new Error("Stack is empty");
      }

      return this.stack[this.stack.length - 1];
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return this.stack;
    }
  }]);

  return Stack;
}();

/***/ }),

/***/ "./src/structures/Vector.ts":
/*!**********************************!*\
  !*** ./src/structures/Vector.ts ***!
  \**********************************/
/*! exports provided: Vector, ColumnVector, RowVector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector", function() { return Vector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColumnVector", function() { return ColumnVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RowVector", function() { return RowVector; });
/* harmony import */ var _Matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix */ "./src/structures/Matrix.ts");
/* harmony import */ var _RationalNumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RationalNumber */ "./src/structures/RationalNumber.ts");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var Vector = /*#__PURE__*/function () {
  _createClass(Vector, null, [{
    key: "areLinearlyIndependent",
    value: function areLinearlyIndependent(vectors) {
      var m = vectors.length;

      if (0 === m) {
        return true;
      }

      var n = vectors[0].m;

      for (var i = 1; i < vectors.length; i++) {
        if (n !== vectors[i].m) {
          throw new Error("Mismatched dimensions.");
        }
      }

      if (m > n) {
        return false;
      }

      throw new Error("Not implemented.");
    }
  }]);

  function Vector(n) {
    _classCallCheck(this, Vector);

    _defineProperty(this, "m", void 0);

    _defineProperty(this, "elements", void 0);

    if (typeof n === "number") {
      this.m = n;
      this.elements = [];
    } else if (n instanceof Array) {
      this.m = n.length;
      this.elements = [];

      for (var i = 0; i < this.m; i++) {
        this.elements[i] = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](n[i]);
      }
    }
  }

  _createClass(Vector, [{
    key: "add",
    value: function add(x) {
      if (this.m !== x.m) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new Vector(this.m);

      for (var i = 0; i < res.m; i++) {
        res.elements[i] = this.elements[i].add(x.elements[i]);
      }

      return res;
    }
  }, {
    key: "sub",
    value: function sub(x) {
      if (this.m !== x.m) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new Vector(this.m);

      for (var i = 0; i < res.m; i++) {
        res.elements[i] = this.elements[i].sub(x.elements[i]);
      }

      return res;
    }
  }, {
    key: "mult",
    value: function mult(x) {
      var res = new Vector(this.m);

      for (var i = 0; i < res.m; i++) {
        res.elements[i] = this.elements[i].mult(x);
      }

      return res;
    } // [ALIASES]: innerProduct, projectionProduct, scalarProduct

  }, {
    key: "dotProduct",
    value: function dotProduct(x) {
      if (this.m !== x.m) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);

      for (var i = 0; i < x.m; i++) {
        res = res.add(this.elements[i].mult(x.elements[i]));
      }

      return res;
    } // [ALIASES]: directedAreaProduct, vectorProduct

  }, {
    key: "crossProduct",
    value: function crossProduct(x) {
      throw new Error("Not implemented.");
    } // [ALIASES]: magnitude, norm

  }, {
    key: "length",
    value: function length() {
      var length = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);

      for (var i = 0; i < this.m; i++) {
        length.add(this.elements[i]);
      }

      return length;
    }
  }, {
    key: "deepCopy",
    value: function deepCopy() {
      var ret = new Vector(this.m);

      for (var i = 0; i < this.m; i++) {
        ret.elements[i] = this.elements[i];
      }

      return ret;
    }
  }, {
    key: "toMatrix",
    value: function toMatrix() {
      var ret = new _Matrix__WEBPACK_IMPORTED_MODULE_0__["Matrix"](this.m, 1);

      for (var i = 0; i < this.m; i++) {
        ret.elements[i][0] = this.elements[i];
      }

      return ret;
    }
  }]);

  return Vector;
}();
var ColumnVector = /*#__PURE__*/function (_Vector) {
  _inherits(ColumnVector, _Vector);

  var _super = _createSuper(ColumnVector);

  function ColumnVector() {
    _classCallCheck(this, ColumnVector);

    return _super.apply(this, arguments);
  }

  return ColumnVector;
}(Vector);
var RowVector = /*#__PURE__*/function (_Vector2) {
  _inherits(RowVector, _Vector2);

  var _super2 = _createSuper(RowVector);

  function RowVector() {
    _classCallCheck(this, RowVector);

    return _super2.apply(this, arguments);
  }

  _createClass(RowVector, [{
    key: "matrixProduct",
    value: function matrixProduct(m) {
      if (this.m !== m.n) {
        throw new Error("Mismatched dimensions.");
      }

      var res = new RowVector(this.m);

      for (var i = 0; i < this.m; i++) {
        var sum = new _RationalNumber__WEBPACK_IMPORTED_MODULE_1__["RationalNumber"](0);

        for (var j = 0; j < m.n; j++) {
          sum = sum.add(m.elements[i][j].mult(this.elements[i]));
        }

        res.elements[i] = sum;
      }

      return res;
    }
  }]);

  return RowVector;
}(Vector);

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXhlcmNpc2VzL2ltYWdlUHJvY2Vzc2luZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9Bcml0aG1ldGljRXZhbHVhdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9zdHJ1Y3R1cmVzL01hdHJpeC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9RdWV1ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9SYXRpb25hbE51bWJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9TdGFjay50cyIsIndlYnBhY2s6Ly8vLi9zcmMvc3RydWN0dXJlcy9WZWN0b3IudHMiXSwibmFtZXMiOlsiaW1hZ2VEYXRhVG9SR0JBIiwiaW1hZ2VEYXRhIiwiaW1nUiIsIk1hdHJpeCIsIndpZHRoIiwiaGVpZ2h0IiwiaW1nRyIsImltZ0IiLCJpbWdBIiwiaWR4IiwieCIsInkiLCJlbGVtZW50cyIsIlJhdGlvbmFsTnVtYmVyIiwiZGF0YSIsImltYWdlRGF0YUZyb21SR0JBIiwicmdiYSIsIm0iLCJuIiwiSW1hZ2VEYXRhIiwidG9OdW1iZXIiLCIkIiwiZG9jdW1lbnQiLCJyZWFkeSIsImNhbnZhczEiLCJjdHgxIiwiZ2V0Q29udGV4dCIsImltYWdlIiwiSW1hZ2UiLCJvbmxvYWQiLCJkcmF3SW1hZ2UiLCJpbWdEYXRhMSIsImdldEltYWdlRGF0YSIsImltZ0RhdGEyIiwiY2FudmFzMiIsImN0eDIiLCJwdXRJbWFnZURhdGEiLCJjYW52YXMzIiwiY3R4MyIsImtlcm5lbCIsImkiLCJqIiwibmV3UmdiYSIsImNvbnZvbHV0ZSIsImltZ0RhdGEzIiwic3JjIiwiZW5jb2RlZEltZyIsImltZ1NyYyIsImF0dHIiLCJyZXBsYWNlIiwiYmluU3JjIiwiYXRvYiIsImltZyIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwiYyIsImNoYXJDb2RlQXQiLCJiaW5EZXN0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiaW1nRGVzdCIsImJ0b2EiLCJBcml0aG1ldGljRXZhbHVhdG9yIiwiY29kZSIsInRva2VucyIsIm1hdGNoIiwib3V0cHV0UXVldWUiLCJRdWV1ZSIsIm9wZXJhdG9yU3RhY2siLCJTdGFjayIsImxlbmd0aCIsImlzTnVtYmVyIiwiZW5xdWV1ZSIsImlzT3BlcmF0b3IiLCJvcDEiLCJpc0VtcHR5IiwicGVlayIsImlzTGVmdEFzc29jaWF0aXZlT3BlcmF0b3IiLCJwcmVjZWRlbmNlIiwiaXNSaWdodEFzc29jaWF0aXZlT3BlcmF0b3IiLCJwb3AiLCJwdXNoIiwiRXJyb3IiLCJ0b0FycmF5Iiwic3RhY2siLCJwYXJzZUZsb2F0Iiwib3AyIiwidGVzdCIsIm9wZXJhdG9yIiwiVG9rZW5UeXBlIiwiVG9rZW4iLCJ0eXBlIiwidmFsdWUiLCJMZXhlciIsImlucHV0IiwidG9rZW5JbmRleCIsIkVuZCIsImdldFRva2VuIiwiUGx1cyIsIk1pbnVzIiwiTXVsdGlwbHkiLCJEaXZpZGUiLCJFeHBvbmVudCIsIk51bWJlciIsIkxQYXJlbiIsIlJQYXJlbiIsIlVua25vd24iLCJQYXJzZXIiLCJsZXgiLCJleHByZXNzaW9uIiwiZm91cnRoT3JkZXJPcGVyYXRvcnMiLCJ0b2tlbiIsImdldEN1cnJlbnRUb2tlbiIsImNvbXBvbmVudDEiLCJ0aGlyZE9yZGVyT3BlcmF0b3JzIiwiZ2V0TmV4dFRva2VuIiwiY29tcG9uZW50MiIsImFkZCIsInN1YiIsInJldmVydCIsImZhY3RvcjEiLCJzZWNvbmRPcmRlck9wZXJhdG9ycyIsImZhY3RvcjIiLCJtdWx0IiwiZGl2IiwiZmlyc3RPcmRlck9wZXJhdG9ycyIsImV4cCIsIkEiLCJCIiwicmV0IiwiVmVjdG9yIiwicm93MSIsInJvdzIiLCJtYXRyaXgiLCJNYXRyaXhJZGVudGl0eSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsIm51bWJlck9mVW5rbm93bnMiLCJ1bmtub3ducyIsIk0iLCJlcXVhbHMiLCJyZXMiLCJzdW0iLCJrIiwidiIsIkNvbHVtblZlY3RvciIsImlkeDEiLCJpZHgyIiwidG1wIiwic2NhbGFyIiwic2ltcGxpZmllZEZvcm0iLCJzY2FsYXIxIiwic2NhbGFyMiIsIk1UIiwidHJhbnNwb3NlIiwiaXNJZGVudGl0eSIsImZvdW5kWmVyb1JvdyIsImlzWmVyb1JvdyIsInByZXZpb3VzSWR4IiwiY3VycmVudFBpdm90SWR4Iiwicm93UGl2b3RQb3NpdGlvbiIsImlzUm93RWNoZWxvbkZvcm0iLCJwaXZvdFBvc2l0aW9uIiwibnVtYmVyT2ZOb25aZXJvRWxlbWVudEZvckNvbHVtbiIsImRlZXBDb3B5IiwibGVhZCIsInIiLCJzd2l0Y2hSb3dzIiwibXVsdGlwbHlSb3ciLCJyZWNpcHJvY2FsIiwiYWRkUm93cyIsIm9wcG9zaXRlIiwibWlub3IiLCJjb2ZhY3RvciIsImRldGVybWluYW50Iiwic3oiLCJ0aSIsInRqIiwicm93SWQiLCJjb2x1bW5JZCIsImFjYyIsInJvd09mZnNldCIsImNvbHVtbk9mZnNldCIsIk1hdHJpeEVsaW1pbmF0aW9uIiwicjEiLCJyMiIsIk1hdHJpeFBlcm11dGF0aW9uIiwicXVldWUiLCJlbGVtZW50Iiwic2hpZnQiLCJwIiwicGFyc2UiLCJhIiwiYiIsImdyZWF0ZXN0Q29tbW9uRGl2aXNvciIsImFicyIsImQiLCJzaWduIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJnY2QiLCJybjEiLCJybjIiLCJsY20iLCJsZWFzdENvbW1vbk11bHRpcGxlIiwibjEiLCJuMiIsInRvU3RyaW5nIiwidmVjdG9ycyIsIkFycmF5IiwiUm93VmVjdG9yIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNLEtBQTBCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsWUFBWTs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsSUFBSTs7QUFFcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVEsNkJBQTZCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZixTQUFTOztBQUVUO0FBQ0EsUUFBUSxpQ0FBaUM7QUFDekMsUUFBUSxvQkFBb0I7QUFDNUIsUUFBUSxzQ0FBc0M7QUFDOUMsUUFBUTtBQUNSLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLDRDQUE0QztBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFFBQVEsR0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLDBCQUEwQix3QkFBd0I7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0Msc0NBQXNDO0FBQzlFLG9DQUFvQyx1Q0FBdUM7QUFDM0Usb0NBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7OztBQUdBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsY0FBYyxxQ0FBcUM7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QixXQUFXLGtCQUFrQjtBQUM3QixjQUFjO0FBQ2QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLG1CQUFtQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSxhQUFhOztBQUViOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7O0FBRUEsV0FBVztBQUNYLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsc0RBQXNEO0FBQ3BFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQsZUFBZSw2REFBNkQ7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRixDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7QUFLRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNMLFFBQUYsQ0FBVzRCLENBQVgsRUFBY0MsQ0FBZCxFQUFpQmtGLElBQWpCLENBQXNCLEtBQUsvRyxRQUFMLENBQWM0QixDQUFkLENBQXRCLENBQVIsQ0FBTjtBQUNBOztBQUNEc0csV0FBRyxDQUFDbEksUUFBSixDQUFhNEIsQ0FBYixJQUFrQnVHLEdBQWxCO0FBQ0E7O0FBQ0QsYUFBT0QsR0FBUDtBQUNBO0FBWkY7O0FBQUE7QUFBQSxFQUErQlosTUFBL0IsRSIsImZpbGUiOiIuL2ltYWdlUHJvY2Vzc2luZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2V4ZXJjaXNlcy9pbWFnZVByb2Nlc3NpbmcudHNcIik7XG4iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNS4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMC0wNS0wNFQyMjo0OVpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgZmxhdCA9IGFyci5mbGF0ID8gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmZsYXQuY2FsbCggYXJyYXkgKTtcbn0gOiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuY29uY2F0LmFwcGx5KCBbXSwgYXJyYXkgKTtcbn07XG5cblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG4gICAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xuICB9O1xuXG5cbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy41LjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGV2ZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAoIGkgKyAxICkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdG9kZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBPYmplY3QucHJvdG90eXBlIHBvbGx1dGlvblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggbmFtZSA9PT0gXCJfX3Byb3RvX19cIiB8fCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cdFx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cblx0XHRcdFx0XHQvLyBFbnN1cmUgcHJvcGVyIHR5cGUgZm9yIHRoZSBzb3VyY2UgdmFsdWVcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0gW107XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggIWNvcHlJc0FycmF5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHt9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBwcm92aWRlZCBjb250ZXh0OyBmYWxscyBiYWNrIHRvIHRoZSBnbG9iYWwgb25lXG5cdC8vIGlmIG5vdCBzcGVjaWZpZWQuXG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zLCBkb2MgKSB7XG5cdFx0RE9NRXZhbCggY29kZSwgeyBub25jZTogb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlIH0sIGRvYyApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBmbGF0KCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjVcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMjAtMDMtMTRcbiAqL1xuKCBmdW5jdGlvbiggd2luZG93ICkge1xudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKCB7fSApLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaE5hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFsgaSBdID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58XCIgK1xuXHRcdFwiaXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lkZW50LXRva2VuLWRpYWdyYW1cblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiP3xcXFxcXFxcXFteXFxcXHJcXFxcblxcXFxmXXxbXFxcXHctXXxbXlxcMC1cXFxceDdmXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV1cblx0XHQvLyBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcIiApLFxuXHRyZGVzY2VuZCA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcInw+XCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaHRtbCA9IC9IVE1MJC9pLFxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3xcXFxcXFxcXChbXlxcXFxyXFxcXG5cXFxcZl0pXCIsIFwiZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBlc2NhcGUsIG5vbkhleCApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZS5zbGljZSggMSApIC0gMHgxMDAwMDtcblxuXHRcdHJldHVybiBub25IZXggP1xuXG5cdFx0XHQvLyBTdHJpcCB0aGUgYmFja3NsYXNoIHByZWZpeCBmcm9tIGEgbm9uLWhleCBlc2NhcGUgc2VxdWVuY2Vcblx0XHRcdG5vbkhleCA6XG5cblx0XHRcdC8vIFJlcGxhY2UgYSBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2Ugd2l0aCB0aGUgZW5jb2RlZCBVbmljb2RlIGNvZGUgcG9pbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTErXG5cdFx0XHQvLyBGb3IgdmFsdWVzIG91dHNpZGUgdGhlIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZSAoQk1QKSwgbWFudWFsbHkgY29uc3RydWN0IGFcblx0XHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICtcblx0XHRcdFx0Y2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZmllbGRzZXRcIjtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdCggYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSApLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoTmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoIGVscyApICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAoIHRhcmdldFsgaisrIF0gPSBlbHNbIGkrKyBdICkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKCBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKCBtID0gbWF0Y2hbIDEgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmICggZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDIgXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKCBtID0gbWF0Y2hbIDMgXSApICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCggIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkgKSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDggb25seVxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHQoIG5vZGVUeXBlICE9PSAxIHx8IGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApICkge1xuXG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXG5cdFx0XHRcdC8vIHFTQSBjb25zaWRlcnMgZWxlbWVudHMgb3V0c2lkZSBhIHNjb3Bpbmcgcm9vdCB3aGVuIGV2YWx1YXRpbmcgY2hpbGQgb3Jcblx0XHRcdFx0Ly8gZGVzY2VuZGFudCBjb21iaW5hdG9ycywgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC5cblx0XHRcdFx0Ly8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcblx0XHRcdFx0Ly8gbGlzdCB3aXRoIGFuIElEIHNlbGVjdG9yIHJlZmVyZW5jaW5nIHRoZSBzY29wZSBjb250ZXh0LlxuXHRcdFx0XHQvLyBUaGUgdGVjaG5pcXVlIGhhcyB0byBiZSB1c2VkIGFzIHdlbGwgd2hlbiBhIGxlYWRpbmcgY29tYmluYXRvciBpcyB1c2VkXG5cdFx0XHRcdC8vIGFzIHN1Y2ggc2VsZWN0b3JzIGFyZSBub3QgcmVjb2duaXplZCBieSBxdWVyeVNlbGVjdG9yQWxsLlxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB0ZWNobmlxdWUuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgfHwgcmNvbWJpbmF0b3JzLnRlc3QoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblxuXHRcdFx0XHRcdC8vIFdlIGNhbiB1c2UgOnNjb3BlIGluc3RlYWQgb2YgdGhlIElEIGhhY2sgaWYgdGhlIGJyb3dzZXJcblx0XHRcdFx0XHQvLyBzdXBwb3J0cyBpdCAmIGlmIHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgY29udGV4dC5cblx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgIT09IGNvbnRleHQgfHwgIXN1cHBvcnQuc2NvcGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0XHRpZiAoICggbmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApICkgKSB7XG5cdFx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAoIG5pZCA9IGV4cGFuZG8gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzWyBpIF0gPSAoIG5pZCA/IFwiI1wiICsgbmlkIDogXCI6c2NvcGVcIiApICsgXCIgXCIgK1xuXHRcdFx0XHRcdFx0XHR0b1NlbGVjdG9yKCBncm91cHNbIGkgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblxuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKCBjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlICk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblxuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KCBcInxcIiApLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyWyBpIF0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIubmV4dFNpYmxpbmcgKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAoIG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiICkgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0aW5EaXNhYmxlZEZpZWxkc2V0KCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoIGogPSBtYXRjaEluZGV4ZXNbIGkgXSApIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFsgaiBdID0gISggbWF0Y2hlc1sgaiBdID0gc2VlZFsgaiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBuYW1lc3BhY2UgPSBlbGVtLm5hbWVzcGFjZVVSSSxcblx0XHRkb2NFbGVtID0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApLmRvY3VtZW50RWxlbWVudDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PThcblx0Ly8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlIGxvYWRpbmcgaWZyYW1lc1xuXHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNDgzM1xuXHRyZXR1cm4gIXJodG1sLnRlc3QoIG5hbWVzcGFjZSB8fCBkb2NFbGVtICYmIGRvY0VsZW0ubm9kZU5hbWUgfHwgXCJIVE1MXCIgKTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoIGRvYyA9PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPSBkb2N1bWVudCAmJlxuXHRcdCggc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcgKSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBDaHJvbWUgPD0xNiAtIDI1IG9ubHksIEZpcmVmb3ggPD0zLjYgLSAzMSBvbmx5LFxuXHQvLyBTYWZhcmkgNCAtIDUgb25seSwgT3BlcmEgPD0xMS42IC0gMTIueCBvbmx5XG5cdC8vIElFL0VkZ2UgJiBvbGRlciBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSA6c2NvcGUgcHNldWRvLWNsYXNzLlxuXHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wIG9ubHlcblx0Ly8gU2FmYXJpIDYuMCBzdXBwb3J0cyA6c2NvcGUgYnV0IGl0J3MgYW4gYWxpYXMgb2YgOnJvb3QgdGhlcmUuXG5cdHN1cHBvcnQuc2NvcGUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblx0XHRyZXR1cm4gdHlwZW9mIGVsLnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdCFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpzY29wZSBmaWVsZHNldCBkaXZcIiApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZSggXCJjbGFzc05hbWVcIiApO1xuXHR9ICk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoIFwiXCIgKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiKlwiICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlclsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcImlkXCIgKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyWyBcIklEXCIgXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbIFwiSURcIiBdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1zWyBpKysgXSApICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbIFwiVEFHXCIgXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kWyBcIkNMQVNTXCIgXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoIHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkgKSApIHtcblxuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHRcdFx0dmFyIGlucHV0O1xuXG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW3NlbGVjdGVkXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIn49XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0XHQvLyBJRSAxMS9FZGdlIGRvbid0IGZpbmQgZWxlbWVudHMgb24gYSBgW25hbWU9JyddYCBxdWVyeSBpbiBzb21lIGNhc2VzLlxuXHRcdFx0Ly8gQWRkaW5nIGEgdGVtcG9yYXJ5IGF0dHJpYnV0ZSB0byB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBzZWxlY3Rpb24gd29ya3Ncblx0XHRcdC8vIGFyb3VuZCB0aGUgaXNzdWUuXG5cdFx0XHQvLyBJbnRlcmVzdGluZ2x5LCBJRSAxMCAmIG9sZGVyIGRvbid0IHNlZW0gdG8gaGF2ZSB0aGUgaXNzdWUuXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJcIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPScnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIio9XCIgK1xuXHRcdFx0XHRcdHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpjaGVja2VkXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjpjaGVja2VkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIi4jLitbK35dXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTMuNiAtIDUgb25seVxuXHRcdFx0Ly8gT2xkIEZpcmVmb3ggZG9lc24ndCB0aHJvdyBvbiBhIGJhZGx5LWVzY2FwZWQgaWRlbnRpZmllci5cblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiXFxcXFxcZlwiICk7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbXFxcXHJcXFxcblxcXFxmXVwiICk7XG5cdFx0fSApO1xuXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbmFtZT1kXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjplbmFibGVkXCIgKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCI6ZGlzYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBPcGVyYSAxMCAtIDExIG9ubHlcblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIiosOnhcIiApO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLC4qOlwiICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAoIG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvciApICkgKSApIHtcblxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKCBcInxcIiApICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oIFwifFwiICkgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkgKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGIgPSBiLnBhcmVudE5vZGUgKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoICFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUgKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBhID09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcblx0XHRcdFx0Y29udGFpbnMoIHByZWZlcnJlZERvYywgYSApICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGIgPT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRjb250YWlucyggcHJlZmVycmVkRG9jLCBiICkgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG5cdFx0XHRyZXR1cm4gYSA9PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoICggY3VyID0gY3VyLnBhcmVudE5vZGUgKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwWyBpIF0gPT09IGJwWyBpIF0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbIGkgXSwgYnBbIGkgXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG5cdFx0XHRhcFsgaSBdID09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwWyBpIF0gPT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblxuXHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBleHByLCB0cnVlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSApICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoIHNlbCArIFwiXCIgKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoICggbm9kZSA9IGVsZW1bIGkrKyBdICkgKSB7XG5cblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFsgMyBdID0gKCBtYXRjaFsgMyBdIHx8IG1hdGNoWyA0IF0gfHxcblx0XHRcdFx0bWF0Y2hbIDUgXSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMiBdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWyAzIF0gPSBcIiBcIiArIG1hdGNoWyAzIF0gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMSBdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWyA0IF0gPSArKCBtYXRjaFsgNCBdID9cblx0XHRcdFx0XHRtYXRjaFsgNSBdICsgKCBtYXRjaFsgNiBdIHx8IDEgKSA6XG5cdFx0XHRcdFx0MiAqICggbWF0Y2hbIDMgXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWyA1IF0gPSArKCAoIG1hdGNoWyA3IF0gKyBtYXRjaFsgOCBdICkgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbIDYgXSAmJiBtYXRjaFsgMiBdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwclsgXCJDSElMRFwiIF0udGVzdCggbWF0Y2hbIDAgXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IG1hdGNoWyA0IF0gfHwgbWF0Y2hbIDUgXSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KCBleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSApICYmXG5cblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdCggZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoICkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XHRcdFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApICkgJiYgY2xhc3NDYWNoZShcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoXG5cdFx0XHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8XG5cdFx0XHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHxcblx0XHRcdFx0XHRcdFx0XHRcIlwiXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBfYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gbm9kZVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFsgaSBdICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblxuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGkgXSA9ICEoIG1hdGNoZXNbIGkgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblxuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QoIGxhbmcgfHwgXCJcIiApICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJ4bWw6bGFuZ1wiICkgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoIFwibGFuZ1wiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoICggZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSApICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuXHRcdFx0XHQoICFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpICkgJiZcblx0XHRcdFx0ISEoIGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXggKTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCApIHx8XG5cdFx0XHRcdCggbm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkICk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbIFwiZW1wdHlcIiBdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKCBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgKSA9PSBudWxsIHx8XG5cdFx0XHRcdFx0YXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9ICksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9ICksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0gKSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID9cblx0XHRcdFx0YXJndW1lbnQgKyBsZW5ndGggOlxuXHRcdFx0XHRhcmd1bWVudCA+IGxlbmd0aCA/XG5cdFx0XHRcdFx0bGVuZ3RoIDpcblx0XHRcdFx0XHRhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbIFwibnRoXCIgXSA9IEV4cHIucHNldWRvc1sgXCJlcVwiIF07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8ICggbWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFsgMCBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICggdG9rZW5zID0gW10gKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAoIG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkgKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWyAwIF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0gKTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoICggbWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApICkgJiYgKCAhcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdCggbWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkgKSApICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbIGkgXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoIGVsZW1bIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoICggb2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0gKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAoIG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKCBuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1sgaSBdKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWyAwIF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbIGkgXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoXG5cdFx0XHRcdHNlbGVjdG9yIHx8IFwiKlwiLFxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LFxuXHRcdFx0XHRbXVxuXHRcdFx0KSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoIGVsZW0gPSB0ZW1wWyBpIF0gKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwWyBpIF0gXSA9ICEoIG1hdGNoZXJJblsgcG9zdE1hcFsgaSBdIF0gPSBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goICggbWF0Y2hlckluWyBpIF0gPSBlbGVtICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKCBtYXRjaGVyT3V0ID0gW10gKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgJiZcblx0XHRcdFx0XHRcdCggdGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbIGkgXSApID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbIHRlbXAgXSA9ICEoIHJlc3VsdHNbIHRlbXAgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDAgXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlWyBcIiBcIiBdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoIGNoZWNrQ29udGV4dCA9IGNvbnRleHQgKS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICggbWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaSBdLnR5cGUgXSApICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyICkgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbIGkgXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1sgaSBdLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaiBdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHR0b2tlbnNcblx0XHRcdFx0XHRcdC5zbGljZSggMCwgaSAtIDEgKVxuXHRcdFx0XHRcdFx0LmNvbmNhdCggeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0gKVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKCB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFsgXCJUQUdcIiBdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9ICggZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEgKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblxuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0gKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoICggbWF0Y2hlciA9IHNldE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISggdW5tYXRjaGVkWyBpIF0gfHwgc2V0TWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFsgaSBdID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbIGkgXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZShcblx0XHRcdHNlbGVjdG9yLFxuXHRcdFx0bWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzIClcblx0XHQpO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoIHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IgKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAoIHRva2VuID0gdG9rZW5zWyAwIF0gKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAxIF0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbIFwiSURcIiBdKCB0b2tlbi5tYXRjaGVzWyAwIF1cblx0XHRcdFx0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksIGNvbnRleHQgKSB8fCBbXSApWyAwIF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByWyBcIm5lZWRzQ29udGV4dFwiIF0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbIGkgXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAoIHR5cGUgPSB0b2tlbi50eXBlICkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICggZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdICkgKSB7XG5cblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKCBzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWyAwIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbIDAgXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0XG5cdFx0XHRcdCkgKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdCggXCJcIiApLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oIFwiXCIgKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKSApICYgMTtcbn0gKTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJocmVmXCIgKSA9PT0gXCIjXCI7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSApICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIF9uYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09IG51bGw7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdCggdmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkgKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9ICk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0gKSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59O1xudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0aWYgKCBlbGVtLmNvbnRlbnREb2N1bWVudCAhPSBudWxsICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExK1xuXHRcdFx0Ly8gPG9iamVjdD4gZWxlbWVudHMgd2l0aCBubyBgZGF0YWAgYXR0cmlidXRlIGhhcyBhbiBvYmplY3Rcblx0XHRcdC8vIGBjb250ZW50RG9jdW1lbnRgIHdpdGggYSBgbnVsbGAgcHJvdG90eXBlLlxuXHRcdFx0Z2V0UHJvdG8oIGVsZW0uY29udGVudERvY3VtZW50ICkgKSB7XG5cblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggX2ksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBfa2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIF9hbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gZWxlbS5ub2RlVHlwZSAmJlxuXHRcdFx0KCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gSUUgPD05IHJlcGxhY2VzIDxvcHRpb24+IHRhZ3Mgd2l0aCB0aGVpciBjb250ZW50cyB3aGVuIGluc2VydGVkIG91dHNpZGUgb2Zcblx0Ly8gdGhlIHNlbGVjdCBlbGVtZW50LlxuXHRkaXYuaW5uZXJIVE1MID0gXCI8b3B0aW9uPjwvb3B0aW9uPlwiO1xuXHRzdXBwb3J0Lm9wdGlvbiA9ICEhZGl2Lmxhc3RDaGlsZDtcbn0gKSgpO1xuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbmlmICggIXN1cHBvcnQub3B0aW9uICkge1xuXHR3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb24gPSBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF07XG59XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgYXR0YWNoZWQsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGF0dGFjaGVkID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBhdHRhY2hlZCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuLy8gZm9jdXMoKSBhbmQgYmx1cigpIGFyZSBhc3luY2hyb25vdXMsIGV4Y2VwdCB3aGVuIHRoZXkgYXJlIG5vLW9wLlxuLy8gU28gZXhwZWN0IGZvY3VzIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBhY3RpdmUsXG4vLyBhbmQgYmx1ciB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdCBhbHJlYWR5IGFjdGl2ZS5cbi8vIChmb2N1cyBhbmQgYmx1ciBhcmUgYWx3YXlzIHN5bmNocm9ub3VzIGluIG90aGVyIHN1cHBvcnRlZCBicm93c2Vycyxcbi8vIHRoaXMganVzdCBkZWZpbmVzIHdoZW4gd2UgY2FuIGNvdW50IG9uIGl0KS5cbmZ1bmN0aW9uIGV4cGVjdFN5bmMoIGVsZW0sIHR5cGUgKSB7XG5cdHJldHVybiAoIGVsZW0gPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgKSA9PT0gKCB0eXBlID09PSBcImZvY3VzXCIgKTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIEFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiB0aHJvdyB1bmV4cGVjdGVkbHlcbi8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM5M1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBPbmx5IGF0dGFjaCBldmVudHMgdG8gb2JqZWN0cyB0aGF0IGFjY2VwdCBkYXRhXG5cdFx0aWYgKCAhYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUoIG51bGwgKTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblxuXHRcdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICksXG5cblx0XHRcdGhhbmRsZXJzID0gKFxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0XHQpWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG5cdFx0XHRcdC8vIHNwZWNpYWxseSB1bml2ZXJzYWwgb3IgaXRzIG5hbWVzcGFjZXMgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGV2ZW50J3MuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0XHRldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgdG8gZW5zdXJlIGNvcnJlY3Qgc3RhdGUgZm9yIGNoZWNrYWJsZSBpbnB1dHNcblx0XHRcdHNldHVwOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIGRhdGFQcml2LnNldCggZWwsIFwiY2xpY2tcIiwgLi4uIClcblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiwgcmV0dXJuVHJ1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJpbmcgYSBjbGlja1xuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBzdXBwcmVzcyBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdC8vIEFsc28gcHJldmVudCBpdCBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGEgbGV2ZXJhZ2VkIG5hdGl2ZS1ldmVudCBzdGFja1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdFx0cmV0dXJuIHJjaGVja2FibGVUeXBlLnRlc3QoIHRhcmdldC50eXBlICkgJiZcblx0XHRcdFx0XHR0YXJnZXQuY2xpY2sgJiYgbm9kZU5hbWUoIHRhcmdldCwgXCJpbnB1dFwiICkgJiZcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRhcmdldCwgXCJjbGlja1wiICkgfHxcblx0XHRcdFx0XHRub2RlTmFtZSggdGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxuLy8gc3ludGhldGljIGV2ZW50cyBieSBpbnRlcnJ1cHRpbmcgcHJvZ3Jlc3MgdW50aWwgcmVpbnZva2VkIGluIHJlc3BvbnNlIHRvXG4vLyAqbmF0aXZlKiBldmVudHMgdGhhdCBpdCBmaXJlcyBkaXJlY3RseSwgZW5zdXJpbmcgdGhhdCBzdGF0ZSBjaGFuZ2VzIGhhdmVcbi8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cbmZ1bmN0aW9uIGxldmVyYWdlTmF0aXZlKCBlbCwgdHlwZSwgZXhwZWN0U3luYyApIHtcblxuXHQvLyBNaXNzaW5nIGV4cGVjdFN5bmMgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuXHRpZiAoICFleHBlY3RTeW5jICkge1xuXHRcdGlmICggZGF0YVByaXYuZ2V0KCBlbCwgdHlwZSApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwgcmV0dXJuVHJ1ZSApO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZWdpc3RlciB0aGUgY29udHJvbGxlciBhcyBhIHNwZWNpYWwgdW5pdmVyc2FsIGhhbmRsZXIgZm9yIGFsbCBldmVudCBuYW1lc3BhY2VzXG5cdGRhdGFQcml2LnNldCggZWwsIHR5cGUsIGZhbHNlICk7XG5cdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCB7XG5cdFx0bmFtZXNwYWNlOiBmYWxzZSxcblx0XHRoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgbm90QXN5bmMsIHJlc3VsdCxcblx0XHRcdFx0c2F2ZWQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0aWYgKCAoIGV2ZW50LmlzVHJpZ2dlciAmIDEgKSAmJiB0aGlzWyB0eXBlIF0gKSB7XG5cblx0XHRcdFx0Ly8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcblx0XHRcdFx0Ly8gU2F2ZWQgZGF0YSBzaG91bGQgYmUgZmFsc2UgaW4gc3VjaCBjYXNlcywgYnV0IG1pZ2h0IGJlIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3Rcblx0XHRcdFx0Ly8gZnJvbSBhbiBhc3luYyBuYXRpdmUgaGFuZGxlciAoZ2gtNDM1MClcblx0XHRcdFx0aWYgKCAhc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgYXJndW1lbnRzIGZvciB1c2Ugd2hlbiBoYW5kbGluZyB0aGUgaW5uZXIgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdFx0Ly8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IChhbiBldmVudCBvYmplY3QpLCBzbyB0aGlzIGFycmF5XG5cdFx0XHRcdFx0Ly8gd2lsbCBub3QgYmUgY29uZnVzZWQgd2l0aCBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0LlxuXHRcdFx0XHRcdHNhdmVkID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBzYXZlZCApO1xuXG5cdFx0XHRcdFx0Ly8gVHJpZ2dlciB0aGUgbmF0aXZlIGV2ZW50IGFuZCBjYXB0dXJlIGl0cyByZXN1bHRcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHQvLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91c1xuXHRcdFx0XHRcdG5vdEFzeW5jID0gZXhwZWN0U3luYyggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdHRoaXNbIHR5cGUgXSgpO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCB8fCBub3RBc3luYyApIHtcblx0XHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgZmFsc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSBvdXRlciBzeW50aGV0aWMgZXZlbnRcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IGZvciBhbiBldmVudCB3aXRoIGEgYnViYmxpbmcgc3Vycm9nYXRlXG5cdFx0XHRcdC8vIChmb2N1cyBvciBibHVyKSwgYXNzdW1lIHRoYXQgdGhlIHN1cnJvZ2F0ZSBhbHJlYWR5IHByb3BhZ2F0ZWQgZnJvbSB0cmlnZ2VyaW5nIHRoZVxuXHRcdFx0XHQvLyBuYXRpdmUgZXZlbnQgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZyBhZ2FpbiBoZXJlLlxuXHRcdFx0XHQvLyBUaGlzIHRlY2huaWNhbGx5IGdldHMgdGhlIG9yZGVyaW5nIHdyb25nIHcuci50LiB0byBgLnRyaWdnZXIoKWAgKGluIHdoaWNoIHRoZVxuXHRcdFx0XHQvLyBidWJibGluZyBzdXJyb2dhdGUgcHJvcGFnYXRlcyAqYWZ0ZXIqIHRoZSBub24tYnViYmxpbmcgYmFzZSksIGJ1dCB0aGF0IHNlZW1zXG5cdFx0XHRcdC8vIGxlc3MgYmFkIHRoYW4gZHVwbGljYXRpb24uXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fSApLmRlbGVnYXRlVHlwZSApIHtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgbmF0aXZlIGV2ZW50IHRyaWdnZXJlZCBhYm92ZSwgZXZlcnl0aGluZyBpcyBub3cgaW4gb3JkZXJcblx0XHRcdC8vIEZpcmUgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IHdpdGggdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdC8vIC4uLmFuZCBjYXB0dXJlIHRoZSByZXN1bHRcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCB7XG5cdFx0XHRcdFx0dmFsdWU6IGpRdWVyeS5ldmVudC50cmlnZ2VyKFxuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHRcdC8vIEV4dGVuZCB3aXRoIHRoZSBwcm90b3R5cGUgdG8gcmVzZXQgdGhlIGFib3ZlIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCBzYXZlZFsgMCBdLCBqUXVlcnkuRXZlbnQucHJvdG90eXBlICksXG5cdFx0XHRcdFx0XHRzYXZlZC5zbGljZSggMSApLFxuXHRcdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHRcdClcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIEFib3J0IGhhbmRsaW5nIG9mIHRoZSBuYXRpdmUgZXZlbnRcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y29kZTogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG5qUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggdHlwZSwgZGVsZWdhdGVUeXBlICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdID0ge1xuXG5cdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiYmx1clwiLCAuLi4gKVxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUsIGV4cGVjdFN5bmMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlclxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGRlbGVnYXRlVHlwZTogZGVsZWdhdGVUeXBlXG5cdH07XG59ICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5nZXQoIHNyYyApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkZXN0LCBcImhhbmRsZSBldmVudHNcIiApO1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gZmxhdCggYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSwgZG9jICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIG5vZGUsIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgaXNBdHRhY2hlZCggbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5jYWxsKCBlbGVtICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBCZWhhdmlvciBpbiBJRSA5IGlzIG1vcmUgc3VidGxlIHRoYW4gaW4gbmV3ZXIgdmVyc2lvbnMgJiBpdCBwYXNzZXNcblx0XHQvLyBzb21lIHZlcnNpb25zIG9mIHRoaXMgdGVzdDsgbWFrZSBzdXJlIG5vdCB0byBtYWtlIGl0IHBhc3MgdGhlcmUhXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRhYmxlLCB0ciwgdHJDaGlsZCwgdHJTdHlsZTtcblx0XHRcdGlmICggcmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRhYmxlXCIgKTtcblx0XHRcdFx0dHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRyXCIgKTtcblx0XHRcdFx0dHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHRcdFx0XHR0YWJsZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4XCI7XG5cdFx0XHRcdHRyLnN0eWxlLmhlaWdodCA9IFwiMXB4XCI7XG5cdFx0XHRcdHRyQ2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCI5cHhcIjtcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnRcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRhYmxlIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyQ2hpbGQgKTtcblxuXHRcdFx0XHR0clN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIHRyICk7XG5cdFx0XHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID0gcGFyc2VJbnQoIHRyU3R5bGUuaGVpZ2h0ICkgPiAzO1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggdGFibGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhciBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGUsXG5cdHZlbmRvclByb3BzID0ge307XG5cbi8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwb3RlbnRpYWxseS1tYXBwZWQgalF1ZXJ5LmNzc1Byb3BzIG9yIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIGZpbmFsID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgdmVuZG9yUHJvcHNbIG5hbWUgXTtcblxuXHRpZiAoIGZpbmFsICkge1xuXHRcdHJldHVybiBmaW5hbDtcblx0fVxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXHRyZXR1cm4gdmVuZG9yUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fTtcblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIF9lbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gVXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3Igd2hlbiBib3ggc2l6aW5nIGlzIHVucmVsaWFibGUuXG5cdC8vIEluIHRob3NlIGNhc2VzLCB0aGUgY29tcHV0ZWQgdmFsdWUgY2FuIGJlIHRydXN0ZWQgdG8gYmUgYm9yZGVyLWJveC5cblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDEwIC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBJbnRlcmVzdGluZ2x5LCBpbiBzb21lIGNhc2VzIElFIDkgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGlzIGlzc3VlLlxuXHRcdCFzdXBwb3J0LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgbm9kZU5hbWUoIGVsZW0sIFwidHJcIiApIHx8XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0XHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdFx0dmFsID09PSBcImF1dG9cIiB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdFx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApICYmXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSAmIGNvbm5lY3RlZFxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwiZ3JpZEFyZWFcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5cIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1wiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBfaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHRcdFx0Ly8gT25seSByZWFkIHN0eWxlcy5wb3NpdGlvbiBpZiB0aGUgdGVzdCBoYXMgYSBjaGFuY2UgdG8gZmFpbFxuXHRcdFx0XHQvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxuXHRcdFx0XHRzY3JvbGxib3hTaXplQnVnZ3kgPSAhc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgJiZcblx0XHRcdFx0XHRzdHlsZXMucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblxuXHRcdFx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxuXHRcdFx0XHRib3hTaXppbmdOZWVkZWQgPSBzY3JvbGxib3hTaXplQnVnZ3kgfHwgZXh0cmEsXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSA/XG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQwO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSB8fFxuXHRcdFx0XHRcdHR3ZWVuLmVsZW0uc3R5bGVbIGZpbmFsUHJvcE5hbWUoIHR3ZWVuLnByb3AgKSBdICE9IG51bGwgKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IChcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0XHQpWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBIYW5kbGU6IHJlZ3VsYXIgbm9kZXMgKHZpYSBgdGhpcy5vd25lckRvY3VtZW50YCksIHdpbmRvd1xuXHRcdFx0XHQvLyAodmlhIGB0aGlzLmRvY3VtZW50YCkgJiBkb2N1bWVudCAodmlhIGB0aGlzYCkuXG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSB7IGd1aWQ6IERhdGUubm93KCkgfTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBfaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gPVxuXHRcdFx0XHRcdFx0XHRcdFx0KCByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gfHwgW10gKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuY29uY2F0KCBtYXRjaFsgMiBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSArIFwiIFwiIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oIFwiLCBcIiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UuZ3VpZCsrICkgK1xuXHRcdFx0XHRcdHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgYSBub29wIGNvbnZlcnRlciBmb3IgbWlzc2luZyBzY3JpcHRcblx0XHRcdGlmICggIWlzU3VjY2VzcyAmJiBqUXVlcnkuaW5BcnJheSggXCJzY3JpcHRcIiwgcy5kYXRhVHlwZXMgKSA+IC0xICkge1xuXHRcdFx0XHRzLmNvbnZlcnRlcnNbIFwidGV4dCBzY3JpcHRcIiBdID0gZnVuY3Rpb24oKSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggX2ksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHR2YXIgaTtcblx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0aWYgKCBpLnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC10eXBlXCIgKSB7XG5cdFx0XHRzLmNvbnRlbnRUeXBlID0gcy5oZWFkZXJzWyBpIF0gfHwgXCJcIjtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsLCBvcHRpb25zLCBkb2MgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucywgZG9jICk7XG5cdFx0fVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIG9yIGZvcmNlZC1ieS1hdHRycyByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gfHwgcy5zY3JpcHRBdHRycyApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApXG5cdFx0XHRcdFx0LmF0dHIoIHMuc2NyaXB0QXR0cnMgfHwge30gKVxuXHRcdFx0XHRcdC5wcm9wKCB7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9IClcblx0XHRcdFx0XHQub24oIFwibG9hZCBlcnJvclwiLCBjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UuZ3VpZCsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCB0eXBlb2YgcHJvcHMudG9wID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRwcm9wcy50b3AgKz0gXCJweFwiO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgcHJvcHMubGVmdCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0cHJvcHMubGVmdCArPSBcInB4XCI7XG5cdFx0XHR9XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBfaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggX2ksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9LFxuXG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblxuXHRcdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdFx0fTtcblx0fSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbi8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxudmFyIHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG5qUXVlcnkudHJpbSA9IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcIlwiIDpcblx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcbn07XG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsImltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9zdHJ1Y3R1cmVzL01hdHJpeFwiO1xyXG5pbXBvcnQgeyBSYXRpb25hbE51bWJlciB9IGZyb20gXCIuLi9zdHJ1Y3R1cmVzL1JhdGlvbmFsTnVtYmVyXCI7XHJcblxyXG5mdW5jdGlvbiBpbWFnZURhdGFUb1JHQkEoaW1hZ2VEYXRhOiBJbWFnZURhdGEpOiBbTWF0cml4LCBNYXRyaXgsIE1hdHJpeCwgTWF0cml4XSB7XHJcblx0Y29uc3QgaW1nUjogTWF0cml4ID0gbmV3IE1hdHJpeChpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xyXG5cdGNvbnN0IGltZ0c6IE1hdHJpeCA9IG5ldyBNYXRyaXgoaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcclxuXHRjb25zdCBpbWdCOiBNYXRyaXggPSBuZXcgTWF0cml4KGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XHJcblx0Y29uc3QgaW1nQTogTWF0cml4ID0gbmV3IE1hdHJpeChpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xyXG5cdGxldCBpZHg6IG51bWJlciA9IDA7XHJcblx0Zm9yIChsZXQgeDogbnVtYmVyID0gMDsgeCA8IGltYWdlRGF0YS53aWR0aDsgeCsrICkge1xyXG5cdFx0aW1nUlt4XSA9IFtdOyBpbWdHW3hdID0gW107IGltZ0JbeF0gPSBbXTsgaW1nQVt4XSA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgeTogbnVtYmVyID0gMDsgeSA8IGltYWdlRGF0YS5oZWlnaHQ7IHkrKykge1xyXG5cdFx0XHRpbWdSLmVsZW1lbnRzW3hdW3ldID0gbmV3IFJhdGlvbmFsTnVtYmVyKGltYWdlRGF0YS5kYXRhW2lkeCsrXSk7XHJcblx0XHRcdGltZ0cuZWxlbWVudHNbeF1beV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoaW1hZ2VEYXRhLmRhdGFbaWR4KytdKTtcclxuXHRcdFx0aW1nQi5lbGVtZW50c1t4XVt5XSA9IG5ldyBSYXRpb25hbE51bWJlcihpbWFnZURhdGEuZGF0YVtpZHgrK10pO1xyXG5cdFx0XHRpbWdBLmVsZW1lbnRzW3hdW3ldID0gbmV3IFJhdGlvbmFsTnVtYmVyKGltYWdlRGF0YS5kYXRhW2lkeCsrXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBbaW1nUiwgaW1nRywgaW1nQiwgaW1nQV07XHJcbn1cclxuZnVuY3Rpb24gaW1hZ2VEYXRhRnJvbVJHQkEocmdiYTogW01hdHJpeCwgTWF0cml4LCBNYXRyaXgsIE1hdHJpeF0pOiBJbWFnZURhdGEge1xyXG5cdGNvbnN0IGltZ1I6IE1hdHJpeCA9IHJnYmFbMF07XHJcblx0Y29uc3QgaW1nRzogTWF0cml4ID0gcmdiYVsxXTtcclxuXHRjb25zdCBpbWdCOiBNYXRyaXggPSByZ2JhWzJdO1xyXG5cdGNvbnN0IGltZ0E6IE1hdHJpeCA9IHJnYmFbM107XHJcblx0Y29uc3Qgd2lkdGg6IG51bWJlciA9IGltZ1IubTtcclxuXHRjb25zdCBoZWlnaHQ6IG51bWJlciA9IGltZ1IubjtcclxuXHRjb25zdCBpbWFnZURhdGE6IEltYWdlRGF0YSA9IG5ldyBJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XHJcblx0bGV0IGlkeDogbnVtYmVyID0gMDtcclxuXHRmb3IgKGxldCB4OiBudW1iZXIgPSAwOyB4IDwgd2lkdGg7IHgrKyApIHtcclxuXHRcdGZvciAobGV0IHk6IG51bWJlciA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG5cdFx0XHRpbWFnZURhdGEuZGF0YVtpZHgrK10gPSBpbWdSLmVsZW1lbnRzW3hdW3ldLnRvTnVtYmVyKCk7XHJcblx0XHRcdGltYWdlRGF0YS5kYXRhW2lkeCsrXSA9IGltZ0cuZWxlbWVudHNbeF1beV0udG9OdW1iZXIoKTtcclxuXHRcdFx0aW1hZ2VEYXRhLmRhdGFbaWR4KytdID0gaW1nQi5lbGVtZW50c1t4XVt5XS50b051bWJlcigpO1xyXG5cdFx0XHRpbWFnZURhdGEuZGF0YVtpZHgrK10gPSBpbWdBLmVsZW1lbnRzW3hdW3ldLnRvTnVtYmVyKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBpbWFnZURhdGE7XHJcbn1cclxuXHJcbiQoZG9jdW1lbnQpLnJlYWR5KCgpID0+IHtcclxuXHRjb25zdCBjYW52YXMxOiBIVE1MQ2FudmFzRWxlbWVudCA9ICQoXCIjY2FudmFzMVwiKVswXSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcclxuXHRjb25zdCBjdHgxOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjYW52YXMxLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHRjb25zdCBpbWFnZTogSFRNTEltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xyXG5cdGltYWdlLm9ubG9hZCA9ICgpID0+IHtcclxuXHRcdGNhbnZhczEuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG5cdFx0Y2FudmFzMS53aWR0aCA9IGltYWdlLndpZHRoO1xyXG5cdFx0Y3R4MS5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xyXG5cdFx0Y29uc3QgaW1nRGF0YTE6IEltYWdlRGF0YSA9IGN0eDEuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xyXG5cdFx0Y29uc3QgcmdiYSA9IGltYWdlRGF0YVRvUkdCQShpbWdEYXRhMSk7XHJcblx0XHQvLyBkdXBsaWNhdGVcclxuXHRcdGNvbnN0IGltZ0RhdGEyOiBJbWFnZURhdGEgPSBpbWFnZURhdGFGcm9tUkdCQShyZ2JhKTtcclxuXHRcdGNvbnN0IGNhbnZhczI6IEhUTUxDYW52YXNFbGVtZW50ID0gJChcIiNjYW52YXMyXCIpWzBdIGFzIEhUTUxDYW52YXNFbGVtZW50O1xyXG5cdFx0Y29uc3QgY3R4MjogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gY2FudmFzMi5nZXRDb250ZXh0KFwiMmRcIik7XHJcblx0XHRjYW52YXMyLmhlaWdodCA9IGltZ0RhdGEyLmhlaWdodDtcclxuXHRcdGNhbnZhczIud2lkdGggPSBpbWdEYXRhMi53aWR0aDtcclxuXHRcdGN0eDIucHV0SW1hZ2VEYXRhKGltZ0RhdGEyLCAwLCAwKTtcclxuXHRcdC8vIGNvbnZvbHV0ZVxyXG5cdFx0Y29uc3QgY2FudmFzMzogSFRNTENhbnZhc0VsZW1lbnQgPSAkKFwiI2NhbnZhczNcIilbMF0gYXMgSFRNTENhbnZhc0VsZW1lbnQ7XHJcblx0XHRjb25zdCBjdHgzOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjYW52YXMzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHRcdGNvbnN0IGtlcm5lbDogTWF0cml4ID0gbmV3IE1hdHJpeCgzLCAzKTtcclxuXHRcdC8qXHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMF1bMF0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMF1bMV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzBdWzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzFdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVsxXSA9IG5ldyBSYXRpb25hbE51bWJlcig1KTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1sxXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMl1bMF0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMl1bMV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0Ki9cclxuXHRcdC8qXHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMF1bMF0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzBdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1swXVsyXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMV1bMF0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzFdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDgpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzFdWzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdGtlcm5lbC5lbGVtZW50c1syXVswXSA9IG5ldyBSYXRpb25hbE51bWJlcigtMSk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMl1bMV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKC0xKTtcclxuXHRcdCovXHJcblx0XHQvKlxyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzBdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzBdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzBdWzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzFdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzFdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzFdWzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0Ly8qL1xyXG5cdFx0Ly8qXHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMF1bMF0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRrZXJuZWwuZWxlbWVudHNbMF1bMV0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoLTEpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzBdWzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzFdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzFdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDIpO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzFdWzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzBdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzFdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0a2VybmVsLmVsZW1lbnRzWzJdWzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0Ly8qL1xyXG5cdFx0Ly8gY29uc3QgbmV3UmdiYTogW01hdHJpeCwgTWF0cml4LCBNYXRyaXgsIE1hdHJpeF0gPSBbcmdiYVswXS5jb252b2x1dGUoa2VybmVsKSwgcmdiYVsxXS5jb252b2x1dGUoa2VybmVsKSwgcmdiYVsyXS5jb252b2x1dGUoa2VybmVsKSwgcmdiYVszXS5jb252b2x1dGUoa2VybmVsKV07XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgcmdiYVswXS5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHJnYmFbMF0ubjsgaisrKSB7XHJcblx0XHRcdFx0cmdiYVswXS5lbGVtZW50c1tpXVtqXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdFx0XHRyZ2JhWzJdLmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRjb25zdCBuZXdSZ2JhOiBbTWF0cml4LCBNYXRyaXgsIE1hdHJpeCwgTWF0cml4XSA9IFtyZ2JhWzBdLCByZ2JhWzFdLmNvbnZvbHV0ZShrZXJuZWwpLCByZ2JhWzJdLCByZ2JhWzNdXTtcclxuXHRcdGNvbnN0IGltZ0RhdGEzOiBJbWFnZURhdGEgPSBpbWFnZURhdGFGcm9tUkdCQShuZXdSZ2JhKTtcclxuXHRcdGNhbnZhczMuaGVpZ2h0ID0gaW1nRGF0YTMuaGVpZ2h0O1xyXG5cdFx0Y2FudmFzMy53aWR0aCA9IGltZ0RhdGEzLndpZHRoO1xyXG5cdFx0Y3R4My5wdXRJbWFnZURhdGEoaW1nRGF0YTMsIDAsIDApO1xyXG5cdH07XHJcblx0aW1hZ2Uuc3JjID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsXCIgKyBlbmNvZGVkSW1nO1xyXG5cclxuXHQvLyBPdGhlciB3YXlzIG9mIGRvaW5nIGl0XHJcblx0Y29uc3QgaW1nU3JjOiBzdHJpbmcgPSAkKFwiI2ltZ1NvdXJjZVwiKS5hdHRyKFwic3JjXCIpLnJlcGxhY2UoXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsXCIsIFwiXCIpO1xyXG5cdGNvbnN0IGJpblNyYzogc3RyaW5nID0gYXRvYihpbWdTcmMpO1xyXG5cdGNvbnN0IGltZyA9IFVpbnQ4QXJyYXkuZnJvbShiaW5TcmMsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpO1xyXG5cdC8vIHJldmVyc2VcclxuXHRsZXQgYmluRGVzdDogc3RyaW5nID0gXCJcIjtcclxuXHRmb3IgKGNvbnN0IGkgb2YgaW1nKSB7XHJcblx0XHRiaW5EZXN0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XHJcblx0fVxyXG5cdC8vIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgaW1nKTsgLy8gdGhyb3d3IFwiTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIlxyXG5cdGNvbnN0IGltZ0Rlc3QgPSBidG9hKGJpbkRlc3QpO1xyXG5cdCQoXCIjaW1nRGVzdGluYXRpb25cIikuYXR0cihcInNyY1wiLCBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxcIiArIGltZ0Rlc3QpO1xyXG5cclxufSk7XHJcblxyXG5jb25zdCBlbmNvZGVkSW1nOiBzdHJpbmcgPSBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFQb0FBQUZRQ0FJQUFBQVpmdlJXQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBUCtsU1VSQlZIaGVoUDFubEcxYmR0K0huWFAyeWFIcVZLNmI0OHZkNzcyT2FBRGRRRGNhcVFFMDBCRUVvNlV2L3VKdjl0QUh5YVpzazdTR0xFdXlQS2hCeVRZcFdSaU1JaVdCSkFnU0FJbE1BSTF1b0YrLzJDL2U4RzZzVzdsT25SejgvLzNuT25Yck5VQjcxVDVyenpYWFhIUE50T1plZTU5UStmL1BmL2MvRmdxNWZENWZLR1JVaFh3MDh2bVp6KzdMZzlTUjVZekpxVGYzR0ovTHpXamsxRFVUV245Z1p2bVo2Y1FvbHhOckZYcFZ6M1RPVGFtbkVPbzFtK1duTXhxcXBzTEVvYVlxbmNZYU5aMnFPUkdsaDBmOXVKdzBUdzFURVJwaE5OeHlBZWVRUWozU3drMUtBQktNRTZ6Ung4SVpuQ0pTYmlvSk5KYUJsR25vSWY1U1hMb3lBeGJ6VUozenRrVitJc1FVVStnUHhFeThhTUpOR0hWTko4SE5Jb0pTeFFRdzE1QnBTTzBDZTZ0eVVvVXdNN3htRFA2ejk5U1VRNFdDSWdSeWdmeFVzUTRxNE9ld3hab1hOK2ZvT1FhRGlDU3BKZ1dndCtPc3l6UzRqVDNJTTRyU0JtU0V0VU1VTElMRm9rQm12R294K3g1Slk5NFBRRDVoekErT2phSlFVWTBMc0MxMXdQbi8vdS84ZlVsakt4R1REdEN3RHFpQXdwRUZFVEJDTnM3d2NzSEVvaWhrQ29RQ0RuTXpiMC9aRldtaTRPVWVSdGhKV0FncjZFUlJ1QWZPQVdUUmFGQXA4QXdLRmpEdnNMcjBtaU5kaklSemRFY1JhQUpoSEZEemtzOWxTVG9La1J1ajlFb25qMVdaTVBtOEY4R2tSTUZ0T1E0T2lic09yMmR6dFdWQ1d3a2dBZ1ZJc0l0SVFrWXg0OHc4N29JMG1zRWlyN2gzZ3hiRmlpajZVMGxZNDA5S2hMczY1d0RsaE9hRVBnQVY1dmJzSnlVd0tpZHdySGF2d3prOVdKMG05cHBpSEtVVVQxNEVpQ3hDMGFqTEtBWUM0a29NUUVQUytYd2kyR21wVGtvZzAwQU9QT0J4SUgybW5PWXd4eU9KeEJQeUErSCtQL3gzZjA4bjhWTUhSVmdNUlJjdmw1QnVEZ3VwbEIvV0ZESVN0MHBrR3FBUXlRN1hhYWI1bEdmbXpGTFloYllXRHdHdFNZeWFDeXlKZmNKeUJBZmdTWEVQeFJLcGd3b293UjhvVEtwaTJYbUpRQmVxeHlYQzNUUEpIY3lpeFJzb2hidGQ2TWlsMTJQcG1uc1JucHJBa0tUa3ovWktraUdQWmxiUWFHalNFY0FkNU1sNWcxQ21FMzYwUW1FV1ZiSThGOWZjMUZmWFpFcFRVMDRIdDRwYTM0TlJFVm5VcDR0Vmkxa3AwYVFnSTAzRURzUzhIeng1V2gxMElTZG9DSFR4bFhBQkIzV2NVR2ZlRE9VaVZVVFFnWFN0SUZHb0NQYWxqM0phNERSY3M1NEtFUlhUUUY4b0ZHbFB2Q3h0V1ZuN05BZVkvK0ovLy9jRmFYTGgrVk94VHd5YjJFTUE0aFVrRHZjNXhOOU1MMU9vRUJ1YTNqQ2lLZG1rc1RFcXFDeldYRzZvd3RzVzBmam9VcFl6UUtBSkhjZ1lhRGhONlRxVmlOV1EyeDBSVUpiSzB3dWJwRk5CdnNRUEIrS0p5Tjh1WWZyVVVDc1lnS0xpRlBKYUw1enRUc3dpazhmc2p6Y3pxVk1sdU0wRkJjRlFRNUUzaERhVzNLUUpYTENpajRTRE9DcjF6ZVBiQUtpVGhSRmRBYXMrS1RINUNYeUNvU0R2cWFhS1d0SStDU1ZBTDlVTUU5TWdrYVUwSlN0WVNCRHdZTXBnRlVnMW5VeVVNaUU3SlppdGwweWk1Z2srU2lEVmpUOEV1SVluTklGRDM4amkyc3pZajhDblMvN3YvdUkvOUN3eHE0Vk5WTXdlODhha05uZk1ZcTNUVEFrdjBBQlRwbDVyRjBFc3BZbDVSb2pRTklIWEJCQXhCaU40R0ZXd1NKeVNIS2ZxQUNud28wUWIyRVkrd2FnRVFSVFBUNTNrTktOa1lnYzdveWFSdCtiUlNJWnpScGtYTlJKWFZkb2twclo1eTRzYUorNm5aMldNK0QwV3lmeUZsMVBzZTRFVzdNUVJhYjZ3M2tuZ3FoQWxqLzBRWFRRRUdOYStsQkxFMzFOaWlJcmdKTUM4RHVBRVZqR2NrcnV4RTZGMEtnaERIcWVjMEFzUXo3bFdia0lHcEZuTkk0V1Z3eDhyY1hJNUVTeVVGSlhKa3luQTI1KzIzdU1VbVNMRWR5bWNtU2pCTVR6Zzd5bjV2LzkzLzVFWFRPSXVPNTBRYWt3d0NJeGg5Ym9WNGNMT0VyUnFsK1NIK1dTblI0c0daeGhnSTNHYUFqVThNczJuczZHNXZoOVF3SUNiN2swa0luVy8yQ0JoL0tta1FYTkc5RlBDdG5oa3poeGQ1Vng3eGxucjhZMnhYc0pFbW85UmF0c0FOTGlYVEphRzhRbDNScHRFdXoyQjZra2lVU0lBblAwTG9SRkZBelZhRFRPQnhpeXBJcFFGWkR3dmdOUTlwclFvOHhCUGdPbWo5d09GYWVibFpGNWtNWHhTQnpDZEpoT1FCU0lGOEZJMTlwbVdPQVo4VXRRRW95SGhFMFp6RHYwL0lJRWxQS21SV0RRZUJRZE1obVc1VHFyTlRKTWcrSjRpZ3VDaWlvRi9xcHdnOC8vZzcvMURUVWJtVjNsTUNTU2FRbHdtL0RpQ3k2cExuQzJUUU9RS2NWWCtWTVNuRXEyZ09pRU9UaWpraVFQditudkdScE02NElUd3pSem4rVURoNFVaLzRoRDA2WHBpUVdtQkVyRWFCTGhnYVIvUkhQNWx2KzZBSlB6dFo1blVwSmliSTYxMmRhb0VlNk90akV3UVRSV2tnVnlVY2ZWS01qUE9LMFduSUdPc1JhTVpLeVRhWVZNSytIbGh5bm4vOSs1YjVxR2ZpcnBPUjMrYWNRNm9DQWo0Z3hncExFc0lsdFlSczBaTE1NaVVEZEJGZklVUlFNTUI0VE8wR2tHSW4rS3BXdk5HODZRRWhuelBjQ0pjM29ndWxmbmQ4R01tb2s0TkI3cEtjQ0ErNWVKVHMzelAxQ3JaMTcvMlZaM3NKQmxGZEdxbEIxc0NHQWJLZTEyRCtES3hFZ3VNcUU2cEJwQ1FxVGJHamRSOGJES0dtTUMxS2VaRFRPR1I4K0l1bjlPZ2s0cXpKTVJHWm9La1JzNkhmRS9Cd2U3QlpHamxtTllJNDEzQStZOUFuMHp0MDZBQ1krZERZeFNZa3lLdTZ2VkFzNk5oR1pVcXdIb2EwVFBFV1ZNVzh6akxQbzhXWXpqVDBrc0Y3NmRMeWVtQzN0WVg2SFE3NmhPTXlra3pnTk1semVUNmd3Vkp5S3FJR1Fad2xUcXRUb0F1WWk0aVRhQWpNTkdyaHFzL3pmOEQ4Z2dXUlRLYzlIWGNvM2tFdDArcUVySHZoVFFHT0ZBdVFxb1pUbEh6aEY0Rm1ER3ovUC80RDhqdUhwcm1EL0tUVmZ1bmltYm0yUk9nVnk4dlR1NU1xOUdRN3ZkOFJUamhvNVdyT2FJbGVpK3F4elBIOUhNcEtBSnR4T2hnUm9KcFhrUXB6aWYwcHdlcXhLVFFuRnlWakJTVm93ZWttc1FoWjRxWVI5RVF4NjNkVE5oYWpCQWJWVlVESXROajFZSWw0akdwWUUxamtVSitYblNMUUoxd1ZzYUYyd2YzajZmVkNaY0R1QVF1RW5jaWNCSHM1SjB1QW9XTXBDVTRjbnhRbnRTbmdWQWhBQ1JBTDUxVjZTUUQ2Q3BubzV4a2QzcTVvZEZpWmYyUjlqMCtSdU1wUUxNQm81SVhLVTJpUkNncGVqSTdpZG1LTTh3RkRuNTBHSG9MSTlkRlBBbFFiK1R5UDEwMDVHUkd5WHRLUVFwUzZXU0M3T2UvOWpWUDhBRUtGU0hUc08vcEl0bzkzajFvNTNkVW9xQXlpdUhVMERLcGxDaEF1V0hnTko0MGtxQUFWQkpNVU5uWXA3cStweVJSNTBXVUp4Z05DamdOdDJVQ0RJeHEyU2lBS0xxRU0xK0V1MC9LeDFZcklTTlBDd1RnNU5GRWlQaW9TWjd5OW9qaEl0RFptM24zRzRsSTVuUXlMVHdNRzZDSXU4aWlKSlJ0N3ZveE1nRGFSRDNtbm05ZDZBMDQySjRNY1NFWjhxZVNPa1J6TWp1U0lQQmNZaHEyaEJvaUZsYVlJQlhraXROanBHSGJDSE13RVlza3JXeW0wNlF4TURBNm1UTkZGclJrd2xHZk1EM0YvSU82L0x0S0V0TU1PTEpmK05yWE5WQ0ROVm9IbTB3TEYremtFNGxwQWgyUldEeU5HaUVLRFFoa1Y4SDBJYlR1dnlDS3VVemxVUlkzMm5QRlE1VFR4ZUpKVUJuRGNlTEZJN1RYbVY5UlFzSlRKWnFQQTEwRmdSbUgyb0d4ZnB4alh0V0VKVmtCakF0eDZJQW1RT04yVFhRT1prN0dhK3ZLTFBBT1lvLzNWWjVGNEhrTTRtb1BZeXBqR1c1aGFNOFBXU09RTGhiYi9PZmJtRk9ZS0FKdDlnOFVSL0RqM2dSRkRjcEY2U1BRd1d6ZU5UKzhMSTB4c1lvc2tLd1EralBTMnM2SjVpVVd1SzZucXJuKysrcUFKSFlOT0R0Q2N5bytNRXhvckp0dkRFQ3NpMG1TV1YzSktoQUowS0ZZMUNoMitmL3VFdlJSekRBQktvS3pQMGU0dzFadDNVd0pxZWs0cUtBTFdWMU9nTUJUTk9BRU51OFRHaHRQSmRGRndQa0kyWTJOSTJZbk5PZ05QQ1ZoMG1HQi9uK1cwMzQ5Z1FWRXNUakIrWVFNU2h2SVVBcjVjR3JBY3dwaXdDY0xvMkpXWUZ3anB5a2NGY1NGL0lKRHdhZllNTm5qZ2ZRbGdFY0ZFOVhSWldIcENnMVVHME9oUFM4SkU0UG11a2N0ODdvekxSVlBJYVRoaEpDZFk0RGxDUzFablQ2ZktDOUFObkdvZTYxREVrelZTQUZxZm1iRFFBR2hwc2lEVGhScHJUdStOUWFZUHdlQ1NsTFU5Q2NxVUJKR3hjTkQyTWZJS0VtR2VVbVVpYU5od0lSWHVPdFdsZmlUR0JIWjZNTVpHUlAzR09HVHAzVExNZ3NWaC9SUFdMMHdqU0xBOU9uNkVCdkxNTEgvVGhmWUpCSC9yS0lPall5SklRclJXZVhmT3dSOHpDT2FmQzR6b1lnNHhTeHFlcmlxeDNXa0pRREpQWDhla1FyaWczWVA2SGdpTWMyTlNZUytLZ1F4TjZwTUJCaUdZNmN1R1EyYVJGZ0FaSW1XeVZSN01RcTBhZFNGc216QkVUY0ZoYUI0NW1uL0FBVXl0U2owcG1JQ21qRWJLTnpyOURIanFVU3lwNURSaVR4SnRwQlZCWWlHWDd4dm96NmltUENmeDdwQlVVUkl1ekkrT3JRVjErQzh0b0thU2Z5WURUazhPQ3F1QTc2dFo5Q2ZVWXczMThmbFJNMDBsMHR3bXpjaDBVUkcwcFlzcWh6dXRvcy81MlJ6OE9JdkZmV2hJMTczVUJoRkNaS1RLZVFuV3dyU2sybkNFL09KcC9JVnJHbkY0YUx1K2ZzRnA4dmNqVkZpbGcrUUlZMXBOT3NIaVYxT0RKdkdHdEFmTW5JQ0k1bFNVZ2VZZ3pUQ2c2WUJVbHVuazM2UXBvSUUyQU9JZVkrWXowZ0pFclBTK1FRMGR4S05BeHlVUkkwalNGWHdUTFNsbmdDalBOUWdLNEt3alJMOW5FenFGeFlRRkFQVTBrUkN1ZC9qcVBSQ2dLQXhsQXJySGcwZjI0WHVlVU93d0xRa1BGQU02STllY2tOaTdRVlBRVllrcGlrUk1KV25WNkhyaEF6eDVpMTRmYUFFQXZKb255cVBNZWFnSWhFRW52RElmdUdyWHcyRCtPQ1BMaWFNRVVHbkdxeGgxM0VSdDVDMFFvTEVOY0dBbE1lQmlMbnAxY29LaE1hN0wrMG1WZFRMNGViM3dGRUNPUi8vWnhYblB4RW9nVEU2NFpMWWpxd1BGdEF1OW1QQXVDeEI0ZHk1RDNWWU45NGhFaExZU1VDWGhCQ050am02NllITTdOSHVWMjFUKzV5aVVTMXZTY01Lc2hkbkp3Q3JvcWJneUFqUmdvQkFEMjdnZzFGcUNReFdORGdlNTNMQlhCNFFod09QQ0pDVUVYdGFzeWVMbHhNYXpPOWVwS1NJdEFTSVY1cXFZU1NtWWFSZ1JKY1A3K3dFU0FJRFVRSndIU0xxVEJJTUNva2YvYWdlc1dneUEvQ0tDbXpxL2RQRnVxdHJ6aDZxdE1TeVAvZlZMODhSMGU5cFFjUkpMYWtWbUNpQmg4NnlwUTcwTkZjeENkaEZRTXdxNEJReWRISWZua2krZVZ6bTN2cDNGWHIvLzlFOG5tNE9jZVloS2tDTUZSQ2VqY1N0cy8ybTRuTTBIeU5kSUF3QUczQ1dZeVVMa2FLU1lpR1lNNDhwS1FDMnN1WVdQVmZURktwWXdDcDVqSkJ1K2tVM1pRN0VJazdNWFhDQloyRlFrRkhqSFdQb0JlZUJWQzZXeXBKYXZCQlNOU1UyYlk1Nkg3YUFqY0EyYjA2bkdudGhRTHEweFJHUmV5Z3hrZ2VMa0p0Z1hrN2drQ1hDU0RDVUo0cDZHTDJKM3Vkb0cvWmZLbTVqejhBYUw0NU1uUWJONndqMytYWGxORFdCQzZneGp2ZFV3b0JHYU91allTejZNSE5Td3hHdm9sb0xOSVppK0JOTHU4dXY1TkU4dTBuem5WTUNCc0VjK0dBUjl1UXdNek1Yc1U5UXVBU0Jxa0I1aVNjamdGZjkyRDhxNkdrWDRyZTVoMVB5dHNQaUVCdjNDMmNlTVdwdXVKUW13YU9IaDBnNnV2M1dBWDF3U2NheHR1aHVqR1NYZURvWUMxcC9FUXFDckdQTUl0aG5UK09KbUVLVVFhT0xUNHlsNVY1RDg5NFBGQ1JVbHlwZHNaRldtbG8zd1dFQUErcWFUcHptQlZ2WnVBeUlOcGpRSlVrWVBVYnRDZnQxa1lpcGxVc1RQUzd6cGlXVFYzd09USnhTUDNOQkd3ZEYzVGJzSEJma0tzTEYyT2c3d2M5TFB2djVyM3hacXZKbkdwVjBZcXhIRWI0Y3dHSGs2QkEzSmsyaGhGRmMwdW5mWFpMYWM5UGJHY0lnM1NsL1FNVGxUT1ZQU2EyU21EQjhmbTIyUUVaUmZhQUlZOXREWlprOUloWGVPcVVFS25uNkJEaEZDRXJNR01ITEtaQlhSTHA1UmczL0VFSkFxdFVsNVdRL090QVp1UzF3b3NUSTZLOGFqU0Nlay9JcG1XaEFTWXJSbEpvK1A1K2FUbk9PK2VLY2JtcjlFYlNZMThUZld5eHRpdHhvdXFodGxFczYyU0JFaS9EY3VVSkN6cHZiU2krUEIzSENLRXJNUkFWRXAxOXpHRU9nNlp6VVJTU09hdVBTV1M5bUF2eGVaYVJnc3NEY3JQT29wWmNCM0twKzVjdndVQ014WVJidnpvQTQyOURxa2pFc2xUWG1KRnU3eEdDNGlqOFpMSTMyd0NqQk9Rbys5WU9Ca01teUdSOTdVK090KzF6cVA2dlFtd3J6eGdDUEptakFlc1pFaHRsRUZNL3kwMEF3RGxuSGNNcmZydHhocXdxcFljRUtCakhJUlp4Vm00L2dBRTJWam9DWlQ0b0ppa1U1RDJVTFpNcUNrS2UxRVFqTUthQzVSZkNkWmcraktNYm16U1FRV05FSEpTUGlGaWFlR3lZT0hqRmxPelNYMTgvSXBiVDZITFFSUzV3ZkF5cGp2WlRhL2U2OTBFcmhHZ1UvMHB6U04yMVI4NzB2YzJDeUtKckNFd1dRSmsyS3BhYTNaOWpBTkNnU3RFbEVaSjREajdHcG5HNjR4Nk1URm5QbzhEQzlFS3lBUW1acGlTbFdGUFdGd0JoekJmQ2R4MUFjT3ZCeFY5UXhGeVVtbWhmMXFxRkRwdGZoMGFvb1FZRCtvbGRyamhmdmxOcm5KZkFCQkdadXRGVGNuUWdBVHhFWW4wYlJIeVFCeUw3Sis0cDZIVkNHazlFeEtMR0pyZ0FTRHJkYnl0UlVsemtHYzhZYWVGeXNsMFBUQldONjB0UXRFRE1tUGtaUWRNYllCaUN3QWVlajFJOWJFdWtIQjZvRURHb2VuV2FUSUJYZmVtcTlUTklINHJBMnUzSWdEWEtCV0hTR0NSQU92R2FFS2EyTEcxUjhxVUljNWwwbnhSU01qUzd4QVJCZkU1OUlkU0xidkpoNGpqMmwzT05pSHVibUtSSjJQdElsV29tVlRLRkRtNWt2UVJXMkRNZ0ZMOHdMNjlkNTZERU84NnZnUjdYMGdvRTRrbFUwZzdtWnluNUs1SFFiY0hTYklKMC9VQUpwR3FSNDNQeXppRlVzVi9SL0w0RXc3aFZFSlRpSkJrQldENHlNNGdCemc4Zks0WmNUSXdJb3g2VUcxd2N4aVNOSzVPeUVqeFIrZ2dtaFZLZG1raVZYMEIwTDVnSWRqT2gydGpNbFRWTkNJankwRXMvRUtSZFlkbDBVSldBTVlSck03T0dxR2FnUlFzYUNvYVQ2VkpscjdoSXh4TjZieFNBakpHQXl0bU9aOHlTanc5Wlp3a3ZJakRYYTFDZjhIRWlTS2QyNUlJYmZpekUyeVJFd0FLUFNRQkJpSFlBS2s3dWxvams4d2cwVms4K2JUUEVZOUFremdKcC9iWWVBbGg4NVlHeVpUNG9aZlJDVitFMzhWb3NTSG04S3FzenhGTm9KVEtJRlg1cHpEcW1HNUlNbFJ1S3ZFeDRVMis1eGllR255L2ZRbjh4eUdxQ2NtcE9XNmxPZDh2RXAyZy9BYm9ZZUVXRWFxOE0rRDVVOXYrUHpwSXZhTitOc0xid1U2SnJrSnZFdFQ4MnZRWXc3TGFTSm9yakZRTVorSU1zcXFpSytWSGpQeXdtYnlFdEZvUVVqeW53SUVObmFHSHp1VENtMDZwU2h6Zi8wRU5VV0RoREJJNThoaVhvNXNjalNNRDV4WUp6MEcrY3RqOFpZMFNBV0lLbkF3eklRRE5GeUlwWTh4TlBOUzhqQUJKN09lU2RtT1NsUW1SSkRRZXltYS93aVNMVUtuMDdsUEYrRkhpSmVKM0dzYm44RE40YlBTN0JrWUJSL3h3WHhYY1JVaDFUUzhCQmNodlJOZXlxTThEQkZCODNUckZ6VWpuUWtxVGdjNktMRWNDbXFDSTgwUElWWHNoSGovNnh5MGdXUjFNWGpGRUlDT0ZnakpEUzRBVkwwd3FEeWdaVEJkc0tlRnVCVVVWT0hZbElqM1RhZ3lqQmF3Sm9jQTVFTzJ6eFpqZ05Na0ZBU3ZXUjFEWmtEeXdmbTlSaUcyMWtpQ0pYQy80Szl4NURNd1J5L29Db21rMXJHUXdrZ2o0L0ZGcGhIS2V4eldEbk82TXFCYnNJUHM0ZzNaMGNicjFnazRHbGdLZG9zSWF1akk0T1FDd0t6VHljRnVFSFBZbE9vQkI2ZE1BYnNFWjhTYk8zYlJPOERCYWhaMTE0MjBJTkRNWTBTWkVOeU5wSW03UGxNWll4TG8ra0xJck9Jd1ZMQXM3bkRKU2hQRjZFSUZYWGhYeGpZYkk5N2RhVDg1T0d1QVNJVW9oQWpwNW9uaGN6NHA5QkJIQ1doakV6UXZIZ3VIUkdwOHhJeWhhQ29odTlCNEZISFF4ckNhcU9YWmp3dS9jQzhwNHNJVk9rbzhOMWQzaVVxOElRMWpZclpvdEJNQzhlMU1KYUUyV0NRZE1XY2puVXV1aDV0d1pMbkZRVzZOT3VReE82aHR1ZEpOd3FnQ0FXR3VIaTRrSUVQalZRSHhnU095RFNMQzBLQUZ6Y0JoQ1pOZW1JVUExa1ZhU0ppV25zZ2I2cFpmbXB6ajJ1NnhJcXhxVVJUektNWmtSWUZXZ1pRMUZUWFNlOXBNclVRWDRzcmhGSFh2SE5PaHNEdVRTWDcyczk5TWJSUkNlNFkweE5SZWNtUmo0RERDOGFiMkdjZ0NSNU5TclFmZDRSbFlXR25FUk5lYkVSK0JJb2dVY3cvdHNvczdGOTFtamRWUkFBcHA4ZElGWkR6Y21yYzk1U0lscERLQlg2VzBySVpoY21NRTJEbnBSSnIxbHBFTUhwT1BtdExrLzIzNU9ac3dhS0FmU3dzZ3d5b2poT1FHUmlEMkdtcHFHaDVNR1BRaEdzOHRYQ3hMSnp1QUJFWEdObDAxamd4WWdqRFQyd2hUb3hLWkhhb0dyNzJvaGpaeWRieE5JOGp3NTBPQmdNeHY5dUtLc1FSS2VSSXdjbFU1SFZCNXNtc3pLUmlRZEFMN1RtQlJpeVJXdk5FSWpiekljeVZwa3kxdTMyRWtPaEJVd09CVmN3RGtpZzZneUNxSUtRVTVGaXRzRmdOSjB1SFpRSTVzQ3VLTlkycmliV2NqNEovVUNRNVVsR0lPYndmYzFCaFRqQnpxZWE5QmxNZEZrbk9DcEZWaDJjVDdzOHVKd09qbkVhZWxIOVhRNkFPbk9lWnJLMyt1S2ZpT09GYzRPc1RPaFJNR2QrZjBDcDFySU5VRnpFV0pRaWdPRDNjVUJ4enZMUUtiNkc4b3dvN0tDeWRvY09wYkRad3FqRDVpYkk5dmZsSnZpQnBSVGJKczVtSmo2ejVVSmVhczFFdU54WnpiWGJacnVnZ1BObWxPQ1ZUUEYzRXZ3N2VHNTR2UEtUaTBxU0pUcVNsUWpZKzN1MEEwWEJkMG1NRitDRDJFakhlQjZZSnJBSWthZWhsTmFURGowQXd0Y2pFU1BUUWhnY2VCNVNZUnc0NlFRRmJGeGdhZzQ0dzhXR3g0Sm1pMU55eXIzenhaOXhwV2FJSU11eXppeDgxZUJBNUtZanNCK1BRR21sRE14K25oa01RT01jclZIWTV5Y3ZiU2ZlcHFTMkFvSGxJVUU1aUJSTVk0MDU4QVFlSGx0RndocGdKT0FEcGVkekVOSUllaTJYeGs2ZUJkQTY3TUFEZmVTQkg0dVhaSE5oc1ZtZ0ZaaTVUYWxKYlRzZzhpMnpIeG9aSlQ3WkQxUDVoSjd4TG12ZVZUZnFmVEJka25Dd0dMWUxZcW9rc1RPa1AzZE9yR0RXU0EyTG1EVGFlQWdKaDhLR2FvYlV3ZlBaQjRwbVg5ZWFnQjhza056UEl5MHcyb1RlT0NMV2c5K2JBSm1RdXg1VzFjQndqTG9kSWRFWmx4UktkU1Rvb0xhcDFCeEFMbG9IT0ZnaHBtUXhoUWlUN2hqL2h4TUFXb0NVTEJpeEFaTW04aEpqbk1rMzJwWi81S1RSdzBSbmNueXEyai9xaVFSSEN5eG9zTC9EK2N3bU1STlNFaUJKdHE1WW1saUE2T1VDTVFEVDlDV2tMbkdBaGl3YWtRTkZ0K0RSKzNvd0NoZ2tNdUNERFhBTVh3MGpQbndzeEx0ZHFRRFRWd1h5UTJxejhDZ0NSSHJERG1RWjg1b2c1YUpkNnJPVUNvNnFZT3ZrbEJseWlickdiOTRvK2NjUHpPSjRnSVpIRGlZL0VZeDdIZ1h6b3B3aVFTZGpBT3hNNzBJMW5idDhSU3hFK2dRY05sQmlCdEsybThOUXFYTVJPTjAwMmQyLzhlY0NNVDFRalhmUjRsQWZvSlZqamRRcnRESHFkKzVDZ3dtTUxxeDY3WTVwRXRuVzNDVEMwR2lHRkJQVXN3SkFSNlZUdXRnUVdLMG9NUENuQkJpUnJBaFkwYzluUC9jeFBNbEJwUXI0V0dSTUlyMDV6NU5vcGtPdWdCbWttRG5lb0cybE9TcUtIaGhaZFhvNVN4cFY0aG1LbWxTUElkS0lJT1ZYcmhGMUMwbFB5d3lpZ2VVRStCbE9mTGpCeEFaNlRSTEU4bk9kamFGcmUxQlYxU0dqTktNRkxCNUhOajJpcVNsdVcyTGNnTE1zZ0NFd00ydGc0OFVjM2dhMHUxQU4ySDhWeFR4L20wR0c3eVBlMmpEQWFvQ1BpRmRFNDdLVEMzSWtPY2FMQlUybFVEQWtqcWNsWVBPR0hvUXAwYU5TYUQvY1h6OExqdGdBMVBNbmR3dE1UR0xwa0Z4NUl4TklMRFNTS0JZNC9Lc2V1K3Eyd3lLUXRYU2xUQ0JIVUx1NEpFTXAwRmsrbXRGUUNVUGRVVVk4ZjE4empOQlhiRkpFRVcxeHh0a294aFRsbVAvdlRoSHU2UElCQ3pjUTJKakpXZzlSQlJqZFNpQWhySW41T3JBTVRndUlqU2xIY3pWREJjNXpIWW5lem1JdUl3OVVtQUZJSi9KOHV3dXBJZEhPUzd5RldBNm1NczNnbkpVUTFOTWNIQUFjNmFjVHJBM3R4MzV3UzY2ZVEwb0Vma25XNEo1RmtXNXJVd1RPelNuS1BFSE9HOURJYUp3VXFpSWcrajFQVGdVZ1dkRFRidmZhZmpLbTBPcDJIcVk1STh5S0xWVUhTdFFDaVYxZk1iZUxvbFlMRU9tT1IxdE42VGpOQmZXNGIxQXhrR0VkRlpIYWxWYk1LU0tTenczbWVyK0hDQ1oxY21US0k1Z1hXYWdaZjJqVEJCVWJGYzFwbEFVaUFHSnpCK3FYRG5Cam9tSUVMWEQyTm03YW9Ea1lFbkgzeEozN1NxczA1RXEzQmtEb1ljeE52R3QweHFWOWcwQksxSnlmakJMa1Z5OHF2cEwyRVVKVktDS1dLNnphQUpVeFM0aXFqMDRBQTVxSnpzS0FFT0U0Z05aTFpnb0dMUlFvQnFDazZpemhrcGVEM2dGSmhCTm93VUprZ3phdVRZdHB0SnlqTkFJQUFpRW9CcWFMbG9kcTVTMXNMQnpJeUdoRjdTUk55bUkrcGRZYUJVTVE2YkJXN2ZDTkFzaEsrUGtSRE0ySFlzc3NKajROYnFNek5Ra0ZkWXNzdVA4UXc5eURUZGlLMkgxaEJhbXBuUWorb3RJVG8xQXV6Y0lTQmJBMFZEQ01aUlcrZTJBYWxMU29pTTBBeVNBV0JURTVpTUpFbHdWVFEwMHdCVjNTUGhGRlhpSXNnVEErQlpHUDZKQWtZblQwdUNtZUVNUWVkYkRyVndSS0t4LzI1bkhhU0dwdjl6RS84ZUhDSVBPMnphWFdhSytxUGlLZkpveWYyN1NnUU5QQjBsK25ZOVlRT29wSEozUzI4YWV3QWhMUGgxTEEwcnFJSU5DTE15UUJqVFowS1JqdmRuay9Fc0JOWktBalA2V1RhVkJJbG5YNlpLbXdFSERlK1NVSmNLR3J4RDVrWk9BOUIraFZrTklsdnRSWFY4cUw2dkJoVkJIdTN3em5Zek1QY0t3azhxeWlHcUJLU08waUlxUjJGREFUd0RBUzZ4U1lKeWRTaVZ3REZkcHpNbElaRGIydDRJR1FhUzlOanhSQ1pnYU4ybHkyQ0Q5R0xnZW9FcDlvQ0lweU9wSm1LRVlpWEZMSEg5R2VOVHZkYUpCZU1KbzZNQ0psTkpDcFpGNUVzbGRCYVdzSXl2UTROQ1JHQlJXWVNENHV4TVJlQ1lVa0tFNGdjSm1qb0FWcndQLzBUUHliRmVDT0pDRTRiYzFVeW9GdWtjK0ZkMFJWUG9RdGE2aExCeEVpQWVHb0pnNDJZek5TQloySlhTR3VFWHdpZXhOVjVIdHhVSExheGlHT2tyQ0F3bXZPRHEzSzZGTWlGNWhOMTBsUXZHajY1NDN0S21FeUZhVUo2Qk1icHVwV3h1VFVGQkVqa2RNNEFSbmttdGhNVHhSd21VVERKMEFvMUpoUStsQUV1S08raVpyamZLVStaRUMrd3ljRkJ3VjZ2dEFNUkdUTEZmcVBneFlhYUVraGRmb0NvM3NJWUV4R1JFNXNSZW9VNE1OTkZUQlBvQVJqR2JVeUU5VFF4U0FRbWNkS0xJVFc3MUdmR3VNaWx3ekpvSjJaaGtaWXpva29IaWpvY1dBNzNJalRZemVUVTVIdXRaRUdleFpiRW8weEVlTUxkK09RQTlFaElwRDlWME03Q1VQTVdHM3gxM2NVQklZc3E4UTRkNWk5VmlVMytiLzJYL3pmQjZJUld3ak5sWkJsTUxKbjRpMmRLWnFlcE1BSGVEbjdjY1NNOWNZSzFOUjJLSXJ1WEdwTERFbW1ZVmRaVktYQ3pKOVRqN2JFMUZ3YW5XMjBLK0hrQlJycUVDUnBWTUkxbDdISjZDRTRqVHJ4Y3NZN2JMdWx4ckRDR0poTXZaQjdQNkRTbVJxRTRUWXFsOHVhWk0rVlNlV2xsdVh2Y3JkYXFta1pkYThzck4yKzh2YkswVk02eTNkM3RjU0c3ZS9kTzcvZ0EvUWhzdVE3N0tLeXllRHlNYXJoVmNGSlllc2ljRWw5VElqbVJ4d2llcVpOc01DZHFTNWhKak5RQWpSQmJscWhoakZLUTF6VlNuTENRR0JGNEdBTXJZMlNSc0NjclpQakNIa3FUQStGZURLcTB4NFVCQXlFRkh5QVFCVlpRcjJ5REVoS0ZKY0k2SngzNitUR0FiWVlJREZFaVFCaGRkVEFVeVFOaDFCLysxN3pvand3UldPb2h2NklLazlteDdrV1FxRGg1MWJxcGJpb21sNG9DbU1scTB1RitGWjNtRXdQbi85Wi8vcC9GZVBWaFhQVFhlTk9aeEp3RlVaZ3VXQWdobnNFY1RFeEFlQVdsQ3RhVEZCajNoR09TZ2lua2piajVrNXhReFJDdSsxT3lIemFLZUxCQ2MyNmV4NkJzeVprdzRJUVpDQTBtWWtiQ3dLWU5RTnppT2lWRlhjZmI3UTU1bDZrL1h1Smd0MWU1VWVFTjhkVzE5USsvOEdLNzNhN1ZHcndwcm81aHY5cG83ZTdzWkwyRFFtSGFHNUhoTzhmZGJEVCsxbS8rMnJrUGY2UlNieTJmT2Z2YWF5OGQ3ZTFJUjl5RTVJNVZIY1NmWUhSQ2JsV1dFQ0hkSU11UXN4M3VkRTE5TVlnM2p6UU9tcUJYZ0htUmNOS294OTZJR0hjRnpPRktMNFU4OW9rY3hTWEJodlVMeTNEb0dvQ2tzaDJSV1pCMlRNaG5XM1FpMXRWVUxOT04rYkFuUHVKaGpzZEpFTkl6b2tNcUN2dFFoMjFCMnkyMHdldUdmY2tUaCtpYUZ4aWFPaXdCQUVmOXpUM3JtY2t0eEJEczFMUmh4UnViYUVpRW5rdjJoUi8vVVdTQUJVVzl3ZGd0MWpWVWFNUlo2RGg1aFZvUTl6RStLSHo1TkJVNE1La0xXTUlFbVY3QWRBY2NrRlVUQlJZQVRqd3RISmhvWXA0MFZrVkFJbElIemhYNFdEMFZOU1FTTkRFbzlXcHAyRmxNb2tMY2VEN1JBb3luNDlXTnpVLzk0QSsrOE9KSE5qZlBUaWJEUnFNeDZ2ZXkvSmc5d1dSYVZqV2JsSnNMdzg1aFkzRzVOQnU5K2RaYnk1dWJGelkzaS93L2s4bVpNMmZYTjg3dUgrNlBCaHBGMnBIWmNZZkRMVnlnaXJPc0l0bENQSHdvMkk5L3ZkOXdORXltZVc5YS9Ka3ZqeElNbVpDa1lNS1c5MU1aQWpJR01sYWhOd1V2MXV6dnhUeXNyUjIvcmxvMkdEU3NMTStPTE9Jc25Ob0o4Z2hPQ0s5RGdKY1RLcUVZU09tRTQwQnBZNk41MGoyc0NGamJNSmpiM2xVVTlYUFN0T0ppc1I5M01uVUNZYVlxaU9taFM1eE5udkZ3akZ6dGZzbXYrY1JJUlN1YkVzT3NYL2FUUC9xanVKMW1lQjFPdFBFOUtEQ1FBOU0wYU5mNG9rZERjNURoR0d4eHVjNUNCaVZJNFZURk5kRVRxYWJmZUdtYTJMcFlVTm9nOFlIQWszbVVkMmpESzJhQ0FSWDloQkZ1U0tIalEwWFM4WGxNQ0tNSnJWbkEwelYvY1pXUWJBcmlwZlcxTDN6eFMxZXZQYkhVYm1mRjRuZzBrditHL1g1Mzc5SEM2dXAwUEpxT3gwZTdEL0padWRGb1RzdWw0bXgyNjd1dlBQbmhGL3E3TzVWcW9iRyszbHhkYnk0c2xyTGl1RHNvTmh2OTNwRmtVWDVVQ01nYjhjeUhTSkVVMUdvUU5CZ0VzWDBQZ081S2tvNWdlaUozNmpZVVhaeFZ1RlZGWHJUVFpZZjByMVV4TVFINUZwVVVCR0V6WFRKdEN4SmU2cklCdllwU2VOaWF0clc3RUFMaFBFWkE3SWdJY1d3UEtLUVhWVFFoRVNQV0FpczdGQ1JPR1FkUC9Va0cySnVyZ3hoOVk3S1lsSUtpS25TeDlRTXZxN25BaVpvaUlKSTZLRzhkbVZDakNBT1BZc25wclBoQkJSa2crOEtQZkY2UVF4RVRlU0tkckxoc0ZYTlpGSXNRUmEyRTU3ODB6Vkh3bVJ1TzRSYkluTkpWaXFZRFRoMmtCeU5DUG5kU0JOa1VpU3pXUzRnRnJWNjJUeXdBSFdGQUVQQ01BcmM1WHFQd3EwQmZZYzBLR1ZURTJhRUFocERpS09RKy9xbFBmK2FIUGxkdk5NdVZpbm9WbWxtV0g0MEc1V3Exc2RobTl2eWtWQ3d1TDYvbXk2VlI5M2pZT1ZMVzNMaHdjVERvRG1hNWpiTVhqeC9lM2JwejgvNk50M3U3Mnd1THRmVjJPMTlzSEErT2N1TVI3ckVMVlhDTjREaXNteDFNZ09KdnRpaXlHbDhUSXF6SjBBSVV5aUtRYXNBa2NrYzV1UzJubTFmVjJ0L0hjeGhyQkdleERnSk5JYnpWQkg5Q0VOWTR3Yy90UHkvRUpCVEE2aU9oMEdJTUNPKzBBSHlRVUhVeXRhbkl0ZnJ6djBVRDRVMlhCNXNHamt3OVIwWERVWHFDQ2o4YUkxSDRNd2NlaFJtSTdBNVdaRXpHdFBCVmkyNE85ZEdUL2NUbmZ3Ui91eEdyeXZIQWlvam81MCtXY1prYnhtUm9BaXVORXA2bFlYeWF3TmtqNkNCbG5QQnU2T1hpK1N5WlphRWhoWFJLL1o3TmludTBpdVJnbHZtaU9zRlRFTVlJQzJZQVZxa1EvUUhGVlZ0RTZTRVNlQlpOYnBxVmlqLzMxVDkzL3R4NXJrNzhBaFRYZWpFcFYydmFqbys2UjZWeVpUSWFaS1dLaUR2N083bmhRYmw5UnJNTlJwMytZRlN2dDg2ZXZ6UVo5YnVEWWFQVnFsZXFtK2ZQekxLU1BOeFNxcTh2YnUwOVlPdWhxSlRMMmNsalFGK0ZMUkJ4SUMxc0NURFNrYzg4RWZRa1l6OUt4OHlzMHNCd3M2aTlpbXM3U1hqMk5tSWhCcUx6YWhGZTB3bDI1SEdJRS9vYWRseG9DQkdCWVpqWk13RjRiWnBBNmRyQ3BxYUtndzFpK2lDSWxqVnlYeGJyQUwrbzZUR2lNRjJzSVUzaXE0QkZrT1NDekVMQ0lRbmRkRG5Hb3pCU0Zlek5rdnUrTE8xcFlxaGVhUzQzVkxSMUQ4M0VjSmI5NU9jL0QzZW1ZQklnejJTTFJORVpXZUNJSlJFcllkMnRJcXdiU2t2eldRSUpENXVWUVRSNU1aNk9PRXlhbW5RNjR1MHEvalRZc3dpWGFBV2pEUFNtTVh6YUppNGk5L2IzRkZiTXVGS2t1R2NzTWpHWHdtK3l1THp5VTEvOHlzTEN3blF5R2ZQZGhGbXBWT3dOSjNLWDdGVXNaZ3F5U3JVeUhvMEx4ZUowa2l1VktzVmllZnZleldKK3FJWFQyOTh1TlJaMjc5OWFYTjJvTitxRC90RzRVTW1QaDlXRmxjTTd0M1ZCYUxTWE5sZlAzOSs3TjUyT01oWWZkMURlclZwMXZJZ2tncjFkWVcrSUNzN3hqeE01QzBDempUMktyTzk5bWloNUxtbXZ6c25vbFcxc0ltc3FEa3pveFdNbnlRd01jWnAzRVk0aFNDSXNRYVBKU2Q2eXQyT0tRbE9Rbzgza1hnVUpmZ3hBaG9LYWdwREdTZEZyU1pMWGdseHplVlFVK3dXUmZSTWFGTUhIb010OE1KeWpEYUFxV0dsdXF4SVR3ZEUwTU1sKy9IT2ZjNWMwY3hFdUJSa1E0eGtWVnZNMDBBWTNjQW9na0VMWVJCNE5TalhQNWpXR0ZRSTVsZzlpcnRWR2VSYk5iS3dLQlByem5Cek9oVVJHOUx1MkRnSGlZTk9COWlJMkdLTUYwK25ldVBhQWtaWVFDVTJJKzFzSWZJSjBjWDN6eXZXUGZ2dTFPNy84cjkrNGQyK24zKzBkSHZWZWV2bVdpUGQyai9qdzdYUlVycFExWURRY2p3YjkzR1FvdUZpWUZZdTE0WEJTTFplbWhYcGhjbnpZeTczNWIvLzE0dkp5NytCZzJqOXNuN3Q4c1BWbzQ4cjFWLzdvZDN2dnZYSHgrVS9WVzZ1UEh0MGtZcVdISmJHb0p3WWhkbTJnZUJzRVMvRnZaWGtmQUNScVNtd3JacWRveXk3NjJNWTQzeFBOUEsvMHIyT0M5STRkUURVVHF1QnFXd0NiaEQzQjJrQkJRbzk3aVhLYW1OY0dSbXdWb2gzSmlXamF1aDVHY0p1YWJYUXcwbUtCS3pUMGdESnJtRE42anRYTG5xR1RmbENHS1hNOElHTDRVeG51MWpUcGFZeTdBUkVESVMyV0k4U2JlMXREK1AvaWIvdzFMQU1OaW1NVnJ1Tm9HRkdHd1A1ak5PUFk1TXpacDE0NllRTG1Bd1hLQU9nSkVUU0Y1bmZhWUJ5OVVzTFhQMnFzb0JrUW1kV0x5TXlpbHVrOXhIRDRDVVJVc01INlRnN01TQjJVQkpBRlVOQlE2NlE0MFM1Z3pEUDEya0orK2JsU3RUYWFaY2ZkN21nOHlRMEhwV1pwc1ZMcDlCVFRDdlh4NFhHdlhja09Edytldm5xbTIrMVU4c05QdkhCZDgrMDkycXBOdStXMVN3L3UzbDRvalcrOGQvZnlsY3ZIdzBHcjBTd1Vwa2Y5OGU3Nzd5NHRMN1UyTHQxNDVadVR6dEVzYTYyOStNbmYvOTEvVWlvVWVRZFdNczBUUnZJQ1JaSVJ1endYNVdQcmlrN0Y4VWhMUkJFdis0a2VuNUkvU05nT1hDTFlZUVcvMEJuYnpFM3IzYTNNRXhkL0JVQUMyR3hqRjRVck55bCt4NllvZ1JSRWhCVnZrV2xVU1h4WWFGeVEyQldaSGtIeGdXYU9tYnhHalpWRWRnTXczY2FpaHlxRUZBVUZwM0hDR1F3S05PeUNFS1lDeGQzc3BUVklpUkFkVVJMc1RvWUhLVEltVmxBWVZnemtzeC83N09lZ2RHSEdxTnd3d1BCZ0NUdkphdlhjREJwbVlKNUFmRStaSXpRVklNNTFyRXR1cnRhK1lBV2ZxRXdYY0RwUkdPZ0tDODR4V05KaGpnVUNHNEtvUTJrUTdRUEhtZm5JYWdpaVE4bHlQSjJPaTVYNjZ2V1BiVng2dnIyeXVOaHVMcldybTZ1dHRhVm1vMTZxbHhUL3RVYTVLUHBDdWFqZFE2M2VyTlRMTisvZDIrLzNEMGFGYjM3bnhuSjc4ZHlaOWpoZnVQSHFkNjQrKy96RDJ6ZFh6cHh2TEsvT3hzTzlCM2NVV3JuUnFGbXJsa3JsUWI1K2VQZld0ZS83YkwrLzAzMzBxTHkwZW55NGJiTXJnbVFHUzQxOGhyRUNhVjZIcmovQ0s2eE5NUm5udEJZbHZKcGpvdDgwanc5VWs2YlJ4RnJtTDQ4SmkwRWNOdXBpVmFpTGgwUTRoSWF2QUVBc3BXaEVEaldwNEhueVlSeW5lSjJNd0FXa0ZsT3dzRklQVFlhNFlTK1F0NElEajZrU0NhZVlCWEpEQ1dDSWl0YW5WbWdzV0JmZVFQQWRBSVZhWEMwWmxVYXBCOGdyWDF1eUVIdW1jUCtzUUxQRTZvYTlMcDJHTlRENmlHbE9IR0VoNDdFanVQbktCdUprYjZYWTRwQnZ4QlFIU1E1c2FkZWF5THhnaHRCMms3aTRHZUI4bmpnbFFDenNQeEU0eHZVeUcvVUdYbWV1VVNTT2tOZXhya09TNXFaajdjNDNybnpvaVkvKzhHSjdxZDRvMXlyRlNxbFlxMlJUZjQxWU5LMW1kVy8vc0pUbEtrVXdlenVQK3NOUjkzaW5XVy8xZTUxU29YM2h5ZXV2M1hxWTlZODNWbHJhN20vZmZMTzZzTEQ3NEhaaDJwa05CcHZYbjVHQ3hXWjdPTXMvZVBOUFNybngrbFBQN2oxNnVIYnUydUxTa25aS0I5MUhzK2tJVFRVYmo4YWxlVEthVTUwRVZhd3J0Y2QzbEhUaU1ibklkSHM2U1hzWXZvMHY3YVl6clFFQW9rY0dpRXh2VlVOOThaZitYSC9ER2hqSUFVaHNDR056TWRiK3h0V0VGTjFxcTNZWVI0eHFKQVY2d2w5MTBCckI0WEpDa3RxZURON3VpRDhUMDZiQjhnaDYvYVZqM2gyWHA2QkppS2dnNDNJRG5iVFRpYm04Sk5RSDdETVdjWlBJeVQ3LzJjOWlIa2VpejBhbjhBR0tnbE44SWNPRzZzQ2VVZk5IbkdIdGs1ekVpZ20wRWkya0pGeWRrWTJCdUUzMDJsbGlRdmhMWHZBaE1teFpjNHlrVzdValYxU21oeGhaM1pnZmZ1aUIvR25OZ05KSWJXUzk4UlhNVitER2svSEM2dG5uZnZBTEY2NDhWU3VWNnRWcVZpejJld1B0aVZ1TjZpU2ZsYkpadTFHOGYyOWIyL1R1NGVHamcrNVJwek1hYTRPejMxeXNmK3lwL21jK2MzVnY1OFkvL1h2Lyt0bm5uOTg2R0d6VWh0cjlyS3l2SHp5NGQvN2F0ZHlzdkhyaFVuOVNlblRyclhIbmNPM3MrZlhMVCtlYnl3L2Vmbk5TS09tcWNueDhzTEI2dnQ1b1AzcjBEdjRMU1JFVlA4aDYxTVI4R0pNMG91QW0rbjBZZzRZVDNaNkNGK2hWa0hibkViNnlJRDBZaExZc0lQYzUwTEZoTXFPTmhhMXROd1lwVXFDZVp1RVhWUUlzcE1na3FXdTRCR2FxM1Jnd0JJeWVSeVRUQVhoWHBVRmFLa0ZsZ01HdVdTL0VMbjBBQWJQWFVuK0lRaUdwKzNsQkVIZ2FpaksrR1pyS1drYy9oY1VKYzFoUnBEZDkrZXhIZnZpSElaUlVXQnJqaDhIUUUzMFpiMWVvWWhUOENSNUFHNCtXWWpHOElrSkFEN0hEN0JraVd5OE1iZzdrbTZBd0UwMG8wMmh2YUJQamNpWmhIc0ZtcGlKUHN2TmhGbk1URDJ3ZEJLRFZKTm5SMUZsL3dZc3g0eWw3OU1sa3RMaCs0Ym52Ky95MXB6L1dxRGRRREZLK045K29acTFLVGhSSG5lNTBPTHB4ODg3dEIzdUQza2lCM2g5T0J0MWVRYmQrV2UzTG45dXNOemJIZy9yekgzcTZ2alQ0OVYvNmc4M0wxenVQM3I5K1lYUDMvdnNMcXl0WklhZVZjZnpvYm40MktCUnJ4LzN4N1ZmLzRKMXYvTWJpNHNyeXhjc3l6VnUvLzZ1TjV2THUvbUd6WEMzVTY5MzkrNFN5WlVVbG5odktIaktoWTVwMHJwTUFkVWxPNWZYQXE2aHJMRU13RnQwWjVzOUZoSDhNWVF6VUZ3Y3NpeFBwQVk0RG44aHNJc1RORVdEK014QUJJbGhoWmJiR0NKWEdPSHRHWEtVT2NLNFVkeEh2Y2xLS29hRFI4a0hFaUZqeEZibDR1TW5HSkM0aUl1V2tTdmhDZktoYTJMU2JFVkVVbjVuUFowNmVoZk1KeHIyZ2RTTDBzODk5anMyTVFLSWNROHNpTmtiSWloMnhIU3d3SUNIRVlBTjJFcFVJYkdGdXJxaDEyT0R3TklFSGFoUXMxUXNqOXA0aElJTTVpOGFTZ21ZVXRVRG1wWVVVU0tRSnhIZ3VvRVJsSm13RnFaa2psZUpDVStsQ0gvS3NuNy82a1U5LzRkclRMOVpxTGQ4RDBqc1pqMHJsL1BKU3M3dDM4Tlo3OTk1NDUvN04yL2RmZnUzdDRYU2dyWTEyemVOUllUZ2Q3eDBjNkU2eGxzMCsrNW1uL25mLzIvL3N2L212Lzg1Zit2ZS9kblp6NGYvMS8vamJUMy84QjF1RjQ4M1Y1bWc4SEJ3Y0h2WUcrZEd3c1hKdU9ocVdhdlY2czFFcEZjNTgrSk8vK2MvL3llamhyZFd6bDU3OHpCZDJ0cmNhS3h1M1huazVQNTd0RHg2UVloRDdaQ2NqMmRpM1dHd0xDVENacE5CWFJ1ZXV3eUV0VlVrb1NWUGJTelVqU2ZOQzh0UXAzY1dLclFCTXhpeDRnamhVanlwTzhWNk5aWWtnRk5NVS9ySTBHR0xQZGFJblRNM0NrY0dkQ3JBd3BIeldBVVVvQnJ2UVNVSTNKM0IwaVNKUm1yR1pTRnJvSTh4alFUblNCVGprUHhqNG5tTStEWng5cHB1eGlCVnRzZFhkOStkLytMT29oaXdTazRrejNnckdkalRtUlZ5aUJIOFpDNG9veHN1SUo0ZGQ0VWpWZ2RrNXRIckYxc1BpNzRRTm93M0gvRFNNOEZrTzBsa1NxeWxiY2drQVRSVzFsMFFNMWNSc3BKQmdva3ZKWkRLdXQ5cVhubjN4VTUvN3d0bUxUNWJMdFNGUjJaY1ZTbG1oVk9SbVp6YWN2UDNkbTk5OWYrK3duNStWS2tPdGpueHhOaW4yeHVQK3FEQWVEdmQyZHlxRjB1YkdTcGJyUC9mVXBmTlhMbjNtMDUrNGVHbjF3WU90My82Tmw4OWNmZUxzOG1KcGVLVHRmNzkzZFA2SloxWTIxc2E1WXFOV214VnJSL3NQQjhOWjc5R2RqLzNvenl5ZHUzaTA5K0QybTI4ZTNYcy9tK1g2eFZ4SlF0WnF4NE05SytwbmlKak8wUW5BYjR5TmxlK0pZZmJ1Ukx3dVZNUTlpd0pkc1IvQmJTOUVVNnp3ckd5Q1diQU9GdkhoYXA3ZEZXU0tTKzZwSEEvaEsyQWdsb1VBZjhqUzcwMUJ3Y3V4NXlaRUNja2pIYnBnQVhGVW5nVlJJQS91cXJoMXBwaUZKQ0UrOWVkbEFEcUlBeG5Ga2V2dGV3cGlTb0xTR01lK3J3aEd1T0VYYXlQYUFNS3htYkZ4YktnWWJndDR6VEdjeFJncW0wQUZTbGxSK21CbUJncFNXaUhOdU1qOEhvbi9URzQ4d3BoM1FrU09ZU1FZYzZlQ3NSZ2hnUDNHTU41SUIyYyt1TTA0aDRmNHlmRk1yYVF0eEdTY0x4U1gxamFYejE1ODhRZCs3TmtQZjZLOXZOSHZqN1Q4dXNmSDVVcXBWT1J6c2Qzajd2NzI3dGJEN1J2djMrOE1Sc1dza0ZXeTBhQTM3T3hQOHJOaUtTdFhhcU1oOTRxYTkvN3QyN1BCVVh0bGNhRXkrZGhIbnJ4MGVWMmg5Wi84WC83bWh6NzErYXhRYnBkSG02djF6djdoNnNicXc5dTNwdm5hL3M2OWUyKy8xdC9mYVM2ZGFUWHJ6YlVMM1lPZFhHbXgzR2l2blQyMzN6dit6aS8vb3ljLy9zT2R3WFNsdmJiYnZUOFpEd2hCQ1M5OTBDdUZQdEd0bWZ6T3FHTGR0N1lHdkNyaW4wT3BLUlBhQy93bFU0Y2xNVzY0UkJhbVlSdW5MdHIyaG1JQUs1T3JDWEQ4UTBBUUwxb1BhcXJpTThOUk14b2tzZTQraDJxNDJ3d0pxcmhBK0FyTUVQR2kyM09vamhKalU5TlNxZE9zSWt3VjBCd2lFT2h4WXV3b2R3VTNNRkVqclY1dWk1bzNXczBCOWlCNTBaUEwvL1gvK0QrMnJVajFNakxqVUloSXMzbHNDb251SWtvdVZiWmRGQ0dWRU5YMHhqeGhncDRwekVlcUlJdE5KcHRxY25ybEFzWVVpcGdZYXRSU3hpRi9pMWg1QlFQRFdES3grNFRlbDJiWWFRcTRDNGx0dVdpWEc0Mk5jeGZQWHI1MjRkSzEvb0ExMCszMUJ2MitkbitWS3M5ZXh1UHBrTSsxRERvSFI3T3NjSFJ3TU5Ka3VuVWQ5R2ZGWXJYZU9EenM3eDhkMW92WnJGTHY5M3ZiaDdQcDRIaW9LMEp2dUxmMzRQa1huMUxZNVk5dXJpNDN2dm50NzlZM25sM2RYTnQrMkRrN2VmLzZ1WFpoT2prNjJMbDgvWmtzbXpiWHowOGwvK2o0NEhEdi9vMzN6bDI2MnQ2OHNIUHZSbXRwODZoem1CVXFEKy9jTEdXbFlhbTZkL2RPWVNsM2QrdGx0RkFzU3pNWlVLSHMzVXlrY1lLYmRTZVVVdnQ0d2svSHlNd0tKZ2Q2WWNhWHA3QXN3UlBCUlVPRzQzRzdvekkzNDRQdWd1UGJobG11NkFBb0ZyVE15NFY4cVpBdlp2bXlUTStJZk1tZmZDbkwrc1ZjTVpjcmFsREdrcENqTXNlRTMxUFM1WUhadU9uVG5ESzNHbmlmZDJYd1BzdFZXYzhUc25wQitXVjZDbG51Y1Z6UkpIZzhOckNjZFVCdjVWaVAxaTM2ZzQrSGVxVG1BZ0R0U0lFa2Vzalc3T3lFK0d0LzlhK1NLZVlGZHFZOEtXcWhnWEJFS09QTUFrWWFaakdsbDJEMzBrSGVGeE5abW9ubkRLTldJZkpWWE9NaEpvQW1WZlRMN21aaER1YUZHTXdxVjhUczZ0SGl6RXF0MWZXekY2NWN1SEp0WldYOXVEY2NqM1RET1p3TXgzTG1aRFFwbDR1VHlWVDc3LzVnUEJtT2pvOE9DNlZ5dHpjWWprYmlWeTZYdzBpN2UvdkZhcTNSYklxRGNtaWhscFh5MmIzZGp1elU2NDRPRDQrSG8rRmlxM1p1ZldsaHBYWDcvYnV6MmFoVXJML3g3b01QYmRZKzl0VHlaRFI0ZVB1OVM5ZWV6czM2eFN5M3RiVjkvKzc3N1VyMThrYy9YU2tWanc2Mks0VnNVbXU5OFc5Ly9mcnpuN3AzOTczNnducXQyYnJ6M3J1ajQyN2w4dEtiYi95YXc4SWZaVVJGZG9UYXZjaXEvdEZVUnp4M3FRcjNrZmN6b3ZJbkhMR3FMSXlSTlV3QjZDU2hsNk1jVS9JUk4wQWRmSlZKRVE5YzVFMG0zbWJTMnVOcTU0Z3Y4bGs0aFhKSmdTNHp4ekxRdmsreUtkQ2RsTFN5dEFBa3F0K0JraXZzUWZuUlFBUkdGSU1weURWVUlnTVRzUFBpL1JJVTRxOG1WekxVaHh0YXBYMUJLdWhBY2VUd3lDS3hPaldqWUlVRzFranRVeVhJNlAzci8vdi9nMDY2VXBKYnhZV1hMV1MyQ3VHa2p5ckJpRTN4V0Q4UkFHM0hpRmVhR3dkNXZCZ3kzSER3OUJSRzBEWkVXaytOS1A1NUN6c01PazFrV3BsTWs4dEE1ZnBTczlWcUxiUTN6MTFjUDNPK1VpcVB4b29UN2psbUJQczBLMmFUOGFUZjB4YUdyVysvUDVDekJrUGw5dkdBUnpUU2E5YnI5U3VWU3FsU2xHK1BqN3VTWWpRZTFCdjE0MWx0TURxK3VGeWRaZVZxdWRRNUhyejc0R0EwTHRUcnRVZVBIaDV1NzNVSC9hVldvOTFzYUhNdk1TZkR3Y1hhOGJuMVJqWWRqM1A1emJQbkJyMWVwZGtxRnJUQ09zZkQ4ZjFiTnpiUFhTN1hGeHJseWFQZHZWbW5jK0dGSC93bmYvZnZQSDN4Y3YzTTJlUHRoOVhHMGgrKys2L3lrMk9uTmVjbmRpd2tlTFVscmlENW5XK2FrQytIc3JwQUxRbFNFT1lMbzhwR2ltd3NLWmdkSGd2STBlOExKYjdqbTBVQUJTNElDdTVDbGhVTEJkM0ZBQ3VPaTNsZ1lwcHhHdTJzVDRpcnFWbzBwWUltSVM0YzhYeWZMUVVvSGlKWUhSYUk0N0FSeEl3bVMyaFR1K0JNUDZDVFJBeFYwRURsZnRSN25JS2pSRGd3VDVDWW4wcmlUTUY2Q2Z5emlucXpIL25NWjNSbUJ0KzdXTDRFYTc4Y2xwekdkeHdmeDdvc2lraFd5V05WSVRrdkRrME1FM3RRZithcWdmRDF3dkVPUkdiQU8xZ3EzdGttOEpWRjhKTTd6SW5oTWUwMHE5Yk9Ybmp5c3ovOXBTZWZmWDdqekxsR2MwSFJkc0JqazVsMktTUGRGUllLbytIdzhPRGdjTCtqY085MWo2Zmo0WVRQS0haNjNZTlJ2NVBMRGFlRHJ1WlFtdFF1YkhCOGtNdVBxeVZ0cU1ibGJOSmVXdFR3Ui9kdXZ2RGNVOFdjTmptRDd0SCt4bkxqM0dxcjFheHNyaTAvY2UzaXh0bDF5YmUvZTMvUVBkamYyU3JVV2c4RzlULzhvemVLaGQ0NzMvbDJjWGg4OGNsbkZwZVg3dDk5T0o3bVNxWDY1cFVuNUlUOHVOdGNYS3ZxMHJDMjh2cHYvL0lQL2RUWDc3MzV6ZWJLaFZ5bVBkYngvdWl3MTkvaDhxaDQ5alUzZGpIZXdzdm8yc083c0dlVDZkVGlQUTRaWnZyNCswMFlTaWNIamtiaE9GbmZJU01TZ3NTT1lKenpDempaSERPVDUreUVnamZ4T001TkJ6aUR5RnZTZ2FFcERRbHZ4bDRWbmgwL01oTXZDR2tHQ2o3ei9tQXFRSE42YVpvWjNlRi9PMTZIS25kN2MwVjBXTlJVQkQ5dUpFb09NNkhsNHdQbE1lVmYrdy8vSTFreTJpb3lFRW9pTlZndW1NcW9Wa25ocmpwWkh0dVMzVG1UZG8weEJiQkxHTUtESXNHSUc3ZnduTm5JSzdXa1NWV3NqeVpVaGxMUXNzcEU2R3VMT0U4cmxjYmFoU3NyeTZ2VlVxVlF5cldXVjh2MWhzS2plM1JZYTJnVDB0cloydTBjN2c2MXV4MlBwTGcyQWFQSlNISFM2eDBPdXIzeFFNa3hsemtmYWZ4UXUvakplRFFZNEw5aTFsNWJIdzNIazlGSXlGSzFmTzM2czBlSEIvZnYzUmxOeWQrVmZHRlV5QTI2UTIzdWU3bnllSklmemtyRDQwRzFVZEgxL002dDIwZTkvS0RidjM1bVliVnljSDZwVXF3MTE1ZnE2NWV2RDhhRjdkdHY3bTF0alFhSDU2NCtYOVJscUxFNEhlbFNVeHJ1UGhqTUNnZEhnOG5CVnJGY2ZGQVl2UEhPcnl0U1pTVGVqY09XNURvdW1OeVE4clFJRzBzKzhycHVUOE9vTWhmYlVQWEVCZEZteFByMnZPenNBQkpUYksyTVRIYVhBNVRkdGI2VjBSVk1SZVdYZ3U3ZWxXNEVhT3ZpYlE3WlhZVEZJbjVqYitQRVZNek5sT3pGVUR1WmtrU1N2UHplaHlhUUlKNE41eU9ZQUdyN0hKaVg2Uk5hUkFFNms5R0pwNG15aytCUkVad3lIa3dDNzJFSmRwQUVBbUxOQU9DZ1V6c2FwK21aaTNBbnI1QlR0UnNMeWVFcWt3bXYycFRNcld6aVdxTGhFaTZ6NWdFaHpyQ3czQldZaldDMFNmT3FTSE91cTdJYlZ3NGFBdE42TkFDU1RPSVRvOHhwT3F2Vlc1dXI2d3VOYXFOVnlWVXFzOXJDOHNyWmFTR2JUa2U5enBGeThFRGJrYzVCNTNCdjFCK1VLaFdsdUVkMzcrMXQ3MmdITDNWSzFYcXBXbXExbHdmRFlhRmNyMVVyeFlwQ3Q2WHdVenhWcTlWeXBUTFNWbjZXR3c3N3VyeGtHV3RjTy8zRmhmYXMwbFNZSFBYSEQ3ZDM3NzUvVDZXN3Z6Y2M5SHZqMGJCelVNcE5lOE5lczlKY08zOXg3K0hEYTJjV250aHNYbm55eXNxNUM0MTZ1VkpiNlBHdTdBTjhWbTZzYmVnKzlUZy9HOWFiN2IzOS9jcDQ5UEx2L0l1bmYraW43dCs2YytiWlovL3hyL3dObTRaTWp0S3lwejhrSURQS0M5eXpVbVJqMHJ1ZkRoVDh0UThYTUxLYkxJZTdNS2FFeG95NGdTY0JiR0RVbE0xa2MyQnQwclZ4WWFjT3lITXB3ZHFzK3laV3lZWkZBVzIrckcxTWtQbWlLOU1vYWFRZFBBN0c5MW8rek1COFhFN3NRc2NJQ09MSVoyTElKMXBrVlFHOFM0YjQ3b3Arb3BYWThnQmpyRjN3K3RNbDhTYjAwKzRuaFR1alZTUVprV2lZclU3K2IveEgvNkZNYUg0MlZ2b0Q0Y2gyandnWnBFTTI5ekloRC9tVzFCZFdwWFVjSkx5RmpqT1NpTm9YQzAyR2VvUzEwRTRKNUhOeUMxNGlpOGZUQXVSam9BY0pXbHhhdjNyMmJMVlYxNFpsbEMvMXg0Vnl0VGFiOUxWUjd4LzN4c1ArMGY3K1VhYzc0ZUZkZFRyUmJqMVhLVmZyclhwN2NVRmJFTjMrakNVUTRjTFRIY21xVEtVTnNiYS9jdW9veTdyYVQ5dFhaWGxXR29ndW13MkhRKzFyeDZOY1Z4ay9WeGprcXZ1OWdvSjhOaDFyZGVoaUlyWHEyYVJTMVV5VnJhMkgyM2Z2dnZIT3JmR0RONTdkcUJkcjllLzc1Q2RMMWRsS2UzRjE4MEs1VXRLdXVUOGNGY29WM3NyVjhxczBKN244ZDM3bEY2dWJWNnVsK3FOT3J6Z2JmL3Y5WHozcVBKREtNcDJZMjV5MnAreU0yTjdCODdpR0UzTGF3blpjc2hYUktZUDV1UmJKblc4d3FURXJnZFZCbkdxM1F0NzJJeGh0ekxVMWQzQXJ4UlBUV204UnlzNzBoUHVNcHpRcDMvTjBoeHRXNy93MW02SkZ1UTBYQ2NDZGtrRUJSSkFMUXhIQXpIVHFjRGdFUmxMUDcvcE1DQVpvcm94MVAxMGdmb3lCeCtNQ3pDeVBoMFN2eDhoS2o0bVZCSExaNTM3b00xS01YdFpoYkdSOEQyUXhnOUJ5WVg1V3BmTU42MkNLdXFEWngzdUFYaHlrZUN6QlFQMFIzR0ttUzZnb3ZOaTlycGpNMFkxelpGK2RtRkkwWEtPNVRHYnQ5WE1mZnU1RDQxS3BQeHdmOWFlbFlsbCtLbWF6aGRicWVEQ2VsU3Bac1ZGWldOaThjR250ekxuVnpmVXpGODZ2YnB4YmFDODNXaTBGZG44dzduUkhrM0crMngwTitzTitYenY4Z1RZOGcvRTRuNVVPTzBlNm04MjBYODFJZ2Jxa2E5UmdOaHNQQjZWU1VVZWxYdUhSVFRHclZpdjFSblU0bUI3c0hZekg0MHFwTUpnTVo2Tmh0OS9WbmtrclNRdHNPTTYvZDI5YnU1emhZUGZCTzIrdnJhNHZyaTdmdUgzbjduZGZ6a3JaNHZyNVAvNnRYeFBQTjE5NzdkNXIzeXEybGdZNXBkTHNsWC83cjU1NjhUT1Q0Zkc0Tk5uZXZaSGlQSjR3S3JaVFpFY2prcnNkZ1dlaDhUckY3Q3FPenBPQXN4OGNZd3BTMGdpV25pbGFjUU5OUE1YNlVQZ1M4WVFDWTAzTXNLaDBrZy9kRFc4bUZwV3c2bVlLY25qY0dGTkRwSVB1TkRUbXdOOGtOVG9KTU5xd1MzUkJ6MFNQeDBaelhnU3lPQTJlR2liQjUvVGk2WGc2b1FNdjNYVGJQVzh6L1N6N3NSLytJVFhtT0loVTZRL2Q0YUttN0V1eG5ZbDFsRVJQRlNuSkNvQWVBL3BndEwzQVNSMStiR3YyQ256YkhpL29KVkFIUHVCQ2JtSWlIdjlwMnFXMXMwOWNmL0xvdUxQejRNR3dQMnl0blZscXIyemR2blc4YzcrenYxV3E1c2VEdm1hdmF2ZkNqN2dVQm9PcGdybkxIZXJnNktoM2RIVGM3UTZHbzNGL3FMZ2M5b2JhNlF4N3ZhNDhKMlMzUDhpSytTa2ZwNVZXL0o1R3VWenA5cldaUVdtaGVxTnA1N2lyTzFlbDhIeWh2SFUwMk52dlZMSlpjNkhhNjA5cWhheGNxZW9Lb0tTcnpWQnZvQlZTR0U2elo2NnRISGY3eGRsbys5Nzk1dktpekx0eDdtSjdaWWxQb0k1N3M5N3hNNS84ZE9mUmplUGQ3Zk5QZlBpN2YvU3Y4NzJEeldjK3NkQnM3SFoyN3UyOGdaVko1Y1FRV1FVcmsxdXdOeGdRZ0FJaU1kcmU2YVhKc0RFUHhkUXBXRmhkQStNaCtZbGhiWHliT2lLSCtHT2RGREU1Yk1TZGZnNzFBd2QvZWhnV2hTdWxlOTFGRnRSQzlCU2V4Z0FQUGIyaW9LQTQzajFudEZNRXVLRUtBY0M0NFNVUjRNa0JjdzJIeHdrU01zM0NzSmpGYTRBK1lLbzBlMkN5bi9qY1o0MGlEaG1HamR6SklVb244aFRQWVdzZmFoUDU4cU43Ukcya2hxSWpzMklkLy9DVWIzUkNDbVp3QVZEK1pSblFnYzYrUm1nSTE4WlpZM0h4bVNlZnZmSDJPKy9kdURQUXhucmM3VDI2c1h2L3Jmem9vRERyNTZaZDNXTk9DbVVlSHBlckU5MlpzbkdiZEk1N25ZTzk0K1BEOGFpdm0xVXRCdDI2emlhalliOHJtVE9leGtpa29pSzgzKy8zRlAzOTBYR3ZONTdNeHFPeDl2OU8vVHp3RzJZbGJiMGJqZGFzVk90TWl2ZTNCdy92UGVvUHU2MVdxMXhxdEdwYVlKTk90NnRiMzBwWmQzTFRScjJ1V0x0MmZ1UDdyclcvL3djK3ViQzJ1ZDNwQy9QR3EyL3NQN2gvNGRwMUNiTzhlblpiKzY2N3Q4Kzk4T2xxZS9GYnYvU1BYL3pobjlqZTJhc3R0TExScU5aZWVlT2QzMWJzRU5ZOGlDVFkxZkNUR3VkMVljQ3hteGNadHhkZ2NJUHRIM0VXUjRRRHJEQ24zUmpoVGdhMmthbE54SGhaUDhpTllRM29xcUhhYnNiandIUkM0NUJ6c1lEcUZ6TkkxQUZ6RlNMQ2c4ellBNFd5ejBHNng3MFFRa0dnaThpY1F4aDN1QzJBcHNWTC9ObDl6RWNnb0lsVk00SE9xcGhJQmY0S0orTURYY2ovNS8rbnZ5cWtiQ3pVWERNcGFsVXhMSFlsc1dCd0xxbW9qSjJkZFJnakdYZ3gyR3I2NUI2eWh0Q0VQRVY0eEFGUTBIRlZWWEZiYWQvMm9nQklMODh6MUVaVk8yZyt0RGlhY2Q4NUsvSXhnSEs1MXFoVTZ1UHhwTjVzN1IxMjkvWVBPL3Q3bGVKa2NiR3FaSno1eWZRME4wTDBUQ3kwKzlWV1lNeVRqY2xzTUZLT254NTF4cjNqaXE0TnVoblREcWxhTFRicXpWcWpYcXJWeXZYRjJ1S2lwc2l5OGlSWEhBNXpXenRIMWRKTXQ3YURZWDg4bXBTTDJmRnh2OVdzSG5jNldiRlFiZFIxNzd2U0tEL1IxaXJiMTBaWXQ1SlpyZlhhTi8vb3hVOTg2dWI3Nzc3MXpXOTg4ak0vZk83YVU4MmxsYmQvLzFmUFhIMDZYMjIvLzlxM1ZwNTQ3dEVmL2RybXA3OTA1OXZmdVBUeEgvaEgvK3IvUEJqdHk3WVQyWUNvSnFJbThaRXZ3OXFONHd1Wmlzd1EyeHFpQ0U5d2djUjIrRTliUSt6ckg1SFJwVlZPeHNwYWZYeGpXakQrY0U2U0R3ZzVQM2ZYRGwyRGZMc3NIUGV2amxBbGZUYjBJcy94bHBNekY3dFQzbDRsMHV3NSs1WEVKWURkUDVLSVVtTzllSFI0R3RBVVQwK2tJQmZCSXVhY2lCMWZ3cUtoUHd5aHRvY2wvS2s2UWluVkJzd0hDY2tHSUtpQ2NaUkMvdi8rMS82UFlzdmVUZWtSTVdSSlpRWCtreDVyUU1RQTNDb1ppSEFYQiswZEZmUmNKM0dGaTBacFdTakk1U3lrT0ZVMFNyMENuSWVrcHpocjFrVEZvaERlMklJZENzNHJTWUFzQ2dvRGF4SXZKSDdIUVFDYkl4WWw4a2dxeVN1NWVFNm5PRUVOZ2o2ZVpDZk1KRC95NDJ6UmpBdTU2VkV2dDd1VGRZNldEbytGazF6cXlwWHk0MkpXWEZ4Y3JDeTJCd1BOVWw1ZFg2NjJGaXFOaFhacklaZVZkcmNmNm9weHRMYy9ub3pLcGNJMFgxNWNxRi9OM1hudUV5OGU3UjAybGxidTNybTdzYjZVSzFiKzdhLzhzeGMvOGYxcmw2N3BSbGlXNmR4NmEvM0tVNy96ei83QnM1LzQzR2c4eUJVcTI3ZGV1ZlRpNSs1Lzl4c3JUN3o0UC96eWY4RDdxamlmV05lQi9MS1hjencrNW1SN2MzTWtIeVUzT3hWaFhCbExVUTdndkthNHc5cXlsSnpDVDFYaXJZaDR1ZGV4empaVDk2a0VJS05WODRnR3BKMmwyQ1hLK1RSQnBsdDRickV3ZjVGVnhzeHNsUENoWWgxUHFCZjJBQXlQWHU0ZEhPb3FHcUp1dklZL0F5c2Z1eTNHdURIK09BaXplUzMvejJNcytvQzRaL0Nmd3dnVURPbEJad1EwQTAraTRQQ2l5bjc2UjM5RWlrdEFpTkhmQzFqaVd1U0lTL0hUSDNweDJDSHVUR2NORGRQeFpGYzNZRGFraXgrOHBNSzdlTDUzZ0hOMFlSQ0cyekxpSlpWWVlSellGVUhrUHpkREFGM0Z3cU1nZVo3RE9qS0JOT01oZE1TMzR0NDVrZHlnOWVubmVMUHhsQjhBMHk2ZFQxNnhMSGd3TjZ5MUJxMjFuWHBsTUpwVXpteGV1dkxrc3hldVA5MWFPNis5L09IUmNTa3JkQTUzYnJ6OTVyMGI3K3h0YjIzZnZiRzNkVzgwblR4NHFJZ2ZyNS9kbkdibG8vZmZQdHQ3ODRXUFBsOXZOaFkzejd6eVI5KzZmTzFhcDZzZDErVDdQdmRqbXJxejlmNm9lMURLNS9xei9CdS8vUysrLzR0LytjYWJMNTI3K3ZSRWU2enVzVlRjdUhCQm1uL243ZCtaemdaWXdGN1hvdFVKNlZuMTRXUmxkVURTTzk1UWg3UzJLZXhMb2VqbjBKRFpOR0k2ckVvYWc0TGxBejIwdExWd05COCtad0ljclJJQlpkQXpTaElYVFVYK1k0aUp2SDNIOGd6MjdoVmhMRStJSXRCQ3htQ1lXY0FUenFFSWNUUkhtRGdHR01iRmpuWGo0WjhPOThIZmxNRTNPSUFBcFpoeFQyS0NUTG44Zi9PZi9uVnNJMm1sc1dWaktTQUc2VnhGYXFqbW4xbEZrdkdUdlZBNUpnMURtaW1zbFdpd29hYnk0eFpXamtVd1hoQmtiTnd4bFlqZ3dOV0F0NERJV0dZbkdqQ3hoUlMxYVhtd0FHTmJFd3lUd0pZa0xpYnN1aVU2bjZCeXJQQnBRcWRJUWwreFBsSkd6eXZvaFJtcFNkQ3pQUnV6TVRCK2IydnRjSHVqdGJEMHNVOTgvK2I1aTlWeU9WOHE3WGE2ang3dGIyMC9tQXkwZ1drdUxqUzFuMXBlYkd2dm41V0wyMjk4WTNEcjI1Lyt3bzh2TG05czcrNVU2d3V0OWxLdTE4bEt1VkpqWldmM3FIK3dmZUg2OVlQRHZVSytubVdqM1J2ZkdSODhYUC9FMTQ0ZTNpaE8rczNsYzkvNnJYLzZ4TWQvVEhuaVY3Lzl0N2QyM3JTaWFNbW5IYVFKeFVHaGZPWGJROXhoRzdDU01SZDltQk5EZ2FheUk5UjA1dEUxYlZxa1Z5aThvUlZBc3pEamZUNy8rZXhEa0hPem9vSDdJaWNja25yc2oxeEhPc1FwekNOUStVY05YUVRrbG94SG5iQUorbGhXUEphUVVCSkdad0dpWkZtb2hTSktkWnlSalVnakNPVjY3OURZU2tnUitSTWxLZW84dWF6UngveWVKY0xNQVVZemZvM2ZaRmhDb3ZySjBTejd1Uy84dU1TVFF1cFdmSW9LU1ZBN2NqYXlLK3ljcHdYN2dCYnBRY1V3Z3pwSTRKakg3OWJBbHFKYVpLcDV0QjQwZEdBOUY0bktHMzVKQ1luSzBoTlNzbk1sNFJJc2F5Z1pDMG1NeHlINUllZkhFMlVYSHJ6TEtIelFkemJUVGFvenVwOXlwSHhQam1jWjZNNHYvbSt0QUNPMUdCVDNrMUZ1VXFrZk5CY1BkN2R5VzNlM2ZiTTc2ZmQ2dWVsb2VhRng2ZHk1NVpYbGpZMzFVcVhTN3c2THBWSzdVYXdmdkxYLzFyZldWbHVMaTYyTmk5ZlBYM2xpNjg3N2xYeCtNRGpjdVBwc3FaQ3ZOWnNQMzMybFZHczFGbG9QYjczWDNYMTA0VU9meUkrT2g4WG00dExxWkhCODU0MXZuWG5xWTlvN2wrdnRXMXV2N2gvZXRmNlNXczZPWnpTc1pLSkRCMGF3alRDWndvbzlqUkFNb0VrWVlyK3dhUW9GbmJDYkRDWjN5NkpCWTdJZ0VBSTRRZ01NeklnNEFiNmFZSEZpejVWNlVvNWp6MG5iV3dyTHArS1pVcFF4dGYvRVVJZXh1RThzZ1JpaVhzOW9xaGdCWUZaTUF3MXptSVB3ZkFwY295eUFaM1J0SUF4aGR1YVgrUGpreFFWR1Z2cnlULzlFa2QwYVd6WjBKMnFKUmNlaml5T2JSYzZmZXpQdWJBaFgzWTJRQkl4ejJJdXI3dFVpMXNWV05XRXVKdDRrT20rd0lkUXNNUnM4NS9zVzdPUnJETmRmUEtsYVhYTkhzcE9ocVVEbkltaERPQWQ0Y3lLN0UrbkVydUtZSGdLRmd4Nit3NStDVzdHdTJ0OXUxa0RScTJNOFpEZHYvK1VIaTZzSDNkN2cvWnVIdDk2OXFYQXY2OWE0VnBYVjZyV3k3azFicmRyRzJzcGlaZFk2ZnVmTmwvNjQyYXc4OWZIdlcxaGNxRFNYdWdjN1diRlVySmFYemx6V1BtWFFIeDN2M2wrOWVQMzJkLzd0OHJrbkZ0ZlB0dGZXT2tjSHl4ZWVxYlhhNzd6eVI1c1huK2ptTXQwUmxDcU5Rcm44alZmKytYQjRpRGlzWVlTSnozN0tFRXJQTW9BYXNnSVdjRHBRQjE0MFNpZjcrK1NnU3l6U2VzQmk0WDYxc2FDYXVJbytzM0QrRk1aRTZsZVhPQktPYWhMWk9JTmN5d3NrMlpkM0tWVnJFSVNncVlLai8zelJWcHNhdmlmZGxrMG55MkJTbURBVEs1Z3A0QnhlcGtNMlVYNGluVUhqMFNCcG1UNTBJWnowQjJNSVhRZUF3Tnk5NmxMeTFTLytaTVNrWXhQQUVROUEyMkZOQ0x0TElGMjhMZWVkdUlraXVFOWdQb1l4aDFrYzdObFpUMFVXQkRrYmxPdkkzejRRaTRXTDI0aG1KTFQ1OEN0QWFCaTlVbEQzbFFRcWh1RHIraHFySU5jdWl5MkFldVFiLzBLTDBnR3hMdDZLYlA4d3RZYndqVStGdTNpeXl5SHVXUkppaEVkems5RnMxR3pOcmx6NjRudjNkcmUzSHU1dDdlM3RIdlFHdmQzdHZWcWoyYTdrVnJLOWhmeis0ZmJEU3hjdlhQend4eXFsYkR5WkxTaGI1MHVqems1NWNmUHc0ZDM4ZURDYjlMcUQ2Y3FaUzh1cnk3bnU5bjduWVBmdW5ZMHJUM2YyOXc2MjdseTQvdHhnMEt0a2xjNTRvbjFXdWRwNDVkM2Y3QThQWXFVbVA0YlBJcHZKay83RmQ3bEFsMzhYY056d2lPQ3hheGxpNHdqUTNsMWRyQi82ZVJCSmtpVkFDZTRvR0piWUZjZzhtQ3JpVXlXNEVubmdmVVk2TVdVcHh1VlZIUENhNWlIV1ZFY2E1MUNsRWFieWVlNVRjWEpTRStST0Y3aGJiUHJuZ1k3ZjRnQ3ZxY1A3eUJ6elF1dDVOQ3ZOTkMxMm9aRVVaN2dnQlZLaFZGUWc4amwvQmEzeXNZNXlsb0ZNUjZGWUFpbW9KSHdwSzVXVndjcEY5UWt2cEZCMGdpaVdzM0paRk5DYVhIeDRlNUlWVUhMb000dVdqUTV2NVhqTXhYSkNlYmFTK01uU0pyVU5xeWdpK1NVdHhiVGpPSDVLVHNpUlB3S3VvUFdoelRvUDMwYXovQ2lYSC9tdWxCMk9zc0xZSDZUTnE2VWJ6SmsyUE9NcG55RnpkbWUxc01kUnRMUDduOHdLRTkybXJ2V09lODFxdFRjcTlYUFp5b1VMbDY0OTlZa1huM2poY3VQUzBtaHpxYnE3czk4OU9tNHRyUzZ1WHh3YzkzUnJ1LzNnZ2VKdy9ZbVBicjM5N2RMQzJ1SCt3Y0xGRDJYNTBSLy9pNzlmWFRvM21KWTIyOHVLdnJkKy96ZXF6ZWFzdjlQdDlWdnR0ZUhCWFJsbTF0bXQxaHIxV3Bzbk1mTExiTXJURkh4RkRNbVJJaW15ZFJHZ2pFRVFGMlFFb2w5bWNRQmhuTEZXQ05kdDNmTGdYRVd0ZjZzQWR4TTRMSG92YkV3bGRma2doU3lBeXNTRFFERFlVMWFkVE1kamZyVmhoSlY0ckd2NzJGYVQ2VkNNbFJRbTB4RTBOcHo0Nnl5bXVpK1N0WjE3U0N0eWs0MVBKdkszY0ZEUUJVbVVYSFFnRFRDUEZoeWFocmtVVTF1MWNMMmw1ZnZwdUJXSjRjYkJlQndaZU9ieVFPMW0rVDFrZEdXZDhJR1M3T2UvOUFXdE00V2h0aXV5cHBhRm55WVJnM0U0UWZQWk9kVmFsUXBpcDJlV0IxbWNSRTRVcXhsVk5MMjVpYzFMWENuU3RsNkhncGlhNFBhQmkzVHlhdmJhbmZLendteGRDR3RXdk9PU0N6T0d3QlkyaE9pVDZ5QndmRnN4cDNRWlNCU1lET3RnQzYwTjNjWkNRK0R6UnIyc3BkU3FYc2kwMnhFbGppQnRWRHA3RzhPalI0dk43TnhTOVljL2R2M0NldlB5WnJNNEhXaDFkenFITy9mdU5SczE4V3cxRnhZMk5sdUxTN1B4K1BCZ2YyOTdlKzNDeGY3REcrM044M3QzYnF4Zi9WQit1SmNiOVJxclorV01zNXNYYnJ6OVVtNDRYVGh6dGYvby9kRndYRjlZTE5lYWo3YTJzbXJ0NXYxdjd4N2NZWjNMQTE3enJIYTFJeTNKTVU2TnlwN2VVWVM1Uk1JNmxpN1Fha0VvYmtnWlVwODhBVGZwUzZCN2xMT0ovMGdvMGhjaWs1a2pOUndUWTl1Q0NoSWlEZGlVT3RIdEJRblRtRTFJRGhJcll6eU9rd21qSWVJRW5RRE9jUlpQWkNKblRuK01Ba2ZqWDAxMDRuRURPTTU0cElTVFlra2VqQlpNckIyV1NkY0Jwb0JlKzhNLy8rV2Y0VTBHZ3RsRmNZazVhRGs2QS9CTnBSb25oVWhtZGFnL1luNGU2NndIc1ZPSldoMGE2bjI4K0dxQVloMmZnVVVPUzRqQ2trWnRoWnJrUm5lU2dhU1VOMGx5RXB3c2hBb29USUFTeGxMYldZcGw3U1NtbUlZV3c1Q3ZoSkdiTkVwNCtWZGtZcXRkalEzQkt1SkxReUtDVDlwcTZxOWRleUhmWHgzMmo0dUZhVkZiamU3QnhiTm5HdlhLYkRLY0Z1dkRYcWZHVHdLMzhzWGE4YU83OWVYMWUyOStwMWhwdE5iUDdEMjhwN3VEVW5PeFdxdG4xWHJ2Y0hmbDRoUERmcTlZVzZnMmxvNGV2blAycVk5dHZmRjdaNTc1K0dEUXJkVHFuYjFIN2JWTlRUUWRqUjRlM2J1My9ZNnVjaktGcktJYkY3YVZ5VEtjc0I5QktDSGxXNXNGUEFobkRmQWFTQWpHVGtnOHNDMUdoT084aUZhMmkxN0Mzd0doTWkwb0VRUS9ESitHRVNpaVZOWmxIbGxKQkJZdml1VXp5K2pEd1dsTytGSXhkY3dmSG1jeCs1c2g5REtObXZQZEtlNFZiMDVxY2tHQ1R3cDM0VDBFMzZsQUt1WmNtOENvQlZNazlveWhXa3lCeHVhUS9ZV3ZmcEhndG1reEdZWkxvWTFrRWROdUtzS0JDSFNpUEdFZDZ6N0JJUks2aXJjc1ZJblliRTNEblJhU0NJT3M4ZEEzeEVVcmhUdTZFYjRLUVp2QS8yY2lYZld3TTljc3h6UUtSRVlYUkMwN2VTV1F3cmxRQ3B0dVNWa3RMQUNOSFdtZ3JtdnhzeTFnUEZiRW1FYzJtK2JPcnYzY3dVNW5vaXRobGw5b3JTeTBhcXRySzJ1YjYzdUhoNTJkdlVtM1U2bFhpK1Y2YTJtcFVLMGRiZDFwbjdzMjZoM3RQN3EvZk83Sy9SdHZEWHVEbFhNWHF2VmFkWEdsdTcvYlBuUHgyLy9xNzVlTDFmYmxwL2NmM20xdW5COFBady91UDFnOWUvbm8zaHZ0alN2ajhhaldiSC9yelg5ejJMa25HV1E0dklSSENRNWNCeVE4Y29NaE1qQmhWQVl3SnZhRVdJb3dRaXE1STFYRUFjeWRGZWhQYUlXbmhpakh6T2MwQzFPSTBpbEhmUUtqb3VpU3lFazA1bXUwUjFzQzA2aERrT0lKYkVLa3RTR0hHZ01pZGFvd0ozcnBjQURnWDErQmFaS01FQWxzd3B1VkVJU0VWRXM4MUlzTTZqVzFHYkpVcWVGTXVEc2NGWXpTbkZpVk5CcmlSNnlSa0ZOeEZDc0FpR01UcTZuVndNTVpjT3hkT0lHbEk2MlR4OUh2RXJFZStzcHprbDYxQkpSa1dFMHlXUUhpR3lsNVA0aFZIa282c20yQ3RKM1VTWm9RdUdrbm95Mk5UbkR3U2hocjk2YjhqZHVveDJrenc4RHhpRlVFVy9uTFJyUkZaOU9WMWtkN0J4ZUd4d2M3dS9lWDFzNXIwOUpzTnFyVlVqV2JWR3V0L2UxSG01ZXZqbnI5eVN5cjFjcmxXa3NESy9WR3ZiVmNhVzkwRDQrVzF0YXI5Y3Joby92YVFKZWFLNTE3cnhWTGxZMXJMK3k4KzQyMnR2ajMzanYveEF2SG5iM0I0ZmJoM3ZiWkoxL2NlM1JmVjRQZTRmNnZmZXNYYzRXSmR1MXlpd3psLytLRmRyS01iR2QzK3ZHQ3JXVGpDWkozYlVtaG5OUklkWTdwRS8rN1lGYVJhNGgwaEl3T3NvTnh4S2p6T2tuUTNvQ0xqTWcwdHI1cWpSRTkxamVuT1grTUpnSGhBRTk0czY5eXAvRG1wQUdxSlJRVE1KSUlDOUZjSXh2Q2NMYXY0elpEbkp5TVZJdUhkK29pODJYRUErY0htZ3RRai9ncnZCQk90YnNzc2tJcjNvS2M1YksvOVBXZkpYZ2RnVDRjckZZSG96bktCVVNsRnpuYmUyKzZDV2FqaVhUSE5HZS9nb2NabTlDOHFKQmRvQUdzaHkxSnhqWTI4UzN0cExNTzdqVUZlQUVJaFNGbWJNRzVrV0lmamdKamhUM0pHN05qSFdySU1JMDlsR0pkS291TTJ5NzJRRG93b3hhRHBzWlVtSmhoTXViRjgxOTZkSHYvenUxYks1dVhhclhxUXFQR1AxZktqUzljZnFMSXgwNXk1VXFaLzhvMTZZLzZnNFdOQzhkSGU0c2JWNzc3MGgrVXRLR3BGN1YvUC8vazg3M2VrYlk3NDk3aDBhTTc5Y1gxMmtLN3ZyUStxeTlQam5leVNyMWNYOXc4ZjYxL3ZEczY3dmJHMDRWbXM5UHYvdjVydjZUa29XQlRJcEU4WVN6Y2dHQjR6MGtCTEVVMTJ1SG5PUjF4bXZIT2ZzS2J6STl4cEphZEw2dlJZcWk5RUZ5TWtEZFFIM080R08va3pGWkRjT1FHMEVZd09VVDBtUUdUbVJVK285akp3bWlPT09pand2VUdIWmNnNEcrdU9Ob0hPWTQ1NWo3RmFjd1BEcTdRV0FvVjg5TDZBUXZzK2MyR0lmUDE1ckd6N0s5OC9XY2xnUGNZb25KQWs5OFYwVHcxZEI1M3NLWkFKb2hWaWRveExaV2dGMEFiUHBtdUNGRzROdGg1c1ZrWExNVVlMaVRxaGRBeU5ETE5VNnhqRjFWUGZpdUxtQTc5Sjl4eFMyOXVzVzBGWXRiM2wyRVQzNE1iTDFhMm5RNkNYb0JYVk93RkZlWWF6aDJzcGtZQ1F6WklibVA5TTRYUnM3dmIyMHNyRzFzUDNyOXc2Y0xOTjE4L2QrSENELy93cDcvNzJtdEx5NHZEN25HenZYUzBkWGYxL0JXdDd0dnYzcGpPaXYyajNlWE44NGU3dTdsOHRuN3QyZVB0aDFtMWNlZTczOW00Y0xWWUxPdnF0M3ZRcVpaTHgvdmJxK2V2SFQ2NlYybXRhTytqMjluNzc3NjhlZVhaL3Y1T3ZybjRoOS8rWDRwRlFrRjI4cVpTRnBPSjhBYitjeEdHclo4dFRFcExQWndnbG0ybEIzYy9HZ05TMTE1SG5mUldyYkUydk9OWUhSQ2pQckQxeHhvaXNGRVVQaFFsVlVFRnZoVUxVdDJrQnhjWjJlc2g4QzRhSUVuVU5GWThrcFNNbzV2NWc5SWo1SnRZVE9FWEJqbXBPUktZM043a0lESUlkL0E0TzZBWUhzUTBCYmdrYmp5dFY5RUlPeHFKc3IveTgxOUNBZ0lUc1JTWGJxbHdjcUJId1ZZUXhKb2c3Z24wRXdxV0Fzam9pT0tyTUl4NXdSZldtalRrUTJaRWRKTkFwMG00SzZESHM1RVRNNzh6NFVjdUJLaVBrV0o5N0l4T3FwNk5kWmtpdzdNcTRHT2pFT1VhYmxPcWljZjRrRENXQXFBWEN3cXY2YlhZSkpiM2Y1UEMyWlV2NW9lTm9xNGh3OTd5eXZxSG43dStzTkJlWFYyNGZ2M3lLNy8vTzArLytOSHhZS0NOVGIyeDhQNGJmN0orN2JudE8rK1ZLNVZpVnRoKzhHQnBmYU5hbkwzOWpkK3VyNXlwbHd2bm5ucng5bXUvdTM3bGVlWDRVbUUwUE5vclZldmE4ZmNIM2F5WXZmVFBmN0ZZcmkxZmZiWldiVXFnbllPZFAzN3puK3N1MzhMSUM0UXo5Z243T1ZxZFRXalFscXBCNlFDMm1hTjRpY3dETUJhRVVBb2lRc0NHaGdMcnd5UWlSSFlQMk1sUVk5VUZqbkIwemxCdnBBMUd6Y05RWFNaaS82VkRUVTBISDY5V1FSRFFWS2VON01HMHZlMFFLTEhsRk04ZkJ4bGRoVWlJZUdVZUgyckJTTEIzSmx6L0xTUUx3V0ZObnluZ0V4Z0dnZ2lZNWl6N3k3L3djN1p1RkFNU1E4STVjTmxxZWI4dVZuUzVJS1lJRk90NGdVRk8vSFNwVmdjZk80QkQ2cldHbWhQalN5eXNDWXp4UXpoaUY4dDRuNjI5aW9OYllaM3p3MTJpWDNrOXp3WUdTdXN2UmRtT1E2ZUtRcHBudFNUZFpJWFVwVFdRRjAvOHhSSmkvZWpDRVdTNlE3Q2JZSkE3dC9ialY4NTg4dUptN1JNZmYzSmx0ZjNaejM1aW9WN3FkenZIQjd2WHIxMWMyamdyMmFlVFViRmNsbWIzM24xOWtpdlZGeGJIdytINUo1L2J2M2NqWDJrdlg3aGNMT2JHK1dxOTBkeDk5R0JoWlYxTHFycXdVRzZ0YmIzK0I2MXpUL2QzYnBlYlM5cGdMQzAzdXR0M3EwdG5kdloyU3FYcU96ZGVldmZCSC9Kd1BVSVZBOHV2TmxwWUQxZkVyaGl6R2l0d3hoMVNaR3NiSEZXTWQ5dEpYSHBxblVBZGV1b0dBQWpyRzNCSSsvR1ZtNnFKYndqWVFFZ2ludW1xaTNpU1BkUEtrZjk0VjVVTGhqZnVoRERTeFFYRS9ZNFN1alJZOHd1WDN0cGtLc2dKVVA4NVpOMXllTWErVXBWcVhkaVJUaThSU0FEMTQvVjVRVkFyeGxMRnViUTBxNGlkUUhVaXJ6RmNzSmJtLytvWHZvekVJaUplRVhKK1NnS3JvdHQ2ZWMyQ2NZOHhIQjQ2THd5VEMwekRBRXd2d0RVQXVuR1FSMlRRRUN0U05lOU5hSGRPeE9lMFFWZUM5M3NXQ1NrdFJTTk12THVFenRZZnBURVFaa1FyKzB0c01hVE5SUFkzeEhWRDl3QXNHRnZCOGtnMHpIbjE3RTljTy9OVGx5NnU2eWEyMVdwY2UrS0oyZkJvMUQ5ZVA3TzJjZlpDclZyaW9XU3BkTEIxZjNGMU5UOGJQbnJuNWU1Z3RIcitlcjdjMUozTCtxVW5icnoyclVhalBaNFY3dnpoUDJ1dW5LczJLZy9mK3M1eGY3U3l1cjYvODZqYVh0eDY1enYxcFRQMVJtczB5eFhiNXlmSGo3TG14c0xLMnIzdnZySi92SGZqNGJlMDYwTWlHM0V1UDZGTXc1YWt5NDlXZkxid2lSNWlVV0VPa2NXR0VXZUJucHVlZ3JreEZyeGxCZzFVcEVka2g4bThlWUZTdFJLYThnTDh5T2dPR1pzWWptNXFjdElyLzAzS1pPWXdMeWthWXhDeWlzWlRlM1M0VFJYemVmSklUd1FERitsd054R3NFU0VkdFgwRmcxU2tJYld3NkdRYTlWdEY0b3FhTjJETVI1Y0ZoZnRYSlVSa2RZZHUraWlXY25USVR3ZTlhdGlHQnYxd2xkUWllcUZFNlVFVUVudzBFQXFWZ0VKRHJCM2lrczZSSHZsODAwMGRiOXBGUmxkOEF4Q2owL1FXcVdERnZXajhSaDM4WkE3emhMTzVjYkFHS0JnclptU3M4YUcvU01IalZpd2sxTVhWVDM3cTJiOVlMczNLaGRHVks1ZHlXU2szSHJiNGYzbXQ5OTkrN1p1LytidG56NS9ORmN2NVFuR3dlejlmWDFoWVhoK1B4eXViNXlYNXdZTzd3K21FcjV5MDI2VnFvOTVzVHZzSGkxYysxR3d1WnJQaDl0MGJpeXNidy81UmMzRnRlV1ZwYit0dWJmbnNySGVROVI4VkdtdmlXU21XTzN2YmgxbjN2VHQvUUVqNG9DZzR5QzVJU0o3aGpWWHNyNEpoT1NkaXFhRnVIa3g0WjYrR0ZOUUZCQTFOakRubXUxZTFsZDBWVVBJWmthcXo1OU1hVWxNRU1hV1NxdUlnT0FqQmw5WkVyOEc2VXFpdGVUd3Bub2FyZ0l6UkVwQmVKSUlMY2NIa2FqT0RxTXdjQjNISFNVMkZ2L2lQc1BpWENSNjcwcndZNDdOT0RFa3pVQ1J0ZUJheDdWejFFZVdzR1M0bElqUTk4MUZuLzk1ZitFb0lMb0hpakNWODFrRnFTV0VSR1FXQWlkUS9QNkRsU0ZzWnhwcU1VUm9MdVp1QXpPMGw2RldMb01EY2NNNG1JemJseXNTS2RmOFlxZU5laVhtY0cvS0pMb1p3enhxTGc5Rk1BVU5aTVo0MEFTQm54QUM5V2xRU1FYTXh5c3Rkb3pCbjNMZlpLYzNhK1ovLzBuKzEwS2hjT0wreHV0eTYvZjd0NWNXNjdpOGJqZWIybmR1ZFR2ZktVODlVU3JtRHV6Y2xWYWxjYWl5dTlUdWRqVXRQU3FEM1gvNW1wZEZxYjU3TlRjZDNYdjJtN3BZTHBWSmo2ZXo5NzM1emNlUHliTmc1Kyt3bnUzdGJpK3NYWjRmdmw1YXZIbTdkYUM1dUZGdkxzOUZvVmw5V3NJeDZ2VVBkQVJ6ZHVMUDFLclpHZUF3ZHN0blNiQmVVaDlUMFZSZ2taQmpiV21JQnlQaStxZStYTWdEMVFhcFgrbVExRFU2RWpBN2RaOExGZm9FSHk4dHhRL3libWdLRlRwNUhBQXVLRURkclRXWHJ3OWNIMnlSYUliazVpU1B5aFRTRU1rNWlmcjlZaW5IWmtGOVVDOVlnQTB3YkpFeGl5R0pibE9BYVl1a2xRRzUyckoxYVU2SzF1Nk1PTWljT0tvVGxPc20zVFVKODhCaVlMZzUrVm93eGxEQndzTkFmTGRSbXQra2pPRUJwT3lPSHBWZThwYTBYaHJBVzNzS3hxMUZUR1oyWVpvOGVDZDZ4VG9LZmpLZERoZFQ4YVR0N0V1VjRQcGdCRFlzQi9qQmxyekxHY1A3Z0JEK2JxekZxY2oxaGVvdW5XOElRWGZucC9QcjNMVld6NVhham1PVU9PcVBOemJQVGZ1ZmhlNjlwODcxLzU5MzIwa0t1dDk5ZU83ZCs0ZEtOYi94V3E3MHg2dTVwMjcxMTk1M2J2L2RMbDU3OTBHajNsbWF0MVJ2bm4zbGgvL1hmS3VZTEM2c2JxNWVlT3RpNmQrdVYzOVB1S2FzMThxWFNLR3R0M1g2bnZuSlJWODNlNGFQZXdWNHB5eWFqNld0dnZsMWIyaHoxRDJRd3pJWGg1d2IwZzBWam84dTk2WkRraVl6UTV2a2pIaE1ndGJ6NGVRUXBLOE9Obks5TDhaUmZDZE9mTlZlb3l0MFpUaUZtZEdtUWpUeEpYTG5OaUM3SFkrUjVRdFdZMkhqZ1RwQ1FjV21CQ3dtTWZCUXU0K3FNdTlpcWNxczFucWpnUkNOMDRCdy9hK0MvcWdoa1AydS8yOUhLYnRyUTZzSXVJRDJta3hUcUVFeGhObGZFRjVNU1F0NGprRS9OT2Q2NjhRMGJNYURzL21XMEQwTmhMMkRKbitMQktydFBoYXNaeFRVaHl3Z01HSWJHM21IeDRHTWFtd3R4RWl6NVVxcVd1VUtPOUNraUthOFE5MDZHSitzamIybmlFMTBhS0hIbTZyRkVZTVljWEZkVjZWS29TbFpuMmFBZVFjOUZ6YldHYW5uWVdMVEQ1ZjdMVjdPRmp6MzM3MTg4dTVhYkRONTQ1WFZaYTlUWjd4d2RiVjU2c3N5L29NdTFWODUwSHQ3ZXZQNmhNci82TVMxVTZxT2ozZmJacTR2cjV5YURRYTdXUHZQMDg0dXI1MTc5clg5MjlmbnZiMTk2YmpUb0s3NHExVnFsV3M2TmU4MmxqVktsc25mck5ZWDQ1cFVQRFR2N3crNWVhKzNTM3M2OVNxVTJHSTNIdzM2eDJ2aVh2Ly9mNXZNanRvYXluRk9NUC9aTUtTclZ6TytPQ0cwdkJodlpGZTk1WUcvKzFDVGx3MENSYVVyTWd5dTk3V0NNa0NjTTJEY0VpcFROSnBTeHpCVkhCZ3NvK2RvcDA0UDBQUFNyMS9NcFQvcWhOVU1nZzBjTUU2a1hIQTA3bml5REI4eUREQmdPWkgwNldGaWNJT2xDUExzWlI0TUJKdEE5eXJ3aENsNFJ3RUZnZWdVRFhURldDcHV2ZzRYQ1pzTE10VlpoSEt6bWt5RXFTd3BBK3pyUDdjZDh5cWJlSWFnYkx0UmVMVUU4NStNNGs1SkVJZkhtaVBYNjR6YVV1S1IyeE9zUWtsVkowSS81ZUoyeU8yLzRPNUV6VkhuRkV4REJOQ2RzZ1pRMFJsb2JYdERhRkxFWGRJS1JuSDZPeVhVcHZ0Q2lGeGRRNG9BcjFzZWUvZkwxaTVkcWxkTDlCdzhYVjlZM041Ykd2YzdaUzFmMzdyenp6c3QvVXFxMlN1VmlQcHNXc3VKd2toOGU3WlRxMVhLOWRmLzEzeDExajFhdVAxK3YxdVRsdmJ2dm5uLzZoVC80NVgrNGQvUDFTcVU4bXd4di91Ry83QjBkdEM4K3Q3LzlvRmhiN0IzczFwYzJKc051YSsxTWRmbmkwZTdEbFVzZk90amJMcFdLRzJjdTNONTlhNXJ2aEh0ME82UXcwalpkQUE1WE9DbncxZVZnbkNteS9ENEdDd0FGL0NUSEdMYmszRzJ4bVZGbktaQUVvNGZDbk5qVXdiZUx0TjJoNWxmd3NrelJxbmxoRmZIdXc5VCtzZ0Z2aUZ1bWVCZFJSV2ZoSXg1MTFrVlZMckgvNVZtUWdvbDRISzFna1kva0Y3dzh4T09BSkhweUUrK2x5SEU0WEc2S0p4YU9KZ2F4TUFnVXVJYlhpQ3V1Sm9wZWg1WW5paUlxSmhZcHJpZmtCRVJ3RXA4RXFnN3Q1K0UxajBoa1N2REpaRjR4a0hHb1Y0MzBYNEVjOS9TeU1yUmttQ09PS0xBU0dRd0p1MGp0T3BqWWdTNk1VQXhSb0t1cEdJWXAreGtpT2VTaW9LbzNMVDU0Z0dQeklhMkxUbG9vdzluWUgvK1NXVDBqV3hlMHNBS3lQNjRnQlB6cFkzbnoydGtmK01pelA3TzYzTnplZW5qenpUZGJ6ZHJ1bmJmUFBQSDBiTnhmUG45NStlelZjcjA2R3ZRS3BVcG41KzV3NzU2dS90TkJmK25NeGNiaXh2Yk4xNVZBaW91TFd2ajhXUGJ5eHNVUGZ5UTM2WmFhaXd2TGEydFBQbjMvOVQ4cFZ0dnl6UEgyM1dKK2R1dmJmM2gwMUJscGN6OGJIZTA5VXNRTXUwY3lRYjI5K0szWC9tZC9YRFJYa2xDV2pMZUgrRVEwSDYxVGFCSnRPbWNLWWg3NEtoYWxRSWtmdWVOMzdvaHNoeXdMeGQvRGNlaDdmK00zd0NQTXhhR29rQzNtUzhWY3NUZ3JxaGFtcE52eUdmL2l3Yjgzb0owWUgvN2dzMzVPQmw1WTRsQWkydm1XdG5yTEdrVXZ5ODBmR1lFM0FlajQ5MWxXNXMrRnorVGgwb2dsZTlvUmdrTjlNYmIvSFFaMktMVzZUa0tPVDNmQ2dSampFLzlpSll6MjFUNENKdTJTZVYzamNVYzV3RW04cGNqSi91S2Yvem1oTklsRVl4dk40Z3hab1hPWUNDRGdWRG0wZFFWUUxUa2dFeVppaVRONDBjQkFjbHRpaDZuajBuelF4eGcwMFlHR3BIUDI2eW1wVDRjT2FHM2dTUERNYVZabUIzLys0b1FFS3JCVUNJT1I2Wm1VZmgwYXlkMkkrNkJEUW1Gd2tGNmJLOC8vK1MvOXA4MTYvZURSM2EyZGcwWmprZDlFSFk2WFZqZG1rOTQwbDAxSGcveWtYMTlZSG84R3plVU5zUmtQQjRWU3ZiMTJwdEplR1hhUGk4V3NmM1R3NkoyWG14dVh0bTY4dW5ieGlVcGpZZWZ1allkMzN0Kzg5b0lXblc0Y2N0UGg4cG5MeFZLeHNudzJHM2Z6NWNhZFYzNnp0bngrMERra1JlWEwvZHp3Ti8vZ2IvbExNY1NPcEhQSUNsU29PVGNINkRXZ1RsSXIzd3lOSlF0TjZtZHdLa0xMSWdJMGdGSFFpUlZYTk81d29UUnZDci9Hb1NaUjdtdEZwSEEzV1ZFTTkwb0xqSWY0YzRNZUxqbDEwcEQwaVNtdUpxR0NWNTdmS0dBeXl5TGpSOFlSN09XaGhpdUZuZGFFM0NVSWw5cTlVSXFNSVFIRHdVNFBkaUk2S1pvQ0NvOVN3TVJjK04vTHowMEh0dTVWL3RJdi9MUWpUNk1KTEdKSHd5SmkvS0xBaVRTWm9nNFo2Tk04T2dGUVlLSmlndGhGUlBhTlF3TzVlTUZIMTdiNUl2WkZqUTBNUWM4eWlHZU83RnpBZTQwaEhoZEdUME1kcXRDVSt4RE5vcnRmTnFhTjdrU0NOZ0x5QWViQXAwcHczaExycGZxclgvaS9sZ3ZsOTk5Ny9mQjQyR3cwMzN6NWowdXo4YlZubnMyUGpyUlJHWS96MDNIdjdOVm5aNFZ5NTlGZENTcUhQbnJ2dGZWclQvZVBqL05abFYrOEtWZnJ6Y1hlMFdGOWFXVjhkS0JSaXlzYkN5dXJkMzd2ZjVrV1NodlhuajI2OTFadjUzNTk3ZEtzM09oMnVnZmJ0OWN1UGozTmwxcUxhMGZkbytOK3J0bGF1THYzM3R1My9vM1N0ck15Z3ZxSEd5T1kxT1FMMU43YkJJWndqRm8wRG5PSE8zN2xsellZUWhFbllxSkVwN21LakZBMmJReG5Lak1oY09tbFQxTTRjdUhNQjFxWlVoY0J5VVRpdDBoOHJ0dDVYYU10Qmt1STZ3SHpxbysxd0RJNUtZNU9PU0YrMnN4eUVkVHV3bmNFTk9kVUFxbWlVR0dzRCtkcGV4NTZVSklCcm1xWkkrenBkVTdqQ1pHYXdxdkJiekI1QWpnVXZLL1M3blk0ZjlyTkxzcTNqTUt6KytGYW9NZ2pPdFdsMEJPZ3lBSlBNdmFGSXdpNFhvalZoSzBZVHhWQkVzU0VPL2ZwYXRMbFRSZ1lUMEc0NnhqejVFUThXWGxjYWtKNHJTdnJZK0ZsTFRiY3lJNmVxTU5KaEZiTURpWlhLZlBwRXM4L1lTSGpVT1FoZXc0aXVVZm5LMmUrLyt6R3BRZDNiNzN5Sjk5UmI3VmNXRm5iSEE5R3RWcGwyRG04OS82ZFVyWFVhRFR2MzNxdldxdFcyaHU5em02bDFscS84aHcvQjVwbDczL3IxL3U3OS9QRjh2YUQyd3ZucnBTejR2cjFaL2Z1MytvZWQzS1Y5cmxQL09qTzdYZms4dFdyTHk1ZmZQSzdmL0Nyc29tMkVOM2RyYzdlMXRxRjY5UEIwWEF3WEdvMVN0WEtvOTBiV1VuYmpFS3hwRzFHb2FMd0t2SnYwdGhwWkxxVExxQkx4ZyttU1MrbFdBNzJIb2xBQi85V2hralVSbHNFMHBDZlorTS9FeWp1K1BuTHZFekJtc2t5TFNwKzVOY0JyWTBOUDNRZGU2U01yNnhSK09hYU9aY3k5UmFLdVZKSkJBaElSSHQyNVF3NGFBbG9Pa2xTeUNTYkY0eDZXVE1zcUhTUFFkSGFvay9JaUVzOEdsN2tQcEY5QU9GRVBreHhSUWpRNHVtRXR5Z0tHS1U3TmtYNWNhNHd5ZXZRVHFZdzRXNU1TMXlIcjJZYzJwdG5Hc3Q3WmFwOVV5RnUzZ3VwWDUxLy91ZC93bE5HMExNSUZJVU9PYlpCRG11aUR4WWFhNUVza3lnUm1Yamo4aUY2RFVCa0NjZFRLcTBOaHpYTGdEek5uU1VwMy9xWUY2dUZqQjlmOTJLL3prcnp3VEpqRkJieHBZU3JpZmFpMkUwMktPaXFSTUx6NUN3RFllSk9pOFNDYlExd2N4WFhXYlZVSE8weWViV3k5dE9mL3h1TlNxRzl1bFlxbFM1Y3ZLVGg0MG11VXErZFBYKytmN1RYT1RxOGNPM3BjWGVuMFZyUWJNVnliZmYyMi9sS1hmdmM2YVJmWFZqdDdHL2x4OTJGamF1VkxMZjl6cmVhWjY3VkdpM2RLZWUxQWVwMXM5bms4TzQ3aStldWxSWlhSNE5SdmRWNitPWkxGNTc3dnU3aDlzcjVLKys4ODA0cFArUE9kWERZWEZyLzE5LzRtOFBSdnNLSDZGUTRJTEFPNGlZQTZjQURoWWdaaWUrZ0Y0Q1hTYk1hNFdzV1dVMUUvc1ZlVmo4YmNlNWlZNDN6Nk1ROEZXcmNKRGlYZXpyUk1zUThkVGltSGMzQ2c2U0xYb0ZSQUxTUStCS1BqSW1KeGRLQnp2MEdGbVplRWpuTTRlOFhhRm9TbEZRRmt0dHFBSEt5WXBVMGJ4ZmpWVVpGdUN0TzUvc1RqNEt6ZFdkbUR4ZUdRQ2NXL0d5SDV6d25lRnNHUXAybUJXMG54c3JyL0o0Yyt3Y0FaMklsKy9GazdMYUtjamI1T09WbXhhVy9qRWlFZTkvaUZVSXVIK2ZpU2VLUVlEVVQxWDZvb2lZc0lySW5mREI5a1BOVGw3VCs0Q24rc2R3bExwbGV6cGF3cU81THE5YTFRQ21wMkxBWDhaWnZtM1NndjdNNFRpcjVndXhZSVl6NFppTHhCS3BjbUg3b3FmOTF2WlFkSEJ5OC9lMXZ2Zi9XbTN3TnExemJ1bmU3dGJJNTZBOGswTUw2ZVhHYzVyUHBlQ2plcytGeDUyaC9kTHhmcWxaN0J3ZWE0OXd6SDM5MDcvNTRQS3F1bkNzM2x2WjM5MlRFeHZxRjJXaTR1THkrZlBYRnhRdFhCNGU3eDlzUFgvdVZYeHlOY28yMTg0ZmJEOWV1dmVqOTJ2Rkx2L21yMnNab1czODhQRGpZZjJmK2RXSFhaTnhRaEN6T3phbHp1VEtvVTc2U3JsU1ZkTTdZMWxPOVdLZVlWWlRwSTR1VHNOV1ZxN2dwRHVSZnIzdXpZaUx4S1pVWVd4RmJFZEhMN0Z4bjFDVWJNbDNCVnhLR0s5a0xxYkhsa25zemJuRExYRFdnTHllRDQ1dDgwV3ZHb0pjS3VxZ0hGTElMNGlFU2I5bzZYY3JsWGcwQ2NUeUpsYThWeDgwZUVaeXlyY0tlRk03T2xsc3lkaTl5MGJqQUQ1ek5zanhabjUrVDBjRktJN1g3TWtLVXAwTmhSSFQ2Z1hkRXA1c1I1R29PNTdDUjBhdGpOaHB4RXphT0k3WW93cWVhcGc1RlBGc2p2ajBVT1p1RURRMUpuYUIzQ3Vmd2RZQ3N6d1BFTUFFTGNsNklZTm5PRnBUWnVFdGpINGlQNDBtRmt4a1c5WXJIZFVTOFR2WXVIdkYzekJVYnRTeDNmdlB6VDEvNXFMWnUzWU45NmZHalgvcHF0VlkvUHRpVkVHVlpyVlI4Y1B1OVNtT3hkN3ozOE8xWEphVUdhelUrK2JFZlhEKzdXY0hWdGM3T3ZVcWpmZUdGSCt6dFBoUlZyYjM1OEkvLzVkR0RtNWswMWRUVit2SGg5dUJvZi8vK3pjVzFzMHZuenZidXZYYm02alBhRGxVWFZnYkQ4ZFduWHBnVVNyM2o0OFBlK0swYmYxQ3VLdG9WUUJUTGlmUTZpRFpDbWpDU09sS1NET3FiRDBlemtNQXNERWQ4Q2l6blkxbktQUGpldlNpRkw1UlNBaFpUQXBISVptREV0RGM1V2JsWTlFckEydFRlcTNnZnBiMU5Hb0lBWW1nNXVRUTR4Ykx3dktrZzRlc3lnamQ0S0JScGlCQkhlRnlKczJSa1JLQ1RQNUNxRmJ1S1pnNEJDbE0yTXdwMDd6Y2NEb0VuaGZNb3B1QmRTa0VCclEwQWEwU1RGZ3YrUmU5VUVFT3JBb2FuU3ZiMXIzNTJ2dVh3WmwxSDNFRjZlK0ttSWNKUitWelJ5VXhlZVhTQkkxalpuSkRzRmE5c1ZDU1Vjcmt3NlRBVEpYZlJlNitTSHRjb3h3dWpKU1ExOUpKa0FBNTZzZUtUR2xLU2pCQkdrOWF5azRxdlR6eG5FMVlLVVpPK2NFUkJtUVlpTWczSVdBaHdHdXMxbTN6cXhmL05Rbk81a2swYjVlbjU2MDlwS1E4SC9YZS8rOWFWcDU3WjJGZ1pEL3FsU3UzT0szL1lYajlUYVM3bWk1VmFvNmtNVVcxdkhqeTRwY3RlWTJXai8raHVyYjJhbGF1VGZyZTJ1S2JWTXV3ZVpvWFo0c1lWNVpDZCs3ZHExVkx2em5jV0x6NVZhNjludFdaL01Hb3RyKy90N1E0T1ZmWlh6cHcvMk50VzlCejJ4Ni9lK0VlajhZRkVWUURvT3VZUVFXalZEbHdyUitGYTVnV3VMZ1c5U1J4dVNVbGJSZU1kN2JIRE1RTDF5UVlhemxhY2diYWFyNDJlWk01Q3R0TXBiQnBiY1BkcEhwa1VkbUZKMDl1MlBKTVhVcjJTbkg4T2tmRGFzcWlHdjZtcERQa1p2dnlHbmw0SkZ0cXBXaS9WY3lXRTVJcE9tSHFzZHlObVJUcEhWdzdmbDBPbkhsTlE0V0ZDWHlBTGdPbE1UV0Q1eUw3NmxVOFQzdzVjMXBQamtyQ21WdVlHQ0NRRXFsbGhmdGdwWW4rc0p4WUFIOTRpV1BudHhSanJuYnByYllQNGFKMkllWHVmTzFxQ25wMExpOEZMaFNzQWdTNE80eHovZVNLdVdlSCs4RTF5cGhYMldVbGVTdHJLMHBQUXg0RXlQRU5FaHZWTkp5SzlaS0I2N2ZLTHovNkNCR3czSzhOQlY3NHRsc3Y4MDdKUnJsNnZ0dHNMMCs3KzRjSCsyc1dydGRiaTR2cWw4WGpJbFhReTBWU0gydzhtdmNQbXl0blpkRkNZREtlRjZ2NnRseHFyWnl2TkplbHljUCs5K3VxNVJudWx0L04rWS9WQ2ZmWGl0RkErMnJxN3NIWkdOd05jakdlejVlWGx0MTUvYWYzOHhlRmd0TGE1TVppTVhybnhQeFV6Ly9LRFg3alFvUElya1NEdHJDcTFRMFY5OUFTU2F4enVGS0NUYlFQQVdZT0RKd1h6bWEzYThkZ1JFcGxMMDZrTHRMcTlCa3dWcE1BWTFyMjZWV0sxWUVnZGtqaFdGSjJRK1ptUHdnMEI0QStaSlFuSmVjQUpwWVJFQngvdUZhWENWTnR1MXJtTHlaUy8xYU5JRmxLa2ltSWpHTVVhZ0E1WmdYMXp3anBpbXhNcnhNeURLSVg3cVpKOTVhcy9vR2p6cnBsd2RGaVRtMVZwRFVTV2RSYVBjSFNnS3dDSVd0MUhpbXd5NG4xVzNVWkRxVU5keXFSd29KZXg4T2MrVzVjbnY5L3A5NCtFSk9pNVVMQm0yR25wdXVUOUhFOGR5V3B5aVF6RjNZOWgzNUJoRVZVQllMTEFxSTRMdXRvQXdwQ3UxTVhqQ05ZOVgvL09QL2ZVZjVBYjVwKzRmdTdlZTYvZnYvRk90ZG11MUZ2RDBWVFdialg0VXQ1NDBPMTMrRjhJRmI2ZFdzdU5la2Q3Q3RaaE1hc3F6M2YzSHJUV3p1dktOeG4yeW8yRllhOHpLL0IxVmMxVktXdkhXaWxYYTN1UDdsVXFqZnR2dmxRcWwwc1ZiUktLN1hOUDZHNzNjRytyVm0vcVpxWFJiTis3ZTdOUXF1NTF0dTl1LzdhMkR4SVNIZVV0MUxSYURoMFVRejlKejg4c1dsMzhGeDBBMEFWSUszb1VpYWg3UWtRa2k2OFlhcXh3SjEwUm1tNTRlMkVjQURqYlVJZU1LYUt3WjVLTzRJSVFkN0F5R1FCT284eERXSzhGZGpkdUNla1J1bThrRmtGd1cwdXNxMWdLRndXMHM3cDZ1YkR6QjQxakhRN0FHa1VlOUQ1ZXA4U0VTb2ZDSFdJRTRyQmtkTWFTUVlyczU3N3kvUXAxeDNySzd0ckprTEFKVUcrc0hiV3grU2I2bmRmemhEdWg3OFRzZHdrSVgyNHllQVRrdUhmdUo2QmpMRUhzUk83VlF0eXJxV1hnZlpHYVhwM29GbmNiYUNMckVPVXludGFsTFlRR1R1UTZsSnpRd0JoMnBCRHpSL2hnS3ZJVDkzV0VCRFJyeTU4K2MrYXoxeTV2M25qbFQ4cFo3dXFIUHRIdkhkKzdjL3ZXalhkMWxWbFpXcXcxR3BKbE1CaFdHKzE2clR3KzNtK3RudGVGZXYvTzIvWDJhcVhlNk93K1hGaGVsYk9LMVVVRlFwR3RjZTM0WUt0U0toZnI3WHFyZmJCMSsrQzlQMTQ1ZTYzU2FPMCt1SGwwMkZrK2Y3MWNxK3ZPNTg2Ykw5V1gxNDY2L1hhemNldlc3VWE5c2R1L3ZYdjRLb0piTDEyWHJMTDMzL2FSUFllL0VOOGxBR2lNazRaczRBMEpyVFVUNW9Cam9OeW1CdkEweGhKTXhDM0I2dkdwaDBUTVBsK0EwemQ0bUhrMUJnZHc2bEk3SGFZUmU0SmJaNlRsTDdaRkxpaUZPbklPRGR3UjZsa1FYR3p1QnBnRkpNUDRzK2lDVTN5RFZhOGlQaGtvNGhzWXpFbWhDd3lkNW9sTXFyT2YrOUluRlk1TzZteEZkS0dQV0NjWFIwd1Rwa1N6YjRvRmpGWDdyVjN3Q21oL2ZGNHZrajN4ekl0N1V5N2dKTzlneUVMeXhzWUQxVlFuTTNMRjBCQmxkeDZlRmlhT2F0NFBEeXZZWkJoWGhTQk9wZ0hRaFl5Z0o2Yko1QTRiWVJ6cmVORWVwcVVoclB0ejUvNUtzN0s4MHNnMXFzVzFjMWNQRDNZbGc1SnpwY0kvY2xwc3QwcVZpdTlWOG8xbXRWS3BqSVo5aVpncjFWckxtOFBKcUZ4dkRJLzJOSGwxWVpXSDVGbFJGeTN0NFBPajN1Qm9iLy91bTgwelY2dVZhbVA1WFA5b2UrbmlzOXJUdi8zS04zb0h4MW0xT1RqYUx0YWFXYkhTWHQvWWZ1LzFQLzcyRzArLzhNeTMzdmgvNS9OalFpRDhRY1JUTzJabzR5dzdyQmllRHIwNUs1WVNnaDlnOXlCcEthd2hvUjAzUVJzQUkxTTBjYmNwREErN1dEYk80eXdhMnhaeGFFY1VXaDQvbTlGSUJ4cjdDcEVoTkVNUURMeW4wY3RTTWRvVEJRNUtlMDFOaGlPS3J0NGl4amV3QXlkdmFpWDRXVE00R0NlR3p0bXc5Rys3RWlSR3N1MkhpUTZnZEdZV0kxT3dxNGhjVTZvU0p2dVpMMytNT0NiNkZQUWE0SGgxa2xZMCs2MGZwMlErL1F2R2UzY3dQUE1uN29sWFozSGxhVTJvekozQ1dpY0pGK2tmbnV5VStPYVlJeDJNZXRuRHNNc2duVnNIMzR1RWJONnhrVElrc2UzT3ZoeHpKS1hBNFVtZDJQb1I3azZWdHJJVk5NcGhvL2c4Yy83Y1h6eTdYSndPTzdYVzBxM3ZmbHZKV0R1VzhiQTdHQTZQRDQ2MFl5bGxtVzVHSjZOeHBWYlZUcVJZclEwNkhXbFNybFNIblYzWnI3bXdwRnY0L0tpYjFWclRRYmZiT1JRVExZZlpkRlJmUHJ2MTN1dFpxVmhyYjA2VStVdThBZDlzcjQ1Nng3M0RuZkY0dExTMmthODJsRTJVN1BlT09yUGE5cVA5bC95UEcrVjA2MGg4VUZsRkI1SUtYbmZ5c3I3MEVPTG9LMHBwRm5Ga2JjMGtqcmdpT3BCa082eVJtSW9hSFBjR3dya05CYWIxUUtqSkhlcVU4YmpwOUFnMWhkVEpZOVVEZ0ZBZU13Y1JVNitZVlpVZHBMNFF6VXBRUmFRaVBaaU1tRk0vNGhDaDhJQ1FqWTBDd0RIZ2tKK0h1L0NLRmtGYUlHSUZnaWJyUlF4RWFDSjRHRzFwWUlvaEM4cnVIMVdrOGcxbjByTzJKY1FmbjZlTk9DYUxUL3g3RUdMa3BNN1VDblF1QmNLd0FCeTdXakFSMmR5T0lpb2Z6L0srbkNqbkZqU2tKOWFsb1dDTmtoalNnWFRPc3JGNUxadnNneS9rTkVEQ09aQnM2SFhDei9qRmZpSmF5RkVhNjZ1bEtTanlpdHhPM3RLMlozbmxpL1hLdVV0bkZ2WVA5bSsvOWlmRDN2R1pxMDhmUFhyWTd3MjJIdHk5ZlBYcXlzYkdzSGMwNlhjTHl1dmRvMEs1VWluWHVuc1BkOTk3YmZYaU5iN0tsRmZjTjdKeXFYZTRXMmt0NTVUWVcydDdkMiswRmhabnBhcTJOcEs1dTNWYlc1d0hkOTZmVENlVmhsYkhSbUU2V3I1d2JUZ2VqYmZ2ZGtiVGNxV3BmYzZ0UjYvMVI5L3REN2NsWkFtQkpUeUpWdHJoTGxRaFRQU1NtVUlmSDlnR2Fsd29oYVZhRVZkckhJa1lMTVNFTDJkWmt4MkZBOTFMQmVONW9ZUXgrWndPS1Z4VGV5RFdac241OEd3YWhaV2ROOVJuU2tNK2VNRWNCemdRaVJKZ3N4ZWhHb201WnlHVWc0ODhycVpIUkZ1S2lvc29JWFZ3V25FeENNY1RiWVNIVjRSRzJVaUNSRVZvc0MvUU1JY1lCR21RU0pCUkFGRXZwQlQ1NHBkZmRDYU8zVXVFdk9LVnVDY0V2WFh4aDlxVXY1Mk10ZUU1eWZSRXNYWWtoTHVZZWRQQ25EcmlDaUNlU0dxa3lTU2ZKdkhpUVdpTnNvd0V1a3pBcll6ZHh0c1FPRWc3QnFRVkpBWHNBVm8rOEFBT3dDanozQVNjSUEwbHhURUl5NVpXMXY2OUM2dk43dEZPWjIvbjNlOThjL1BhYzYzMlVxdmRHczN5L2NHZ3RiVGNhdFJMcGVMZ2NLL1lXbjU0NC9WeXFWUnB0YmdSS0dXbGVtTTg2SGQzNzVmS2hWS3BKcUU2QjN2VC9xSDJFYnZ2dmR4Y3Y2akkxeVN6ZkxHNWZ2NytTNzl4K1dNLytzWnYvTlBheXBuR2duYno3N1hYTHgzM081M2RyVkdoTHBWZmVlL1hEbzcvNkxoMzE0R0ZxeEVXNFFrWE5pU1MyZ3RmUmxJUFpDeGJiendpbHRnRjJJUWFwZEhoWEdKREJ6RWpoRjJPajIwaTBjcy9waWVVeWYyQ21JaEl4aWtPZkFMT2VJSEFaYzBzaUNHUXVzZmZJZFNVb3ZNTU1JckNPWTBXTTB2bjBZUlpPbGhzQVNZZ1NrekM2S0JWVkRpSzNTV0VZa1JjVXl6REdPMVFTQjMwT01MZ0YxMzBtb3NyaEJDSW1GTHdwNy84WVI3VTgvQ0hmVXJjVUpLREk0aUplekZWNFBJNUJLWWcrb1hTN2p4bWlWVkJVZHZwS1c1a3llSWhJcUhna0VjbDZybFN6S3Bya0s0ZTlwSUZrMWc4a01IQUZCc1Q1ODhkaXowVjdIYU1mZVpZVjRrMHlUV1lqQUlCQ0NJblg2Ky9zTlQ2V0szWUsyZWxWMy9uVjVyTDV6NzBxVS9QUnQyN3QyOC9ldmhvKzlIT1ludTVWcStWaXNXdE8rOGY3VHlVdUJxKzBGNW1nejRlaW1WUitidFltUFdQU28xMnNkd29sZ3FUL242MXVUd2M4ejNEYW11bGQzeVF6MG9TZXpnYVZxcTF4c2FsZDEvOWs4V2xwYVA5M2Nsb3RITHUrc0h1VnE1Y3k0clphKy8rWXBicklXYm9FczdHZm80MjJ3QTl3MHVPTkNsSitCR1cyZ3dLd2RYUndSa3NHT0w0OUsybnpJVGRHWGhpTDloaFNtYUl6UXBXQyt0eWdnYUJqTkFvSG1mWmRJSXRGNTgyUXh5dk1wS1M2Yno4SU5HbERSVGVNNGFWcVNZajFHQkdnY0hBR0dSa1poZmhCUVd0bFl5QkVVa0VrRkJFa0NTUVNGb0xIbVdUd1pJSzY4VTRzT0J0Ti9mR2l6NEIvckx6ZUZad0NtY3ZybzJLSHhmNnJwUm41UDZ4Rjk3VXpZOXl1VUhlR0RZd3ZtSE44ZDhiRmRtNllSMnBTNG0vUU81WGwzWXB1ZzZNODd6MTVTYWVJb3RiSlQ5KzRRTk1zNkxTaGN3bWsrQURFZ052TU9vT0tXVWhicFRpZld3UWZFYUE5eFQ5Sm5uR3oyd0xGMDlqWEFUSWZyUDBNQnVmRnZPemR2c3o3VmJ4OExEejZPRzl4Y3N2Zk9SelB5aytlL3NINDF3MjFCNHFLeDhLSGc4bmswbTUzaXlWNjYyTlM1VldlempzSCs5dUtRV014eE14cmk2dTE4NStTR0Uwbm82RzNlT3N0aWduTForNTFObTVQNWtNSlh0dU11enZQY3phRisrOSsvcnF1Y3V0UnJsYXE4M0t0VnR2djVJYmpUYXVQVityMUx2akI2VWlsM0lYTmhvKzVCZjBzK2VRMys2RUFDWFlpK0U1Q0d3bkpYdjFKWnJrWTl3Y1pBU0U5MisrQ0ppYi8yZFdjTlBKdzZDbEFNV0JISTVLNFNLS0JFV1RnNjJ4ZTlWSWtLbnNUZEtrVHZSNHd3bUFUMkdyQTZFZ0Zna0x3c1hMRDBvdEh4K3h6Qk5uUWRDVEo1VVR0ZUV3SDFnNWcvS25UaEt0c25MS3RpcnVkd21lSHNJRlU2RDdzcC8reWpQYWRmZ0p1bkM4UGN2REV6WXRiR21JZTIxTEdLa3BxY245dUlpRnA0bHhGMHl0QUthV2FNcnhtaWc5VEdSV1ZjektYb1gzRkpqSWR4dDhva2hHWWFCZTZ1V05EUG5VMlNBcHpraHBKaUM4SlRMaDJIYzZNa1RwUnhNUU9SUUVPemxwWGlVa0VWUktGeXJWSCt2dTdhd3N0M3ZkN2pQUGY2VFpyQ21VYTdYNjlzNSt1YnFRbGFwTFN3dXQ5ckp1Tng3ZCt1NlVhQ3cydExscHRQTEZvcll4V2FWV3FsUjdCMXVqL3RHMFVCeDNqL2owUkZZbHJ6ZVdhMHRudDk5OWVXRnRzMVJwSVBGMCtOMXYvT0haSjU4clZtcjV5WEQ1ekpYdDNkM1cwcnB5LzUydFYyL2MvWlh4cEl2U29rUlVqVURJRkZoU0ZwOWh0ZkE4a2VjTHUyQ3ltNUJFRHU0VGtxQlFNN2pBeHZtWU1tZHVnRkd5bksxQm9TMnlXRjBZVUJBbXBvY3VDRFE0MkZCQWN6bjUzZ0xHRjIwc3I0WlNoM256Y2hBQUlDZFZ4QU5JNGhVcUtZRncvQkNoRlRXQ3luOEV1b1lSUFFFNStKZ04wWXlnd1FGcytXS1FLTURQOVJWemJoSG9MMlEvOWVXbkZOYnBsNkFJWW9XNEJuSG55akpnbzhKMlJhTXlaWEdhTnFrQUZxc3Q3a21zSFlkdlErMGFLTUVqQjdOWnloVEhPdUJqbUJ2a0VyTDQ2bWkvYWJoT01xSEdpNGJnY0FMVVNSelViUWY2UUlUd3JXMllKcGlWN0FCTldhNy9VSmFkYTVZTDE1NjgzRDN1TExaYms4R3g5RklXcjlUcU16NENuVnRjYklwUjcraXdkM2g4dkw5VGE5UjB3MTJ1MTVXZmp4N2R6VXA4bEtDa1FPL3RGN1YzbitXRzNiM3F3aXBidWZ5czMrdGsxWVZlWjd1NXZLbVlyamFhdVhMbCtPRFIwdnFGbzRlM3lvdHJCN3U3bmVQdVVYZnY1VGYvRnUvSUlwYVhMYVlrbE9kZUkzV1FQV2lwNWpxSENhVWdLaEVUVUViVHpyTXR4RWRkc2gyeFlHdlpKOEdXWHRXMkVVYlN4VHlhZ2FhWUY4SUV4cmtESzhJTnM5S3dUVW1UNW1zNlVTSVEwc29GWnFQaXVaR0JHVUZGOUFYOGVCS1JpVHVrSjd2YzZMSVdwbkFSNE9RTkZZeUlORWE1TmtFUVJ3Q2lXb3lPb2praGdRYnhLUXIzNjl4VzhrQXdia201T3JCWDhUUk8wbkJTVTRrWmFUeWJsWlArTm9nWmgyR1lqQmdOUVh4SVZWWVh3UmNZVWp6Z3FYemh5elBHTThZc2JUQVFJb3VjclQ2dkl2SVJiVzdmWUdLVVF4L0lJbVQ4L3llMGx5N3R4UytQKzdsYWVWcVJmOGJEYk5JcFZhdkR3ZVN3Y3pUb2p3Ymp5Zkx5MGtBeHU3ZDN0TGRmTEZmYkcyZjVJUGgwMEZ4ZW1SWEt2WVBkNmFoWFcxalZIaWRYS0E0N2g2WEdJcHVwa3RKM1MvZm11a3JzdnZmcWJOVExxdFY4c1RydGQ1Yk9YZEcrcHIxNjd2REJPK1hHOHZMeVNtZTgvL3AzLzNaa0dRbWU3S0EyZHNKeU1xdERKOXhqODRHM01Xdy9RRERxaWlzemloSXlNVkN3S0tVeHlTWVN1U0tFc1NZa2lQRWNlWU11WWVYYTVFYTFQWm5JRk5BK201K003NG1FRmpGcEJYZk05enZ3Q0dZNk94MGhEZDZTSklRZnNnaW5YZzJFTmxLaXAxUm5JTmtnMkxuQmg0cXhCTGNTZ1JvS1F0d2VTSUZjaG9KWmhMNEtpWmM5ZzFvbmZCQXB6alRqeFFBRkRQdDFQMmJoa1NKN0dHL0tGZm82dlBnMHAyM2xvb0gyZ3lTMlhrNzg1cWltN0tHdGdML1A2MCtvc1ROakU2T3VTYTR3emhXbWNnWCtvaXRrd1Q1WUdSUEdRY085MkVSQVJJZFUwY1NzQzI3OEk3aE56U1dCT1poVGJkYUdMaFVhSVJIRVpiRllXYnY5M25zcnE2dGl0YlN5OU9qKys2Vnl0ZGxlcWpkYm8ybHVjV0ZCK0ZLcDJPc2NIUngxWmxsWmpKWldsMnVMN2VIUi9uUjRWRjljRVovaDhiNHN6RjUvZUR5ZGpMVFhPZGg1MU5sL2ROemhaK0JYbjN5eHRYbDFPdWlXdFBmTGlyUEpaTlE3SG8wR0J3ZUhwVnE5MXozdWRoK09wbjNjNWNnUVEwVWVsLzVJREZnMHZodDlxaG05MnNsQUUzQWlrOEdpbDY4NnpZcitySGNoUDlWT3NFUUtaaithVGIxUFpLQnVmQWlkT0NqeUQxUGI1bW9TY1dsUzZQR05taUFENXA5U3dvY0JSSU5HeWF5WVBqbEp0azZoUjRLQnBmWDBGUWMvcUM4Um1FV2NER2hHVm9nTDQ4VGR4YjBPVGgwV3o2SGtEK3RJSklKU1NDNk1TamVxUFF3R0xxS1JmV0lxa3JWUUFna3IxOXFqNnhaejdGdFZkN1A5Um1YMUk3ZUU4djdLQ21nQWIzL3FVTnhwWmFHeXVqZ1V1RnljbFhSeGdnTTZydG4yajcyRWZWZ2VLSU91c0ZidFQ2dmFmbXJLcFRaam1EUE1HdG1kTzFKL0F0eVNxVmEvWjJDSUtvbU9hTExGRkdIVm5kWHFIOWRpdmZ6a1U3cEJiTFJhOTI2OGUvbXBGOE5HdzRIMk0rVmF2YkcvZnpBYVQvS1RVYjU3cEt0QlhxUzVRclc1cE52ejN1R0I3ci9yUyt1RC9uSHYrR0RVNisrOC80NXUzQ1hTWkR6b1BMcFZyWlIydHU1TGt1bGtYRytmT1Q3Y0sxYXEwcTlhcWVkMVRha3M5Zy8zU3ZXbGc4NTlaSlJVaEsrdGlLaXNUd0c4MTRTbDVjVndsUTNNeit1R092eG1nTmNKZGhHQnhNdkwvSkZWN0Fyb2xVczBSRUh2WmhESUZhSlJ5R0lRWnJjYkhjb3h5bUdraVFzei91T1RNRWsyUG5ZbEYvbVFyV1JyY3Fnby9RZFNFY0ltUU5FaVZtYUpWd2dzenlTYytXaW92YWxpYjRvTWZoNFpJZVp1eGhIZ3VuRWs5RG13aDZsSnV1cUVCcnp5dlFYejFKS2ZIb2VlSnljV3pETlp6K3FFNkxKT1hwdVpLNW9BZFJKSFRZNldJYVFRSGsyWENnR29KaUVHRDFGYVh0R2pJaE9xNmZya21DdkpjSGVDMFFDQ01aQ20wZXllRVJUVXdoazlSK2tGWTUxMXdKTmVGd0RZMHVWdWdlWXNwRFlqSDIwMkw4cEc5Zkowc1Y1ZFhGbFNYQzYwbHd2RjRtU3NLQ3J1SDNRcTVVS2xYS3BVcXNWaXJyZnpzTFd5VW0yMC9KbTVzUmhvMzE1ck5DYVQyZkgrbGxUMng4SXpiVm9Hdlc2dXQ5dGNPVnNwVjNZZjNNdFB4MW14V0d1djdXM2ZyMVFiOWZicWVORHREWFBIQjdzTDYrZi81S1ZmWkRraWxWWHdKVjlBOHFOZzFYSmxVa01kV1FwOVovUlkzNlJ3NHRVMXhNQWVpeW5JakxqRkhreERIQXBDeHhVVWpCaUtFNU5Dd0tUMEJ4bEFnazhmc0tUWTJ4Z2FIVTZLNTFWUkYyZ2ZjQ0Q1aFZoMnBmc0U4bEsveHFBQjdSVFQxQUZGVVlmZm5uZFJXeThNUWlITXhVOHJFLzdNWmJTWUVaZ3hGVE5TdUJTb0lhek1KUjdaRjc1OEdaZ29GRmxrZDNpbVZTTitFZnJJekRLQWo0aERPWjNNbStpZjhSNnZzWTVFeHByVUxxTHR5aWdOdEtCYzhuZ3VvOEhCaDhHY3pjK1FKMVlkSmNTVVRpQ0Y5ajZWZmc4R24yQm9aYWRwYSttbnl2bksrKys5OTlRelY2cmxVbTQ2YVRUcXg5M2U0VkduUHhnZUhIYUd2Uzd2OTg5MGUxbHNOWnZWYW5FeUhCd2Y2cDcxUUs0U2dGNlZTckZjR1hUMmMxbWx1YlErR282ckMrM2pSdzl1dmZsU283M2FXanVyK08vczNOV2VYclo3OTVWdkZ3dVoxc2drWDlnNGQvR3Q3N3hVYTdkdTNmdzM3TGgwVVpCazg4Z1FnSWloTWxja05iT0NQenBrREpjcGFZTE80UTBwRlE0SmxlMW1YVit4U2JLOU9BaXdFUktjZkNqams0ODV1UWxYUmxNUlNXRnRISytTT3Mwd0FJSW1tb2tHdkNDZVhjeHhnbkF4SGtZQTF3d0laMGtxUCtmd1NQd0xONDNnMFFpQ0dXMCtySFBIdUk0NVJsTmdLeEdwd3N2Z3hRRzJxc0FSenVqdUtMRTFZQm5XOEIwQW5IU3IrcFVya0ZCZzROSDBSWk9ocGd4WWg1SzlUdTZOU0VRSW1taWdvcWIvVGc3N1ZsZGlNd0VSNHhudHRxUVJKQUtwUUxkUjBNenA0ekFtUkxPeGFObTQyRGZ3cG9qNUxGWXhPMU1zZnQ5ZzBPdHMzWHZobzgva1p4UHVRVXNWWmVpeHRyZWw2dUgrNGJBL0tQSVo0Vnl0cUEzUnJOWmFyTlZxbmEyN2o5NS9VOXVWWW0yaFhLN3ExbGFkNDJHZmVDenJCclhkNyt6V211M0RoL2UxZzgrWEtzdWJGN1Ria2NXYlMydjU2YkJaS3c1R1U5M0pEb2JEOXVwYXA3dHo5OTUzYk5tMGpKT2tjcldGUjFZN0hRQmxSVVNZWW5zRE9KcGg1SFhCWGdiaWxKcHhFWUNuZzhBY3FMR0pNQkJvanhzRS9MY3hEZFQyUUtkNXI3cWdWalBaMmFGMmNwaEFlT0tOSFlTRkFaOVdVUXdobll2VU1EdWlJSk1zQXN6WVVnVXhyeURXaW1GWEEyVVVjWllzdk1zSmYvQmcvSWMwdUZkbm1LWGlKdEhuQmgwUjRpZkN4Q25teldjLzg1VXJESVZGNEdncFpGaGdyQ1BRYytZUlNSZ2I5Z1FhZlY0QStNMUR6UUlGTlEva01SZ0o0dXdEa3JRUVlLSVMraVppMTF4OUVWMnM2VFFCZ2U1K0NDUmRTQUFtc2hxR2R0dFg4MUwxVTFuMTBzNzllNnVyNit0ckN0eXMzbWhxVzNKMGZLVGgrM3VIRXo4bzlrZmJKcFd5ZHQwVmY3cHowbHBlTDVWclV4NjIxSFA4NjlpaU5qU2xXbU00bWZXTzlyVzNxVlRxaFdLcDBWNWF1M2p0OE42Tnc4UDl0WE5YdEwwWlRjZkxaNjRlUEx5NWR1RkpTVEhwSGpRWGw3ZTNIeng4OEVmV1JXbUdpQ2VScTlmYlZ5Nm9rZEYxOEFQb0FtSjdiUlcxOHdhV3FiaURGR3cxNHdDdkk3bWIzYWhnaFlPWUc4bGJJOUpQUEhVUUt3RVFTU1JtYktvOVBaNFdzYmlwTWs4MWFhUW1oMTZPUU1jUUR5N29nby9Ga1B4MHdjWHoyblVPV0w4OWc4Wnc5U3dpSjJBdGdpZ1pSSXUyeEJaVEJsSzhrZkZMRlhRcDVyaENnREszaUF6NGFBS3ZlUmtxQktZWEVSMGlVRnFnN09lK2VqWENSd2UwVEkzcWdiU2tORTVxREE4ZGhXREVqVEFVU3pVOURscGVpTWVmQ0xpYUlCcWtuRUdqZkp6TWdMbGc0QU5ScmFNSHVmSlVCdlJpaEJYSFdMYXk4WFBOZGZCNG92NlpZbm5wYVA5b2FibDFabldoWHEvNFcrYVRWck10b1JUcjQ5R2sxejArT3RnZDlydVQwVERqeWp3clpZVktvOVZjWGwvY3ZOamIyL0V6b0lKdXBxZXo2ZkhlM3NQWGY3KzVzcWF4NWZwaXY5ZXRWU3NyRjUrcWxZcmR6dTdDNnRucGFDREgxeHJMbzJHM1VsOGNUY2FsYW0wOG1iMzk3bSt6bVpGZzJNd3hUWkh3TWhKcjFSakV0am1qUHJrVHRlbzJEM2VUVW5ST0hCd2NjOUtkVVhRUkJHSFV4REFJekNwc0Nqc0ZsbnJaUWJNSUhSZG02Q0dZRnhSdUVGSkQxT0Q3b1JNNHV6Vy9VSWdtcGtNODlqTys2NkNwZ2w4Z2tMK1lsTnRBSkFpc3BvQnpNRmNOQjd5cHVKeXZxS0QxTENySVA1K0xnY2s0TWRhYkhDUzM0bWdYZ2pFV1ZyS3FCbVUvKzVYTERIQUFxVlBtaEFZbWpNbFUwUWsydm5YaE8xZUlYWHRxZDhjcFRZa3NuRW5BNUFVVGVENk50aEJwU05UV1FyS2JvWkJ6WWVaSDRxVTZFSjRaSkpLZjFwbUNldXBGdzhvUEtEN0sxZnBpUGJlKzJ2SnZxWlNiemRaa05odU9Sb1BCVUtFdkNmZDNkL2NlM0MzVkc4cmpFLzRYVFZYcnVWaHRGTXUxMFRSMzYrVS9MRlhyNVhLcHhHZmdTN3FMMVM2bFdsdVlURWJqMGZEZzRZM3hlTFN3dWprZGpZNzJ0dXJ0bGZ4a01oZ09SSzVZMGpWQklUSVlqZDUrNTNmOGZUd1pUZXJ6NFFIZU04QldmSGMreENaZWc4UTY4Z1JRcWdIei9FSG13WVh5SmtpYTZzVnE5bTRnZFdpM1pRdGlsb2pVY1B5SmlXaENDU013TVhsazRDbkNZVHh2V3FEQldXRmxWWHk1bjFHTTRmb0RyWmNyNzFLQ05lZTBkTjBVRFNJaXBCREVnVWJiUFZZdEFEWnllTmRkNGtnL3JDMFozSHpoUWpVOHJrNU1BWE8wRU40YUJURUVzTEpCSW9BOWRYcUFvOHQ0OXJOZnZRcXBVS0owRUt0aEJvTEZHSmZJREZJVXhiajF4VFoyRENXQzBET1RHcTBMMDNJeUV4dVFmc1JGTjR1bkh1dHRVMW9pUnFnZ0hud2Q5U1pSRStySEpHREVEYlkyRFRhMXYwWEZ3UVJHNVVzZktXYlZVajYzdkpDdHJDeFZxclY2clRIV05yWlE3SFNPdXAzalJxUFdYbHBZWFY4VCtmSFJZVVVibXFKV1I0VkhudVdTekR3WjlLYWovbXlTMTVhZG44Y29WWXFWeWxnYi8wSysxbGpzOWJwN3QyL3MzM21qMmxxcUxLem5zMnpuMXR2TjViVjhvWFMwYzcrK3NEU2JqTFZzeXBYSzY5LzVWZS9Ed2g4Q3NLQnUweVdxM2FPWERDOTdrODd0YVdjTi9NcUIxMjFEOE5yNVlHa2R1QkI2TngwcTJHWnVLTmRoSExjZkY1RUlpNm5VcGM0d01GalJuMzdxOTVnNE9EdDJmUVExY1FGdEZPZDdCb0drNlM3QmxrUXg3WXVJTVNKTEFzZkhZUUM5dTJLdklqZ0dBcy81RS9HYWxnaTJ0R0dORU1hWVNCT0VqcnE0YWpHSzVRb0hnaGRNSWZ2WnIxM0YwZ2hGeElzdHJtQ2NlVkNaZHd5bnczUldLTEJRY09JN0hab2JtQUlnRlh5NXROQTJrNVNramE3R2VDNzVNS3dFTHl5U2FvOVFneEhXMEVoV3JuVUVHWVFxcWFrcm9SS25wdFYybzl6Nm9jbDRxQ3ZVYXJ2ZXFKZWJyVmFROXZxOWUzZnVpRWJ4clRDZVRjZjFXa1ZMWVRJY2pFZGRQb1kyblpaTFplMG1pTGZjdExtNldhcVZNWXRXZTFiV2ZZRXVEWlBwcUZTcVZSdlZmSDFwLzhGdDNRRlhXOHVUeWZSbzkyRzkzYTR1ckJVbWZaR0poNjRTOSs3ZDdIZTNkTTJRSCtMdFNmd2ljY00zTW1nOFJIZEpnZUtieStSNEhWTGFWdkEzWk5URm5wN2VXWWJwTkdUS2UrTTJyVTJKcWFrY0VPcWMyMG5GeG9kTXlIVGxOWXoxa01tTmhJZU1XUk9WaGlZRXdvUklwSFpQamJGRUdiR1ZKRWVTOERzWUFFMkFDdllnU0dQU0o2MUNITmhJZmNjZERoWm5wV2VHRUFTRXFvZVlNOEdEUVFpa3lCZUVKd0lnSGh5RWhJMHRtOCsrOUxYcldSckRURHhDb1ZzTkV6eUdMSWQ0YUI0MGppNUJtaGF4SkxlV1NyQk9yelFsL09Ra25UQlY4SUZldERwQXFhRVR4aE1UUzJJKzdvZ3plbXFVbWd3SE10TCsxamlRSkxsY29jZ1RhNG1vNllyVDBuTlp1ZDVvMUp1VndzcHltMDhkekhLRDRmRGgvUWVkem5GZDJ4S2V4bWlna3ZqeFVudXhYQzFYOUZldWpJZWpqSjgwendhRFFVMmJuRXF0ZjdnM25ZMjduVTYxMlJ3TmgrU2RNZmxLOGh3OHZEczY3dWF5Y3JGYTd4MXNMYXhzS1BsbjVkS2szNjgwMjVOQnAxU3BYYnYyc1U0dmQ3RDdIdSs4T2F5bEJKN0RUOGxEdHBVVWwwQkVzdzlwcE5xdVFVZS9yY2hPWXg0b09weFFTWXJPOGRvN2VlT3JQOHdMQlhreGJCYVFaclhGMUdXUGdSSXAxQ3J6NXR6SWN6L2dLVGMxTXNFc3kwUlB0RUVhOTl3SkdUZlp2dTFHV3JxTWNXaDY5V3FJM0NwQWtXSU1EQjFmQkc2NGxWRVdtQjFkeExFOWpud0lDWC9ld0xUQXVtUWF3SUF4QzZ1Q0diRXpCdnphMTU5RVZtY3VoMVJzemdWN2JxSHhCT0pyMWhESDB3aUh5aXBZVGhKREVvamNCTjMwSjlJa2E5d1hjNWhXMHM0dk45eUlzNmxUWDFweTVpVFZVUnh0dzZpZVFXZWFWa0NOTUJCTkpvTW5Xam1rcE9kc25ML2VYajlYTG1mRmZHNXBxYUdPNldTOCsyanI1czJiK1h5NTFtd291MHNsS1R3WjgzOEZXczFtb2NnUENOUVhXbU4rbkNGWHJWV240MUdtalhnK1ArcjNSdDFPNzNDdk1CbGxoYXk2dU5RLzd2RHBnOTV3WWFGZXJ2UE9WRzkzNitEaCs3cEpxTlFYZXAyRHdteFlyTGRuNDM2eDByeHc0YWxKdnI3OThIVnNXOUNjSE1pSjQ3Q0dtcmhaMWtZcGV5MkZpSlRIaGxIanRwVEYrU1V1S1kvUjVsc0NkWVNab01kbXhEOEVkR0JZd2dzbytzWFRmeTVHcVZDTENBQk11Sm8yUG94eDVwVDRpVllyalZVbmFYbHYzZDVVUGxhSG81TlZaVmFrWGlaRkN3THhoQURWSHVQTlU0Y0lsRGpDdVFwTFN4NHptc1p4d2JzMnpJQVYvVFJiVGRPd1Q4R3VZVXp6VkNHN1B3RWwxb1dJRFdWd3hDc1F6YWZYR09ZekpSVzFXUWhHRHVKWWNnc1VwZERNRjdjSVBrRE5yNVdCd1haVU1Fa2xXT2dQaDJJQWNDR0FUcXFESVlPeEhYdzhBbWsxTDcrR3d1eCs1M3lXcXk5K2FqSXRhSXZTS00wV0doV0dUU2RLN2JwSnJaUnJDbjJsZXdXNlVueXYyNTJPeDdWR1F5b1BSOE5TdFRvWmpaVG90UkpGTmhqMDhubHQzYlV4R2ZPL3NFZWpVcVdpTzFWdFRYYTI3aFVyalhlKzlidVNiS0c5MGprNmFxeWN5V2UxOGFDenNIcTIzenN1RlF1ajRYZzIxWjZxdExsKytlQ28zemw4M3grWFJhbEk2ZzU5dk9YSEdoS1R1TWRLWEs5aURXdWxzcjF4U0xGWnh4aVI1cE5USWlaT1ZWSGIydDdkaVM5bVM5a2ZrTzVFQXBQa0N0c2MybmtYWnhNSFMxQ09lUXp1ZUJWVy9HbmlLMGh3aDJpU0ZpYUx0M1Vsdjk4UnMrK2dERzdrVmk5MU5mR3BhNUhoWEhaL1Voa0hDOGxGTHhtRXdhNGQ0anBGOFl3Nk9mU2hKS2xENmJXVWZlV3J6eVRDZkZiazkyTEZIV25FbE5oS2ZDVkNjRUxvaktTQ2NjSUlCdVFNVm5FS1BwR3JqMnlrUG01UjZJZ3dGUi84eE5EWURTUlRpdHFTa28wZVV5SW9Cb25oMVBBTmU2bUZHYnltWllYNVFsV05rTGw4TlZmOWVGRTdrT05PZnRwdDFhcmFsSS9Iby90Mzd6ZGFpNjFtbzkxdThmWm5oUytoNnQ2MDNXNW5KY1czcGhRN1BzS2orTmEyZnRRZkREb2QyYUpVcXNnbC9WNWZ3bGVyemQ1NDlQTExyN3ozeWplMzNuNjFzYlNTRzAxMWR6dlJ6V2xudTdHMDFsbzlOK3gzV3UyMVliK3J6VXovdUZmZ0IzYkwrNGNIT3c5ZTVUc25uaVd1cGRZRHI1QnZaQlAxc1Z2MU5rQzZZRTlIRWg1UXdRYmtKVlV3a1luVUdjYWhNL0RZMC9SWWxieUpoZkdMa1ZwUFlYVzVUZHptc0VpQXNUanRTZURVU0tNOUJSNGdlb1FoREkzRGhDS0drSms0eU82YUMrRkZtWG5icExiRlFRYWJHVW9IdXZDT2FYdmNUUHdneUpkZTVoZUJ3cEt4eVVyZS9vbFlaNUhCVWtoQXJ5c3VtNHBUTEJ1ZEZra1RaVi85K3JNZW9LRGhNM1FPTmVhRHhnVnhQWUVYSzJvekZoMjhFVUgvcENTR0FCYlJYSGtUNnVWYVRlRTlUTjBlRFdmMWVvNHdwRy9PcFNmNFFIcWRwQlljTENUMllrdEF3aU9wcTdiVmZCRHhoVnpsb0h1K3dtK216SWJIUjlWcVFSdVBvNlBEM2UyRDFjMnpDcXB5cVRBYURiUjNZZmVUWmRyRktOUG5waE0xK01ETVZMay9yOFRPRDdueUU3R2owV1FrTWNhRDNvajBYK251UGlvYzNENjhmZVB3OEtpWW15eXNMdGNhaTYrKzlLMmJyM3g3Y1htMVA4NVA5dTlWV3MzcXd1cmU3ZStLWmFXeHFKamUzTGlZejdXM0g3MkxLYkV4S25EZ1p2a0pySDBjc1M3Wk9kQVhkMWpyY0JBSU5hRlBmWEJ4bDdaL0RpVnhGQTY3NHhNN3lwUmg3bVRzNkU1SVVIR1pBTFlBbWxyK2dJd0dwSTVwM0VDWXN0WFVGS3hWaTZDaUNvMGtnMExXNCt3bUkwMUdaQ01hQTVqQ1RZNnBhclZTbktqbVVhek5JZzdxQ2JXY3RoWFZqSTU3SGtIS1RtcEUraUNZNFlBWkdCV1VBSXFZcjM3MU9UYTd0bnVtK3dQbVV4OVRRaXhwL1hrTXpNRnZDcWdTUUtDU2hxMmUyOUdyQVJnb092aFdOdXlDaTFPL0xUZlY5UXhHbWtKRjNkYlBiTkJWNXZSNmNFOXdVb0V0NW1aWjZoQlBiM3l0dkVacmV3Q1N6VXl5VG01V0xqYWVxWlNMdFZLMWQ3Uy8wS2dWUzRYZDdiMkY1YzFhdmF3dEN0OUkwclo2TUtyV2VMYW9FY05CWDI0YUtuK1BoN1BSWU1ULzV5aU1lOGVUOFZEM3dMcWhIeHdmamdmOXdkSDI4ZUZlNy83TmhkV1ZNODk5NnNLNXRYUFhuK2VYZVhMVDVlV2xVcVc5Ky81M1YxWlhGdFl1OU82OVhtMHVETzYvTml2V2RXRXBsc3V5ODZwdUoycnJXL2U4aVpjS2NTMGxJSEN3dktiSUFDK2NmU2swaVEzZGNhQ05vUzZLUU5uSGVOUERnaDJvT3JBNUZQUkRBc0wwWVhhbDBxQWhYOEFvMmRvbk1oR2dZRmt6RWczRCtTa3ppRldEVVNmMjkxYUVXUFJFTmo0N2VNTzR4b1BaWkVvdndtdE9uSlJpQnNpQ2oyaFJ4SHhpMCtJMUErQjA1azJndkIybXN6MDB3TjdYb1dGYUFNUzZtczRhTVpkdXZiUWUyQ3RtWC92YTgwSXB4R01sU1FneHdsU1NnOTJJcEtWMnRObTZ0aFNBUTFBU3E1YU51RitCUHBCUUFMTlppVHRYOWkxaE9RVzl3dDRmMjVCV0tvbmFyQVRvblBoN2FxYlFnV3lvbEhUMitnUVRXamtDQ0hUTXBGV3VaRis3TXF0Y2JWWno5ZEswYzdUYmFGUTF0dDVZWEY1ZXJKWkwzZU9qN3ZGeG9WanVkSTZybGZKRUFUNFlhUmJGZW00eTFDWkdXWC9VNncrN2g0WGNSUGV6V2czSEI3dmF3TmVyOVdxdFVhbTFTcldhYm0vM2I3K2RIdzl2UGpybzk3cS8vazkvZWJjM0tSUUw1ZUYrKzh5RjRhaS9kUDY2QXIzUVdDbVdpOXMzMzZtVUpxVnFZellkRFNhek96Zi94QWtRWFFoTDlESUN5N3VOeXZqUGlSOEhwamdJbXRScnY1dWV5bTdER201aVVnR3lkL1M0bVZDNHhmMlkyU01EdE8zVlExNHlHRDNTUDBENHhzd1JpNDRuQmhtSlg2UVJmaUhnN0N3U0VBbU5yaGdkSllSMEdzWnJOZ0lZODdRclBiMlk0OSs0ZE9zeUxyL2IyUTRCdE9Xc1ArT0U0VUFRTXpFTnNFbkppZG5YdnY1UlliM3g5YUpFU2Rkazc3a2RISWoraVJudW1UUUp0cUpwVzhxSVdOVGlwUUpTM1NLWWlCUUtiKzRaQmplRnZsdW1oQU93TUlodlltUlZsZ2ZqVFRtMjA3NUV3U0Z0MkZlamhuYmNXQUZ6S0s5cnM2dmRzQUI1UWtZWloxZjJPNU5zMGoxL1ptVjlmWE5wZFcxdjc3Q2xIZnBpbzFiamphU2x4VVdKMFRucVBIcTR0YjZ4Y1hoNE9OR3Q1ZUdCWWwxR0hmVDdTditUY1YvaE94d014LzNqYW10cDFPMUxoUEZVUzNWV3FpM3ViTzhNcHFXZHc5NWtNTjdmM2ExV0tnOXViOTErKzYzdnZ2elcvZGRmeWgrOFgxOXNiTC96VXUvb2NGWW90ODgvNWNkQlM3bHh0MW12endxTGU0OXU0Q0pVUmxuQjluMjRUaGJBMnNJb1VybFVReG5rZHFIdFpCdmpTQjFxQWdqRStQUk4zUWc0REErb0FYS2NhTVBSNHFCelNrWHlzbFlYWk1hYVhyTEkweEI2aUdxWThKMFNKeG8xbVYwaUVlak1pRHNpeGVJSTFYaE5UZkZVTDkvNGc0YmxISXJFMnJDbzhhVEJyby9sWkZqY1lKakl3andPWUpmVFpKNENqTUxBTXdJekptYlVkU1Q3K3RjK0hsaWhZcDFwSnUyaVpCNE54dHprQVNFZGhlWmhXNmlMUU1ZeDZrSytxT2xTbURMYzVzTE1JbkhvaXlDZUN5akM3Y3d3bm9jaUZsZDJuUVZ3RlVVTmJjclJSQWRwRzhOWk4yb2h1Wks2U1VaUnJJdFBXSWZjVUgrbU44aEtrKzdHV3J0UXJ1enM3WTFHK1ZxOVVxM3dpRVYwMnJvb2xJdFphV1YxUTV0NHNTNW1oYzdlVGo0M3FUYWE1VXFscXp2VXJKQ1ZLc01CLzgyaFdtdVdHczNaYUpwbDVhelNRSXRac1g5d09EN2VYVmhxbmIvMnBMWS9seTZlZWY2RkQxMTc0U09EWE9IZS9lT1ZsWVhOYXkvdXZ2dnQzUWQzZWdkYnJiVnp4VXBsT2hvT2U5M044MWQzOTNxOXppTnRQa0pCckJjR2xncU9ja3hCaExsTGVQVWtTRTZ4TTJ3bHUxTVZGQ1FSbVpYQXRWbXhQM1JZM3hsS1FQakNsWXI5SVJLNUl4SVlNNllVaEk4MXZWM2pxVzN6Y0kwNk1iNEtVUlExM2lHd0ZOUE9SSFlUYkJUYThpT1N4aUVPWWljYXBBN1Y4Q01URXN0VytjVExSUzhrcGpBWkR3eWwvS2tDKy9oK2oyaVkxekZnaEhLbEowcTloZXpudi9aSkZrdW93YlA5ZUk5YTNXeG1wQzdXY016cGJIMndHNE1SeXJJU3VxcHAyV0xZQm5QcEhISmhJSnZMaTg4MjFIeldKK0kxRUtSbmlTZkNpSFZFNXphVUlaSVllZ1RnWVBuRzh4TXZBMi9aNXhZaGw4eUt4ZVdQbFl2Vk0yc3IvTEpBVmx4ZmJTdXI2MklqV3lsckQzcmR6djd1YURodXI2eFVhMVd0d3RGZ2tOZDlxZ1NaVExUSVJwTmh0VnBYMUpUS2xRbTNLL3dyc25IM2lQK3lWSzhqU2JHMHNIWm05Y0tGUlc0R2FndXI2NWVmL1ZCN2JYUDU3T2E3TisrOStnZS92M0x4VExGUW5WYnFlM3Q3QzVWOFp6QnFMQ3lYR2t2NVlqbGZLTWtVbDU1NDRlQ3cyenQ2SUVOSkpkVEViSFlNWmsyNXlsZ2lTV2RNZ0swQTdjandBYVRDS0ZacDRKd0laYWNhem81K2t5dktmVjJGSUM3UFpoaExRSHlFTU9URXJDblZ6N1dGUDY2Y3h0aHhqZ2RMNUdCaW15R01oRklYQWVwZTRjSGdLZEdMVTJoblBVU2prM29WQ1dSNlBBNEhraXpOK2Q0ZHREcDBFcUFSRExjWWNJSTdjNWtJNW9qTnppYzRlS2o0V3d1R1o3L3cxVThsbG16SzBaMG5vNHB2R2RDeEd3Nnc5QlJNa1JyZzQ0S2J3aFFPR3NTVWlqbVRzWW9ZTERMU0ROeWdSd0xaRmZtaUdSY2dBVEUySEt3cFZIT29KVHd5UXgvMk1vMmZuUG9PejRmd2trVDZMZzRLRnpWRHBjdzMzNnExMnVibWFxdFJ5ODhtRTIyNDkvYU9EL2VuQTM3WHJsUXVLZG1PaC8zWnFLOGN6NXRMa3pHUGE3Snl0ZG1vMWh1Rkl2K3FZam9aNXJNeTk1cW9PdU8zYmNxVlRJUHpzOGJLYW1OcHRWNnRUckxTL1Z0dkgrL3ZUblBsN3M3MmxTZXZMMSs0c3J4K3ZuUHZ6c0hod2M3YnIrN2NmYTlZelpiT1hDMVhGL0laL3hDajBWNi8vZmEzYlNBcmkvV3hFc1crQ0dPcno3QXRIcDFHcXBLT05Pa0dJR29qU2J2UUlaaURNVzdqb1RDOVFMbkJxWXNSV05aTWtPVHhnVW1ObEpoQzhOVlYycmhKM1dKVENqTGhWY3M4aWlwaElNYjFKTTN3ckprd1VCTkd1blhnaGNmbllZb2M0RU03RHBIQzJRaFRXZ3QzV0NQb2FMcVhrQWdCUUVORER3ZEZGdjhMWC9zQlpCS1JRbHdGNFRReUNSY1Q2K0toZGt3YWpCQmFtTGxZNnRYTkhNVkdJK2JtY1k4QkVWQjlvdElGRTlsNHFJOHRXR05PSGc1Y00zT3FSa3FsQkVRUEJZVGtPOWYrSHlvU210eW1GQkw1eG55UVMrYUttNUQ4cUhSNXIxT29sV2MxUldHdTBGeGFYT0NuWWlvNnl1V0tFbm16MlZoYTM5UjBuWU9keWZIUmROZ3RzY3ZSVFd6Skh5UmJWR1FySlNyUUpVbXBwTmpXcGFJaG9OcW9GNHNsMW9OdUZtd3lQaXRmcmZOdmVXZjVCemZmN2h6dTdOeTdkL2JhdGZIUmJxbFd2LzNtSzVkZitGajc0ak5iZHg5a3plVmlTWGU1amZyaXNpNE9rOG5reGpzdkh6MjZZV2RocUxDVmk2SWtJR2N5TkF6UDJ0VVU2TzBHQ0QyUXFJWkt0UysvYXFvb0E0RjNQMzNBK0ZoWTcxRFRFQXdPVi82eGtod2h5N29WZ1NSRXBQQWd3V1Y0RnFUY0lReVZiN0hJV1JMS2wxeVFPRnBRd3JnSlQrSkt0Zmw0Sm1yVGsyTnBNaE15UTJmWk9FeEFTRnAxRVlaSXhzTkJjODJicWJaMEZzRkxvSkQ5aGE5L0dwc0l4SFNSZ3lVY2ZUQmtHTFV3dGpnVnRmRkpLcjc1ZTBMbWxXT0xXSC9oa3dtbzBaWjd5ckNJZWJKTG9ZYk1OTURXbkVYRUd1QituSXVSVjYwdkF2VFNwRE1VODRVUkgyaU5pZk93L09ISmVMaTJVQmQrT3RYdW85UnNLSEoxODZsZCtGaUxycVFkUlM0M0hQWUhod2VWU3I1VXJaZXFyZGJ5V21SMEVVeEdnOXlFMzRUSlRTZUtVWDR5eVdtcUxNckdZcVd4VUs3eUM1TFRLWjh3Vm1qeFQ1REs1Zjdod2FoN3NQUHdvUmc4OWZFZktGUVd2dmw3di8vdzdWZnk0OTRMUC9MRmIvL09iMVFML2Z4TUlWOXBMbTMwKzcyMXRiUHZ2dlhIWVIwWHRDQUF3N3dSeFhZRzNuUWxrUktKdTFUYmNjUTB6UWlXZVRlQVRqSU1qZlNwSzlNNzBIM1FsczlrU3p4blFXejZtTXIxM003TVExUDNsRGlFZkJSSlIwNG5OK2tRUnhhTFBZc3J5VDdKUjVvTmoxa0JZVHlYVzlITElYSG9vZ0VnbEVZaFd1TGdGMnBScEVvZ2pFL2pIQllKRTB2VVhjTFl4dG1mLzlwbmFOTW82RjRlUzdxRFN4NGNjUUM5SUNXNmxvQ244UXFaSzArdktObUJwY21ZMjZHdkU5NVVhamF4UGVzbGdVblZCV0hFTjNtVUtSRFlHQThVSHY3eHEzZ0V0YnVZWkU2ak9pdUpodlhBZFNpZk5TNlhGNTlxVmtyckcwdURRYTY5c2pnZDlFdlpSTmw3TXVyMys4Tit0MXNvOElQVnVlbDBkTndwbG9yMTlpcVN4dS9UOHp4K3BuaWZqY2F5UXJsU3k4bzFNbG1SZjJzbkl2NkxnZGFPam5JdFUyK3htaTlWeHVQSnNIZlVXdHZVelRBaHNMalNuODBXbDVkTGs5NW1wVGRhV1AvT3E2K1Y2K1YrWjlCZVhWbll1RkRRRXFyV2V0M3UzdmFENmVESWpnc2pVOEtqanRjRUFLV21hc2txWXZ0QkFMZFl4TGszNUNCMVZ1NFdLVS9LR1liRkNXbzdocnlJVFZWQkpPOXJacnJVaWdiczdSWk03UjhsZEw5OE1YOUt4bVUyc3J1OWdPL2l3QS8wQ21hWFl1TGdxQjdTVnFKa0dxNE0wUXR6SzJRWVNSeDRhQXBKZEZ0Z1ZBYXllb1RYdkJoaHpqcnJSS0owYUZLQmQxZjJGNy8rV2FVdHNCcWd3NXNaUWxPOEFSQUpnM0dvRUxWR2NwRmx3MjBGYkVzTjFPRlFEaVZObHZBd2o2YkNWMjNSY0g5cGN6Z3h5SGFwR1ZHT0tTTzQyY1ZFTTNUQW9NYUh1ZmxGZjZiUWNMWlArV3A1L1RQNXliQzlXSzNYRzh1clM1UEJvS3c3dyttb1hpMk54K09qb3lQdDM2dmw4bkNrMjliODR1cHFyYlZFQnRIV3BaQ1ZpT05TcVZMSmlwVlNyU2EyZmkrZGg3S2FnOVowck0yTVlsMHlaTVhTZE1MdkRhcExXNGJKc0Q4ZDlCcUx5MHViNXdiajNIRG43bUp6NGVKekg5czk3ci83ZTMrNGUvdmRyTjkvK3FNZmVmbGYvcE16WjVkeTliV2Q3WWZ5ZjZsY085aStoU3N3TkJWbjNKb0FqQzdsSG1QODhsOFVNcE5iT2pBRVhXQ0lIenI4d21mTW9iMk5oMEFwczRXbnNMblVNVXBHVnUxZ2wzRkwyQnhyRys4M3NOMGswYWlPQy9pSjQzQUhiazAwa0xtY2ludVRDM2F0bHp2aGo5eHE2TS91TkxIT2x0bk42TlVKWnRCR2NhZTdxQk41UXBwSHdNRTRuLzJscjM5T2lCUXh0cHNONWNsRDNHUTNDY2lTZ0lFQTdPOFY0cVlveFVIcVlVdWFMQU5wTDJJNGExOWptcFRwR1dLN0VLemtBRERNUmRPVGtsRWkxaWxjT01OOE1LRVhXRjZKNkJjM21wWW5WMnAvdkZ4YktlY20vZEg0N0ptTnBZVzY5aFhGTE5PMld6c1p6VFBvVDlwTDdWS3AxTzBjVmV2TlNyV202QzhWSzhvOStsTmRyQWptczVQallWZXJSQXJFdFVnUkw2SEw1U3JURnl1S1U2VkpTVGViVGZudk8vYlpaTlFyMWhxRmNyTjN1Si9ySFpjV0ZrZXozTU03OTg5ZTJuanVzMTk4dE52SjhwTkxIL20rWC8yZi9rbm4zanZyRzV2MzN2cjIyZXZQUDdqMXVnWnJIbHZTRTBhWlIzQzBCYWlKS3pDcGdIU2J4Wit4TGxCZ0tDRUFsZVpsWVNoWUZYYXpwOEcwb3BaZUpHK210YkZsWHRlMnR0UzFhMUorSWJNSWJ4ZmdFUjZUejNzVjl5YTJVd2dGOVZMYi9RYm1jekEvQVFFWnJCQW1FaHhhV2NJWXBKTjRJbTNBekFtWnRPSCtUMy9tcVY3THJ3SWhCUTA4N2NsaFNrN1pYL3B6bjRlbFNNWExaZ2xRdmZQaDBBV0JMZW54bWdNN3hrVEV1b21OWjRLU1FDTUZSeVlROHlTdS8vbVBBSDZOMFBUU2hFd2Zhak1Cc1U0b3l4TldINFBTaTJJMm5PZzVzYWpnRHpja3o2b1h5KzFuTG00dXJpd3Z6Z3FsY3h2dFVqYXJsNHZkd1ppM3gyWmo1VzNFMVlRU3NWd3FscXJWV2sxWld2RmExQlZZMFQzbDMxRTZTbkpLM3Y1Y1YwV2JGbitJWU1ya3VpS1h0SHNwYzZIRFZQRUluRWMrbzlsNGYzdXIxeDFPWnRvVkZnOGZ2RDhiZDdjZWJPdW00T0g3dCt2MVFsWXV0bGZiYjMzajM2NHNWS2FWWnFOZU9zbzE2K1h5d2Q0ZFhWWERZcmdBdHFrRUpIbDhwdUFpcndGUkI1em9PZXRBR0FIYW04dWFBaUsybytCR1JzcVlHRlVtbEQ3UlFVN2hPcW5veCt6WUZLQUl3cUJkd0FNRDljaFp2cENhUVRnM0hiSUo2OGNDcFdTVXVnaE9BVXltSXlDUkpTUVZlQThFME9HT09DZHdEbGhqZ3d5dzFaQUJLeVZsTlVqb1V6TkdYY2ovNmovK1QyUXh2Nit2MDFUWHdYZ0dtOTVJOWdmVlFZSFFLUWdFNi9LdE5wOTkwVnFiMDBzT1BqYmdad1YrUXdrVUFjR1M1TzJuNUpWVXVTWnExSXUwb3VMR1J4NERVamZrT3RuaUZobE5CWEgxaEI2MTJVamc1T21rVUw3d1U1YzNWMWJhOVoyallTWEw2aFZwTkpHT3Uzc0hHbFFwRlNhemJEVG90MXJWeEs5UUtlUVVuTXJ2UTArbVhSMVBYTkJLVTJqYUVGR3BmalJVNnMvbmRLRW81a3BWNWJuSmxLKzcxbXJORVo5QTZFN0hvOEZvOU9qOVcrUCtZRGJ1MVJiYnVxTG96dlhXelhjbnZjUGx0VE9ObGZVYjMvN20wdHBLZmVQeS8vTy8rSytYbHF0UFg3LzRzUi83cWYySEQrb2I2OTJ0ZC8zNDBQR0lUYVZSUEI5SExOblNwclFqZElDdzVRT0QzMFFNUFdlNUFPK29SN2NpZE11NWFvcFdDZ0tvWWs5emN2aEJneC9tOElkaHhJUmFMemZpYkt5b0dLT1dYV3BISURnc2VBeHRGdEJvTnBOWlhvK0MwdEZqYkdBWWlkYWhpekNDMU1PN1hGcFFzSWlZVVJHRkFUdm5NU0NjR1VkQnFGZ3pZVGhtTkkwcWdqRDdLMy91SjRoNkRoWXVmYXdaS3oxSGVwWEVvVUsyZHAzd1R2R3g2alV3dXRLbHg4bmJWMEFKNGk0blZoMmtiZEtIQ056RnFwelA0c0dCVWE0aG96aUZjTkNqR3pEbElSS09CaWdFbVZucVpLMW5Well1cnk3VlI3UHM2S2k3dkZEU2ZrUjk0OUZZVnpkZGg4VnJNcDN5cjgzNVdUeHRTOHJENFhBMlV6b1hJeGttcHBmZkNCblpRZGxZdHRjT1R3cG9TUWpTcm42V2xVWVR2bzgvSGsxR0dwN0xUVVlEZnE3RG4wRGFmbmd2TnhsS25QYkthbjE1UFYrdWJPL3QxUnVMbFpYTmxUUG4zNzF6WjFhczZKcnhrVSsrdUZpdnZ2ZmFhODFhZVp6TExqenhrYU9EQjhvSzJCNGJodmx4a3M3NGpIWHRUaHJodkdpbEpuVzhNSW5hWVJuYlZWaHJxSDZ4RnA3Q05mSnhVWEFvSlV0aG1ZdCs3SHhTd3V5VTRDS3VkcVVHa0wvbjNJRUJKSEx5dXlmME1pQWtFaG1hV0U1SFRlbzFoZ0NGR1oxTVFyd0dzU2xVY3lhZ3dURkFJcGdCT3FsVE9nbXdibzgxMWRUUmoxUVMrZGYvNS8rU2xST3J5N1ZmZ2VGVGpVSXIzeWxEYU9YNU4zQVVEblJxNFJFRnp2a3FrZmdWS1N4cU0xRmJzZ1VmUkNSZk1WeElMMjR5QmRyUmJSeGFhcStNYklqUDJwZk9BS3B0REo5aTVhcUp5dnpBaGlhY0ZHcU5xejl6YVgyaFVxMU0rVW1OWWJta2ZEOHA1TWE2Y3hwTUpvUnNMdC9yOWVxVlVxbXNTMGpXSHc3UmF6S3VWU3V3MGJCQlYzNHBsOHA4dURGWHRBMjB5ZUZIeG1hVEVWcnh5NUtEOFhCUXJEUTB0ZmI2cy9GWVF5WEtZRFR0SG5lbW8zRi8vMEd1WEs0MEZsNzl6c3YzN3R6NWs5LzhOOHNYTHEyc0xMejE1bnZidDI5dnJyUSsrdnlUbDU1NGF2ZW9KMTZOYW03akk1OHBES1pMbDYvZGVPbFhwUkRLWUJFbWsrMWtNWXlwTkljeE9GU3dsUTNyVE9nejdyRFo4UlRYWFl5S24wd3J3L054VlZuSzd2UjZacGJaSkw0T1JXcjNwS3Iwc3FuVFhtMXVaL1c2eFZrc2NBcWhUQ3BsanZuVElibFFoMmNQbjRvSmhUbzBjUEVRTTBOMHp4bFlLYVNHQmJTd1pwcUc4OTdPUklDS0ZRWi9JcEZsRlJDVUdraldnQmNvazhFOWwvODN2L1JmSmFQQTVLVG1yT3JFZHV4MmJHMk54b3lZYlFLcElYbzRKQ1pTYURKd21ra25PNEdwK2MxYmN3YVdMY0NTMnBITE9NSllPR1VDa1JIbUZqY0Fyd3VITytSZUEyaWhpVHhyYWVNSGxsY3ZMTFhxeXVMMXNoTHd1Rm9rM05XcmhLT2tyc1NzTk44ZjlCZnFOVTA5SEkxR1F5SlZ3YS93bjRoVXJwK05zeElKenFzMkc0OUhDZ2lsUEVVOHp5Vnp5dWpqd2FqSG0wdjh6eWp1eTBzbDNTSUwzeHQwTzROZVR3bWtVcTRNZWdlSGQ5Kzk4ZW9iYjcvOXRxNXIxWHB0WVhubDFmZnVGVWVUYXJONjdzejYrV3RYUjdOQ3Mxem9iNzJmSzVZUGozcWYrTm0vL09ZcnY2N2xaMU5nU3VJb0RPZUVFb0dLS2RXUU8xeTdva1FyU1BqSGIzWUlnNkhXaTA5QjJFNXpyNWlYekFlUm11N0dybllBZnNDMDVFZ29JK0VrKzR0SUk4TnJkaFFBekFJSXN3RHdFTTlCSTVqS1o4MENGWUxDVXBCUkZrUVF2WjZCTWtmTUN5Q01UaWo1UTM1V0J3S1JMaGx2c2J4cFFDbzFhVU9zK2pkKzZXL0NpeUl1TnJjckdHTlZSN2szNHFvWloxU1F1SWhHY3lyc2hBT05qU0FGMWd5aHNQMlcxRElhMndrU3NSVUs0Y01CRnRzV3A0bUpDVUVUcFNMWTQ5QlIxNUJwYWJGMStmT3RXcWxacTJpdlVxc1VCOE54VlpBMkl0T1JDTWQ4RTYvYTd3LzRmeHVWMG1RNEdrK25yS3Jac0tLcmdIWkhWb09QNEdncm8rV3R6RjBvYXI4dWV0MkNsa3MxN2RobjQrbitVVWVuNDhOZVkzRkIrNk4rOTdqazNWbTVVcDVNaHQzdWNEcnBONXFMZytQOXUzL3dyODVjZS9iV3pmZW5wZExPNFVHcDNQamQzL2l0czYzNjVXZWZldjNObTlYcGVHbHpkVzJ4MUY1WjMzcTBkN2k3dmJoKzl0cHpMM1NQdDNyRDQrUWtteDFEaGdGdGJxeUQyS2xnTnAyNHVtQlRGWnpCMlQrZjRTQTNHK3hrQndsU0xWcFQyWjFoV3BvSkdWRk9oYTF4UWRvT200OE5MNkVZWnBETnRhUC9wQmUvaUJrMXFraE1DNlV6N05NMFBta1FrWkVRTG9MbEMxT2FGd1JRcExHbWdINCtpbGtjU2pGMXFvV2ZBOEpRQlhYK3QvNzUzK0tNSlpuSm9LVUExaW5NNVZzZ0J0SDJyNzBKa0FXRlU1Zm92UnowSWdZOWpUUTNVZVNjeDZwaUtWRktTZ1pEOVpnY3lYakFEWUJmalk2bUdxNFN5SWxlSkpybWx6NVNXcnBTS2ViUHJUWGxZMjB4UnBOWnZWcmhEU1BQSXVwaWx2WDZ3L0ZrV0t1VXlmWm94aitXcWxiU1RtWTBIaXZUaXlPM2ZTTGU2eHcrMm43MWxWZXVQLzEwWTZsNXZIMzR1Ny81MjQyV2RuZXRuWWUzTGw1OUtpdVc5cmEzem00dVhYdngyYVdsamR4MDFEbllIeDBmRFliRHJtNWF0Ky9jdTNuejRUdHZ2Yk45K09pd1h5bFZOaTZldTNicC9NcVpzMisvL2U2VjgyZHV2L242eGN2bnl3dkw5MisrMHpzNHJwVUwxNTk3L3V6MVp3NEdCNFBPRG1ZaTk4aHdXRlhLb29iTmpRZGNCSUNuU09xRVVUVUgxUWgzVVRuS3BUVDZtVURGeEZoeVBnZzJZVjFzVG9kN0NYKzhsZ2lEUVAxcG9jRFRNUmZzNklnUUJBN2Z6d3Z5L0g4Wis4OW9XNWJrUEF3c1g3WDkzc2ViZTY1Mzd6N2IzZWgrYURRY0FZZ2tERUdBRkVBU3BFZ1FJQUVha1pUK3pOTDhHZjBZcmpVLzU4Zk1tdEZvMWl6TmlKS1dERVZLU3lRQUVpQUlkcVA5YS9POHVkNGNmODcydTd5Wjc0dXMybWVmZTE5RGpKT25Lak15TWpJek1qSXlzcXAybFpCSkF2OWxwalFKOU5MUU9UbnJFUkpWaEF5RkFDbGh6dHdLNUFlUCtDY0lnaGRwRllsZ0lFNHBxMy81WC95L21Gc3lLZ0VKc2NyaTc1WGVlWGxRUjc1WGtiTVFEUVVOMmdHbm0zRmcyVXJXelJySWk1a1NvUjZyL2dvVWRFd1FNSklrZ1ZvTGxUU1JCMms2ZlhXWlA1SVNFQ0lDSzVJdk1iaFgvcXhtdUoyNnRkYXBvUTY0TUttbU4rbk5JQk5lZFdaYmhtMVpZUnpGZ2Q5cU5MQ3RoRkpDUVEwdGQxMFBsZVNaRnNXaDYxcDBmQXB0ZER6N3YvN24vNmZSNU9SWC9zTWZmZWY5ZTh2ZGw5NTY2NnY5MEc4WStuNS9taFQ1cGZYbG8rTSs2cnF3dXZLVFgvclNaMzd1WjV1ZEZoWi9iTkNpSUR6dG42WnhHZ2V6cmhZOFBUaDQ3NXZmaUxUNjlxV0xFTnJTOHNhN24zelNYVnQ5OXYxdnVzMU82RTg4eTJ6Wnhncm1UWGNsbnAzc3ZQbXpzOEVqUFkvUU5YRVgyY25uUmdkd2xrYVdzcU9LUmdwZ3lOU2lpcGdVVjZNcE1kcDhSc21lYVpaVkNpZXlwWGdSVVRhR2NXWGxTYVBPQ0dxYVFjbDVTVTZ5Y0pUTGN5VTNBcm5MNEZhQVpxbVpSdHdjVHpWVUYyWmtnZ3ZuS2srcENnOExYRmp5ckJZQWlxQmQ3SW1nbWVDUnJoUzU0VFJuQ014WC91WC9XODZDVW9jeVY5V0xJd0V4YW5VVlo2TWdVNVJDTlRqUXhwYkZGS2htSy9tZ2w5Sm15a2gwVkZIU0xnaUdXYUxWTWkrWVZtVFNkTXhTNWpJcXpXZU84Z3NWbjlUcGRxNzlCMUVVclRTdDVXNGRhajJZeHFaUk5GMVdCek1PbTE3M2JLeEpHSHJZY0xtMXBXZHhuS1VwK0RsUWNmNWl4WURyVXZOcTRXVDYvci85MnRmLzZILzd4dmUrVVRpdC9zbm90LzdhTDd6N3p0dGYrMkQvenMzTnR6N2E2N2JxUVpyRFlZK1RETXJkcm5sQkdGNWVYdmsvL0ovLzhkTDF5L0NFK3YzK2swY1BIeis0OSs3WHZucjdDejk4L2NMRkp3OCtySFc2ZkZqSHNBNGZQeDN1UGpvNDdEL2U3M2Vhbm1rWU5jL2MzTmk0dUxXKzB2UHk4V0Q5MnN2MjZyWnVSRVVhWWdkZXJ1c1ZLT0V6SWtka01TSWtsRjJaZ0lPbkZsdUJ5bHhKbEFjWkVNVUJCNUVzekJlQVBnbENPUmprVHFGRE9QRDdtSzUwbXdSQ2o0Sk1TbFJHUkVZS0oxVEV1aGdsV3FyZ255b21oU1NERVNLa1h5WDF2SStDS1Fra3FhRFVKcmFSelZYdEZJU1FzUVZzQTYwN200RjhZVU0rNk1CWGYvZi9nempFdzQ0S1cvQ1RpQlJtVEJMcTlmSVNRVnFVR2FXaFVDV0NjUkpXd0xwbEQwRU9JZ2RHbEpyU0dZSWlMM1FNSUkwRWlFd2tMajJoMlNlVUxaZWVTQUN3ZU42NTN0cDhPUXFUblpWYXc3TXpUWDkyUE80MkhCaDZUYmRtVVdycWhlZWFHUE1rU1MzYktYSmVuY1NRWTdPS3JhZm5PWmJOMFUzalpIWTAraC8rTC8vNGV3L2ZqZ3hyWjZYWFhYYnVQZGpiNjRldTR4MlBaNWMyMW0wcmVYUTQ3bmFhai9hT04zc3R3N1F1OUJyZitmZ2hKbEJEMC8rei8rei9lUG0xT3g5ODlNSHc1S2pXYW1wcGRuSXlUdlFNTy9UMjBoSmN2bi8zYi81dGtrd1BIaDlnRXd4ZnE0VWRnVjQwbTk3NlN1ZkdsUXNiRjNjKy9QalpsYzMxN1ZlLzREVHEwK0ZUTEtKb0p6cU1ma0pXRkFZN1Rha3BRWlRMcmtoRHJpQ1VjZjZHREhqeDZVc2hpMElMTllaQ0JrOHlLMGxtd285QlRreWRZYWhUWjhPaWxGNXkxVkh4VnlOTElPcmN5QXB3OUlndG02OEtsYWVTR0ZsZ3FNcksvMW55UEZBUEFXaVpVbnBRZ1JJZ2NSVXAxUjJneWpNUCt2ZWJmKzNQU3dTNWlwSm5KR1ZwNEdWVUVCS3BUcEl0K29mbFRpSzh1Q2xYY2RXMWR1S1lGSk9BS1cvd1VqdUplUFdkWkx3S0t0ZHgyU0RoZ3dRdjB6TENRQUlWUVZmT2FCU2VkYklpWWxXcjllWkYwMjNEK1lhS282b3dLWTVPeHE2TkRhdU5GUjJtM1RZTHg0SmV3YXVSRDM4WHVXVWEvQ1UxM0JZc3BBRExUbFB0M1QvNitnZC8rRisvLzhsYkh6MDU4WnIxV1p6dDk4UEJLRUdsclVZZFBYbHllR3lHeVdRMjY3V1grb1BUdGFiOVlQY0VPOTFabkRSYzgzZ2F2UCt0dCs2OTljMDNmL1JIRE12YjJONWFXMXN2bkJxV2w0Mk5sWGFuQTU0WHJsMFlIbzArL09BOTFOcWZCay83NC80QXpsVXJLK3p0MWVYMWpaMm5ENTZFd1hSNGV0Q290ZElDdmNtb2F0V0l5Rm02clpJY0VXSW9LVVl4WU13bk1KZElRYWlqeUJBWmxDMVBGS2FVNW9pVXVZeHo3U05LanBTNXBOZ09TYklJMWtmU2NpQlFpd1M2Y1hNMlZZVlZBeFhNTXhpWHlzL3lBUE5FMlQrUUU0Y2dzWGxSRmk0akFxU1JGZ29IUlBqZ0FuRnlRS3VyZXFTVStiZisrbDlRL0tpbVhKS0lsMDRJQXlWRXB1QkduODBocVlBS0xXektRTWxJcU9JZ3FDWkFTYU1PeU1KWmtqek9wNEg2SjdFSzBnTGtNb0FTSzVBZ2lSWUN0Q1RMNjVjMUc5dlVvdGV3VGROeWJPdndaS29YY1FQcWJ2SVNqZXRnZUVBSDgyWWtjV3p3TjYyMEdZWnB4bkU4bXdYaEpQeVgvL2YvNHAvK3kzL3kxZTkvOU1zLy82Wm5KTy9jUFlMbFdXcDYyT3oyR3RxVFowZGR6MTFxZUtQQWo1UGszdTdSNW5Kbk5KNjUwUExUY2J2dVlRSEJWUEt6WlBmd0pONi85K0R0ZC8vTW4vdHhJNWk0eTJ1dFZzdHd0SjBMVzZzcjYzcVI3VDM5SkUrVDRYQ0MvVFJjbVZUUFRrYmo0V0R3K1A3REIrKzlDelpvMDFLejVyU1dpeXlMZ3N4eUtSUUtBWXVoaUVOdThWU0tKS3BXUm1GMXo2UXFnMFk3TEltU0dzRFJKRTFaU3NtVHdrZEVGRnIraFZMbFNCVDBjeE9HQUFTSGcvbk1GbUI5VlRpRHMzeGtxQnhSbm5tS3lYbUpoU2hxUE1kSWdmeFVwTXhRN2NRUjdjYUFTb3lnMmlDWjRLZnVkU3BnT2FvN004NHdrcEI1SWRJc2N3QnptUUZLMW9LUkNNOHFLSkQ0R2JaTThabzZFZExsa2t3TUNTbVVEb3VZV1ROVEtvTmtDcW9JTzRXV2NmQ2krcFVrMVdwV1VhdDU2RGY4ZzhBUDR5UTJIUXMrVTVwbXJnMWR3V2FVdGh6dUN4WSsrUGQ1bmx1V05RdWkwMm40dlgvMVQ0OTJ2MUZmWG5uNjdPajlUL2EzVmpjYlZyUTNHQzkzM2MxT3pTeU10WlkzQ1dhUERnY3JqY2FWelc2amJ2UW5JY3ovaFc3dDZXQzYybXFlamlmMWVtMDZpNXQxSjR3U1AvSTc3WlhmL2VlLzg1blg3L1EyVngxcVNON3ByVzV2WFh6dGpTK2NIRDFLazJqUW40NG40VTYzYy92Q3lxM0xXNXVYTGhZemYzdTF2YjdWemJMTXRUZ3Q2NjdyajJabWplOC9ZNURleTRDSU1RTE01VkNKcGxxNklSblM0RWlrWkFGS0dvVmdOaVZmc2FKVkJ5Y2xiV2kzNEFobE5zNkNrNlNBR3N4RmpJQ3FWQUhiVWtiUG1rRjRvV0dLOG5sZWhMTnlLcmZxZkFtbHdraE1VYkN0WmFGRlVxTE0zL3JydjRRVDMyS0Z6RFBPaWxBOGVpZ0xYQUZTcS83TlRUdlBjM0Z3OGFPMGVQK2xraUdPVmFqSXFPZHE0S1IzYUxyS0lMQTh6MERLZzZiSXFSckUrY3Q4bFZKNDhRWHRpYnRqNlZhNzRXS2M2dzYvSDU5bnhjbHc1bmsxejNGUUNaOGI1Z1BxYURBOWVQYUd0N3o1eURyNnRyL25mK2RmL1M5ckd4dFA5dzY3N2FacFpzOE9oeWkrM0czRldmMTRGSHFlY1dHOVc3UDFKZHNjZ2ZNNFdLbTViN3kwTTU0bGcxbllhM3BIVTcvdGVwWnRqR2ZCU3NzZGgzSFR0djdnajc1MU9qeis1RnZmL3VsZitvdDZQT0JkcXNqUFR4NzA3MzF6YzZWeGFYdTk1bG1Sa1orT2c3Y2Y3ZDE3ZW5MdjRlNlRvMkYvUEQwOEdQRUZrN2JaYWpmR0I3dU5YdGNvc0VwNVdwR3FCN2VVVmlnVlYxWkJxUy8rZVdJT2pSU2dXZzBrbDZXSVJMeUUwdXdwUFZhRWlGYmpLVTg3bXVXSUE4bWpoRE9RNGFndzVBd2xPU1BBNkVqTlp6U3E5ak1LRlQvWEpLcld1VVl1NUNOTDlMQUUxVkRTVXhkWkMwRll6dlhrVEFiejhLM2YvMjlRZ2V4cWVJMUZBVWpWRnFIYTdhak5BWnRTZ1JRb2JRa3BTZ3hZTXMyRDdGWUJQTXEyU1M0ejRYeTIrVkRQaVpSUXNlREZDSWkrUkNsZ1MrbE16UkVBcG5JejJ2aHArTHZkcGxOM3RRMDROSTRMbFg2MDIrKzFZZTVoMkkwOGpSM0g0bE16cHBXbFdSUUdFQkZFNTVqMnMrUEovL1JmL3BPNzMvNXZXNjczNGY3b1J6NTNKd3pDL2FQVDJXVGNjZTFSbUQrZFJIWWVhcW0yMXZGYTdXYWhtWk00eGg2NGErbGhianpxVDF6WE9SMzUyQnNFZVdKbW1aN2xwbTNVTlgyWTZTMWJPeDVPZi9vem4va3J2L0ZYTjY5dW51dzlnR3ZVcWptNnhtdW4zLy9nL2tsL2NqSUo3dDI5LysyMzNsMXFPc09ROGprSk1pUFhWejNqNXNYVmRydloxTE0vOStkL3VhZzVlVHJyYmwvazNid0ZFVUFBU01zbWtzQW9CMDVFS0w0TTl5cEtpTUF1RnBSaFV1V2c2MUpPa0JTelNzaldrMGdlU0NyVnFJSVZDRWVGUVZRZVVpQ0NhVFpHUmVjdEx2SDhMekVxRGdhS0J2K29pWEVwcDJwVVZCVXN4Z21xUFREVnZNNHVNRWMrQjZvSzg3ZC8vVmRnN21qb1NNWmk2Q3FiZ0NKRUFOUVU1eFpBNW82eU1jekFBc2lJekN1V3g3U1NsVVlWckdhL0NrUnd3UlRyd3o4MnNzd0FsSEd4SW1LZGhHWU9iR0RKRnFBeVVENTN1cEd6UGd1bVNSaDMyNDEyZzAvcTJwWXg4dm1jbG0zVElLS25ZSVVZRzRscFpCcXU1K1Y1dXIvWC83Zi95KytObjM3bDVxVXRPUFpyVGUvTzlWVW45cmQ2dFhRV3hHazJuc3pNUFArUm0ydDNMcSt1dHVrVDFWMnZaaGgxMjFsYmFyYzZ0UDFMTmFkUnQ2ZFJNUmpOMXBwdWxHU09waC8wWjl0YnkzNlFScG4yK1BEb3lmMVBibDYrdm5YMW9sT3I1VjRuTDh3Z2ppMHp2YkJ6c1Z2M25qeDZPdW1mT3Bpamx0ZGJYZDlZN3pnNlpvVzN2cnI4NW1kdUxhKzBQM3pubmZIZXM4R3pSekQ2bmRYTkxLTS9WaW9NSXh3OWtVYzV4cFFsUlNoQ3BNaktPSWlVQU1YekJwQVVZNHVqOGlZbExXTWtEQkhEVVhHQUFNbWhxa2c1OHVSY0ZoVEdNdlFBMWdlUUEwWFB1Q1FxS09sTE9KK1N0RlJYSnVmQXdTdHJaSjc2YVJ2aWJDNkFReXRrVlNNQktqNnZBQkh6dC83R3I1Q1BkSVluNGxVQkhCR0FVRWYrTTZFeUsyQkcyUkQ2TUV3QytXSmpLeEFtSUZNcVhjS2NaWWxUblMycmxTb3I0c1hLc1hITjdGNWdkS0hycnV0dUxQTjk3WHlQYVZFTUoyRVl4M1hlNHNlV2o1T1hEMFhDaXVUeXpEcUVaUm5mK1plLzg5LzkvLzV2UC82bFY4THg4ZUhUM1ErZjlXOWV2ZFJyZVVuQ2E1ZkRVVEFKa3FacjNEOFlQbmpTSDgyU2RxUGhZYStVRjRlejZOSGVhTFZkNnpWcnB6Ti9wOWM5SG8xMEE3T01UeXRBQ09NZ3ZIWDEwcE85QTdoVGNaNi92TFA4TDMvblgyMTQ5WXV2ZmI3VGJvNG1BNWdhT0dEVDAwa2NUaHRyblIvNzZTOFUzZmJEZTd2YkRmdWxsZDdyMTdldWI3WldscHNUUDZ1MVYxOTc4N045ZitZUGhub3cxTEh0MVcxNVNCVE9Cb1ZTQ296bWdDQ0NBVEFEaWVwZi9KUktlT2NVZ2tnbUY1SFBVUzRlRlpCckdaMlRja2o1aCtvRXBRaEU5UkdJZ3QxUmFEYXRZb2FHcW1qSlVQTDVMODFlQkpCVktKNWxpb0tvTEk3bUxSWTQxOW9GVnJUdUtLNnk0WEVJRWtjRVl2aWpReXJ6R1JiL3o3Zmt1YVNVbk5jbVJjNVJsSWtGNUdLMjBLTTBWekxGQnYrQ0xLbllNWW1qWWFGZW54WXR6M1hTb3VnMmJaRENpVTZ6UEU3eXljVG5KVWpiU25oSlJyZGhuRm1VcGZVaVAzcDIvTC8rUC83eE8wLzN2dm05ZTl1Ykcyczk3K0h1NmIvNDQzZDNUMkRZTmMvUnN6UjN6YnlHQ1NTUC9RMzk4UDdSK0hBVWpxTmttdWFqT0J2NVljT3ROVnExMDhIMGxTdnJnOUVremt6TE1mY0hzK1c2YS9KM0pJV0Y3WEtTcnZacXNQcnZ2UFBSSkV5RFR6NjUvY1VmOVJxTjNzWkdiMzE1YVdQenh0V0xseTdkNkRWVzB6aHRSVWU3SjRQOTQ5TmhITC83d2NHTks5dXVrUjd0SHIvKytzdk43UXQ1T050NzhualNIODltVWJOVnR4eitWQVdTRUZGemxPWmlFVGNBZUF3cSs4NHpNeVJDSEFWUlluaVFoTUx3ckZJRWhWRlFNbGR4T1o0RG9KN0RDcjBBQzBueDUyMDJrUzlpTVBURWxyV3Jlb0VFcVZxWFpOb2dvZFlrYWF1UVNFY1lMNC9rb1ZRRlI1QXltSC9uMTM4VnBNQUNpRDVyQUxLaEdjUXJKd29IQnVhWEpQTUV3d3R3enM5YW9LejR2QWhuSktweEVpR2NVWmNGUzBSY3VGTzk3UnBtbE1SMWZqTVZPOFo4RnZMemR6TS9jU3lqQnY5QmJpOWpwMnBaRm0vKzZucmtoMS81L1g5dGFmM2pnWDg4bWI3M3laTXNTT1dkTWZuQlpQWmsvK1RPNWVWZW96NlpobGdOWE1kc3ViYXU1UzNIcU5mc3FEQmN4NnBiUm44Y3JIWnE2ejBQTXV1ZmpEZmJEaXovTURXbVllclZha2tVcjdXZEtOWDl3RitwZWNOWkZDVHB0Nzc3M3RlKzkrNVdzN2JVN1N4MTJ5N1dJcWRyMXp1QkgzL2x5OS8yZ21kWGIxL1YxNjRPVDArU0lQLzRjUHJ1dlNjZlBqaDRXZGFjUzlldXIxeTVHQjA5QytQbzlPZ3dtQWFkWHMvbTI3b3hoa29KT0FRVUNnOFVuUks4eEtxZ1ZCbi9CQ0ZXbEJJREtCV2ZhL3I4V0JWVlhLckJVOW56d3VlaGJFd0Y4MlFaVVdYUFEwWEQ0MExwczlqNUtzczRRTVV3ajZ0SUNkQmJGWm5YYnY2ZHYvbXJwQ3FUaU1uMHFJb29HNnV5bjV2dWN5Q3ZoZFo5S3Foc051MS9qL0lIZ2FwbHNRMkk1V1p6Wm5RdHcwaUtQUFRES0p4TlpqNmZuMmszV25XK2poM3FEaVV1OGhTdUZseUFMRTh3RFErUEJyL3p6Ly9aNy8zaDExTk5yN3Y2MVo3VHN2TTBqRExUdEQzN1dyZDJjaG82Um5idllMVGFxaFZKVm5QTXJmVjIyelkzbGh0NUVNRCtOMXl6VjdOR3M3amoxVlpham1VWGUrTU1CRGN2cjRSQmdMWmxXbjU3ZTJVd21jMUMzcndkVFpOT3grdGpJdExNZjVBTUR6TnIrZEsxQytIb1NOZnQ4V2dVejA2YjdhYlRYai9hUC9ydTJ4K0dhWEp4cGIyOTFydHpmZWQvKzNkZisrU2pKMTdzWDk2NkZtcmF5Y05IV3BKaS9jcnl2TE8wYkZIanhWelRrbkVjSUY4VlpCakZteENnNk9ZeUJMSVU1RnllUkt1SUhFUUwrTTlJeVZtWVZ2em0xU3pDcDZCb21GbDJqbWVFcVhPRUNzbU9TSFRlS2xVcEFCajJzY0p3MXdoU2FlYWMrSXltcEdUTFFVMjhhb0Q1ZDZIdXFLRmtTcEFFY2dtVkNBQXNBRkNKNStJcU1nZVdQeC9ZeGhmSTVuQldDWWxaNll1MEx4WUdKamV0WWJhRXFHdGFjTStoc21NL3F6ZWJUUTg3eXlMaDVhQVVyZzUvdXNFTDdXYVdwak0vN2c4bUgzejNPM2Z2Zm54NDNQL0N5MWV1YnJXU01CeEVtVjF6MTlxMTlaYmh4MW1lSnZzRFB6UE13MG5jYmJxYjYwdVJadFhyOVY3TGFqcll0V3VyYmEvVDhJNzdwOWlRWHQ5Wm5RVFJrM0dZQk1tVmJtMXJ0Y01IRm9waWE2bis1R1JxWnZra1RwYmJ0U2dyQ3RQZTZOYmYvZURSdlh2M2JsNjRzUFBxWjRiajBmN0JzOXlmVElZajMwKys5NTMzTEN2N3NSLzlvYSsrOVo1WEpJay9XbHRhZmpRWTcrNGRHTU5uZTQrZlRzYVQ4WGlhWjBrMEhpZEp2THA5dVJyd1VrSXZETWVpZEFtbERWd0FwUndLcXFoU080QmlKNXFBb0pDS1pxRWVST2NwRlJjRlVjQ2ZSSlpaQU1rdEdadzF0WXdBSTQyWkU1YTBpcExZcW9qeTNSSEJhYkg5Q2hUbDNMcFhES0R1di9HWGdaUUxNdFJvWmtpK3BFaFVCYUxQbWlMM3E1U3ZvNmovL2VIRkl1SjFsY09nNnNGWmpuOHlHSnBobjJUZGdsOS90MnUybGh0R25CYU5PcFJkOXp4N09ndVNKS3JWWEhqd2NSVFNDOWVNS0VxUFQwNkhCdzlQZDNjdjN0ZzZPSjRjblk3SGtURUk4N3BULyt6TmpXYkQxYUlreXBLaU1IWUg0eXhMaDFPK1RHL3ZlUHJvY0h4aHVZSGRzR3M1V1Y0NHVuYnAwcnBic3lmanFObTBzYnBNcy94Z0hNMm00Y3ZYTDV4T1oyM1B6UXY5Skl4dHUvQXNKemVzd1N4YzlxeWppYjlVTTM3L0QvNDRlL2FzczNYdDhrdXZoTFB4SjI5OU96amFlLzNOVjF0ZVBZcXlGU3RFYzMveUN5OFB4NU0zTHE5ZHZMWlpYMXJWTFFQYkF6OEN4TmcyWXducWJlellYcE9EVDFlVXRvSmgwUVFMdGt4dy8xSmhsSFJwVDJXNjRGaFNLZVZoV3FGQUxSUm5iRmdLY2ZHTWNaNmpYd1RKbDRhVjhSOEVKWTJDRnlrL0JjTkdsRTFuQ291SXRKak5yYUNLc1Q4QU1ESC9IdFM5eWxCU3FvZytwWGtLcFE1bmhBSXEvV0pZQkJRbnZJaEhEcHUwbUhPT0JQMlNjbVdrSEJENDducnRKT3ZFVVp6bnlYcXZHU1hGTE9JUE9PUVRZOXlucG1rR0Q5NjIrQUlaMUJKRlNSakRZZzZTL2JzbmU4ODJ0emVoK2RDYmFZZ05hREtjK3Vra25QakY4U1JjV1dxMGEzYmQ0UnViZE5PYUJQeFkyVWU3dytXYVkzbk9iSmFOZzVpWGhpS3RaaGxKVnV5ZWhuNlVMWFVhV2xGZzMzeHdQTHkydllwTjg4aFAydTNXeEk5cjJGVm94aGcrZDZNeGkwTDArTms0dlB2czhlLytiNzl6YzIxMSs2VmJyYnJXYmhuRFUzODBDaWJENFlObkowc3Q3OUd6a2VPWmcvSFVLTnpYWHIzaHJtMTkrTW16blN0WFd0Mkc0NW9yR3l0dXM2ZWJMbHBvOFhkWTFFL1ROTldUdENMclNsWktuT1c0bDBDYzRGVW1Ub3E0cEpzVEk0THlNa0tMQU9abHJBS2tHUlJJWExCVnZLS1gzRFA5eHBsaG5sM0JQRitkWGdBV2tqWlZkT2k5MHFNS0Zrb3lpbHp6Ny8zbTgrcGViVEVGOVFKd2gxeEd6NEMxcU1zQkMwRlZYRElURUVRSnp6R1IzT2NGdWdnZ1VJTXg1d09ScFlVOU5aZWhpSG1hTnh0ZUdxZFpBbnVhZDV2UUxzT3JPZGlhOGpmRDhpdGllRFJqK04xeGNucXdiK1QrVysvZVcxNXR6ZWdTSkkyYUZZWnh6OU83YmhHbjhTUktrOXpjV0dsN09uK1hiZk1oWVY0dk9KMEc5MDRtYjk3ZXJ0ZHRmeFljOW1kamVPTnBadG5XcytPUm40RjM3dGxHdzlJdnJqZWZIUTNEREdhWHo1Nm5odGJ5YlBqeHJ1dE1aejVtNDJBVW1vNjkxS3RoQnU1Ky9QYmEybzJsclhWdlpmM0J2VThlSGg2MTJ2V3Q3ZVU3WDNyejlPQ2diZVZob3ExdHI1eWUrSzFhdzFycVBIenc5T216L25nQ2o4azlPRHpzdFJ1cFV6ZTF6TFQ0TWh4SWh1WmRuUkU0TkdMNktUSlprOHNzSlVaNUtaVmtsOUtYRWlXVTJsL1JBa0Z1L0tzUTUwRGxLa1lsUDZVdURNeGdLZjZYczA5bGNVQWxNZzl5bGFPTWc4czh2bmo1UTFXRHJpQkdGbENQc3lxQlpwUlpNRmJNUWdFZTRMdi9KWndVR3h6bi9FajlhU0FjU3loUlVqY2JJeFdvT3NvTTRUT0g1N1BLYzBsVEp1YkpoU0M4UzRJeVFqemY5TkJQbW5CUjBDbmI1Q1gxT0lOeDFaZDR0WVpmQ2VZUFVSMHJ6N0o2clpacldoS25ZUndPajQvZSt0NzdqL2IyOXA3dE4xM1RLRklIYmtHVWZPNEtieVpsdVQ0SzAwa0NWdm5GMWJhbTV3M1BodmVQU1hQRWF6WGFaQlpmM1ZqcE5KMXdGbUxwcU5kZHg5U1BodU9PNTg3Q2NMMWJTek56TWc1dVhWcTFISnMzL0hSdHM5ZXFRZHBGUGdtU0tNMDNla3VIL2VIbWN1OUtyL0h1NDVOSm1QN3VIL3lSZjdEdjVPWmYvTzNmL01JWFAzLzc4dnJWaSt2cjY5dE93M3Z6Sjc3UTIxN3hOVHZKay83amoydUJmL242OXNpZkRYZ3pJSHI0NU5ubG5iVWcxVDU0NTcybDVTWDVzcHFTRnFYRWt3SXFJc2Y3SEpKUWpxZVlFcEd0U2d1OFNJL0VRdnBjRmtEbG5pK2tZcHhPRWlzejFBbkhSZVFjT0o1c0YvSG42aThidXdqTWwwbW1Fa3FyVVJsUFpEUFhNaEJoNmZzN2Yrc3ZneGFqd3NraGdjV2twQUxoVXdKRnNnQUtLZEZ6cGgyZ3NnQ1NZcExIS3Y0Y0NIcXhTSGtmR2Y4cUtDaXpGYWpaYk9wN0V4c2JTcGJnWE9VVDltbWM2SHBtMm5CRmJNeDEyRHg0NzlnbDVoTDhJUEpudzlPancrT2pvNGRQZGcrUEIxbXFMVGVkT3hkN1ZxR05wMkdVNnFIbERIMzVKVlNVZGJvTmNCbE5vM0hJKzFXT1pSK01aNE94djdYU1dWOXRzQXBOYS9ZNnZacWpKZWxTeHpzOG5sM2Q3dVI1K3Zod3ZOR0FQMlZqNC94a3YvL2FqWTJtcVdQcFFDT1BzYUhPaTl1WDFwd2luaVpacStXZUJvbXJaLy8wMzN6dEwvM1NYNER6NDlTY3p1YUY5c3JHRnZ5dG5VdTNYM25qQzI5KzhkWFAvM0NVSjJuL29GZlg2L1YydTljeEhIdDljLzJyWC9sT09CcnQ3ZTVOcCtIeTZuS3Q3cFVpVWpJL0I5RHFVbVVxcjNmdXdFQkQrRFNSNEJXb0hQeVRTV1hYbndjcVRJV1hVWklFRDJkeDVpaEsydU1xWG9VenN1ZUNBSFBQUUhpK0FDUkhXMVdXVkVNalE0VmZLQzQyM3Z5N3YvbVhTM1FGeUZFMnZpSmpWSkdnd056OHowR1JMVUtac1FCc3dFSVBuZzhsK2d5RXZLS3ZvTXdqSUlWdTRhK1lSTVlvc2ZnTjZ5SjM1Qlg0OEdLRElLdTdWclB1WU9WT3Nzd0VIZzJIdXVlNW9ablJlRFE4T1Q0OE9weU9SaWVEL3NIcDRQRisvOEh1SUM3czRUVHV4NFZsWVR1WXdDM3k0eFNhZVJSbGg1UDgxRTh1OUZ3c0JuQ1NSOVB3dlhzSGx5OUI1MnVGNHlhNXNiM1duazJtRzVzcko4UGhkSlpzcnk5dFhkdytQanpZWE8xMDZBc1ovY0cwM2ZDYVRYZTU0VTdDdU43eThpZytHc3dTMTl2WjJOeGNXL1pNN2FPbkp6MWJ2M256TXZZSG5jMHJuVWJYYVhWczAvSWFiYS91MXB2dG5Sc3ZUd3Z0RDMvMzY5Ly8rQkI3aGY0Z0xIVHo4cFZOSTUvNnMxbi81SGpxSjh1ckt3MzU0SUxTV3lXc0NrclpMUUNHdEl5cFhGSEVFb1V6VVFKUS9qbGhpUkpZcENwekpTaFFjWVk1WlpsVElqbUlQd0JVUnNtMm1wTHE5RHd3bHkwdmE1RWljcUxTU3lsVmo2ZzdDMVJhekdzM1lscVp5UXdGcW9CYzYxeEFsMlZlZ0RKN0FZQkRvUFBCS2lTcGlnczdLYlFJWmFrWE13Q0M1eUF4aGtsdGUvM0lDNkxFTEFyYk5xRHg4a3F0b3VaYTdib0Y5eWJMc0tWa3UvTWNrNExQdWhYUitQVHdFQW8vR2ZhMWtCY2RYWWRmZE5vZFRmZUd3ZUZvR3ZoOEw4ZkxXNTBpQ3NNb3pEUXZnVytrRlpmWE92VG1MZDJ6TkZqcFIzdW5UdzZtYnJQZTZOVERxRmp0dXJaaE5neHROSXMrZm55MDFxei95QS9mZWZmZTdpelI0SzhjVGNLZDliYkdHNi9HV3FmdTJjN0oyTi90anh1TlpxYlpXMnRMeDZmOXFSL0JMZi9XSDMzMUQvNzFsOWZhN1NzM05oMUw1K3RYbmFidHRVM2JNVTA3THR6LzZ2LzdYOTI4MFA3NDRmNytkSkQ0NDQ4K2VyeFdhL1k4N2NxVkhldzhwbEhhN25icTlab0lpT09saENhblhGbUpFaXZEaVNnU0NKWDFCbTZlTDlJV0tKTVlRVktmQWRObDlEeklXTXUvMGlqU3pTbkxDREZsMWc4TTUwQzFqVUV4SzcwU3pzWFNqUmRRa1dycXFsYkl5Zno3di9HWDVDRTZCU0NVUEltZVlWbEsrUXR6VUltUzFmOHVLRVZYOUtYZnc5U25sa1c3UzRybkZoUHBRMWxTcFhHR3RUMUptdnhJM25Ua2VSNjZub1NSYmxrMXorNDJQZE0wL1RqR1BoVUdHOU1nQ0tLOHlDTi9Xc1NqWUhDMDNiT05QSW1TN09KYXI5N3dBbWgrb1VVRjc4dkNBRi9vMVpxT1hiTjBEYk9CZDJ5eFNKamJxMDJIcnhjVFNlczYvT2RSa2wzYjJXcDAyODJhQTI3ZGJpT1lobkJSQ3R2OHpuZnY5bGJYSHU0ZjhZMDNwakVZSjYrOGRQSHhnNk9WYmgwTHpTUksrbEdoWmJrZkJ0Y3VYeHdkbmZCaG5UeEhFL2VQajhQaCtITS85SVgyK2hxMGtHc1RwR2J3ZzRsQkZPWUg5dzZtK2ZMRzJxMExGNTcyZzM2UzN6MDgvWGgvL01uOTNYQTRlZW4yYmN5ZlRyZnIyR3FGTDRkUGhFZXRnTElBRnFVSmtDZ09Za2NZbXlQUFFVbTFBR1hHaTRDc2tvUVJ4c0ZacFNzUXFoSkttZ1VnQmtVNEN4ZDBzUUpGVG9VbUdZQnFJM0ZrS0JXU25oQWtMcnB2L3IzZjRGWVZ5VE10cTRCeGtZMUtxdnRZaXhTVnRTNlRBRkpYVUtJRVZKdExVUElXVUlneUlZQUJRY1BRR09DZjAvVXlSbUNjMVB5VnBlR2JxLzN4WkRJWkFtRWJmQTRWeXUwYWVxZGR0eTJEN3hMam96OW1sbVZ3M0dGcG9sdy9QVGhPWjZkd0ZMcDFxMmxyTDkrNGVIRmplUlFtRWN3L3RvVFF6cnc0bVlXZnZieUc1UUJNTXJlR1k1eGxhNTFhdzRHRjFqRXo0bHpIK2pGSjB2MzlZWnpxczFtaTU0bGQ1SjVuWjJuZTdYV2VIcHc4M2p1NXN0bk1jMzI1MThha21jM1N3c3l3RFhBTnJkV3VIWjFPK3RQWmNxdWVXWjZyeDUzbEZUOElyVUxIRHZmWjN2NzdiMzIzYTdmcXZaWFdVaU9hREhJMkxPL3ZQMzdwK21wN2RmdGsvK0RCczJmaExMKzIzTDZ4MXYzTW5TdmpNT3o3azJkUG54dzhPM3g0NzlIYXlsS24xeFlmQkdzVHBRVjVsYm91RXBUb0dWQWpxc0dSek5MYUNLSUVKSUJSVU5udjUyRXhkekVRT1k5THVpcndBOE5aa1U4QklwVzZDNVJNcVdrc3l5UHJLSzArbnpXSFdlZDFkMFUzejErRWN3b25pWE1ZT1M2cSt5S1V6VkJBMmpMS254QlhvREFxcnA1cVZkZk1maEJQZ05Beld4VkViNFphTndqU1lPcERYZXUxT2dBWmhsNjBXbzZGMlpObk05OTNYQXNyUUJUSHZHYXBhY2ZISjlIZ01BM0djUlRZaGJiY2FlVkpzclRjUzRzQ1RqYjg5cXpJd2ppL3V0bUZjd0pIeDZwNzdXYXJVVzg4Mnp1K2ZxbEg3akVVMS9Bc1c3UE1KMGY5WjNzSFhxdTJCNWRsUEw1K1pmUGloZVdwSC9QTk5qbWZYMy81MmthZGIrb3I0aVRGVnJMSXRTREpsajBydzg3VnNxY3p1T0Q2MWxyYnJMVzNWcnY5NGFCZDkveENmM3AwK3UxdmZ1UDAwZVBQLzZrLzQ5YnQwZkdlVWVUVC9RZmYvZkozM3YzS1YrSHR2LzNlZ3pnTHgxbjI5c2VQOHVsd2ZhbHVtMjZVRkE5TyszdkhwKysrLzVFWjU2MW1xOTFxOExhbUtMS3lPeUs1VXU3RUxrYlBZWlFOZkI0VXN1UlZBc3VWTVFGbS9lQ2dBTXBLWFRncmVqNWVzZnBVVUpxNFFNdW1xcDJ3QUIxYVdhcUFZV0NHV1BlL2dqTlZiVkdScFNhZU9DZEtIMGlCbENJRGdPS2tRTDZUaHRwWUs5LzJqVUlzV0JKVVZBTENUQXhOdVQ2b2dGcllmNEU1Mi9PQUVuekNYaVZJdzFicVIyRTkwNjNaY0FTWHBiZTh6Qlc4S0J6SG9DL0RkK3ViMDFtY1ovRG1hK3hpbG9kaEVrU1JmM3lRQkpNNG1ISURHNmRKbnJ1ZVhhKzNQbnEwSDJKV1FDQTZhTTFYYm13WU9YY0ZiYmdIZGZmUlhyL2pHaHZMYmRuMTZuQmRucDZNajZZaFBKQnJXMnYxWnFQakZBOGVueXgzbTI2M2pYMWtOTU5NVER1T2RmUHE1a3F2WlZ1V0g0ZExTMHYxZHV2aGs3MWJXMHZqQ1BNdk8rd1BNSE93RUMxaGIrb1l2WlhWNFhnUzVOcG82bi95NFBIZ2VKQ2NIRzlmdVI3TStvL3V2djI5ZDk2NWRlZGFhQzk5ZVBmQldxZVZ6TUpPdHhWaTFlRFBYWXBFTDRJNHhYVENRdkg0NFBqaHc5MzdkeCt0TDYwc0xYY29MQVFjMERtYWNwRWZSVW5GS0RGelpJa2lRb0xTRDVVUEtMTTRnMVRKaWxLVzVrOEozRHZUK0lJSUEwUlNWWXFnamdDeHpndHB4RWlxTkZDcG13cWlMVXJGa1NkYjBqT3RVWXF1V294c09VaU44c3pNYzVyKzd3R3FBTzFGVmIxd1JZWGdTbWtDbUVjTXpiYlNZNktWRFMrQjVBQmhVK2FvK09JS29HQlIwUld3UnJuazNnL3R3dlJtZmdEUHQ5bHQ4VFVyU2VJNVZrTisxMnpKTDFOTnZndFM3cTN5K293MlBEb2VEUTdpeVJBdVArcE5ZWVZadTJFNzlvZjNkMmNSdEJjTjV5ZFViYzI4dU42bzJVYW1XYjF1MS9mRHR4L3MvdEROVGRmU296aGJXbTUvN2QwblUxNzYxTHZ0K28yckZ6WmhubytQbit5ZFBqMEpicjF5NTNCdnYya1o0M0hRcXJsWGIxeGVXV3BQeDdPVFlRQjN5NExiWXh1ek9PTnZyaXk3ZnpKWVhsMmJoWk0wU0J2dHp1SGhFWCtkd29zNjVxT0hENzd5NVQ4K3VQZm96bWZmV0ZuZDN1ZzE5eDQraWFkRFoyMzEyWU9uN1hyTjBQSnIyQStrRVJnMkc3V2E3VjVZN202dnRHTFQ0QVk0emg4OU9mREgvclhyVnd4VGJyamlYdzRpN3hLcWVDWGRjaWdrUWFCYVM0UlpaVVlGQ3E4QUNRWml5MUFxYVFrY1dZVWhUaDFMd25OQlFhbitsVzR3ZmdZTFNuSm0xK2RRVmx0TkF4QVg1dDh0ZmZkL1g4aWx0Tm9SSzNhS0dWV1BVU3p6b3NNNGxOV3ByOHFmZ2NLcVVBRm5vekl4S0lTZ09yWUlaK1JWYnBYU3dzeU96VmFTcEVFY09xWU5mVTdpQ0Y1RzA3TWQxMGE3Zk5qekxNZGVFMTQxMmdLbnBuK3dlM1IwNkNiVEpBcUtORXVTRUZPaGtEdXZqL1pPQmpNZi9HRTZhcmJ6K0dTNHRkeSt0cjJVUlFFYzd5QUkyZzN2RDcvMndZOTkvbnFlSnIxZTgxOTkrMjdLT1c2RXMrak4xMjRzcnkxWjRkZzJ6YmNlN0sydnJjNG0weXNyVGExSTlvNm1SWko2Mk9RYXp0SGV3WWdMRGxySWtjUUdORS9UZXMxOXVIZGdHRTRlQlk1VFg5dmVtbzFPdTYybWJscHhsQXo5YVA5d2YvemswUi8rN3BjdlhWbzZlSGovcFIvNzhmN1I2TDJQSCtUWVpneG5qOGYrenNXdDJ4Zlh0dHAxckUxWTNQYjMrMnZ0OXNhbHpjY1Bua1krT3AzYVRudm44a1gxaWpJS1VjbFVaQ2tKWlJNbGgzWVRJM3cyY2tMKzd3Y29SRzdDVklLb3lqeEkzVGdJNytlWm9rYmFjbUd3R0FTRWRSbVg4U0ZnQ29JQ1JaU25ZSWliUVRJZUFMd1dCeUFUV3ZkUFUvZEZRL3NjcUdMblFNZ3FKTTlTV1A0WVVkUGhUd2FVV0xUNm53S2NEYzh4S3B0WFJLa1oybDNiY2diOW9XN3pwckc4eGpLblRkYTFOTStQK3hNWWVIbVd4Z3JEYUR5ZWprNlBEZzcyNjNvY2prYlJEQVllTmc4K2l6RUwvR2VIdy82TUQvRkNncTVyWTlONmI3ZHZGa2F6N3JidHduSzlyNy85Y0p4R1Z6ZFdtKzEyZjVKODYrTTlTbFRYd3loNTZmTG1oUXViZFRQVjhtdzhpZFozTHV6dUg3MXllY2t4MEF4ajcyUzgybTNHMFFTTzlON3BjRENhd2VlNXZMTTJER0ovRmpZYlhzdHpQbm02YjFsZXpVNG53N0ZsT3ZWMkk4MEs3Q1ZnL211ZS9kNkRwOGVUeWNXVnpaM2IxN3RidC9xNzk3RDVIa2VKNFpxOXRiVmk0dDk5dkxmZkQwSi9kbkE4RHZJTUMwNWM2QWNIcDZlekNaYUxSL2MrM2xyZTJOenV5ZTA0K2dJVW53aFJRTWxUZFYzR1R3eVdhT3R6b3Y5MDRLeW53bElSejYzaTU2REUwNmlwMkNJSXFwd0taZjRpbnhmaVloNFp4MnJNaFFCUlJTTklBZURtRmZGNTl6K2hNeXBIY2ZoQlpJcXJNZ1FpS1JaQWQ4V24rWUc2cmxhSnhmQWlLQnpxbGFyUFVTZ1VJNW9lcHRyRTZNSnhRWjNZWStyeTN1b0lEa2thWVE4eG5VYlRJTEZnTm0yTDFqMHZScVB4OFBpZ2Yzd3lIUTcwWkJyNVByOHVYQlN3Zi91bjQ3dUhneUJKNVk0aVg5UU94VVZQN2gyTnZ2L282UDZ6NFljUERvNm5zKzNsMW5Lbk1ZcTBUTlB2N1o1R0tiK0pnQWxtYWRwcnIxeHQxeTA5VHpURGRlcE4rQ1A5NDlPWGIyNUNvUjJ2MXVyV3VvMTZwMVAzaHhNL2lncmRQaGxFTDEvYk5QWGk4YlBUcmJXbG1xMGQ5RWNkMjlYTk9JeGlxOVlabng2SGFiRzVzbEkzdEpOSmdBM3Zkejc0T0J3R3QyNWMycmg2TTBobTIyM3ZDMi9jdWJDNWRYamF2NzkvRWljNW43c0VlV0U5MnoxMnNxSmhaRnU5UnJQWG5RVEowOGNQODFsMDZlcGxLckVvQzRZTXFxbjJXU0pYY1JyTDRSU0RXUXBmNW9CZzFVbUJGS1NwRmZ6OHFPWlN5WWRqSmRyQWVEVU5GcGtBcWdJS3p6TlZpTkdTSHFCeXhhTlN5ZkpjSWhVSGdiSXZRcjlvdTh0blpuNFFrSnBrejRNcXJBQ3hCUkpHcGNhelZpcDRicm8vbjMwZWxJR3AyTXE1S2pDdldpTGd5dHVvKzdNYUZOU3lMZGh5cUFsMHRlRzVjUlRwcHBubU9ud1pLRHF2Uy9JenEveksyUDdUcDRFLy91RGV3NjVUNVBFMHhGWTFTV1pCOU5HejA0UGhqQS9mUUg2Y0lRNVhSa2I1RmM2bzBJS0k3OGgrNWZxRlRzUGg4Mk5hN3VmNllYOEVYeC85RzA5bW43MTF5WE90aHBNUFI2SFphTmJyenVISnFXdWlkcnZYOEJ6UGZlK0QzVmRldmVpNXBqK2VaSlo3OTJqODNpZTcyK3ZyTjY2dURLWmhtbVE3dmZxamszNjNWZ3ZTek5TemVyTTltNDV5dy9aRGVPRUpmUDVudzBsL05PNC9mbmpqNnZXMWxmYmw2OWVXZDY1MGxwY240L0ZzRXJhTmVMbUpWY2xvMWF6dDFVNjlZVDhlams4bTAzVXR2L1A2cmROcE9NVk9Oc3F2WEwra2FVa3BXMHFUMDF0RVdtSEtTSm1zeEs0SUdKU0txM3dPdDBUT2hyWENQQStDVnprZ1ptUUJjNDVCeFFGVlM5c1FaYTZpbE5jSktuK0dCSUtabDYwWUsxSUJSZk9EMVYzcXFuUmR6ZXl6cHFqaXlrS0w0eVI2dDhpZUJHZWxaS0tlNDBBdkh4MUZseW9vcitJcmE4RW84OG0yckwyRTg3V3dtVEFNZzdRVzV6cDBQVXR5dzNLYW5XYVdSTTFta3kwM3JUVEZacU5vTmx6WHRmd2dUT0prT09nUCtpZjl3OFAzUG41azZZVnJHWEdTZnZSczhOSGVLWGFIMkFCQTRWMlRKeHR6U0pmWEcxajhlSm1XWloxNjdmck9CamFGY0NSNGdkOXk3ejA3WXBzS3pUYTEvc2w0WjZQWGJkcW5KNk5hcjlkdWQ5dTIvdjRuRHhxbWRmbkthaFJsL2RQcGRPaXZyTFdYZXRqNFpnTndpVk1vY1g4NDNlN1dNazBiVDlNclM5N2ovcXpUcWljekh6NVN1OTJiVFVaWkd1ZHBYcXZ4STJiWWJVL0M0SGQrLzh0M0xxNnZyNjN0dlBTWnJVdFhWemRXdi8rZGI1K2NqS0lvT1FpUzVhWHVzNk9ocnR2UmROb3h6WUVmbmc2R0RjUHE5cFpiSzJ0Yk96c09uQzRPZ0dvN3hhcXN2Y2lWS1NMa1dBNUhGYzZSbENBSkVqSkNkWk1SaDA3Z2VFWlZvc3BCVjNqeDdFdVFYUFc4UW9XUm1MTGNsZjRnTHR3UlBTdGFiV29KUE9OZnVQSGxMaFViT0RPLy9xczhsN0NvMWl4Qmt5VXgrSG9vZ0JSY0pCRU55R1Mxa1E0cEVKWXFMTUlpWms1UVlwUTB3VW5sVlpnU1N0YXFwMHllWlFGVWtxOVg1ZFhGL0RSeTZKTG9CbnowZHJ1ZXBYbW4xWEM5UnFZWmp1TUVZVkNyd2YxMThpeWJCbEdZNVkvdlA1d05EazhIcC9maHJZOTVoZng3VDAvaU5LdnphL0dXWWVwUWVtaHp1OW5zMUt5dGpaVlpsTUU0ZTVaMjQ4TGErbklibS9Vc1MycWU1OWJkSndlbnN5amhGOEEwN2U3dWtha1pUWmMzdk9MQ1hsbGZ4UWFnYTZkd3BySDh0R3JlYURLTnc4Q1BpdlhWMWdUYjZ5aUZpamRjYTRwTlJaQzJvYzAxcHgra2RwSFp0VVlRSjFlVzNQdjlzT1BrVnMzcWo4T2Q5V1ZNMjJtbXU2WXhDTVBqdzVOcGYvelp6Myt1MCs1MjF6ZVBqdzdlZS9lRGFaUjFhdTRrVGpFOGptdEFMUFZ1RTdZQWMzNnQ1UWIrNUpWWFAzUHgwckl1cncrQ0FOVW95QmpRY2dtVW9xNVU0UnhVaG96UjgwR3Nua1Q0ejVOd0pZNldTK0VBWmE2QXhDc0V6aW93amxJbEhoMFJCRUdkRm5NQmdoVWF5U2h4YkwrMHA2VGttd2hnM1pHWUJ4d1k0YlJnWXhta1BEU2VjU2xHUW1hVndpakpoRklCSzFDWVhPd0h0eElpT3dSRkEwbXIwdk16QkFWS0ZWY0FiMWhPUkxLSG53b29WUlNlbGUrT3JCejZsdWRKbmtOZllaaGR2dUs5aUdLK2JqZE5Va3dLMkV2THNtRXZUNGF6cHgrOGZUSWE5US80UHQ3dHJqZWF4WHg4eGpRYzNYUTl4NlZWdHp6TDZMUWJuN3U1ZVhGenVYQ2JsN1pXZDFybUVueHp3ekMxUEF4aXIrNXg4YkhNay80WTlhTEJtSEVmUHp2YzNSKzllWHZqdUI5c1g5d3diY2RKQWdQYmlWVGIzdXdrZnRUd3JONzI2b2QzOTUxNkkwbGkwekRqT0Z0dnd5bWFoWEZ4M0IrL2NldkMzdWs0SzdMZGsybTNYblBjOU9na2VPWEM2ck5SdUxuUzIrcDZIei9lOC8xb2JhbXRaZW1UdzlOMFBQbmNqMzdSYzcyNzl4OS81NXZmWGwxZDBtMTNOQndhV2ZIMGFFU3ZUT09QUGw2K3NKcldHMFZxZk91dDc5eTVlTEd6MXVQUVFMelVlQUF2b2Frd2x6VWlQMER1bndybFVCSXdKVVFEb1FyVk9NcTZMUWVsdmdwWUkwakVPRXNaVmFlcXRveExvb3p6VUo3bUFVeWdZS3hOaFJMQmsxcGhBSnpKNW0vOStxK2hxZ1hTTWc0dTZpaHRQcHZOS3E1b3BIa3FDeXpMSXZPZzhGSUtNRS9PY3hXU2pVQXpSTlpzbjhwUXdxaDRFa1FvQ3ZNY2NPWFJlQlBVUEE1eWRCSWVEZEpGbnNGM2gxTEdVWXhDbnVkZ0pzQndvamZZalEySHcwZDNQeHBPd3RuZ3VPNGF5OHROS0Jic3MyUGJVVmJVYmFkVngyWkFYKy9VWHIyNjNXczRTWnFOd3dLK2QwUG5ON0lkUzQrVExJMFMwN1hqS0d1M1c4ZkRNZS9Zd3NtZ1FJclQ4ZXg3ZDQvaW92anNxN2ZzZWl1YURXQ3RSMUJzeTIxNXhlcldVdTQwajJmWjZYRHFHSnJ0dXFlajZYYXZxV2VKYTJwK0ZMLzl5Yk0zWDcySytRT2VrN3hZNzNST1p6T29yRzdxNDdGZmM0d2dqQTZIMCtzYks3bGUzSDEyRW95SDcvelJWOS80N0dmKzUvL3EvN25kcXlWUk1wNk0rN1BZVDlMbFhtTnp1Wk5aUlpobnpXYnJKTURXMWRYaTdNSGpnMWZ1M0xHd2Q2ZGlsRkpWb2daVVVxYjh5K2kvRnloNmh0S1dxNk5Dem9kZEttS0NXcU0wcDBRaFNmWEFiQ0JPU3BVQlVpMkR1bkVnOFRNQ1ljMGdXVFRFeXM3S2NNelYyekIvKzIvK1ZhREFBbGpvUWE2ZUxZUEhJcW9zazNIT3Q2eE1QQ0xKTGZGL1FsQndEa241U20rbGlleWlCQVVWRGR1RFRpTVhVRFdBTW5neGdBVXZKTUwxZURLRTdzTlB4L0tkV0ZDdllaLzZoOTFrbEt3dE4rdU8zVzNYTWJWU1htaFBCeWRINDZuLzRQNG5ybTNjM2xnT3NpeUgrMitZa3loYWF0YXZYMWphN0xadlgxcHR1UFpzRmhScFBvM1JhY3VNQXR1bFA1Zm5hUmhIQlhhMXR0TnIxWmE3alRUUEpyUElOSFRUTXJPOG1FYlJ3ZW5vWjM3a3RVNm5lM3JVYnpwcFZEaVozUmhHeGFPblE2ZldSSzlPUjZOMnkydlVuY0l3eHNQSnExYzNSTnpHT0lydjcvV3ZiL2JDT0EvQzBMV2R5NzE2a0dmWVBXUjVPandkTnVHclJQbEtxellZK1dHZTExejc0ZjcreDkvODZzczc5VWE3OXVHRHcybVFOVnh6dGRWSTRMenhHbjkrc2RVd2kvekdhbU4xY3pQS3JTTHkxell2cjY3M3NDUmhISldrSVUxbHpoYXNMK0x5RzZnenpQTkFCNGJqVmNaVnBBU0Z4NEYxeU9sY2tJSVM1SGxsOVJiSXFvQUVNYW5Bb25wK2RvSUZaQzFRK3NOUTBhdGNCaTc0R2p3MTVKS25haEZ2LytqbTMvcWIvNUVVRmpsTEJHTmVRTy9KQ3hpc2dVVE9neUxqd3NUeUMzaDlrWkkxU1RCa2twV2MyUlRwM0x3ejBoQjFCQkREaGlJcUxDb21raUlWNG13ODRpVlNBckJRYXJCOU1vS2V3U1pxS1Q4V0UvRzdwenAvbEpSbHVtUHIzVllkWGsxZUZFbVMrV0dZbWJVUUF6bmNNN1hrMHNYdG01ZFd1blVuU0xTajRYUm5yYlhaYWNIenFjR01XK1prT01WWXpCS01PMlpTeUpVSUtza1h4aWQ4dGFwam8yUHdUeTRzdDdBTjdpNjFiMS9lZXJ4M0ROY0dmZTk2N25MWGUvVGthSzFsd0RWdkxpM0ZTYjUvTkQ0ZVQ1WTcySEZtNExhNXV0Snc3RmhQQnNleno3eDY3Y0tsZFg4NGpHSnNUYk5Ka3R1ZSs3MjdUMjl0THE5MFBNdDFvSjFoR05jOTYyUVFXQ2JmOEdIYkxzUXdDaFBNOC9WR3M5dXNiUzYzZGk0dmpZZXp3OEZzcFdZUG9yU0kwZ2ZIbzcweE4rcDFQWFVkWTI4d3hmcDE2N1dYK1VFYzlRY3UxRllSdEZKRVFxWDVIQWVSdHFRQXoydjJlVGlmS3lNcllRR0JOT3FBYmlBR2NVcHVhVjdQZ3V3VnoyTkl5VGtnQVJnbWhiUGtzbG9rMFFCUmZTTFpHMVVLNnY3WGthM3VrM0oraUkxblNiSHVyT3dzVUFhbDR5RVlSYVBlK1hIV2lhcGk2Y2tjcjQ0TXFtTlZZR2RVVUJPanJFVldEeEpRNmtwdzB1NUs5bWNCQmFUbnlEaVo1aE00RU5pbFpqbk12QU1IQmtsRGMydk5MTTBzNktiSk53cW1mRFF5bUFSaHB0ZnIwNzBIang0dkxhMTFYSE85VjU5bzdZUGowL0hJMzhTR2tDOWF5aHpIQ253NEJka3N5ZUpDcy9sTVNsNnpIZXhpNHlBeUhBdWV1ZWRBQWhrL09XbFlyNy8ybXBmT0hoOE13cFF2MEx2MzVPRGx5eHZmKytEKzFiWE82Y2xwYjMzYnEzSHpzSHMwaE5aMm05N2hZQUlCSm1sc0c4YnZmT085b1ovZjJGN0ZESFNNQXU0WFpreXpVWWRqOXYwSCs3YzIxNW9OVUpsd2ZqeXpPSm42NkNvZnRIUnN6OUQ2ZnJ6ZGJUdzZIS0JRcjEyN2ZmUFZLeTlmd3laa2VXTTFUYlhCWkRwTk1jOWppTXlmQlRjdnJLenRiUHpCSDM5bm85VlozOW1tVFBrWkxnZ1grUVFaQkpGdGhSSGQ0SkFBSSs2K3lwb0g0c3V6eWxvazRPQ29QQXdVUnJiY0I1WnhLaFYvdDM3ZVlwYjZRK05McmFBK2lBNHdxWTVWVUdwVFJsU043QWlMVUROTHZhTHE2T1p2L3NadktGdXU2bnV1eWlxSUlGU3VicW0zWTdQdktyRGRpanNDTzZTQ1ZEOVhYTXBQQmRYb2lrYUpXSnFvQ3BhZGtiSWxYbFdraWk5MEZTSWxtWnArek5OMGUzK1N5ZmU3ZUNmWmRSelR0b2NUMzYzWE1iSHpOSE5zRFJ2UUxNdUNLSVQ3TzU0RzI4M2kyVkUvVEFzOW1mV1dseDVQTkdUdEhaK2crRWF2alMydlplaVlQTmlCK2trKzlXT1gzK3pKc0FuR25Fbmp4RFR0VEN1c3dnaUN5SVd4OVJxRllVZURZNzZEWUJieWE1VkY4Y0hkdllkN3g5MVdRMC9DZXF2WFcrN0JhY0krNGZ2dmZiTGlGdnhoaGp6TDFuS2Q0OVBCdmYzalAvNysvZmNlOXczTmZPUE96dWJxVXMzUWU5MkdwV1ZQQnRPMjZXRGwwVXdMN2xPUVpxTnBtRVY1cittMDRJNXJjTGV5c1I5ZjJGZzdPQnovM3RlK2Yzb1Mvc3d2L2Nycm4zc2xUZnpoYU5TMHRiV0dDMDVySzB1VDBTeVpqdXhPNDlIdW9aV2ttenNYSU9tNWdhZFNpckx5UWpNSFNESUVWQng1QUhVWkdnWEt1Q3BGMUJtb2dodzRqcFFhT0JsWmFveUtLL1ZBS1JwY05mcFFjZWJLdUNzTXlUZ2xPRTlLdDRJMWxteVZtNjRDVzhFOXNTb2w4WW9TQmMzZi9KdS93VHlscklwYUZLdU04eEVZaExKdUNXY1lOZitvdFdlQmVLbXBvbWROcWt0VlVIZ2hsbFZGK2trTUtsUXpCNkZxa25CUXJXZDFxaWVLaHR4SUNWWnNxSzU3Vm43cXc1OHhvaWdFNzRialdxNlg4WWtXemNVZU5JbmhqTGlPK083YzBPcUQ0YVNmMk8zbDFiVUxsNG80Y0xxYlIyUGZjMnRIeDBlSG8rbUZ0Z2MvQmRVMFBNLzNBeGdoS0FsZmI1R25kYzhCbnRNZzE3eFcwN1g1TWxSb2U2cmJwbDFQZzFHbjF6b2V6SkRvOURxbm96Rm00TVBkMHl2cjdjSjAxbFpYNEg5N05mYzczLy80K3RaS2tVVGhlUHJtNjFlemFmODB5TkFSejdXT3gvNlQwL0ZnSFAvWWE1ZHUzN2p3NGRPamxtTzNYY3V1WWU5dExiV3NtbTN4YmZSYS90SHU4WjJkRmRQR1lwQ2VqRUt2Vm5NTmJXOGNCcnF4ZjNMeXdmZmYrV3QvOWE5Mkd0YjIrc3JtZXJkbGFqWFg3WitPajZJb21xVmJLOTNMRjFjKzNqczE0bnhqNXdJVm5lckpZVUJzcnJlMHdaUS9veklXNVZnanhoSVNMMHRKZkRGVXZnRExDcE01SmNkTzlBSG1GVW1RTVFsRnA5a0Z2bktWbGYzbGFrQ01LQzR4aWdNVkhWblFJcm91a3FzbVF5WVRRempRanBPUFVKcS84UnQvNjB5MzJCNmxiVldvMmlkQmRadHhpRUJXSWdiV1hXYVZ1Wi9HZ1VxcExIMUpJUFNWNnF2QVBoQjVQbERQVlYySWx4RlZmRDYvUVlCbEI4UzZZNXJEb3A3QWRNY3dycHBqTzU3bkRjY2p2bXJKTk9Jb3JIazJSRExoclVYK2FtazBHczZTNG5PdjNEanVqOXM3TjJlRGtlMDVKMGVuUVJ3ZURXWTduWnBxVkRDTDBPR0JueGltWGlTaEE2dHY2VUVVUXd6TlZnZTRMRTBzMjRMclgrc3V4VEUybVA1MFBMMTkreHJDazZlSG1GdEJrcDlNb3pUTjc5eTY2dFZiOElIZSt0NzdUYy9lV3NhRVRGZVhPN1c2UFpybG1GUU9kb1paRmlacGYrWi82NE5uNDRIZmFWcC84TmI5VzVjMjcxemRpcExVcVdHMXlwcXRlc3MybGhvVzl0RE51anNiQmJsbE9ZNGJCTUh4MENjbXl1QmlIWDUwLzgvL3RmOW9hZWRDN1B0N1R4NTVXdjdXMC83RVQ1SThYV3VZcTkzT2ZuODhDZUsxM2txejA0TEdFMFN6ZVZBalJWM0U2RURDak13SENCbVV2Q2owRHd5aUE1V2J5Z0hLeFlvckRnaWdVWGhOZzlkUWxpcUpWU2hyVWZUQ3A5SnNoUWQvWU1wSlVxNEFpQWlCcUxoRTBCZm1tci94bTM5YmRFZzZKbVVXQS8xNEJ1UldOSXdnQzhSVk9JZGhLV2taMmdwTlFVM2lIVEd6NUNtRWl0VnpRZkhoVVZZVk1CRU93bzFzSmJkQ3NpNkZCenVKY0JLYVJqN092R21VeGY0MENHWk92UUZ2WkRxYllsUGFzTlhuSnZPYTU4QnZIMDJtR1grU0NqM000Y3MrZTdiMzBwMVhqdzRQWVBkZHAzNncveXpLOHFQK2VMM2x3V25Kc2dTcWMrS25qbHNyb2huMnZOZ0daQkYyaDZaWGIvQkpzaFJ1c1Q2ZXhXNmpqWmtVRHJFOFJDL2R2TlpzZHJ5R096anR3L3VmaHZIUnlmaXp0M2JxbnRjZkRiN3gzUTh3SHA5NWFjdlV6TWxvY3VIeUpuYVdydWZaTnAxN1N6ZGMxMm8xblAzaDFCOEhXMHZPOSs3dVhkbGN2M3hwR1hNNG5NME1HeHRyWThrcC9PbWsxV3FlRGtkd2srQjRZUTdUUnVxNmErbW53Mm5vRHdhN1J6L3pTNys2Y1hISE5wSm5lMGZ3M1R1dSs5TGxDNisvOXRLbGF4dGpmeHBaN2RXTmpkNVNGem9pZzhpUkUyM2o2T2R5RkhWWCtrZFJpL0NKVWJaVDJUNFZQd3RDaktCR1ZneTVHaS9oTEVjRVRvRG5yb2lvZ3BXQmZ6NndkZVdnU3lqMW9Wb29JRlQrSTQ2V2x3UVZzZm5yZit1M1NwVkNIZndleUxtQUlWUjkrd0ZCWlFtTmRLa014TUdHQ3A1WHNaQlFIVmJjRmtveE1vOUxVS3F2OENWRHhaeDROQlY0T2kvSXhaUW82WmtyV2FqVHlKTnNtQnB4R0lHQW84NFh5YVN3cTdadHR1cjhvRWVQWmt6akk3SDhpMUFjYm5XdWFYZHUzL3pvd3cvcnJVNTdhZW5qRHo0d0NtNVBEMGQrRFZVWld0M1NUc09NaGdyVzNRRXpmcHN5UjlvMEhRdVZKdkN6NElRMGVzdk5kbXZ2L2dQWGNic3JLMjZqc2RTcVhhb1p6d2JqSkdVdGVaaXVOSzNIdTBkM254MUdZWHJuNG1vSDdZbGpyOWFjUkduTnNURlBiRTVjelRIc0MydTlEdmFubG5WNXJWM0g5dlRrK1BoNDNLMTdMZXhRc1FxTitHcW5pMXU5OGNubzFwVmx4M0lPeGpNTFF5M1BEaGx4MG02NlVLWkczZXFhMnJOM3YvRnYvOW0veUdhekw3NXhiUmo0L2YxakI1TmpHbW1GdmJXNnNiYTkwMngzK0RvSGFveW9rZEpJQXpvZ3V6WGxsaWc5VVphZUFsZkNMeFU5RjlkWFhmWW9rYUpGTXYxQVVPcTA0Q1V1UjR3WjFWSEZmMEJRQldtelpUODlWMThKVklrS1dlSlpxdFMzOHNpMUNyUDIxMy96N3hBbDdhdDBUdFhCT0dkQ0ZhaGVwVlpSZTVYK1Zkb21jM0ZPS1VhaTlQdWxFU0JpS1ZXTG9oY1hoY0poS0FVMEQ2Um41UGxhR01vc0l0a1RWWmIxRVFPT2xsbk1JczJQVThndmpGTVFvWC9ZTllaSjNLemJyWG9OZWduTjgvbEw3QXlaVVJyM0h6OWUzMWlGQS9ENDhaUGxpMWZxOWZySjRkRm9jSFJwdmFkalkydm8vV21rbTladTN6ZHMxOVV6T1BYOHdVZFdSR0ZVYXpiUmlqeWpQZDQ3bmRTYnJTUXQ3SFNJcVdZM1BNMXdHNTZiVDRmWTJlNFBmWmN2SzlidnZIVHBkREI1K093QWVneXJmM1d6WTFxbTcwZVdWOFBlZWpvTm04MGEzS1UwaXV2WS9iWmEyR25FWVhMajBycFo1TTI2RndiUkgzLzR0RUQvc2tpenpMcGxyNjUzSEtmUnJPa1A5b1p3NzVkYnRXbVNqMmYrOWxKcjkzU2MrdkVuSDczLzlObFRyRVkxMTNudGxjdmYvL2pKYUJiOXU0OGZmLy9ESi9Gb3VORXdIajk2dkxGNTJXMjFvQW5WaHNyRTFvNUhLaUpzdkNpSjZBYmlrTGxZMzduSmx3bkFYRmhyS3B3NjBrV2hkb2xUUVZaQ1RIcGswUmhKcnNKd05ERTVVWkNEcVhJeHloS3Zjb0ZoQTFocU1RaC9wWlJjS0xqQkE3MmlCSVpIVmFuNU4vNzIzeVVMMVJNVitaU0E0bWUxVWtlRlY5a2xtWERpbHdOUHhXTkU2ZUk4U05NWGcrTEErY3BjS2JzWXpqV0dRcGNwSU5XVnVTVmJCTlVrZ09vSVNFMG9hR2pBdjRhekVoVzVnNWhoOHE2UXJubXVPNXhPb3lnWit5RWZleXlLTUFwSHA2ZHJxOTI3SDN5b21kYkd4WnVlVnpPYzVydmYrY1pLMDhIS3NOcHg2NjR6d2Z5QTYyM3dNVEVicHBjZlo4MkRNTGE5bWxWZXBTaE9obUZtR05GNHNObHh4N1BFZEwxbXV3dlBKeGtkYTdrR2w5azB6RGR1N1dES3RSdk8rL2QzTVUwZTdQVy9lR2ViVHhwclNaUWFKbDhsV1hpV0RaUEg1NURUT0pxTlRrNEduK3dPVnBxTjYxZld3eURmdnJDRW1mckprNk0zWDdzUmo0ZXJLKzNOMWM2encwR3QzdDVhZHA0ZUQxY2FkWGhaeTIwdkR1RHFKOWdabjB5aWNEYnROWndMRjlhOVJtTnlPbDd2dGI3dzhxVm5VLy9oL21EU0gyejA2aWY5ZzZYbGRhKzlKRnBJaXc3cklWcE9OVlhqV0E2ZmlxdWs2SURDSzMxUThYSm9TdE1Idkl5YUZKUkFJd1hpU2tmbmdTQThoWU5TOFJKZjBsVE1WU3NRQklsWTJSakdXUzhVWWs0a2RTRU9kZi83U0tnZ2RHV1F4OUxvQWdwM21lWHNDWkJrVk5LUUhTL3ZjT29RZ3hsUDlWV0xsMmd6SW1mMEtxQjZ4Wlp4dW9hcXo3RDNJbGEwbEJVcEFsVWp5S1FpNlJLYktnUW94ZXN4WnhNQTFWRzJVQ2tnRGdOMHdhNDNtbm1hSjJrczc3NkZnbXB3MTQ5SEkzZ3llWmJ4OG9OOGduTGloeHN0KzN2Zi9PYm01V3NyR3hkTnh3Ry9oeDk5RU14RzhQY2Jwb1hLMHl5M2RhTWZwUjQvejhSdjkyRlBHY1NKN1ZpZTUyQU5zRTB6VEhJL3lRMS8wSzE1eDlnQVpsbG5hUlc1UWY4NFNUSVUzMXh0M0w1K05kZXdZSmlEOGF3L25HRkxPdlVUYkI0MDdIWU5Ld3JqUmd1YkFmNjRienoxVzQ2eDBYTDQ2OXBDKzk3OW85V0crK29yVjZJZ1RETzRYK25keDhkZmV1UHFZREF5TldOemEvbkJzOU11ekxOcFlRWTdqdG51ZEhwdUFlK3RhV3VuVSt4MzY3TXNPem9kMWQzNjFKL1U4MlJudmYxelAvZWpUcjF0TnIyVDRjQ080c25ncE9XMGFtc2JGRGlmZVZZR1d6UkdRamxxR0NPT3lCbStEQzhnWWZYQkFUdEF1Wm16aUpGQkpKOXovS1U2eVJWZEFrYktZbVRQMUwwS3BGUVJWa3dhYVFCeGFDTHhvbVpVSWN3WlVzSU8va2QvKysrRHJncFVVQlZBS2hOTEpWbVptakdxdkxDajFySloxRFp5UjFBMHFJOFZTMkIvcEFnQzJaQ1B4T2tVVWxQcDh4QXBlR21UVUxLVWRLZmtvd2hrTWlqK2lpM0xxcmlNQWFjbDZqQk1NNHJ5U2M1cmlHbWErVW5rQndHMmdNMTYwM1pxcnU0Z0NXK0JLeURrWkpwQlVteDU4Yi83OGxjdjNYN2w1ZGRmbm8xbmNHTDlxZi9vN3NjdW53YW15eWpQSStoQmxPcU80NkhWY0k4TUU4NDM3Q2hmZlNUZlpZZUgwUGVEbHBuRGdabE1nM0VRWGJ4K2cyOXNIWjFpOXdscnZiUFNzZUhCV1B5eVVwSGxEdzlQNGY0L1BCenRyTFpkblYrc240YWg1OVZoN0IzYlBCNU8xcnZOOVk0YkJOSHFjbU52TU4wN25nd0gvdnBhZDNjMExlS2Nkd3RTL2JVN2w0NVArcmFXcjIxMG9paHRkVHVqS0Z4Q1dyTzduVVlVcDVNd2Fia3UvUGllNTEyL3RMR3h1ZHhkV1h1MmU3QS84RTlPWmhjMjFsOS85ZmJWcmJXTm5ubmtULzcxSC82N25tYXVYTDJoaGg1ZFZyWUp3cVhrVlFCR2RQSEZJS3FpSm9rS0xDdExoT2lTR2lrWnRYS3NTd1diQjVXMUdIa1JTY04zcmozU0dDQWx5WHBwQ3FrcTBnYWM4YzhTdXZuWGZ1c2ZVTTh3QTdCUFJSbGdYOWl3S25WWFFYVWVYS3B1TUplZEtZTXFJcEd5Y1dWQTMzTFliNmdKeTNMQ2NibVVCb2xkUnlBZkVldzVibVdqV2J0aUxrZzE5NlJKYW1ZRHlVa3NCWkVObCtCa25FQ3ZlSDA4eThJWUVHSjdWeFRaVXE4RjFRM0RFRE1oNVYwcGVNYkJzcE4rN1d2ZnVuemo1cFVyMTlJa0RNS3dmN0IvZkhSazVqSHNidE8yWVlaelZKZ1htZWs2V3VaaUh2QXBRL0RJNGNwanBjalRsRmNieDRHZEp4WTZhZW1USk4vWXVaaUdnZUhEeStHak96Q3hOQlVXRGhwMnBmZjJqdU00UlF2ZWYzaTAzbks2RFhlNTQwNERib1V4R1k0SHN5TExYcm0xMFQ4WmI2eDFzeUFxaW1RYXgxaHpuajA3YmZGdWE2NmpnM2x4NmNvR1JqZU9rNDVqdFR2WWJIY2doWG9OVHJ0K1lYUEpOSXlUSUg3LzBaRmpHSzllMjdSYjdZUFQwOUh4NGRwSzk4Slc5L00vZFB2eDd1SFJ5ZmlyMy9ybzdROTMrNVBwcy91ZnZIcmxvck8yQTU2MGFDSmtOU0pLdk1vVVVsa2xTWXlvb0l3Q2o2cVV3cWl5WkNMRmxlcXJVWllBUjVBVFFBWk5sTEJpSzlhUVdRamtRQktKSzFiQ3ZLeElpaWhLcEtWdFp5b3ViZUErRWhqejE2anVxb3kwVDhYUDFGckZWU01ZcVBtS21JRmFlTlpWOGkwakNLb1VVRURLUEphSTRpd1JFcGQ4cElqYW9WY2I0bk5aakR3L3FjQkErS2hXZ1F6VEJtZm1vanJZN01QaE5Jd1RBK3FBVUVCUHN4aitRcEh6TlVsNURyT1g4RFZLYVp6RXNONDREVThQTmRmZFhOdGUyMWo2K0owUEliVjZ1L1AwL2djcG5HbmJTbVJmVzdOTm45NVJ3dGNzbVhxYUYyR1N1SzRMWGNkeUZhZUZCVGZtcEk5bU5lczF5L0VhclE0djFjLzYwUCtUaWQveWJMZE96d2VOZ1lXUGtydy85dEVMYVB5RHc5SGU4ZXpHaFpWbTB4c01KaDUvVis2WldyNjkycDJPcHIyMXBTUUlQRTVmL1pXclc1dHJiVnRMalZwdE9KNGRIUjV0OVpwZXUvM0IvWVBDZG9OWnROU3VRYTlXV3czWWtBc1hObTNQdlhWbDgrV1hMLy9lTjk0N09oMzdmbmoxMHJiam1qWFhXdXAybXJaMWVXc1pmczd4MGZIQk9CaU9wMWN2WDNFYTNzWGJyMkgxZ0ZScG1KU2NxeUFZbWhobzVEejNMTWhrV0Jnc0VJZ25MRUdOdTlJdUZSYW5EVmlkaFFXTTZEM3FPdE8wZVM3eVpQVFBncWk0MGhCSkNvYjdDaXprdi9aYi82aHNDalZTR2lUS2RBNnA3SzRxS1RWSnBQVFV5MUlTeWtraWpaT1dxSjZEUUZVc2taS0d4N0xiSWc3a2wzZ1NrN01TcGFJbms3UEF1Y1IyeWpVRTlJUlRTd3lEK0loRXd0V1krY0hwZUVaWFJNdFFkMjdvc09hWVRkaTd3UlNETGtoVDdFVGhiRVJKRFBQYnJEdXpzYit5MmwzcDlRNk9UZ00vdkh6bnRic2YzODBtZzZacll5V0s0RUhyL0VyQ2FCYlhiQjBPTmxvYytxRmw4VkVXK0I4aHpMdG1IQXlHM2JyYjlHek5kQTNYc3cxVG13NktIQTUwV1Blc1JxTUc2ZmwrMUd6VTRqQmJYYTRQaGpQSE5tWnBkamlhWVQ5NmNhWHRXa2JLejMxajAxQXNOYjBRRytJYTc5NkdzMkFXNTlNcEg0NTg4ODJYZXAydVB4cjBKNUZ0ZWJQeHhMVHRvOU5wbWhTWVZKNmVyVzB1b1ZsV3JiNjV2V2xweHVXdHpkbTR2OXJwM2JxMHViTzkzS2tWWnIwWkJLbXBaNjEyczZHbk55K3Z0MWFheDN1bmNWTDgyVi81RzFablNXbXRHczF5Rk5TSVN4eTlnUDZwM09mMFd3MzlQSEQ1NVVIeFVRTkhiZUZnTVY0YVJGQ0NqNmlXQkNrcjZvY3MwUTJGWDd4WldiWUVLYUVrTVZ1b0tDdHUxRG9wclp0LytiZi9vV2d6QXpENEYxV3JyalVvSkFGOEJjUEZvZ3lxc2h4Vm93aHpTelZsZlRBTTR1RHhVajl0UEx1bkdrVFZwSEl2eWtYcUZVeFpmQ0ZYV1gzR0ZWMFZoQWxsZ1NEaUZwN3NzR3g1ZGFOV3J6L2VPOGh6N0FzTitOc3d5WENiNFF0a2VRSjJFYjk4WUVSeGtzQ2hnZUZQa2xDM2g0ZEhEYy9lV08xcWJzY1AvZVhWOWNsNGN2TDBJNUJZTU5MUzY0N243V0YzV1BEamxYeVlKc2t5YUIvOThRTDc0TUVrbUdWRnp6R2FOZGRQTTd2UnRod3JHNTZrZW5FeW1qWTl1K201MkEyZ01hMWFEZXZQaGVYYXl0b1NmSHA0MkZFUURmM3doMjV1a0ZNVTF4MHptb3l4YnNDbmVQakprOXV2M09qM2gzQ3pMbXdzM1h0MmVHMTd3M0M4SzlmV3h5ZjkvY05odTFsYlgrbDAydlduQnllUUJpOWx1aTRtMnYwSEIxNnRaYnYyZER4MjR0bldhdE16VXlNS21xc2JRUmpYR3k3WEdkZDc5UFNrMGUwWXM3amxGaEdzUWxwY3Z2Vkd4amNubDQrT2xVRUpYTVlSTWhSTWljZjRxbEJaYmxLcWNjZFlBRW1WWUJFaEtNdVN2d3JRQ2hsRTBUUVZKRmZwQUJXM3VrVUtkdVhvTTVDK0xNaC9oSVUyU0hGZThnWkdOTlA4eTcvMW53cUZzRkJFRXNvTkIyOHBvNWhTM05JUFVRVGdwRW9wcDBVQ2tHVWpTQ05DVVRTc0ZhRjBWS1JoYkVGcExhaTFpaTNyVW9GbHlSTmxLTmhxSGFncVFnRGdDTHhJUkZSZldKRXRLK0pyVUczWGU3cDdZTnVPN2JxWlBBSE5QV2pneDNDNXN6VFg4aWlCRnhNVmRPK0pTNklvR2gxOS92V1h2dnZXTzVkdjNNQitEN3EyOStDVExBb2JMcFlnMUduQXVHQkZHSVpKeDdOc3Z0b2duNFVKRmhPMGdGNlRaWGQ3M1pPVDAzYmRnWCtmOHFPVWVqSThRUyttQVgvVzNhanhwWG5ZdnJxMmN6d05hNWJXYTlVUm9pUjdlaklhQlhIVHNaYnFWcFNtanFsaGJUZzhHYSt2dGFaK3NMcTJISWZ4d1dILytyVUw4TU1PandkSEIvMlYxYldhbFp0NTBlbDBMTmZ3Ykh1bFcvOTRmN0IzT24yME8zQk5wOXRybi9iN2tJU2VoTGV1YjY5dGJSMlB3NmRQOXdaanZqQnpNRXUvOCs0OXpOanJ0NjZ0Ym01Kzh2RFo5dHI2SzdldkRpZDliTFNYTHQyZ1hTdGxMdUl0VlphQkNnUkU2YWlvMFdFUUJhakdYUkVEanppWFh3eVFXSFFaTDZXK1pVRzF3a3RRTlZZbVVtaUVUQVphNmR0Y0h4REFSOXBXM2h6Z0lHVlNCT1Frb09VdE9VRGQveEZuU0RrenBIMHFqN05CZWtjNHk1MEhrT0VnaW5zRzdMK3E0eXlvcE9DRkp4T2NKTVNMeU1pb1pQaHBFU21vbWxTMXFveVhVZ2FOc2tCUTgxSmt1Z24zQlJMcE5CdCtWSXpHVTNnR3RtM3hWbXNCSjFzTFU3amkySG55NTVzcElFczArdE81NGRYMUtQeVIxMi84dC8vOVAvMzhGMzhrOTZFb1dwVGxody91b1hkMVdHV1FwYWxyMjNtZXgxbmVzT0hIOEtQdldaTFZQQmRtd2FuVnQ5WldIdXdlZFR4K2dUWFViTFkxR0tKOVVadzcvRGlyQXhmQ2xzZHVodE9naGlhejZYckR0ZTQvT1VMMDZmN3dwZTN1ZEFiUEJ3NjJvZHZlbzczQit3K1BneWpyMXEwNGlqUGR1bkpoS1FyNHRmampnd1BMdEM1Y1hLMDNhdFBoOU9xMTdlT1R3V2F2aGJhWmZJRFp3UDl5dDlIRGZPbzBUMDU0NFdpNVhmdnNLNWV3ZTZsM3VxN0Raem0xS0d3MTNPT2gzejhhakRMdGo3N3l2Yy9jdW55dysyVHQ0bTJqeG8ramxENk1HcFI1VUNOWXJyMExlcmtZbEE1d3VIR3NKc1pDTG5xdVZGeU51SkF4Y2xhUjFESWY2NG9oN0lvaW9DRVdJQ1hLVVQybzM0aWYrUVh6QmNyODFkLytUODY0Q0NNVnlFQWRWSnVxK1VTU3NqM1NEdEUyaE1WNEdVcktNdzRxS0VvR0pIZ2tqU1JaaUExRkF5UWlSZ1ZwS25FVnluWkxLSnVxNW94UXlpekM1bFIwblplSldmWUFBUC8wU1VSQlZPYWtLTHg2L2FnL1RwTVlHZy9PVUczWVp4aGVXT1UwamJGK1diWmpXQTRNTXkwM2Z3bVZYZW5wLzhQLytNOS8ray8vYlAvSjNjOTk3dVdUaytGb01rMW5BOU9FVTJSQmR0Z3lZaTBJMHR6aTcxU05OTStoOGFhcGUwYlJXdTVnS0NZajM3WTB6ekQ4Z2kveDBJS3g2MXBCbFBENm9qeHpqem85eHprWmhnMG5oeWthaldlT29VK1N6SitGUVpZT1orbHFYVS9pekxHZzdYVzM1djNQWDNuL2swZEhYM3BsNStKVzgyVGczNzU5MGNqUy9paTRjVzN6OGNPOVBJaDJMbDlvdGxCL1dxODNWbGFXUEplWFJ1RVNiYXlqUFduVDg3NzJuVTlPOXZaM1ZwdEZGQzZ0TEMrdHJjY0ZGcTNNZHEzTjFaNmhKWlArY1pRVnI5NjVmdkhHNVgveTMvL09TcTlUYzczMnprMXVqZEFGVVIyUmNUbDhjQVU1SXVYWU1ZalpSaExINXdLTGxmWWJtbGZwRXNkYlNvRm5ycTRjQWppQ0twZjRFaVUwTEVrZGdKVlVNMFJORWo0WENTSU9QZFdhMVpXVFlXRU5BUUdPNXErS2RhZHVLZTBCWGdXQkNpbE5rVUJLMUY3bEVoYm95N2dFWVZuUkNDaXFSUXlCd2xKSWFhSUtJcU9TNndKUDlwbHpoRWYybllGOVVaVFNOaElKQitKQTZibk80WEVmR0xqWmZDZ3lpVEIyTkpyUWJEanh1b1Z0YmJlOTRscE9YaVRpdStuTzlPQXJYLy91N1pkZWJyZHFiYmRJZFU5M092ZmYrMzZ0N21KTjRLc2JiWDNxSjloZlRtZHgzYlV4aGpZZnJBOGI4RnpRaUlTUDYxaFo1cnIyS09hengwVXdoZGFqVWw2QjFJMEdIQ09zRGtWeFBJMDZOcS9BRHNiQmJCWnRySFRnejhESE9wak1uaDVqajRFOVFOSHNkb000L2NiN2p4Tk4zejN5UC9QU2hmZWU5Qzl2clRnMSszaHZzTG05Z2gzZjhXaFVxMkdyMGxoYWJuL3cwZVB2ZnU4QkhQM05aU2NPb2lBSVltaUhvVDIrL3pnSS9DUXQ3dDdmT3p3YUhaNU9QbnIvUVJ5bG0ydWQ1ZFhseVdoMllXMXBkWHZ0N2ZjZmJhK3UxSmVYdnZmV2UxcVdYbm45QzdudFFDcGlkMkZaU2dkYVNmajVJT01vdVNvaWcxSmlWT0NRSUtMR3NueEdDeEVpNlR5cjZhRWU4MWFXVzVrNU1jOWxxSGdpY0xUSVRhb21ubHF1YUtvcXBGSkZoZ0RyL28rSXI0RHVyWkNYeGFoUHluNHFOQ0xVS1pTaytSU2VRR0JpU2Z1QUxDZUdVSjJYeGFlRmtrVVp5aHFJbGptcThNb1NxTUQyc04wVWhBTEZZWkZBUlVxOFRIaFkwOG5FaDZLYmx1NTZEVDhNZVBGZk4rRE5ONW9kamwrZXczTHpBa0tSYUhCT1R2ZjNudTEzdSsyb2Y5UjIwc1JzUkhueDlqdnZPMFlHRjRUUGhhVUZQQnpzRFM1dnI4TnhMNHE4MVc0VmRpMU5RMHZMNjRZUjE3ditaTnoyckdsU2VLMUdPaDVCNFd4YjU1ZEViSDdBdzdEZ2JwbW5RNzliTjB6TEhQQUhVOFhXY3JmUDkxa21vTUwyWXVCSGw1WWE3Vjd6NGY3eFI3dGpDQmthLzBPdnY0enR4TmUvOWNublhyczBuWXdoNXZaeXo5T05LUEpIbzRsdGFrbWMrTFBnNDQvdjdUM3JkeHIxcXhkWGR5NXYxMXo3MnJXTkxKZ2NIWTFmZitPNlplWnZQOXlieEZxcjFWeGRYOXZiUFF3ekkwcTFSRGQvNTQrKzljZGYvLzdoN3Y1eXcrcDJ1NlBoY09QbTZ5bUdXRlNCRmxRczBYTkJTZnZGTU5lempDUXlwcVV0bDFLaUsrWDRpdjZVUVN3OUkxd0hxRjN5eHlEempWa0x6TmsyS1g2bWNxQVJ5bkp5VWlza1l2N0tiLzFES0EyN0lRMVV4K2VCekpFbE9pWnhWTTNvSXFuZ0YrRjg2Z3lFUzVrcnMySWVwSk1Ja3NuV3EvWXNWS01leHFZU3MxY2tMdm5JVWNHNWVrVytqVmJqcUQrQXR4ckhpZWU2alZwak9oMW5lWW9Obk8wMWRPQ1RWSVlBUlNFb3ZjRTNaUXpIeDZkeEhHejA3TTdLV3EzUm5vNEc3MzE4YjZYVGdxK0VqV21XUnIxMkRUdGdFUHRSQ3A5OVkyM0RIL1l4aGJ4T0Q2by9HUS9xZWg0YVdod1hhVFN4ZUNrRHplYzZBUDBHWU5obmNXN25pV001UVpoR2FiNkNyWVpuYmk0dHpUTCtvQmJ6YWhha08wdTFRSE1mSFE2eW9zQWU0Y2ZldU43ck5yLysvb05rRnI5K1p6TzJuWk5CdnJYVjRqZkNUZDBmemRiWGw5czlyQjlXdno5MFBDOEo4NHVYTnJBWGYzQi9kOXdmM2JwemNmZkJrNDJMMjdybVRXWUJMK3duMFdnd05QampkcXRJcysyZHpRL3VQajRkVE5JdytLR1hyeVNtMWwzZTFsdGRVU0FJK2t3cGxhREZvREl1dzZGbUFwY0NwZHhuZ1JSU1Z1SmxVQk9BaklTYk1KUWpFekw2Q2d2TllIeWhJSi9jUkMyaTBPWG9LM29WRmpsVUdLb09kc0dpNjZKRzdJK29Qb1A4bEx1TUt4cE90VGtqdEUrMkFnVjJ3UVh2S1phNUJFV2tscUVYQXlxVnBVREZDYUxpZ0RtKzdNT0xnWlZTWHNyUkl6M01CZ0syNUF4cVFrdHIyU29LaFJHY2IxeTd6Q0tHSFVRUi9KaWw1UlhiYWJTWE42RjZjTDR4RUhGS0k4MFg3N2xlWEYrNTg0VWZTNXE5UURkU3EzYjg0S040ZUxoVjA5ZnFUcWZWM05qY3FIbmUrdEpTRUJWSmxQcHhYSGVzd3JBd1l4TERtUEVESUdhZUpWNjlHUmRGalIrWGhET2lnVDlheiswd0pJelZCRHVISE5YcFVab1djcnNaVEpJa2hic01uL24xbTFjYWpWcTk1dVcyRmFTYWtXYTlaaDJ0Qi9GcGZ3b1JmUGJWYS8vaXJRY2Y3NFp4NnY2cnI3NXR1L1hwZUhidCtrVStuV0RabTlzYjNaWFduWnNYVnBZYnc4bnM4Y0VvMEszK0ZGMkI2K1Q5OEk5OXdhdDE5ZytPR3RpbnpFWVA3ejFvZXc2OC9LT2owOU9UazluVEo3L3dNMTh3WFhzWUYwL3ZQYmgyY2J2LzhBT09rQm9YS21pcHgvVHBxeEZVOFZKUFNnMVJRellmYUpRaUcwVWpScGMrTjM5MkpGcUVnQWhrcUREcTBncUR5bG9jWHlnYmtNSWZLb2YyQUVrZGdES2dvQXJBa0pLdFNpVU96Z2ptZnlqV25acFV0dS81UUFNcGswR0JkQlY0dEtHYzA2TGJDQ1JIKzVBdGRjOW4vTGxBY2dIS3BVb2kvaUlvQXRLY1ZYNE95dWE5QUpRUFRvcW5hcVM4eXpkT3N1blVqK0xJTWMyYVY0TmFlRjQ5U29JNGdmOXRUYU1BN2cwTVBDRFZzS3pYN1ViMzBmdnZ4RnI5eWZ2ZlB6ZytlZi83YjNlYnpvUDkwMTZydmJ5NmRIUjRHa1l4SDNibnc1cXdyWm5qTnZJa0RZSlp1MTZEcGN6VExKeE5rRHVOWVNKcFVEeDQ3aGdjRjV0WWZxNGRPMUUveUt3OGFUWGNISTVFbW1LeGdWanJ6VnE3MCtuMFdvNW1YTHU0N21RcGZKK0QvbXpDeHhqeW5aWHVTcS9kcUh2dlBUNjh1cm04dnQ3Ny9yM2R3ZUh3eHJYVlIvZjNYM3J0MXRHemczc2ZQeDFwenNPbmc1ZXZiVVB2dlViOXYvdGZ2M3d3Q0l3RXZud0lndzc5V2V0Z1g1dHNMQzFmdmJMNThTY1BqU2h1MXExbXA5dXF1MHVPMGR0YWZmVHdJSTJpRzF2TFpyZlh1SEFMdWtLQnEwR1o2eUtDcVA0NWpBU0l2b3FYSTFVT3FFd2JHYVp5YU9Db2w1ekx1Y094ZzA2clVxV0dNRUEySkFNb3p1aUd4RlZWd3FFS0JEWDNFRmRKYVluNUYwWGRGWlI1RWhRTk1lUW5JQ2l5cTQ1OE1KcFlSU0hGVkJFQmtsV0JhaWNFMGtuK3E1VkV0VnNpN0o1TStyS2ZCRzdzcEM3aHFTS01WeEhHRlN4Z0ZNOTVFR2VSTER2dDdzSGhzZnlpT2pKaDFHMFg0MjdvL0JJVENEemJpb0NILzg1dmp0a2k3dHlvTmYzZGg3dTdqMmQrOVBobzRIcVcyK28rM2p2YVhPclp1ajZlK0FNL1ZrOEN3eDNDMGxHdjErR3lOengrV1Q0dGlqQ09qVHoxWEhPTWZhMVIyT0t3bXJhald5WWFubWI1TkV6aHozdTJIV3NackJEV0Y4ZkZldU5xbHIyNjFGbHFPTzFXSS9ZbjJHdU8vZmhreWwrWDFGeno4b1ZseDdJZkg0OTdkV2R6dFpjWk5yYXRIejQ1ZWV1anZVYW52YjNpWmtIa084Ny8vUHZmWGVyMlhycTE0M3IyTWE5TkZVbW0rVUZpMWpyWHIxNUF3eEpkKzdkLy9MM0h1OGRZblZzTjc4ck8xdE5oY3VYU2hTU2F2bloxYzV3bEJ3ZVRjRHErZmV1MnVmVVN1Z2ZoY2x6d3o5RlVNUUN2ZmloSnExQU54Smt6b3h3Yk1UMmdFR09rUm5aZUJ1WFZ3RVBqb2Fha3FQQnFta2xOUU5DcGthUWlxV1lGcTE4TVFzZXkrSit6QXZkeWlWRmhEblBMT3A5U0RPQTdwNUdtSTFmcWs3QUFaYVVscGNRWFNISXR6Mmhnd0xrcWl5QlZzSjJMWVFIS3VxUUJkSFVxbXB5dTlLZXNEeXFYRVlBc2FycFZiTzlzT1Y0OVM0c3h2eVdaaGxFQW9sNjdnNDByL09sdW8xTTROdDlmWVBBWll0dHhhbzJsazlOOWJCNDFQY0Z1ZFJUbDYrdXJmcExkZS96TThYamZhdW9IZlB3U1RHcGVHSWFtN2NKWmlXSnNXRFdIRTZxRzdTQk1mczh6OHF6dytVdlVJZ25oa21TNnhZZUtNM2c0QmQ5SzRHbzZiRDYvRG10YTB5REk4aXdOWW8yM1U3TTBqTE00NmRUNWNCdUt2M1B2MlF6YjdpQndIUnVPQ21TWWh1SHRheGZmL056THNhNy84OS83WnBSWlY2NXQ4aGF2bG4vMy92NVh2ci8zN3QyVFZWZS91ZUZkdjlBWmpzWmYrZU52L3BQLzVsOSsrV3NmcEg3eUMzL21SOTU0NDlyRGs5bmI5dzh3eHc0SHc2OSs3WjFNZDhKcDhCZCs2bk5tM2V5UG9vUDc5NmdJRkw0b0VnTGk5QlhsMll6L1BVQko1ZTZXb0laUFFPRlZ3QWdpWkFXRGlsUGZGSTBhUjZpUjZGUTU3cUlQVEZlWU1raXBNdzRTWVJCNjg1Zi96aitTS1hnMkZ4bklSenFuTEhISlMrWEtURVhYR1pjNXczK1p1Q1JtU1ZiRFpnQWpnbUcwSWhaNmNoQVVjMWxHMVVVU0VKTkVVVE9HT0d1Y2x5ZWxZaStuZ20rNVVYUTQwaml3VHRXT0NzMmZ0N0I1V3F2VkNNSTQ5RVAybkpmWXNVUkR3Y3htM1NPQllYdE9EYnRFQ2dlOFRLdmU2dFdiOWViSzl2MVBQb1lidE5KcDFHem4vdDUrRUdlMDFxWXhnd0hQVXNmZ296RnhramlOSml5OW5zYXU1L0N0bEFYMkFwYlhYaTVTVEsrWVcxUU1kbEZZbnNPSHZmUmlGc1R3S1BobGVwMU5EQXU5MWU1TS9iRGVhS0NqVVJqQmJnNk9Ua0lzUDFxK1AvRFJMRDlPdWw2dGlQMzl3U3hOODh0YlM4K09CNXU5bmtrbTJzbnArRHNmUHMzQ3lIVzlkKzd0VzBYUnFqc1hyOTk4OE5GSFMrMzJVc3ZzZEx2b04yenJkT2Fmbkk3dTdvM3U3NDRtczluSlpIWjYzRThNODlzZlBqTGplSEI2ZEhsclM3TzFUeDRld2pmYmZ1bjF0TjZCU0ttcElsczVjclZTSTZGR2tDcWhJdlEwWkFoa2pFcGc3aHlwNkRrNmFqalZXQ21NVEtjcVdVVUVTVHpwSlIvL2luNFJXRzJsT0FwSWhoTGdnTEgrWlhWWFZVQXl6a0dGT2MrVjdTNEpxYmdMbWVwbWdVb2hVa29IbU9mNENwNmdMamtwR2xWWHVYOG5mczY1SkQ3RHlKb25nWXJKR1A0d0xWVTFNajA0UzBsS1lzb1d6SkVzR3ZYNjd1NEJINzR5WUQxekdFN0xodDdxanUzd2lVY3RoMGJDdU1NV0ZJWURjK3gxTDdUV2RyNy81WC9kOWx6TE1oNGQ5QXZOeE81bk9BczZEUytLNGxuRW40U2EyQS94b1Y5c0J4cnhkSVJaQVY4RlRRQTNxOVZldTNqTlB6cUVrcUVwSnVjbmxocCs2R3cwRGRBdTI5UnQvcFlpajNPcjJhckJaWUd2QldzZmhVR2FaN1BoQ010Q01LUHZFWUJwbmgvMFI1YzN1bnZIZzZlSGc5ZHZYdGc5bmZZYUxyeWcxWlZPdStGTjR6Z0s0d3VyN2ZjZUh0WWI3c3MzZHo3NDVHSFBkZTUrOHZIRm5ZdnJhNjNsWHZ2ZThiaGJxMS9aWGpJTWJSeGxTNzB1OWhoWFYrRTYxYmEyVnI5Ly8rbGtQRDArT1A3Wm4vblN2YWU3a3lDLzlablBwNTFWMFRhS3RKVHIvQ3dEeE1DWVFzaVFDWklsVkZ4bENvRWlCbG9oNTR3a3N3U0ZneTlBWlN2MW44Qlg2YXVDVlNscEZ6aVNoaXFuR0M2R0NzcmRnU3F2UU1Ybm1NVmtHYXI2VkROUmdRU3VPNm9GY3JXRS9vUHdaeWgzMWhoVUJsa3VVRVROQjVaZ28yVHJ6ZmFBaVd6QXVjWG1ya3BzQm80TW9ybHFlUUxnS0lwZHVsV0kwQm1uazFrUkNBMnRqcXdrNE8vVzNIYTNqUjVrR1IvSHdSWnpHdmh4RHNaWS8zWDB3YTAxTGRjekxaaHN2bllNVFlOcnZMSzZ6dHRDYVRxZStXdTlUdDIxUC8vR0svQnNNNmttNUlPVmFjT3lnc21rVlcrRVNSN0ZmS2dZOHlNcnNzSHhjYjNkZFQwWE84MGc0YU01U1JyekU2bVlUSVlXWWNjUThqRTFMUGxwRXRYY0dxOVNRb0J4aXVwQmlKMnR4WjVsRjVmck5ibUc2VWZaVjk3ZnU3OC8zRDhkSGgrUElONW5oLzBrU216TnZISmg3ZlhiVjhaKzJxNDcyQkNIOG5UazlVc2J5MHZObloyVmYvcXZ2M0YwUE1YMm9kbGIrYVAzbnU0UHdpdWJTNSs1dnI2MTNIemw1WmVzVHFmcmVac3QrNWZldlAyalgzd0RVNmUvZi9DbmYvUnpXUkdQQjZnRmNvWnhFaWhIallNRFVhdEJWNkNTeEZSRXowRkZ6Mnk1U3dOMmNzdU4yaW9CaG9ZcWpTRlpjRmNFRkVhS0U1UnhJeU5aTi9qWWlPQUJwVTZxWW14dnlRR21sQVV3YWtvL3BENENFeFZlQllXZnUxbHpUTmtJVlRGQTRvQVNzeGhVaDNDb2hNS0dNakJPMVo5em5nZTIrNnlmWlVXS1hoMVZya3BXTmN3RHhrZ3h3UkhXTjRXbnF4WFhiMTlQK000TjdBeTFack9OWExqZ1ljSnZvQ0tPZjh0eU1ycmtPb3dzYkRFODVaMVhQMis2RmwvY291WHc3ckd4MDVMZ2M3ZXZaQ1ljRStjVVcxRzQyemxzYnd6dHRXcTFJSTQ5ZVNnTnJnNWMrZWw0MGxyZHlFM2I1NFhMeUErcDRVbWUxMTByaGZlRENjem4xOUFQVGwzTUEzZ1gvSUZKRk1IYnNRMnQ3dGxvcTJ2cW43bTJzZFQwbGhydVlEckREZ0Q2OStEeHZqOGJmL0prYnpTWm9DNFU3clliSjFNL3laTmF6VHc2SFdML2NXRzlNNG1UVjY5ZnVMelorWjJ2dmZzLy9jRjNIejdjRzRUUjczNy8vai83by9kMWZnUGNXT3ZXN3J4NjUvMjk0NDdYd0RSZWFUWnZ2M1I1UEpsdWJxemR1YjQ5bWZtVTRWeWVMNEFhQmNwOERndkpjb3dVallBb1NKbFFVVG15Q3VGZnBsQlUwVWp0ODhJTWl6eFZVR1VBSlJrS1V6M09CZlBQMDNkSFREakNHWk01d3lxbGduUEEzVFFDWW5KVTA2T2Fhb3l3VkptaGlndUhpcUVFWmtMQlZXRXg0ZHdNU08wMHY4U3BMQUxUWnlrQzNRRVNDaSsxMzBBQm1BaFdNZ2VoQVcxWkgrTW9VdFlLWDRUdndyUDd4NmV3bFVBMjYvVWdoSmJ5ZzlyTU5vdzREYUhucE9aQ2xNZHAxbGpaME1KeGZ6anhnOEN5ckNRTVdyWithYjFuR2NYK3lTaE0wbTZyNXRCcEtxRFRydWNsc3luVTE0WWg1YSszekRqWGx0ZlcvZFA5V2NTWFRzWnhicHRzQmpidFVjWnhzZVVLS1BZQnpWWXpTQXJVNkRsV2p0dzBOZElJd3pZYVI2NWpYVnByclRScjNicDdPZ213d1dWUCtjSmg2OTdqbzZ1YlM2Z09MY0NTK05iN0QzN2s5dmJ1MGZCeGY3cmFhVzh1dDVvMXI5ZmtDMVF6elc0Mm00MUdEWk9xWFhQdjdSL3Y3eDA4ZkhKWUpPbU5xOXVlWjJQbjBORFRCMDhQc0ZmdkxuVSsvT0J1cDFsYi9keWYxbG85MUZkS3VaVHJtWFE1cU9pSGlwOEwxVkFMb0NNcWVjWUtKT3BNNVNteDBBY1ZJWkNVQS80Y2dEZEtxaVB5aVZGMUtTMVNJTlV0Y2pOLzhiZi80VUsrZ0JETkc2R1NrbGE0czVhb3pwVFlPVHlYWHFBcEd5MTZxT3c2Y3FXdGlpWEZvOW83RHlSWVNJb0lWWEVXUUZ6eEoxTXBYaElJRFFuRTZoTndKSXJFeUcyMVd6N3NZOEszcDlxMjdkWnFNS2c2VkFmZWk2YkRzK0RxQ2o4YlNxL3BDVng4WGU5c1hOajk4SjNaWkp3a2NidFc0eGRNYldQUUg2UjVEazUxaDkrMHFUbm1lQlkydTczUjZZbGpHVTNQbytPcDY0RWZybCs4MU45OVlybTIzZWpXbXAxd012Sk1BeHNJbWhpNFJLWmg2d1pXRDh1ckJ6SDJGRFJZS0pvbnVaYkVPdXg5a0hpMjJXMDNXM1dYcnh4T3M0RWZ3LytmeHZuZTZSaXo4RUt2aVk1WmptVTZ6dTkvNC8wdlhGM3hvMmozeE44OUhHeXRMcTl2clg3bmcyZFh0cnRwd0k5UWJxeXZ3T1c3dUxac3VyYm1oemMzbXBQeGNLMVJ5OFBBdHJDTHNWNi9zVG55NDFhamVXLzMwSW9UbzducTdseWZheEpFcW9SYXBrVzZwZEtkQnhCeWxGV09TSjVRMGFIdlBKN1QwQktRb1V5d1NpaUZyYW9WbUhOYndCR1FuSWNLRUZXREwzN3VwODFLVWFQbmtLeGZ4V0ZaVVpaSitsbFZ4Y0lVY1loRHVESklteUVKQWdrVXpUeElLYkhaNnU2RDFESVBjc09zckgyaGxBSWh3Skd0VU11WnlrWHRWSEhwRkZsV3hHd1ZoY2dkUXFicE4rL2NrUGRINjFGZTJCWThGRmZlTzFQUXBjRm1nSGZ1MEM2QWFkQ0NHbHF0ZnZtbE94dnJHMXFXamFGZ1kvajhzeWdJUFZOdjFkeitHT2FXajlDblNSSk9ROU9wNVhCVFdGSWVpSXlDSkFoMHArWVpaaGpHMTEvOUREUjc2a2ZUTU1RS3c5K084QUpjaGxtbWE5aEhzTlBZNjhSK0NFOHA1cjFlaWdleklwWGZHUlp4dHRHcWJiYTk3VTY5Z1cwRW5IdmIrdjZEZzRQREUweGdyREdHWmUrZnp1RHJkNXZPd0ovOS9wZS8vVC8rc3ovOEgzN3ZhNE5oZk90YXI5ZHVRUkszTG0rdExMYytkMjFyNEFmRFdmU2xOMjRWV2JDenZiWlVMeDRkbllheDhhVXYzSFNjM0xEY1NhdzFraUdhQUdFcTJVTFFkTUE0S0tWOE9icVZaU2xweWpnNmd6MDdoSWtCb2tOUkRvUUV1WHdEQktEeWtHVWNjYUFISlBSVjRHaXJPQVNoQW5lTDFmZ0NGTThYZ1ZhZmpnbmo1aS8rSFQ0aXB1cGNKRmJzR2FsMGhrbUprUy9QVExFQ01jQ0lDZ0VwMEc1VkJGQVNrMHdoQ01Db0FGQVNtOWVpMEZEME11TU16bGhJUVJaUUhCUXdMa1hVdEZHSEVsUmM2RlY3U0d6b1M4dEx4NGZIY0pMaFMwTnJvRForR3NQNXlESytNeFdlRG9xZ2IzQXFRSTV6WTIxcmFYM2orTzRIV0FvYW5nMlBHL00wUzlOTzNUdVpoUFdhaTZYS2M2Mmo0UXcrU1JaSGZCWVMxaGtic1l3L2pYVWI5WFEyR2s5blc1ZXVEL3RIdmg5Z1dSajVFYTlwOGxXckdsd2EyM0xIUVlUSmgxSnBuRGh1TFk0RFBtTEp5MzdhMGxJbmlUS3cwN0prcmRYSTlHSnpiWDJNRFVHV0RhZllmdVFiU3cwNFNCODhQR2k3NWs2M05nclRrMWw2YTZOek1CaUIrZkZndXJIVWVuZzB5cEo4ZldWSno1TWxSMSt1V2FlakNlYnY5WjMxNFhobW1jYk5HOXYvNXB2dmYvN3puL2RxMXM3RnpaUFlYdW0xamN1djhtNmNFdDJaWkpFVWV3YXBMa3E3QXVvdUVPZUdjcUdzS2lVTWhHMEpIQ0w4QzQ1NUNqdVBvMGdWeEJSV1NRVkVLbTVBellzaVJVcnp6Ly8yZjBJWGtNWE9CYUV1SS9UTHlFNHVFYW9zTWZ3NHlSUW5qbGY5S3NkREZXUXVNQklRQjVLVFZNZ2tpMTBGbGtYSXZCU05NdWNzTFZDZUJKQ3RrbFdSeFV6RW1TUmJSY2tXS0NRQ2Y0Z2tWSEprY1Vib3V1Z0c3SzZmUkxBVzBOUU1lcGtuY0RKU2VCVHlPeXBZM0JUU0Ezbk94OVJyN2FXNzMvM0dkRGFCQys1cUJSeUxXUmgxRzg0d3lMQmJoYjlSZHl6bzMvcjZ4a20vajF5MnA5RFNySUNUMDF0WkM0YW5jTmdOcjRFTndHdzB4RTQwUm1OeURkdFFqSUdGOXZCaWpoRW52TXlRODdmbTNGdkhvWS91MktiUnF0Y3c5eEpnb3NSMHJDakplcDF1WjdrM0M4STRUWTlINHhiV2p5UjVjREtHSEM5MkxNMnJEWUs0NDFvWE43cFlQbXF1OWI5ODY5NzdEL1pmdjdReUdFNWV1YkptYVhIRGM5Yzc5YjJUY2E5ZDM5bFptUVR4M3ZGNFBNc2NyN2U2czdXOHZ2bTlkOTRkSDU2czN2cHM1dFloTkNYSGFpeDRaYWFVcVFCVXJSU3kwbGJFb1FDaUlpVmF5RldSVXFHcEYwSXBjUkVZTThDNVlrNVRUOUtTTmFIU24xS1I1czFRUEg4UVFOMTUzUjJrS0tDYVVmMExpTzZKc2d0YW5WWHVjOVhJc1FMT0gvd0xUNEtpUEd2dCtUTmw5RHlIQmFoS25lTW05UE1nU013cnhrdWVPQWtHNGhBVU95RkJacURRQU4xdXR3YURvV2ZaZnNSN21ZNWxZM2VJUGtIVllUSTF1TmVtQVNPT2dxWnBjU25WOVkwYk4ySFhqM1ozK2JBQlpnQTJuUnBmVHdDWHdPT3o3ekN2L0ZWVU1KdlZiYVBtZWJ5OG9KbkQ2YVRlYklmam9ldkFmZEo2cTZ2anc3MnMwT0lFQzdPR2ZXNldacmJqUUNsVFRiT2RPbHJnbW1iQ3R6OWxhVGpEMG9NbThTbEt1Q3I4QnJmNllqS1dnOXI2K3NyMmNnY2FQNW1oem5Dald6c2UrYU5wZEhXOXZ0NWIrdVJnMkI4R1AzSnpvOWUwZDFaN1Q4Znh5VGk0dWJWMGFhTTVITTVXVnhyb1JHRmlLK3dmbkl5YnRjN2R3MkV5eGtLUkJrSHcrWi84ZWJQUnhHejV5dGUvdnR4c3VaZGZoc2dvUTZxdmttQjVMZ2VoRWl5aEZMc0NHUUNvdlp4NEtBc0lTQ0hxT0JQbGFRN2xxS200SEN2Vko2aTVWU1hCU0JCS0UwUXp5NW1EVENHaWM4d0FJdmFCbGFvOFZhQTZLV0ljSlNtVHRZd3pBcXVQVWVhUkViNDlocjRJMkM3MkdLQ0tnWlcwbUNrK1RDWlgweEZBeXRWQWNWYjAwblFxR2JPa29LaXZhb3d3bndjaXEyYW9PTDA4R2grMUtPbUw3L3ptN1VBMFhqam4xMi9maUlxOFVhdlA0ampNRWdkT1BMeENBOVlWWmMya01QaUFqY2wzay9IWlNTMjNsMWEyWHYzTTl1VXJVODErTkpoQm93K21nV2ZwbGtHajYwZUo2NXJEZnIvV2FnWkJsTVFKRExucEdIWFB1WC8vWGd6ZlBNMm5vMkd6MDBObitSNE5vNGlTVkxOYytQNlRJQnI3dm1jWkpuLzBqUlVtQ1VNL2lhTTh6VUNZWkZrc3Z5RkhzK0M2am1Kc0ZsSmUwb1NsMTgzTFc2c3QxK3hQdzlOeENJYURpZjlrZityUHhvT3AvK2gwTlBTVGxYYTk3dWdYbDl2Zy85R2pnMjdMaTVQbzIyOC9tOFhKOFRUZUcwV05lalBCMXRpd3ZuMzMyVXZYdDllNjNpZmYrTVBlMHVwWHYvbXRMNzc1MllOUDNvTy9oZEVyeDRKU1J4U0NMb2VlOXdmaHFuTUlCQzJoQkFvZWl6ZHAxQWlxVUk2VVhMMHZpWGxsbkJ4a2ZLUVdRbmtDblBHc1lJNVJxcXU4ZjdLbGRtRnhMcS9IcXhyTlg2UXpRMUlwQjVxS3RZcXdWK1dwWEkxS2pJQTBhSjVTSURwYVRTbW0wWHFnRkhjVkdBZlozRGxUSEVxaksveVZEUVpPNk10OFpxbzJsSEFXSjVPekxOWllCZnlETGZvTHFhb0t6b0FDQllGcE5GdXR3NzBEYkNyRExNZTJEOFplUmxLSGIyUHdKZzhabVJhR1cwL2xFUjEwcXRYckhYejBrV1B3RGNjMWs3K2tiamZkdzNHSXJhTmpHZkM4TGR2SjBoamJYNmc3Q3NDQlQ5SjBPUFU5MDREdGJDNHRGMWcxRXBUTCtXNjlobXM0RG4rNmFqc1JOc3Q4ak5mRWJNWGtRYlBqWU1aYlR0aXpvbUZKaXBiNGNScjZ2Q1NhR29iajFUREFVUkQwWE4wUGsvMGhEcndrWDdPTWJzMSsrOWt3eGVZMzB5LzNuQ0xQL1VSN2Nqd0tvdlRsUytzYnk4MWhHRDNlSFk4Q3pIYTczYXIzbXJXTG0yc2Y3Zzk3M0R4a3l3MHJua3pzWnUwcnYvL1ZqYTIxNWMvK0JMUkhobytDeFFsREl4Wktoa21VUVJSVXhsWGtUME9qYURnNk5ES0xVQmFVc2lxblVnbVdraHpKeFltbEVhbm81L2hxZHMxQmtEaXBzeHl4SUZZalg2cTd3a3ViVk1WekxSYlZVYTB0MVlpa25KcUlBZ3RlVW02Kyt4VzFJM2RPTXVZU0tRVkp6R3dCVlY0RmRxUnN3cHhhV0FxOUtzSnVTYU9SRmxrZ2c2QktGUWJxNFFVTXhwRXRtVkJaUlNObm9sVDVPWWlVaVhOY0xPam02Y21wS3o5V2l2WGNnRTJIOTBJL0JENDFWZ2JZZTFSQlU1YkI3RHR3dHMyOXQ3OVRwQW02MzZ6YmNLTWRYVXV4c21HM2FsaXVaZVNHSFVjQjN3Q1BPckNjY0UzUnB4RWZzT0hUWUlWVmE3V0RZUi84VVJadFdWdnFaQ2FmMklheXhnbE5PTmFYSkUwYXpkWjRPRURENE5hWWxvTit3TFNENjJneXcxYVl2ejYwUFJEejhxaVpkR29PZHJLOFdxOXJMZGZwcmEvYzNlTXJidnFqMmUzdEhqYTRHSko3MktwbXZLMTFkYjI1MW10N25kNXdNbXZYdlk2cll3MURMM29yblhzUDk2RmJYWTlUZFgxOTllN0QreTNUWGY2aG4wb04zdUd0dEZNR1FoUUx5WEk4bVVCMkdaQ0hJTU9oOHBCa2dSSXZwVlFHOExSSm9oZGtSUXo1SzNwMStCUlFwQytBMGs4RXlTNXBvSTNtbjFQcVh0V3RJdWhReVVkcVlXdmxMRWVpU0tQQ1BNWHVxWTRwUHZ5SDBCV0hGNkdhYjg4RGkxVUFDb1FTd3dJTUtyVUFuSVJrQnNGSTFkSkoxV1NKVm9DdEo1c0hXaWlmeW9NQVNFaTI3VTVuUEoxR3Z1L1lmQWx2bE1aOEtsSldRM1pIcCtKalNyQUVSSjlBTSszdTJtbzhHc1MrMzJ0NVJSWmpXWWhTYlRvTjZxN1Q3WGpId3htV2k3Z3dlN0Rjck1lTStOTU9QWWlDWHFNV3BIbDNlUVh1dTIxYTA0aGZaRjFiNnBKSzAyTysrSWEvQllGMWh3dmxPTjVzT3RhekpNeFFQNS9FNEFPYnBuRTZuQnA4bHhTZnU0UVh4cHU2d2FUdGVlaHhtaVMyWmE4MGExdnJ5M3ZIUXo2NWdCNW1XZE9pWVhyU244VnBkdElmMzd5dzFuUTB0OTd3ayt6dTA2T2FxZlBha3FhdGRUcHVvL25leC9leGEybTYrc2JHbG1NV0g3My8wY3MvK1hPK1hTOGxDam5MbWNsS1FSWDh5WnZGODNDbStpTGtrcmVDYzN6S0VWNE15a2Rsd1JlREFtb0xDNUtSakp0dS9zSnYvNmVNa3dQT2xmMm1jMHRTR0RRT2dTZ0VjM2lRazJCNDZhSUs0cy9qRDg2WmNFQ01iS2xiWjN4NEtJRWVHK2tWTjRDcSt2bEFSaXBJTTJRR1ZaZ3lsQUNlcEJIbVJDdGhvU0pKQWVaaWtsS29YL0lSWSt1ZzRmbmE2c3A0T3B0TnBxN2pvQmh2UVJwNkZrZTg5aTZ1djI0N1lJNFVpa0RSN1BaeXZkV0tEaCtQUnBPZHplVzM3eCthcmh2R1NiTmVzK0ZxOC82M3JsbVdWK1N1NXlTWUk0V0diU2NXQjFQUDAxeHI5NVpubzc2QktvbzhUTEpPdldhSkM1RWtLVXdvUEJwMDFvRjE1U1A1OFN6SzQ1eXZOcWg3SGxvQXFYSTZvZkdHa2ZFcmF5bklkTG1LQ2xaWUFyQnB0a3l0NFlHVGNUejIwYzgrZHRMMVpzdk1UdjFzRXFmWSt2cXo3T3BtUzlPdGFaSjkrUGh3OTJpODNLeTE2dVpzTk83MnVsTi91dCtmTGpjOFBVc2JTMHZSZE5LcDE5T3RXeksrVkRSeFVTaERnQm9tU1plalVBWEtYRkhKZUpTd3FNb3FCa3daRVJhTUNETXdRWkpXUmhMelVGYWxpcHloa1RwTEtKYkNVRVpaOUp1QUFpeFRBZWlndndoQ1RKRFNETkRSRXRnVDhLc0M5UDJNQmRpV214SjJBMUNSWlh3S2l3SE5CNXh4dzFvR0M0b0tXT05DcURCVldtNVlTSkFLRVRsYnVVcEtCWml4dE9LTUtwcHpVQ1c1Z0VvZEFJajB6c3QzTE1mRTdzK3d1T3N5VGFmWmFxZjhLYmFCM1NxZlpZTEVMTXZBYmxSZTFkUzkvdEwxSC9zUHRpNXMzTjhiUXUwRzQ2bFRxODJDeEkvNUNqN3VCQ3huN0Fmc09IK1VSSEdnbUE4N242WlJGSnVOTmpMZ01tREN6Y0lJUXNHSzRvalg3cGw2RWtWaEdLVkpyTnR1YnRjbW1ZRUpNOFBXbGZ2VkZGdUlESHhUVEVOT1JjdHgwQkhzRUxBVmNSeGV3NEhJUWovczFwd2F0aE9ZRlpyeDFvUERRVmpVK09sOExjNjBSLzN4M2pBSlorT0VkNWkxZmhCOStjT25reG1ZWmVGNHdJY2tkVDAzYTRlSEI5ZzRZMjBwVHUvV3FSUGMxMUNlVkFDS2plRTU4WjRCYzBYQ1FyWkFWdzNvT1ZBWXBTRnF3aEFqaGRRUW40V1NtSnpSSGE2OUMwRnRXRkViS0JXZzBkQ1p1VE96MkJUd0tZOWlveVZWQWNxVGxOb3F6WkZBUWpIeUpXMTFRc1dTUUZBOHo0RE5sTTZ3cUtJUm5oaHlGWmlXR2FtQUJKeWRncGNBR2dxZnRTS0xsQ3d1cFZSQmhqSXUxUWhOMVE3bUtxQll5RUhSNjJzcnkyLy84VmVhdlpXWXN3bE9zbzNkYWdRYWVPdlFlTjcrNUZ5U3U1ZklMNnkxaTZQOW8vN2Vrd1FLcmZOVllXRWMxV3dZVnlOTDg5N0swdUNrMzJrMStQbjVHRnZHQW52UVdSQmJlbUU3VGJmWkNNWkQ4SlFYNzJXOWRndGp4WFVnMVZ4YWNIMGFScDV0K2tHbzJTNDhub1lPTTY2NWxwM2svRXd5UmhENmJkV2FGanBwV2trVXV0eDFHSG5LTjZUQnpmRXMzZzYyTEY3bmdTZVZGUG5CT0poR2ZCUU9UYlZOdTh1UG1xV0hJLy9oMFFUclNWcm8rOGVqcmFVR2FvVGo5UEJ3TXZPamVxczVPdTBQRTkyQ0czYjdDNUhUcEVaQlpDSWZBQTVLSzJBTFpPQVVsa2Y2Q1NKZGtUQkJ0cllxb1NLOHZnTlNZUUFxVWFKS0FZQ1JlY1dWUkFveEExa3FBcFNzekJLUlFMd2NGYkV3eHBtdGtpcTBNOTk5QVlTb0JOcEkwQ2xRTnBKczVpaWhYaXpBdVM4dzc2RUFTY282QlhBdXVTa2t3a0t1cW9FbUhCSEZYV1VwU3RVcDZpK3ZieEZkZFZ2NmVaNFRRUlg3RkNEbFFqdlJKR2pKOXBVckgzN24yKzNlR2pTQXV6cU5UOGFqQm93dmRvZWtrenJSTXNqUnNCMCtUTHg3RjR0K3UrRk8vQkNHMHphMEdwK28xR00wRWlSNjRibnVOQXhoZW1NK0M1RHkyNVR3MXplMlJxZkhzTFp4a2dWSjJvSUx3czhxR2RpaFdyelNqNjFEeGdjam80U3ZBTFJNSjQvQnpZQ2VhZ2FhRkNTSlk1bXB6bXRIMEhJOXo4d3NSa2ZsMG93V0JERThsb1puMTdGY0dIa1FaWmJ0eEFtUUp2MGtYVzk0em1xdlBmR2paNFBaNlNRRUIzaGF0bUhPWnNFZ1NHcVdlZjl3Z09sVHJ6VS9lbnFJRnNLRXBycnJYWHVwN0w0YXBPcUlBeVBLOU1wSVVMSXFLYnF2cEZ3U3kxSEljSlJSVTBFbUNXSWtrN2lRQ2pYajVabHdIbzBxVkVUaCtWZm1xQWdCTVZvK3BYWUNOUGtjV0VxREFWbXdaZk04MlIwd2pvTnFpMnFyQWtRVWFaVzdDT1JKLzBocUJLaGFSQkRxcnhSRUJUS2hwYm5LTFZHWkpCUHVPS0F5L01uNnp4OEpJWWhrR1VyS0tpeEN5WFFCNW5oU1NtZWI3YzVuUHYrRnZYZS9BMjhhT3B1bW1RMzNRdGhEVjAyK2NOR1F1ejZXNmRhZ2ZxMnRuY2h1Yk81czg4c1pmSDdZbUlUeGxGOWExWUx4dE5udVRxWXpPRWhRWC9ndGFacWFqZ1VEbTZXeEh3UnVvME9WUmJWNU1SeFAwUkI1K2h1YXg0MHBzbWlvZFMwSytibS9XTGY4S0JiWEk2L1Y0S0Zna09SRjlWbk9UK0xuZVpDbUVDdXdtRHhSK1F0YXZxbTRiaGhYMTNzdlgxd0R2YVhwRHRyT3o5Q2ljMXhFdG5yTlpzTnQxT3R3Q2NhWUVGblJueVhmdW4rU3BIQVdrK25neUszVnYvN2VnNU5wWWg1KzRJYVJrcFdJbnhxQkl3S1dFeW9wUTVrc0ErOXZNSUxobGlObFRYT0xNVlhIU3FrQWFxekJnMVZJUkVZR3VtSklZRnJwVXNXVHVXTDdxN2djbGM1U3FIS2N4MWs5bFU3YUNSVVVMU1JRZlZTczhxV1VtUlV5aFdaM240TXlZd0dBSWxaTmhxcmdHUWkrN01VUEFNV1o3UkV4emVsVlMxUXVacEdFUHdsVVM4cWdDaTFBbFdBbjRiMXUzcmh4NGZxMXZRKytCL3NPZDhDMTNhYmxwSEw5RG9Vai9HdW1iVG9tL1h1anRyYmV2SHByYXRZblFRSmRoMHBGZkV1TUJzVnhUVmgvY3p6anBaSThUbWQ4RVFDY0lpdEtzeWp5UTdqMWRtM2t4NjV0d29mcHp3S1kvQUpHM2RCRHVEY2FYMDlnMlZScTRxQUF6VjV1ZTJFYzgxZC9XckhVYXFJaGFab20wUFdFRjNOaTNxdEtNRldnKzFpUVppRXlVN1FGbnRWU3U4NVhQdFc4SnQrSXdKNjJYRHNKUXo3UWs2V09sdCs2ZXFIZXFPdU9GeVRaUnN2VHVHNWdHNTBGY2RTeDVYZHE4STRhVnZUMkgvQ2p2U0lzRVNLMUZXa0dZRDV0S0ZVbU4yWnp2YTZHZ0NEWmkzQ0dVV090eW5QVFFCV1hSYlhrSTBnQjZrVUpvaVRWUUZkQlFlbk1DTStxRG9uSXRKVnFRS1NxZlVGZndSckhpcGNrS3NDa1VkV1VMUkRkQW9IUVZHZWVHRmNyeVJrbmdaS2l5Z1l3S25oWklsU1UvWmFzTTFBWkNsNk1LQkIrSlk2ZGtuWlV3QXdZMk0yck43ckxTdzgvK1ZBM0hOT3JlN2FOaFQ3amEweTBtdTBrVUQ1NnhqUkJjYUUxbXEwOFNXWkhCOUJpWHBJUmZsYkIzeUpOcDRIVHFPZEpCRjJ2ZVo0NEd0REx6QUtGWVRRNm5lRXg3M0RCMllDR2QrbzFkQmRtRnpaZW5sNlE1dkgrTUJjVDE3R3p3dUJXTlF4ZHkzQThlK2JEdElPTjFmRDRnRm9SUjFodE1Da3huZEFOVE1XVzU2RnpYQjJoSkliVjk0T1Z1dDIwYlk5M3c4QTd4NVROTWcwNjNhbzNPKzFtemJIc0lrWFY4TDUwYk1lekdJdERnV1dyWHB1T2d5OTg3cFgwNVBINmpaZG5aazF1aERPSXdBaWNraVVPUWNtQTJITWlodTJIUGtCSk9lUUtqN01NcUNJN0h4U3ZLaTRIVVNVV0lLSWNTS1U2aWs3eTFZVGd2QlpEUVRiMExwU3BScEoxTFlEQ3NDRWxOODVEUUprdDhGeHlEbVdWQW91bHlPWFRBdlVEY0w0TndCT0FwR21YNVlVa0ZYNEJtTEVJQ3pSekp1VmhnZitmQU1LQkNyZDg0ZUtmL3VWZnVYbjdKc3l3RDV1cEdUVnVRVFZzUm0yTU5zd2lHTUtYMWd0MzgrS0ZQL1h6Yi95VjM2eTE2dGpid2RHR1drZTVubVE1MUFtVFlqajJMY2RKaWd3dXVBd1JMNStQQjBOc2hYV3poa2JMcXE3MWgyTlQ0eVNCRHhERktZaGhmRUdhRzFvVVI0ZzRqbFdZRHJhdXg1UHd1RCtONEU0VS9CeER3SXYzYUJHdmRVSm0yT0J5amdqb2NMbEJKRi9Md1hqeUp5RTZMNGFPWjd6R3lpbUVQV3FXSFo0T3NjTmVicmU4bG53Sk9RaGZ1WHh4YWJYbldmclVuNjdWdktmNyswR1FIZzVIdCtwR3o2TU5WRU5HY2FtSXhNOEI1Q1BxU0ZBVWFBcW9STk81WWdOZGpocHRQeGxVbGxzbURBMDViYm1LbDNoU3NDQUQvamgzRkNpRzU0SEU0S3VXZmt3U2NRbWs4S0pEb0tvQUx4MWlVN2tRVlpWN0hzQUU0U3hQMForblZUU2NZQ290UTg0NUI2akV4T1dhTkZWQUxvT0FPcFdTa1g3Sm94Wnp4K29jcVAzckdWQXFaZVQ4V2JVS1BCQlVYQVVDYUJCNFBYNTc0ODZkVzNCRitGMGt1WU5qV3hZM2Jsbk9YMFB4NnlBYXRwK2E3WFJ1dmI3NjBtZGJqUmI0UlhCRTBGUnNIdzA5aVVJL1RxR0pjSTBRVUVESGZLREhrd3lIZmJ0V2d3dkQ3eElYK2Vsa2hoVUQvT0hCWUNVQkg4ZmhWOFV3RnRpeHNpd2ZldUFucnVBUlFUZ1duQVMrV3krWVF0K1RoTC9kNWxVNTdHS0xKQzM4T0J2NFVRamZKc3NtWVlqSjZkWGNJSXlXNGF0b3ZKQ2ZZSlZKTXcrenlEUUcvRVk5WDQrTTZlWFpPcXorOGNsUnM4NVh5M2NiZGg1TzBaSis1RWExbGJ1UGRodjhNaVpIc1pCN1hlSnhWM0tUM3lLZmsrUjhZb2c2VTlxSTRTaWpUMDBqRlpHaWRQTlpKRGxsUW9JQXo3RGF3cFBxUVJhaW14TG05UUtyQnBCN0IrNUlHYW9mMnlvNDQxbnlSN3ZuazRIekNQRUZLRW5QdzZkalg0Q0tCUS9vMWh3V2kxTkxNWHFDVlBqeStDS2NOWnk1a0lHNjhxb0FaMFo1S2tIRnkxeEtlMTY2QkpVaEVrY1RpazZ2ODhablgxOWJXUW1qR09xQ3ZaRnBPNFp0cDl4SG1vNXR3K2dhT1I4VmZ2V1hmdzIyMzNFY3I5NllodEVNaXBha05ZdHZIb2pEMklTeGgwajVHbmd2cFgzWERwNDlUVFU5aENIbmg4MDRPTU1wRnBJVWVnbTFTeE54cmRVYld6WGVMb1h6amYwcjNhcGN0L2xOY013TWM2bFptOEt0aVZQc010RTErRGF3OVZSOGVQOTVFY1Zna0tOOHpYTGFqZVk0NGdhaFdiUFJPVXhDUDBwcDQwMTlQQnVGUHIvc2dMb3kzV3E0NW1ReVRvTmtHQmJ3dTJETlYzck4zZDBEYmVYcWcwZjNkeWV4a2h2cm93aXBkbFNWU3BDTG1vUDFCZkZ6b015MkFGTDgvd0ZBbGF2Q0lxaVU2TTdjN0o4RDBpOHFsa0E1L3poRE9NMVlNYzI1c0dGY0RiaWlVZE50Z1ZKYWk3T3l0ZHpteW1iNVU4TUNuRTFCNGxVM2NDRERLaTVucENzeTJleWZXWDBKdENoTUVpQnNSQllLS2pTcEFEaVR1Y0pVd0dGU2NsUWdhd1VXUmxrYmhaWllka3dDcjd0ZnVYemh3b1dMUVpETVlPU3BUZHhEOGltdkF0YVdqMHZDSUxlNksrN3k2dTAvL1l0ZitOVy9sbXFGbjZWamJDM2hxVHZXT0tJQlJ1OWhaakJFS2N1algvblJ5VEVmNkVVZk5DRHppUi9NZ3FqbU9wYmpZc05LZTg2dlN1VzJhZnBUWDl3UEtMazloUkpEOGlZdndtUkoxbXZYUjlNWk5wNVFldjdZMEFRcmJMblJmbDdVWi9mem9sYXJkZG90UDBFeXI5bFlKUEpweEtkbzBBTk1JdmcvNDZtZnhURnlRc3dsbUhldGdPdUNQYmx1R1hYUDJ1bzFQbnozcmQ3YUJYOHlSRk9WREVXNmpNeGxUdlZSTWVCbHJOVVNvQVpYbWFGell5Vm5LbFdsMHh5ejg2QkdYTmx2eGJ6a0xOTk1LSkNtWGlvbUtwZmFVa2JLdW1nekFCeHVqaTRCRXhINUtzNk9NQkQ0T0NVWUNhQlV5UUJBT2pIRENDcitnMERLVUp2S05na1NJQkUxblJiNG5vOHZ3THhaYzdsS28wUlZGVXJVbjl3b2UwRlJtYXJXZjJvYmlRUld3bGx1R2NNSlpoek10cmMzdG5lMndqRHdneUFLd3lMbnJpNkpFcCsvV2NMbVZKOWs2VS84by8vODlzLyt4UnRmK3JPMTloTGNDVDlOcDFIRUVURU11dFZnbC9LK0tIeWlrRE9GbHlRbnNNYnlvZzYwY2NpbnphSEtoZTF5WTBxZm5nOGF3TW9YZko4cjNCdlhxdFhkdU5DREdJT2xZeHFNcHRPMVRtTzExOElraEl1QzByTFk1STZoejJiY3k4TEpDVVRMSVJSRW9BVXczalhMbklSdy9vMVpuR0R4YUZoR2Z6VEdESVNiRkdxYUg4U2VaNE1BVm16c3g5QWxmaXdoQ1RUYlRSb2RMUXk0ZUlwQWxYeDRFc0NnemNkTnlWcWNHZW9zYmJ3b3FNaWFhbFNxZ1l4TVdlWThMTkN3b0xDaEJwZlpBb3ZjRmtISVdSbExDZ1l6ajQwVC9TOG56cndJSXRJTnJGSzBiL0I3NXE1UFNWR0JNSkhsUzZZb01LcnVlVkN3V0l4RkdOZ2F0cmRFbC9FeXVSQUhEd2xxaFJTZXZNWmFCbFdQRUFvc1JFdWdQQ29zeS9KL2tRcHhsVVRHcDVRR2xneGdFN0xMTzlENURYZ2VmQ29yNFJPUmRsSEFlNGo0Vys4VUlzSnVGRHJrdGx2ZGJvKzdUQlkxWUwvaGJzT2Z5YkhsTFhodEZ6dFdlQnlvREVNSFNjU0pLSU9teGZCSjRnUW9HTnpDdEhQeFBNbFdwdTVrUEhVc0YrN0tVcnNSMFZSU3MwM0xtRXltbmFhOTBXdUdTUVlGeHh5QUpjTTJBTTNrYlFuK29pcExvd2orang4bklXL3ZZbmFCUkIvNFBwK1NTTk4yelpueFl6Nm9LVFVzTzBuenVtdFRSUTF6eU5leHBtYVI3Nnl2UXQ2OWw5NU1rZ2pUbDA0em0weUpRVVNNTFlBU09QK2xZOVd5ekFSMlBOejA4RHROSnAxK1RPZ1NpS0VnQ0tRWERhRzZ5Z0JUQW9pSXFqRUFSR3FsUHFNOFVSV1U0eWdtblMyY0t6RGxwbUxuQVVqMUVPdzhRSDV6MjY5QThWUlFZaEF3UTBTaEdWZllpcEtld1ZsbFovazhWUzM4UVVBU29WR1RSR0VxcE9BaGxEbEg0ajhkaEtRYUtBSFYycExMaXlBWlFnSS9OTDkxL2VyTHQyK2hINjdyWWRQbVdwNWx3WDEzYVMvU3pNRkV5TEpaR0hhMkx0Nzh6T2QwdzRLekRQdnNRSWU0L2RSczIwYjEvTHlkWVNYMGdIUVAyd0NLV1UxK3V1OThNVk9XWTlQS3p5V2dVdDcyaHlOalRQMlpaVnUxR25ZSExsK1ZuUmV1YmJVOGR6THpYYzFxTjJwUS9qZ3pvTlp3Nm9VamxoOXFDa1ErQ1FPTU00dzg5dFhVWnZDeExIOFdndzc3V3Znd0FiYmluSUU1TkJzYlcreUR1M1VYMjNDb1BMUUFLdG1zMStyTHEvYlNSdWJVMk5MekVsUHhSWXlDODRNQkFZanV6aldUUG1tSllka0tYeFlTZGlyK0hGc0FkUDFQMEVZWjRIT0FDVVIySW1XU29yQmNGS1U5eHhHOVpKd09DQnhGYmprNE1kQWtWVVJBcHNTOEd1bU0wTStyVjVSbE44NElDWUlzRzRXY09VOXlLYU5sZk02TlIvN2VEVDZ0MEl0dEVFSUNNdWNGQWZOUzUwRDZpQ0I1YUd3VlowcU9VaWNYZmxvdnRwdzgwVTA2ZkJBeHNvcHVwMzFoY3pQZ0w1RU02RHBmT1NiR0trN1NNSWkxSk1yajhOVmYrUnZYZnVZWFllYU5WZ3NDd1dZVTNqVDhkK3hFZWZWZTdzc2lBVXNNeDBQVUhkV3lEbXc3a3ppRjYrTFlMbmFwSUpYSGRXaklaajcyRGZDSkRNOHgzWHJORDdIMzVSdUZNU3F6SUVSRCtic1E2STNocksxdjhqRWVBK2FGQmNFVzI0d2Nub3hwd25mQ0FtTHFlZDNSTVRYQm54NFAzOXhrbm1LcVlWWm9CaDhUS3ZLV2E5bDZqcTA0cGhzY0xsdkwyalViMnEvWmZISkJnUnBaRG9Va0ZUQXVRenlINTNMblNjcWJ3d0RWZzdRNUZrQ2l4YVhDaU9WbTNtTDVCV0RmWGdCRml5bzVuQUFJRlh4Z0xSaEhHVkZpb1dFMUNDQ2RONUNOa1RKb2lMVHRITDBDNGFveVN6eGphcjRpb1NRaStzUVlrNHIrSERCZEVhazhFZ2xJNmprZ1hpMXJRbExTek12T1lURlg4Uy9qQ3FTUnFvVUtudWNnQ1J4S2lmUElyd2NYc0tKOGhYUVlRWDNaRWpvM0h2UXlUYUdzU1JEQWsvRzJMbTNlZXZtSC85S3ZwMjREOXR4MUhVd1E3RUo1Tlo0ZUJaMEtVOTVXNlljUk42K1FiVjVFU1RhYXpUQkE4dkp0QndvcDZzNlhncUJZRUFTQzlsemJ3ZnFTOFl0b2RBYU9oaVBiTUpkYURadlBWNFpMbmVXVjlTM054TnFpSlh5Y3VJaVRlQmI0Y0hOR2Zrd0hCaHRkVTBlOVZBT2RIeGgwNE0zRFo0K3g4Q1R3S3pDdllOcHRVM2M4UHBrTWcxY2t5ZWJ3RVNzUVE2RGduQ0tqR2dHY3lsZ0ZaZllMUUNVNUV6N0l5ckpxdHBTSmltYXUzQ1ZUQVlXaEhnZ1pLWVVNV2NwU3FUZ0FqY1l4cTVTYlZybUtFeFIzVlFLMmJvNlhSckVrNG9yNUhLT1FDbDlpY0JBSFJoWG5WQkVpcEdVR2xjcEtNaDVaVEJKTXM0QkFlWUdrNmpaWm5XWE80Y3liVjJuRm9XeWhBRVhJbEFKVWpaYXAvQktRejhJa1UxRFNueUVraVIzZDRjVDN2SVkvOWYzWkxPR3JPakk5VGFMSmhBKzc4L3A2SGt6SDhYUjg3VS8vY3JHeTgvcXYvTTBRemduYUw3WWM2d0N2UEVMMDVWSUlBdzYvSllhQlE3L2pQQi9UblluZ2I3dGV6WWY2UzlQUkc5TTJUd2Q5U3BEWGRVek5jbWN4cnlSaXpreG5FU3gvbzltQWp3T0hmaGJPYXUzMjhzWW1Oc3E4QjB5cmtHRnVnbmdTcC9Da29QSDQ0eVpZTTRJa3h4UndIWE1TWVA5TjNqTmVGT0pYOEZHdDU3cVRFSjQvcG5IeTdJTzNYbXZ6NTFoS0ZKREZYQzRLS0dIUkZBUVZGeEZLWkFFV0UwSk1NVlJydFZ4MjQwS3FzRExVTWs3UHdmTldYOVVLQ2NwWnFsWVowazZsN2dvQkVIMG9ZYTdaQUpKV1oxVkJoVG1EUll6aWdCUGRkS1lGTzhjdnhCVW9ETWpJUVFwQ0M4OUltSE9PWG9FcXRBalN6VS9qdkFEVlFpQmNxVUxFcWJWS1RhU3lERTlxMHFpZWNReVlJb0tGZ2p3N3pxTkgvbkRzejBhVE1ld2g5RnQrUnAxTVRrNm5SNGMrSEJJWXl1RVlzeURYREh0dDU4SlAva0lLRmMyTEdmeHN4NEpwaDVCNS94VjJrMCtuNUxDdjhPUFJKdFJMSzB1ZHhyQ2JoV1ZES2VXSkhlb21pdk8ycm0xN1hnMmVTV3hZOExpaHhKWmxqc1l6ckFPZFRodm0zcDlPMENSTUJLZlY1clBIMkNSa09SWWxyQmdqK0VEeW9uQTQrbWdScGdNZExXeEYrTDdWeUhHdzkrWUhNckdUeGlTR0pHcXVHK2NaRER6cy90MzMzM0ZudyswbTFZd1NWS0lTa1M2Q0VsV1ptSVBDQ2l6R2xlRHB4aW56TEVqRlVLSUNJRnFvUStFVXZiTHJBTnFETXRBZ3prbGxkRm5FL1BuZitvZElnQml5bHlJbHpPdEJSS20rT3FoNXE5UkVnU0FxK2hJUHpVQ01LaXVOUHhmS0hxbG1uUWRKQzlrWi80cEdOVUpnc1ozbmJJYUtncENSc3d6UWtDbGJ2VmlVSUxSQ3JkSnlPaXZJZitaVE5HVVFYcnJXSDArT3A5TlJFSVRKYk56dngzQXdkQ09MNHlMTG85azA1NXVhQXBqT1BJN2d5L01COURqMFZyYlcrQlU3eTQ5aHVISnVHUG5HZ1J3YkFMWkxCZ1pxQ3RuQjFiQjBIWHBaYy9scWp6aUQ1NUVrOE1TeGFRUU5WRlBYWUhHeHRlQXZ0VTByaXlKc05HZFJERFBSckdFVzFFYWpNV3g1cmRsQ2UydGU0K0Q0R0FzT2VvdGpoUGtXUk4yYTAzUU5NQVp6ZUZHTnVoMUZNUWhPcC83VzZsS2N3QjNMNEtsYk9yODdpOGJxdGwya01lc3FNcnQ3NGVhTlc3c3lUYVhWQUJseE1lSklRRnc4RVhqeGg0R3lKNld5bFpSbkpkR0tBNDhrazF3RVVNN0pRRVE4VStjNG5BT2hVWXRCVlgrcGdVeFFSUXZ6NS83MlAyQ200aVJ3MWxUVkdrbWZRN0hzR1VLNlUwWUowbUFwUjVCYUpQYnZCNXdKRlgrUkg1S015MkluS2M2Rnhmck9RTldETGFNcUxha1NWTmFMQlo5THM2VDZZemdEVlJ3Z0hHajVIaDhlbllRaDNQSHBiQmpuNmVodzM4ME1menJtYlJySHZuRGxpaithK3FOK2h1MWhGSnE2R1VleGdUMng1YlF2M2x5NTg4Ynl6VmNHVHgvbUlWd0dQdnlMN2F2OGVJamZ2Y0VKaHB4M3JZcWlYbmY1bkpkbGowY2orUHB3V1hnWlV6ZjhPRnBaWGFGM2txVUJITzBvd2s0NTRUVkxpcXhScThFVEFyOG95VHZkSmF3S1dDajQ0cjRrZGl4ckV2QTJxNjBiM1lhZDhQVm0yVFJNVjdzTjNwL1NOTGoxM1U0em9yb1gyS1I2TnRZRTlMSm90dHR4TUVQSFVidnB0WXliYjh6NGxPOGN4RmhXOW10QnpNbzZTRnFtQnQyNWVXNmw2UUlTWmZNbHhmVENQS2lPQkJETWFSWVpDRTJsUHdSRnBXZ1l4M2JrNS8vMlAwQ0RxdUlDNTVUaUxNNVdvakhDU1h3ZDN1ZEV0bUt0UUJVRkJxZEZmQVhDb29LU29VUjVZRHRZbElhZ2pCUFBGYXFrVmZta0piNDhWV21BaWtvNWtTa09GWlU2blFkV2N5WmVBbXZtbVZObUVWUktXc05DOEgwKzJYM3FaNFVmKzU1akpsRTIyTit0WndYOGkrWFZsZTByVjlZMnRrQUtrNyt5dEhLNnZ4ZUhQbHh3TTAvbHpoOU1md0MzdUh2MVZ1UDZTNm5YMUdzTloybTVpRU9UNWhzckFpL0pnekRFSE1EVWNSejRHekVVVTI3dlU2ZnBobXUyN1Zpdy8vQ0MwaXlXeTQxMGREUURpdDdyTk9GNHdGcW5SVkdydDJEdHNZbjJMSU8vd0RXMU1NbkRHQlk5NmJXOEZKRHpaNnhMM1ZhT3FZUDlCaFlXUHNUTXk0K21yamxtRWZMMnJiNjJ1aklZRENCWHExWjcvT2pwei8vWm4rcm5icUxUZUtPcGxJMG8vQXVBd1ZUcWhsenNweFh5SEZSRGlrT3BUSXVNVkc1RmN3Ym5GVjJzZUZtVndqT2lDaUt3TEhqVGR3ZkZ1WkxJQmw2UVpZQ3pJeGg0Y2FYblMwV1h0WWJaVWxrNXo1R2xJaThDcTZUdk9YZWVKU3lrS3Y1elpwOENJbyt5Q2hWVDVRbElDUWVWdTVpSk14aVg2QVZnbGpSQXBVb01ZNm9RQVNlR0N0UTBITSttcVZiQThIazJMNXpuaHBVRy9sTE5xbmtPZEtiVjZVSHZydDYrOVZPLytFdXRwZFZ1dStPWjV1bVRlOUYwR0FWVExaNTVXVnhNK3RGMDNMdDhvM0huaDlxZit3bGo4M0xXNjJVdUprVWQyMUxMdHRrdVhaOEdRY1FmTTZXbXd6ZHFBSW5hNGYvWWxqMGFqbUkrQW9DeHdLN1hwcHVUOFJxOEh5ZWo2Y3kwYkV3Qng5VDh5UlErZmJQZTFDMlAyMkhkclBQNU15M01zdjRzNWtNZlNKajYvdUVRdGkvUCtHcSt3V2dDVng1SlRBejZYSHlUUjlKMG5XRm15bFY1L2VOUDdqZUcrOWVEaCswMHdCcDAzdUtWY2xQQXBOSTBEdThaQUtGbUFXQ3V4MGdqZzJuR3lsekFQRllXRmloUkFqUzdMS211bmk5QVJVVjZpZE9acVNwZ21wTlZhaXlkTG5hR2YzT2dmVkxNQVZKSzZGaE1TZ29lY1dVM3EzYWhRU1NXMjUrcWc3SzdFSG9Xa1FvNFBVcytxbFFKa2lBVmFpWEZRbXYrQkpBZUtvWW9YVnJ0OHpCSElWZHNKaHhRVlJuaVpVOVZBQy94a1NoTnM5Q094cVA3UjRPbzBHS29tbUVNOS9laWs4UC80R2QvN3FVZmVuTnBiUTB6b2RYcHVMVWFURE5tSDl3YmZwYXMwRWY5NDNRMndmYWRuMldLWnFibkdVdkxlcEhOcHNNOG1pYlR2bWw0dDE5NXJkWm9CS01CaDFUWDRQbnowMmlPRGR1T2ZURDJsV2dLekRnMm9IQ3ZYUnVlUFo4eGhpaWhURWtjV3pEZS9ISloybXZEcUR2WVAyREQ3TmJyVVAyeDczTklzSGp3dFNLWU8zekF1T1pZZk80Z3l3ZFRORkw5OXJ5WUJ2RktxeEhDb1VtenBzT1hCNmFhdHRuclBQVlRPMC9ybnZ2UjA2UFAzYjYydWRydVpyem5sZWd1RnF1RmtUMFRMRURGQlNteVhRQ1ZKb0VxV2czN3ZIaVpoaVM0cHFyRUhEQVdRREVJQng3SlEvNFVMSlpBY2VSQzNmOWpTVEhJZ2RyR2t4QVJ4YU5TTTE3Y3JhcFJvTElKVWljelNGSUNZL2hIUUJPa2pDcUlZOGxCNkNVZlFRcktZWDRpbEcwQmhraE9KQ1lKYWtyOUNWQmxTc3VmTXdrRTRWVVNrVmtKZkJaQ0lqeEtqTjNuUVdTcTYvY09EeU1EVG0yaWZvZHgrdVNUZERMNlV6LytFKzNsTmEvUmdMNUNDWGd4VzlNZHorMHVyK3crZWJ5NmVXRTJISG0yYTJBREd3VjZsdGliVzFxckRTOWNLNUp3UWk5L3BkNXF0OXZZWHdiVEVUeituT2FjTFhBd2JUUStQc3lQODZFNDNVaVlaTU9QWXR2bHR3SnBoSkgwZmRodDZPNHNpanFOdXVzNkUreEo0OWlyTlRFM0xIbkhaY0VYTnNIOTFrTStGcWxOK2F1ckFsbCtrbUduYTFpNlkraERQOFlXR1NzaTFxaFd6WklubWZXMVRtdVE2eWVubzNiTmZIWXlhbUJCcWRYYmpyNXFKMTMrWU53TURCU2hySjZEUDNHQUNFSndydWk4aUlwODJ0alJHcFJSRUpUUmMwZ0FCNnM4NDU5WjVzLy9MVmgzOEpQUkpGSWQ4YS9TQWh6K01rcGlNWDVTQk94SlJyUUVsajRITklkQVYwSCtoWFJlU2xBRW5PZWFyTTVNWXFKSVMxVnpGVkxtTDZjODA0SVcwOHZJSEdTQ251R2tZMlZUQWV5RWRKb1VRc2FyakpJUGtRbU85Q3FYWjZtRkxQVmlPSmsrSEUyd1BZME5GOGJRSDQ3Qy9xbVR6ZFo2eStzWHJsQWk0cU9paE1XWCtscFd2ZFpZV29aLzBqODR5cU1RcmtXOVZvZXlOVjk2M1hSMHI2YW5VVEFiSEJWK3N1eTZOcDhLTmxyZHBjbHdpQTBvbU5HS1k2L3EySHltTjBsTTJtQzJCbTJaQllIbm9Jd05xeC9CYXZOYUN0ODR5UWNJVEwxWjk3RExoSzVpNFhMbHMwNWh4S2R4ekNMMUhIbXBQQytLYXRnYjhBSzhobFVpVGRLY1Z5emg2c1RZTnZBaGhMckgzNm1BeDJxbmNlREhKNmNEZEE1cmc2ZHArNVBnMmRNRGZ6cnBIejZycjE5UFRKdVBHYUJkbFZKUXBDSUhKc3FCS2tGaFNxZ01zOFFaZ1ZzaUVqK2o0bWhSOXZRSVpOOVlBcjBHVnNreUtEVm5vb0JscUQvZ3IwYVY2djczNS9taUFJaWpUb1dSZUpVclNEVjlwS2ppelhZUXA0allKc2xSQktCVFZHZlRUbEVENU1UU0ZWUlJacFFjRkZRczVFUlFNVlZYQmNpR2hpOGdKRHBQSTBzaytTbFF0ZkU4Q0N0VXBQS1VXREIrTUtQZnVudC93aGM3eHFsbXhJVTEzTjAvZnZkOU05T1hsem8zWG5vRnRDQlZucUNLbytwR3MrazEyN1ZXU3pPczJYamM3UFhNM3BLMnRXWFhiR2plK09Rd2hEOHpDVlpjTjQwaURWWlYxN3RMcTFnbDBDaytyWVZaeFFkZmREOE1vWVd3NVladXhySUxndWxwTjVvcEZnd29aWlo1ZWpGS2NxL1dnQWZGMXhvNDluUVdRSGNzMjRVN1BnMURQb0djcGZLZ3ZPRlpmSXhzczl2eFhDZmtOK3hOVENoc2J6RS9zRzdBdDhIVVcrNTJadUNBaWd4N0dLYll6R0pSWXh1d3NmWmFrMWswbVBpdWJ0NWFiZXpVTXNnbjBwMlVqNlNkbDZrYXUrZUdDN0NJS1lGNFlFVnpKRmNvRlIzOWZlWVJ3NlZUa0FBMU9tV3lLTXl5S0hlWWFnYndJRStpUWQzRm1aRUM2clFJVlh1WWkzK2tnT0dVa2pnWFJSNDV0cXloS3F6c0x1ZmJlWFlvV0RLcG1xc28rYys0Wk1uRUprZWVGeHduSlNBRlVnb29zUjlDcStnWHVJRWVCVmltbWdUZ1drWFBnQmlaK2Z3N0QySkZ5a1loZ3JvZ3I4ZEgvWGZldlp1YjllR1RLWnJxOHRkRW9kNVl0cTM2M3JNbmtXWmg2eGZFeWNRUHBqTWZua1NSWm1hUlllT0kwRnRmWGI5MGVXbjdnbGFyRld0cmV0MnJOejNrZk85Zi9XdXYyN1A5cU90WThDQ1NNT1NqNnZBeGJLdmI3WFphN2M3U2ttRlpvOGs0Q0dOZWp6ZXR1TWo0K0JMOW1haGViMEN2TVNWZ25yVTB5WFJzUjYzQTl6M2JiRGJxTXo3d3FHRUg3TmhPa01aWUl1QzlteFNzanBqTHAzMjBicmZGV3dUOFRUb1VXd1RCVDM2bnBtbjdhUXFiajNFejNRNTJER2dkNWdtMkltRXdhL1Y2dzlGb012VlArcE1uRHgvcC91aHF4OW1zbTVpZ01jZk93RWdxMmNuNW5DNHdMUmdWQVhXbEsyY2p6Z0V0SS9PeVBLczlsVW9EcU9aRWN5QjVrbFJKTDFSa1hwR2JQMC9mdmN3OXM4RlN1b3pJbjhwUU9CWEhjYTQraXExRUNYUHVjMENObFg2WEdDWmVJR1AvOEU4OFlxcWVUNEZ5MmdDa0p6d0pNMTRsWUI5VTJiSng4MGFTQkRIUitoTHhBaXhtTVlZUzh4YkwrZlIwT0p2TytMRXhyYUViRnJ5RmFEakxzRmxyOW1yTFcwZVQ0TjdUWisrOC8rMEhCNCtlanNkM0h3KysvY2ZmL2Ridi9Zdlg3bHgzbSswMERFM0hhSFI3cTlzWGQ2ZkRSc2R0dHVyWUdrNEdwNmxSYjhXSmczMXJHbXVHMlZyWjZHNWZoa3NDcllYMlEveVc1YmFiclZhcmlTbU5UU3VVTk5YNVRDOTJrK2hRdTlXQVp4L0R4ODU0TVJJZU95OVZabW1uMmRRTll6YjFuVm9kUGhKb2dpaEthZjhvSXQ1NDRucVYxMXdYRzl1bTUwQ1B4N01BN2hRV0RTd1c2NzBXRmdXNFpQSlNZbjZkelhFZGVGNTFyQVpSY09YR2pkUEJLUndxaFA1Zy9QREp3ZUhlYnNkTWU3Wld0N3dBbnA0YUdKRWNSMEZBSlJXb0NFWU1aSlY2cUJJSzVvUnpJTzA1RW80blJvamRZZkVGQlFhb0pQRXF6YTNxYi80RFlpcU5FV0JjcVE0VlJER1RYTlZjQW8wZDRoZ3NsWWxUbVlXRWZMUWRoUVZEVHhOSnhrcyt4TS9ER1N6WWV3YnFtV3FWdUtvc3B1cVFmS0VrR3A2eW9BZ29pNEJ0SEVzS2pyUXN4VDgxTllTUXNDaDZ4RWtwelZOSkhpVmVuVXN1VVdFK1BUaklzZkszMjJFV3dLbHA2SnFqVzBXbUc2YWJkMXB4dlpWNzlWbC9ITTFtUlZMNHcyQ2FhOS85NnJlSzhiUGYrNi8veTBmZmUrdU5uL3pwL21ReXpjYXZYTjErODlwbFg4K1BSOE5aN0YxYVczM2xpeisxZGZ1MWF6LzBwZVVyTjNaZWZ1T2xMLzc0U3oveXA1YXUzaHhNWjZ1WGI5ejYwazkwTjNlODdqS2ZoeDhQalFLdVZHYm94bVRtTjJ2MW9zaGczU0VxdzhUbWtuNDRSckRkYkVCQkorT0phVU9UTGZqbG1DSGNBNlNweDlmVm02REhDR0xPdE9xWUQzckROYVpoekxHVVYyNHNOUnBZdmlBTXo3RkhZYnpjYnFGUUhBYU9pYzFwOGhmLzZ0OTg3KzU3V2NnbFk1WkVRUkFlbnd5ZVBkdHJ0cm9OTGR4cFl0ZHJ4TG9sRjIxRWg2Z1Q1YUNWb0ZSVkxlaFVHQ1grT1RBTitua1IvdHhVSlJVM1JzaVFnNjBTa290aVl2SkttTWVRWmY3YzMvNzdjMzVvMW1JZW9ISjkrQ2VSZVdHbTBRL29tdXFCVk1qTWFnTGdvQ2FNS25abUpTVlhDQ3BRNnNYS3oyaFVYU1ZaV1lXazJFaHBqaEFJQXY5Q1VIRkdDOWdJZ05KakZTZVJES1JLbFZCV0xmSHpVRkVxbmlTQnMvNjFqKy83NDdHZTJyR1pkVHF1a1VKN3NCWDArQ20rOVVaUzA1TWsxcVBFeU96WjBKNzR1dDZzNWUxV2FMZmYrL28zSXkyYmhNVkdyeDNXclZmdVhMeTFzZUk0YnFQbXZiKzdlM3lRL0prdmZaR3V6dVpXZTNsMWVYMmowZXZDSkR1TitzcldoWmQvK0VjdnYvTEc1czNibDE3N3pKMGYvdkUzZis0WDczLzBZWC8vS1p4VW1Pb2tUbWhRRE9pNW5Xc0ZURGdNUnh4REtTMzQ4NjE2TFVsU0dPQmFvNW5CRjBsVGlORTBUWVBMQVBjWWtCU0tvUDA2TjhtbTU3bGhHUEM3UFhrKzhjUGxScDNQS1d2NllPWjNtaTI0ODFFVU5rdzRYZmxuM3Z5eHk2Kzk5UDViMzhGc1NiQjFpQk5zQUtJZzNuM3k5UGpKQS8vd1djUFc3ZlpTWWpnWUw2cXlqQ0pYWmxaS2taWmpKQm1MaHJuU05rb2VjZXFGekFYK2MvaVpMY3preUFoSFhFWExHU1ZqeC84RmdLN0N1di9IQzJnWlY5WUNDeWtYbWNzeEYzWXFMbG5Fc2J3MEVXbWNWUnZWOUdQNmpLdEVtSzBhS2xkUjVwa0V5WlB6K1FEK09LbU9FUlNWNU9IQUxQUUFNYkxsNXBBcDBqQXVCRlVCZ1JKNXZtcUNvbE5TbnhPZGtTbVo2SW1tZjMzdmNLcGxMY2V1ZDFyMWxoMk0vUWxVMlBUME9yL29sZGg1MFBmTk5NOHROOUpyUmQxMTErcXptVys1alRnSitOYkhMSGFYVnQvKy90cy85d3Mvc2JiVTBPRWFXNFpoYVoyVmpVOCt2dnZaMnk5cE90OUJDYkhMalQzK1E5Z3FpVTBCTExFZzZiTy85aE0vNWJTV3B2RGxnOGl3K1N3QWRGVWVib0V4TmJBZlRXSit0UTllaldYcVhyMDJtVXdpN0RJeEgzalhOcHY0UGx5aklrM2dxMEJaVVRaT1l0TnhzQWYxUE04UEkyeFhJUW1xZTdzSjV4N1NBQmtXamdadjBCWkZHbVBYZHVYeTVaLzdsVi83MW5lL01UcnV3L1BCdW9GcEV5WUovS1hwTElvS3U3Tzh2bHo0eTdhV3lxMHdjQlExUVI5NDhZZFNsWUQ5QW5BaTloSURhY3VSZU1uaUVBQlFDck5GalFqcHBCU0JDRVpaa0NWUllqNi81c0FCTm4rT0Z5SXAxeEpacWhDeVNBdHN4WXBRRWtrV29lS0lRNVdGSnBUUmtxY1Fsd1Z3a2k0dHRLUE1CYW5Tc0tvbE9DS21Kc2dab0NDSnBSQ1ZRTXBLcXN6RVAwc3FHZ1JoVnVtdVRJZDU0eGRBSVZVSlNjc0JkUU1LTGNuMXgvM0pleWVucDNHZzUyblRhVU50SnVNd3NBM05ydWxPRFpZdEhBWHhPTXVzWnRIdThQSjN6WGFYbkNRWUcwYk41QWYxVE16Qk9QTWJLOTdxMVV0dnZIcDFjNjNic0p5eGxpZDZZZFU3ZVpTdU5KZDRQVkQxUkpyTkpvZzRaT2lZVnVNdlIvM0NuWmMvLzJkKzRRcy85K2UvOUV1Lyt1UC80YS90UDdnM1B0NEhIcnJPN0J5K1BWOURpWjdCczU5Ty9UekxvSXVXNDRRKzMxQ0dvT2VaNDJCRHllZU5lWlZINDBOcG9LL3hDYk1KVFAwc1NycHdoOUI0bmRmK1I1T3d0OXlCL3hyTUpxYWg5enE5bi9pRlgyeTBHbC83OGg5eHA4Qm5FUGdZUWhxblFSejMrNE5ISDc0NzJYczRPM2c4UFhoUWp5WndqL1JtdDFMNk0yRFAwRmFpU3RYaFhSSzVEYW5zRndCZExuVk5VVlJuNmpXaXlGQWNSVDJZS2JXY0IrYVpQeXUzbWFRNlVJS0dNNFFuSldRWmIxVlNkc1FrQWdCSlBDL01uQUhMYzNUT0FkSUtSWjdpWjZ2V3NTdzdSV0JhVVpCSU1LQ3NNaVZYa2ZDc2RGM2xDVTc1L01BSVZZa1ZEb2p3QU1DQWlZMVN6S1NQVEVwY1VhaWFLeGJ5ZmlLdEdNYnhvOUhzL3ZGa040bkN6Qy95ckdNM2REMGREbWRqMDlUY1dncjlDS0x4MDNHYTFYUzNYamh1QVY4Q1RxdHJ4TUdzMW5SZHF6Nk5KdnpFcE4vM09zc2JhNzIvQXRPK3ZaNDdkbWhrcGxtZnhQd0t6VnFyUFIyRnZHd3R3bG9RWXpsLzFTaW94Z0hVZUtLRk1NbndQMHpQdmYzRkg3My85anVqNHdNNEtpVGdiNHVoeVhyQVYzckEwK0ZtREM3SHpBOWl1UGg1RVVaeHExblRZS3NOUFlsVGVpbThJVldEaTAvTnh2UW9Dai9Kd0t2dU9WQkFJRS9ITTdqdjhIbW12bThXbXF0bmYvR3YvNGJiYUx6LzhidEh6dzU0QjUrUDcvUHBUL2hNVVpyNFlYSTRHRStHbzlIaDN1aGd2N0YrMlY3Ymt1RWpzRU15Y2dvd1FrcitDTWlRUGlOV0NxSlVHb25QUVdVdWpxa1VKOWN5UzVHVlJSbGczWlc2cStxcjRTYUlUb2hKVkNJL1U0L3lRS1FDRlZISE13WVZLQXlPY3BFSlZCZzhIb2t0eXhCRFFUQ1FYSTJ4NUFFUVVUeXFzNkpaRUJiN1NhUUtCR1NXS015SE9TZUFsRDJIVUVWQWpGYm9SWlJwRDQ1R2J6ODhPQ2p5M1VFUUpPSFJvQThiclNVd2ZuWDR4dU5oZEZLWW1tbDdXYlRzNXFQRTFyb3JWZ3RtM3NaR1VhdTdtbUhrU1dKM21vNXQyQzdWUDAveVlBaHZ3cnAyZmVlTk4yNWhhMVozM0ZDSGRZOVdEV2VZcHRZMERtZnlnWnFGbHNtWXFYQUdWVUwxQ2NkU0NuQlVYdjJKbjY2MWVvZDdUelcraVFObUZnWWVNc2M1YTdnZWYrN05IMXpsZXBZQmJ4akZuUnRYL1NUS1U5Nm1qWG1WUm4xMVRlNEg4eFVHZkdHbEg4VXIzUTVzT2RSZzZJZk5Pam9GSDhuSERoWTc0TC95YTMvSmFYYkRMUHo2bDcvTXR5dnhGN2xaeXF1Wi9LRVdJTTMwV1JqRHkxcS85c3JPVC80aXY2akc5c3J3UXVRNFN1TVZLSnc2cTJWT01BSklvSkFjRlpRZGw2UWlLNmNFZFZobGNFQVpVVm9ndWVMTWxMSVQ3VkFNS2lnVkJ0bHlKcWJTU2dZaTVnbldpaU85cXpLSEFIcW1oSTlrTU9DZnQ4R3JCdU9NSUJHa1NjNWNSU3dNaUNvRER2d2RMNXZCRlBLVXB5NGdVYUJvMVZrV2g5Szg0eUFOWVVYaUsxS1hFRGd5QlZTOEdDWHhnUi90ejhJSHcrbkpPSUFqd3ErTVJkRnhORW5yYmozeEltdUZqL1NlSnNkSG9aY1gxdW1odDczUmordWExK0hQcHR2T3pJL3Nick8yN0dDc2JXelArSlNWUFFzU0dOYjBOTWtHY1QyTHJ1eDBudDdmZmYzbXBXRmNyRnJXbWd2RENTL0FER2RwNU1kVk54YmdyRy9sWU1zd1MwL0VuWk44QnY2Ynh2Yk5sMzdvei95NWw3NzRFN2ZlL05IbDdTdDMzLzJPemV1Vk9Rdzg5RTkrdDhyaUVBcklSNFBoei96VVQzejh5WDFzYXRNRXJybUdUVzNkclNHQ0RldUlyeVBXcG1IYzltcWVaNXVXR2NOcFMvTk9DMXNSZU9nQmRnRi82cWQvMm16OC8rbjZEMmhaa3ZROERLeXF6RXFmV2Q3ZXV0NDgvL3AxdjNaamVnWXpHQWVBQUFHUUFDbUFvSUdoU0lvQVNPRlEwT3JzU3FTV2k5MXp0RWRIbENpdXlDV1hTd01LQTJKRmdzVEFUNC90bnA3MnI1OS8xOTliM3J1MGxWbTEzeDlaOTNVUGpoUzNibFZrWkdSa21PLy8vKy9Qakl6VTF0ZTN2L2IxUDdTR1U5UU4xVURQd25yQWJGRG5JaHFOMFAySFlIYnArVmVpaW96ejByd2YxaGlNQm40eFZCUVB6VDFpOUkxZnBCTWV3aGFHZ1hESUFoMlBkbERtNWQ0UHY4TVlmaTh5UDgyRHdQM0F6LzNpMHcwRTBydFBENkRxMEVFeElpMm9SRmpBUjdMLzcwWlpQbnlXS1lRdzZtSzJaMW4zME9GQWxIWlJoRTY2ekI4ZXZFeG5xUVJ0Q21FWjFCbnNzL3loV0xpWFpXWlIrbHlrczhDRWk3eEEvRUR4UkxyaldYM2lEankzQjROcituWFRiaytzNmRUbkZ2U2VNRGtoeTFsdHhGNXBOSjdHK2RFaUxaTXpPcDU2OFdnc1g5YmxmRnJjMkJLTmRDS2R6QmVUeFVvcWwxYjNMdVV1WDBxdjVxU1ZrbjVqdmJDeWxiOXlZN1c0bFV1a0VpZnZISWkyOWRrZnVmN3A2K3MzcnU5Vis3MWNOaCt4cmU1NGt0S01rY2ZQUnFibitoKzI0R2xnYlE5SElXeFJtT1hwTUQwOVlwbUhaZ05FWlNPUkxKWTJiajI3Y2ZYV3ZkZS94Yy9wS1c5YTBNSW5BU0dmQjNuWlpmdU5ZZ0VKdytFRUtwMUlpRThpNGZzemlZLzcwWmhEYnllbUJ6c1ZXUUI2Y1JTYzEyVENBTk16SnppRUsrWnp1ZFYxUlphdHdMbnpuYmNJaGF4MjBNMm9FR2w2RmxDdzV6aE9weWJ4dkRkb3p3YTltRE1WRlgxT0N4dXpGbERMNmNNMmw2b00zMVFXN1dReEN0UkdqQ1h0WW5rK0dqNjZ5Y3I2RS9zcFJQL0JkeDdIQUFQcUFmUWduUWdTaVIwaFFtbVROaTd1WDFJbDJEZHRZanY4cFFEWGdoa2crbnM2UE96dzd6a3JkanpkSmptNDJBZ2oyTXRrblhMUkR3SkoyaklKZ2UybGJmcGpseXpZTHFya01nKzBCUWtZS2hIbXBYOUtaMHNYVUR1ai9Ed3VpcG9vU1JFWmZob1hjNEtJRTh5bVFMczdtL3IrMUluT292UEJPREx1K2s3ZmNackRIL3JDM3ZQUEZWdmUvTER1bExLNllmQThMZEVhZ1dWRzZjQVhqNHJGRnZRR1liQ0NLRWh0OUpTZUVvclM3ZnRZeE93T3VmM2psNjV0SlRORy9lQndKWjE2ejRwdXBQV3lCSlU3bTh5ODhVS3N2bnRYMVBNQkNtT0JPdVppUlBDRmpxQlVhZ3JpWWF0WUVodlNzTGVwdGVGR3VKOTI0aE1iMXM3LzJYLzVpMDYzRWZIbjlGb1JlcWNOS1U0UUdPVFp5S1V2NzZ5LzgyRGZkMll1dlk2YkVLQ3BDbFE0Nm41Y2JZenBiVG5CVmlsTFh1eGlVUjlNdGxaWDBhaGVxNEZtdnZLeGwvNzBYLzNyTVo0WE5la3YvZG1maElpZ2g5RUdxSGJtRE9PYmhpak9SVVZlbEdRaFlXZ3JoYXlZU3VjcUc0Vkx6NHE1b3JxNkEza2lNOER1ME5OQXNycFJVK2lQYlNOUWhIWEZSVUNVR2htbVVPeFBockRuMkpFTXZHeUwrOUl2L0UyR0RyYUpzMUFpblRjc2dtZ0Z2dEUra3Jtd0t5bmZ4U2ZNRS82RThrVDFZbEVDSGR2SGptSGxoU25MazdBOVZDRHRJc0xDb3V5ZnhvbTJ3L09HTzlnbWRqTktzc3dWZnNMcUx6L1lqY0pwTmo1cmJkajc2RXg4UTNuR1phbFF5dVJLZWpJbEdZWW9LK0pDNGxVOXJ1dlExTWxFTGwwb1pDcjVkTG1ZeXVTU1VqSUJWcnVYaVQ1emZkVVhlTWZoZGl0S1J1RlVIdjIza0lRWUg0MEtxQ0M3amhDT3pEekdYcDhVaVFoQkpCNUVWdUtSVFQ1eVJST3ZiSll6YWx5UHp1TXBmUktOblhiR084V0V5TkZxcVNEQjQ4bjgvcS8vazh6VzVVaGNDSnVCcW9kZEZQNVN5a1dnazFFSGh2dkRRSEg4NDdNMHh4L1pVblRqOXVkLzZQRCtmYnZYQkRHSHBoVTRlaGNEZHNPRDlWM1gwR1ZkVmR1REliMWtNL0RwNGRRRnlFd2NFa3pyZjlEalRyNGVweGswYU9yRWNSUkZVV1hKdGl5QmkzcXV0YjY1TTNITWRESjdXanVyblp5eng3MmhDcGlDRC91ZmxnaWZ3MFVBRnpKdDE1cE1WRDQrTlVjbkQrLzBEeC9HRlNOUldLRldFU2hKMkFncWJCQnBrMzNUZ0tNcGlORW1heTM5ME85SGV5Wk1wNUpvSitzaDFzeUxYUGlPY2wvNjJiL0ppcVB0Qy9DRmUya2pQRDFDZUJodHMzVFNXcXpnWll6eFNKYURRb2hpbGpWS1Y4Sm9COXRnNVlSbm9SVGFRWFVLdC9CTkxhWjg0UmNLWm1VU0phY29PZThzTmZUaXFjSDRMUEdOSDRTd2VXd1A5VFdwWG5EU2VTeXFKUlVnZUtOaVJPTHpTSnh6RmpHZlhkV2ZBNjNzckV3L1JxR3hJck1BNUZTenJHUTBVSVB4eTdlMk9WM1FGVjVUT0pseVVkM29BZW9JVFZ2MzJCbDVsSUR0Nk1LMDV2SG9ZajBhS2ZEUkZCL05jUkVGRUtmcklpU2xxRXpOaTNURzN0VkNraWFtNDhTZ3RKT1JHdkcvOXVYZmZIRDN6dVdYWHduaGluUGdoMW9kZnFGQllRZXhnSGpZNTJGZ2Fjc0RTUExaRFJQU0h5eWRxaWVJejM3MkM0UGhxTFgvS0JialpyTUFQSVFjQ3hDWXlGeUlSTHpJb2oyQ2tDN29QdWdNaUYwSUFrM0NjY0RsNlJwTDRDL211a1N2T25QcDlRcHhsVmFwOTBSVWYrNUh2VUZNa3Q5NjY0MW1yZGFzTlltc0U5NmhYMmc4Y0haOEF2elM2OXhJMlhzemVvelFzcXkxWno1MTQ3TS9tcTZzK3RhRWsyUm9kNWFYL3NNbTBjWkZJS1ZMUGN3UzZSdFduM0pSS3hrcVdic3BzT3lVRXlFVUlicjBpYjBzblhGMzFsZGhkblljeFVQc1hSeEk0Y01ZUWhobk5jSzV3MHF3UUQ5aFFUUmxZbG5peGM2TENIMkhOV0FqUjRPSGpBeDQzR0xoZERxVFpuMVlQYVluRy9nNGNRYWduR2EwUldhamZqQVpWNS9jOHdiZHUxLzkzZHI5OXhKSlRaQzFPQmVyNkNyR3ovSjlnSHNSNHpDWWNVWFVrM29xb1ZSV1V1VzhwbWpRV0hSdFdjU0pRZEtqVWR2RCtOSEtjakY0ZWV3T3BUY2F2dnVidnpXdmRaUkpmMCtWZHpMcWdnOWdFM0l4RDRMaHNndHpzMkJoQWlEenFEZGZ4Q08wNEJhL1dPalJSU29XS1ltTEVoOHpPQUFvWmtjV3MrakNXVVE3a1hsN01hL1BZa2RtZERoMTlsS3FKUENkeVNpQ2xyWGFmKzluZnFiMzhQNXM1a294YnZQMko2QnkyV2l5YnFJZUNrZVl3VGhNUS9nd2huM0xvVVR2c0FFaXFDTUg2L2psRDdhNUdIZnRZNTlzZDFxMUo0K2dxQW5IcURaSEx4L3hQTi9CUHlDNWlIb0JYWnhoVXczUWk5VHBqa3VQRGNJMTFlQmxrc1RTOG1PcWdzclNsZFpGRVB6NUwzN01rR04zM252NzBZTUQ3SXJHNkdGeklKNytDQmZNektJU0FBTmRxYVFYYUZxT3M3Vjd2YlJaZWZET3E0ZHZmZFBwRDJVOUlSa3BWT1lqVGFOQUxRbGpES0xVTHhjWk1GNzRSc21VQi84c1Roc3NFcWJRSHFZQ0x6YkIzVjkveEg3cDRMQW9Wa3ZxS1RxWTNXcG1rc2QyNDBoMktDUUc0YU9QNWtKK2tjYmthWmt6TEFmeGkzT0ZoUzRENm9RYTQ1dWpNcU1MK1ByOWxqTWNOQTRlbjcvM2RtOElaeTRiOEh3Mm4rZGxOWmswb0MwY2QzSG5tNjhtazdvOXRlQjdxYklzS2NKUC9aV2ZLNWNyVVpGTGFLcXFwYVpSWVFDYksvREFEZGltQkhBekhBUkFNMzJvV2lDaDlpSm1VdXVvMHpBZ01COUl0QmJScm91eDkzdTExaTJGSnA4NDJDL0tyaVN2SzJRRlhHZ3pldzZ4U0drWThJZ1RpY1NCSk9vaktET29jRXJCS2R4RmRCcEVPcENLSURLbHAwSVgwZGs4R1lsVTFFaEM1UVJ1N2k2NG9iK294UHh2L0kvLzh3ZmYrdGJNbm1pR25pOVdPaEVsdTdYVGF6Yys4K04vZ1ZhN0pwMGVkaVByYU5hcnRIMEJmVkluTEVMSkxMYTBzVFMrUy8yKy9DWUhJOXF0bmYzTC8rWlhPb2VIdWhTM1hKY0xsNGluYXlLeE9PSWN2YkRTOFFOWkZDelQxTVI0WEJSNlUzTml1WTQ3S3lSMVExVUIxc0hFM0Z4ZEVlUDhwTmNDNjE1ZHlVRnNQM1A3c3UxNWYvemR4MGVOSHRnK3VocnFIQklFZzRhS2hIVkR4U2xRWGFKUUU1dkZYQ3FmVTQxa2xCZmlSaXE3c1hQdEIzNGlJb25VQkFhZWk3WlN3RGUyNlcvNW9lMFF4S3czV0s2d3BTd1Q5cEpTSjFLNzdJRXdjRi82K1hBU0FjRVk2UXpIZERpZGpVVlpLUjhlRUc1U3BTbkc0amlVRlJsdXNqd3N4Z0xMZFJGWUFhZ2ZZd1QwQVVTODRRQksrdUhYZi8vK3E3OTc5TjdibzlxNTdUbTZwZ1hCVE9EamdXdWIzYmJkNi9ET2NIcDY2STNHblY3UDlWelBtNkVNME1LZi91ay9DK2ZSc2h4ZTBWUk5GWG1pRHI3SUdTSjZrV2EzMHMxRG5BdDZKZVNUWUN0Z01pQTVpNmhOVnhBcC8yeXhHUHR6bE52MzVzZE42L0U3eDJ0WEw0MVZZeGhSeDFIWldjUzdDNjRkTEZ6TEw4cENWbzZEbjFqRUFTSXo0Q01hbVM0V3cwaWtOVjkwL1VYTFgzVDh5TkNQVEh6SUdJMjRHSEhWV0dUVmlDZWttQm1MQ1ZIMnhMK3o4QThQZnZNZi9BL1Q4VWczdEFWWWcrTis1WC83cmJmKzZDdVAzM2hOVjdXTjY3ZVFDeC9XYmVGZ1VHQ2JUR2xSVTJnY0VKc3ZCNW1TTHZJc3Y4TUltY1pvVkUya0J0M211RmtiOUFmUUZUNWdpUjRBcjBKT0prU1FhWm1IdnArcGlrTHZ6dkZuRU9NWjZYcUFjSzVLSXI3SGxrMFBTa21TUDUvRllPN2kwanZIblcvZk9aZ01oNTk3NmNhVlNuNWlXNk9wdythZm9jTlJNL1RDQlp3SWh6Z243WUJqWUU5SDVyQ1A0amxSVzd2eHZKRXIwblV4VW9CTFdhV0tYWVNQdEpBVmh5M1VHQnZVQytHSHprVTVhT2RTRlh4NFBBdmNGOW1NU0hiOWcwN0NNTDhzbWFYaEN5bjBvYTVkUnBjRnNRellvcVNMQk5wTGhYeVlrejRzbGI2SWV5K1RvRzlpYi8zMnYzMy85LzV0OThuZFNhY2QrSE42Y1FxY0pmQ1pXWkRKcE9ISlFXV3pSUThYMDZtWkZHT0RUbnV0a0IyNk5IRWpMc1QveXMvK3hXOSsvVHRmL3ZWLzgzdC84QWNieno3WEhvNCtPSzNXTFdmc3pnWWpPd0tuakM2ZUw0Sm9OS0EzenRIRVYxVERqMEp4THA5QmdDU01QRUtuN2MrdHFmWGVXd2QzdjNPMG1WUkxsOHFRSjFFa25NeTVDRCtmclVmOXE2b29jSndOaUVjaWswWEVqVVo2OCtqQVg3VGRCVW9BdCtFaW5CM0VoZzVoQjU0b01WM0hTUXQ4VVpmVElrQVpqZmllZFZaLzU3ZCsrNDFmLzVkZi8vS3ZaM1VsazlSaHBnTGZ1M243eFVkUG5saFRFM3pnMGR2ZnZmN2l5M3F1Z0NxR2FtN1phZmhCbEhWazJLbVVnY1d3NTJtZTVhZ3Z2eGtjTU1Mc21GeGw4LzdyWHdVQVI1T3hRRzhYam9LbzhMVEFaWmdGQnkrRU9DMlhSNCtFeENYTGc3cW45U3Q5UDlCa211d0Z3b044aHE2NW5nTVYvdHl0WnlLcE5OVE5lWGY2OXFQanpuRDArWmR2M3RwZEE1VnJEaWFzQ2hRSUZHSHRXQXpqUUpQYi9DQ1RLNjVkZlM1WldUOTY4dTQ3di8rYmJxdGVyR3hGSlNKT1ZKbUx0bndvTGdoMENaRFVOaXBEUmJKQXJTUEZGUjVFZ2VER1NrR2daSmFaKytMUEF1NXNCM1hjMDhEUVNYbHBBK25zdzQ1a09aY0ZzQ2gyaFZuRHdBVHpJa01vWk94RHFpUGN4V2dNTnMvZXUvUGdxNzlOS09Ub05SalRLUndZY0crYW9RcjFBZTJPbk1mN2g0ZUhCNW9vZ21CYmkxaXBWSWh5UW04MEJuRkI1dFBUWTlzMFFTVWYzMzk0OHVqZVYvN05iM3psMy95YlAvNk5YLy9xdi81WHIvNnJmL0cxMy9xMzk3Nzk3YmdzeHhOSk5oMEw2ajNxTWYrU2p5Nmc0QUhRQUJSOFJsd2NabDBUSk50ZEhIL25uVC85NTE4SlJJa3FUMitsWGhpT2RWdVBwYVc0RTQyYWkzbDNFZXN1SWxEaG95RG0wRXZkNmY0TnhBQXRHdmpSR1QwT3Q1RDV1ZWZQWk5kZDU0V1VLbXRDako4dlR0OTQ2N2YrM3QvL1gvOXZ2L2JPNy85T1FZN1dxL1Z5S1QrMmlEZkxxbkhwNnVWWHYvcjF5WVFtcTh6OTJiQS9lUEZMUDBKT0hucUJqV3pJaGNQaENBUHRRWGk2SGVZTEUrazMzS0JQR0pBb3ExcXZVeCtlSHNZRkFSb0VmSWJ1SDhGVU1vV0h3ekUwb040aVhZaWhDZlJKSTJrNkZrNE1IUnpuWURDSi9qaTJtODlrVE5lTkJyTlBQdi9Nai8vTi84SlRVZ3ZYQk0xdkRjd1BqdXFOUnV2MnBZMW5kbFpkMTVuYWFCKzBEVEhmRDJ2S2RPb3NpSXdubys3WjRkbkRENngyeXgxTjJxZEg1bUM0Y3VrNkowbFBFVTQxZXhxb1EvQ2hLTDZvdlloUVRvclJnT0dYdFp5K244WXAwQVpwZC9xbEVoZzAyVjVzTVVFSk4xbUV1b3RVd0lVTFM0bExrU0NoSXAyOVRHZUhVbUI1a0IzYm9lcWdSUjVZS2ZDYy9QN3dqLzdGL3hJTFNGR0RaSU9leklPNTYzclE1ZEEzb2tpcnFNQ3Aybi84aEF2OGVEeGVhN1I1UWJTOGhXbFpraXhxdWg3NFFUNnBOWnBkMDdRS2hSd1g1YXp4ZE5qdjBUMFYwM1FtMDJHalVYdjBwSDMzL2xmKzJUOS83MnV2RGxwdGJ6NkRoWWE5akRwVHdOMk4wc3ZuMEdvb09SZGQ3OCsvOXRzUGQ1UHhLeC9ma2Ztb0ZwdEgzZGtWZWJGbmNIT09Hd1NMdGgrTXlFZUowUnZhcWRrTDJBK082RlBNRHVhT0N4MFlrY1VGZGppbUxUdmVwYVJXMFNGbTNNeTB2L1V2L3VVMy84ay9LcWVTV3hzYmhpTHB1cVpyeXN6MW5oeWNOWnF0bTFzcmdwRjYvYnZ2d3NHRDAvRFpuL3hMUC9xTGY0Y1hCTmFsMUxFMG9td1EyT1l5c0UxOEVUdGsyeXlWWmFRK3YvalFLQ3gzVURINTlaMFAzdmlHREVZQkswckx1UWFDSU1BbEJSMG5WeEgwaStFTWhBMnRteml1SkVvTGRoR2RIRlpaUW82QmFWVUtCVzh4bjN2dVpybjQyWTlmalJVdWIzM3FoNDFjTHVxWXZ1UFdoK1o3KzlWYXEvUGM3dnB6bDdhZ3h3WW1TQjlWQm1WVFUxaEFSK0ZjTm56aGdDNEtLWXFtWk1zdi9PQlBhdmxjRkw0eUgyZWtqU3BQYmNRMy9nbW9CRHV3YnRwa2llRStEQ1RycEdVNmhiQi93Zy9UdTl3WGZ1NlhrTVRpdEIvL1lZVlFaQWptWldiOEw0c0pmNUNGL1Z3Y1JidFpiejZOUHhVWmdnWkxZdEFuYXRZNWVQTE4zL2hYNDlhNVI2OHg0bkk1V0VQVDkzeVVwMnJnNENwSVkrQjV6ZE5qTGFHWFNqbFIwZUVKWmZOWlVZZ2xVOGxtdlFGVlVjampPQ044R1RSQWJCZ3FSckJjTHViemVaeE5WZVZNS3YySlQ3M3krYzkvZnpHVFVCWXp1MVo3OVY5L3VmclcyMy80TC8vVkgvNS8vK1c5YjM2cmUzTHE5anYyZURTYlRPT0JkL2VOSjlYM0h2eXBIN3Ura2svQUVHU2k4eDJOMTRYb0pCSWRMSUt1Q3g4Z1FuV014Tm42YzNSTGtJdk5aNEIvc0pEb0toNGdNcWQzNW5sK09SNjduSUJaaVptMmQvZlZyMy81Ly9yZldzZVBoOE5KSnBldFZxdkpWRnFRWmRPZURjZm1sY3ZiMEpvUEhoMjg4ZWJiMElXZit1em5WRjFiMmJ2aXo5MU12aGpqYWZYcWNCaENpcm5zZDliSmJJRFloMjFURWdIL2FTcDl3cDBVV0FiOHlySXlqOFgyWC91YUlDckJQQUt2d2ZWbWlpalpua3Z6a2ZrNEV3UXlKdER3Q3EzTUVaQ2E0bUsyNnhFOVpKTUMwb1lCTmdMOWtsU2tuQlJrOHl0V2FyV3dkM1huaFZlU3hmTGN0ZWN6cnp1MTc1MDBhKzNPMWZYaTgxY3Z3YS90ak1hb00rRUFEWG1xdmVscWorL05YRlhSa3JsODdleisrYU83L1ViZE1OSWlMUlQrUFlGNmdjQzRQRHlFRlg2UUZHSTRiRy9ZTThzVHNEaFlLV3o3VXJ1ejFQQkk1Q1dZTGplb25MQVBsNTlRdDdPaXd4TlExcWNaMkhIc2kzTFJXZGxPeXNMNS92bWR0OC91djMxKzU3M1gvdjF2Uk53cGVJQWtDWW9xZGJwOVVaU2dCaVZGQ2wvckJTOG5xWXFLSWkvaTNLWExWd1ZKZ01sUEpMU1V0SWpQSFZFMnpoc2RRUlI2Zy9IVXRHUlZjUndIM3RWa09pMFdTaUE1NVZJeG1hS0gzVHpIREh3SEd0aHpIVmtXVlUzLzJFc3ZkMDVQcE1oOC85MzM5MS83MXRrYmI1eDg0eHQvOUwvOHcyLy9pLytQYy9jTjkveURQL2MzZmtHTWlSV0psK09jSDQxWWtVVjdOaCs2MU82eEczVWp2RXNYV3JCSnQ4Q2gyZDFaQkRaSEZ6bDNhRytJRVcxcWJlaEtVb1preDhabnRmL3hiLzN5QjcvM0h4UTRFTFFTS25oNVZCUUFxdWhvT0s2c1Z2S0Y3TVNjRm9xRit3OGZUeWJtOXRiNmxkM0thckg0MWpkZS9hTXYvK3VIYjcxbUdJbHNlWld1bExJK1phTkVZWWxxakJUOXNJRUlkMTVzaHJuRHJHenNsMktBQVVTa3NMTDU5amQrajZORk42Qkc2Wm9odkg5b0RXREluZEdxRy9CMm9GQ2c5ZUZRZ2FjWjhLQUFTdURiY1FTZUIvUm4zb3dUNHRaMHV2Q2M3Vkx4eXFYMWpzZlBKSlVYeGNMV3BiMlhQcFhkMkpyYjVzdzJoMU4zdjlvOGFUVFhjcGtYTHUvQm54bVpKbWtMZ3RLSENobnV3V0F5NnJlYUNveEtsT3ZYenZ3Z2txOXNjUFFHRVdSa3pXTmNKWXlpRmF6Vk1melE4V2daU1FITEVEYWVNckhBTG9heVBCSHVTK1Nxc2tBSFh4d1pSaWhPeWFFY1V2SkZjVThEeS92aE51dCsya1o2cU5UaEVYTHo2UEZiYnp6NTJ1K01qdTcyVHA2TUdtZncrRkFNejhkczJ3a0N1RUcrNDlpeW9oQ1RwSmZXUmxMWlRNSlFlcDJlcUtrQTdtUTZTcWVTd0hFUTRXVko3QStHV2lMVDdmWGgxVUVOK1RNUFRGZFJ3Tzg1a0tKNFhKUmxhVHdhUVhBeW1Sd1hqN1diVGRDazBXaUtYV2RueDdGb1RKU1Y2emR1N083dWVhNnZnQm9wY2lGRFR1TmYrQ3MvZDJWalE4OW9jS1ZHUWFUbkw3b2dtRVJuRjliSW1qeXU4Wk9wWXc3bTB4RS9ITUN0cHBkT3N0bkM0L2J3QmNlOEpOTXJVamxWbkV6dDEvKzNmLzhQZitrWE9YZGFMaFdxdFVhaFdJVHhUaVFNREpsak8xQ2ovWFlMZENDYlNUbndBQmFSU2k2TlU4MGhuZGJreFJlZWYvdTk5NGVkOXAxdmZ1M3V0NyttYVdweGM0Y041MFZYTDMrLzUyZTVsdzNIY2dmQ1VrSFJPQzBUYUhsVEFWTDB6aC8vUjBtVWNXcllSZ3dWWFg1QjE4UmlHQTU2UVRLdEdrSVhTWEFBUmtzVGhQVmNhdWpPb05vVlFiQkEzQmNMS1I3SGtLMFhjOVd6L2J5cWVIcVpKZzZnaUxpWVhkdTgvUEhQRkRZdnVmYlltVTRjeHp0dTlVNEIrbnptcFdkdUFCMzk4UmpBUW9Rd3pBS3FCa3N5SEkyVFJpcFpLUHVCYy9MNHp1cjZIcnd2d2hQc3paSStVRTZXUWkxQ1Bka3ZhemVMZkRRZ0lieUlSWHZ4ODk5L2U1K2wwYkg0K3lpVVdXQWl3LzdwaDRTU2lkY3lJenNYeFVQQlkyZWtrbGx4UHIySGFOcHB2UCsxcjQ1UDc4MWNKNWZMVE1kMnM5VklaOU1Kd3pnNVBnR3J5NlRUN0hKRVZGSFZkQ28xR0F3eEdJNWpBWDZLTEhzdTNlVW9sY3IxV3MyMHJYUTJDNDBDMUU0bTAxNS9hTnJPN3ZZbVZPZDRhbm11dmJwV1djeHArV2JUQkFIaGg2TmhMcHRPWlJMVHNhbW9DdXhHTkRxejdWa3FsWDM4NUhCdHRUU1pqUGhZdk5GcWdraFhLdXMvOUpOLzRkb3oxN3F3cTFsOUdFUkg0Qk9UY2VlODlmNDN2dFg0NEU3endkMVJiK0NhRStnMmFpREg2OGxVWVdOajQvSmU4ZWJ0bEt6L3RjKzlOSTNHejZianIzN2xLOS84ZC8vTzZmY3FsY0owTXMzbTBvc0lWNisxVXVuMGJNYmVRU21MWUd0OG5IZlp5aSs3dTV2amlkbnZkQjgrM2kvbFVpdVZjb1FYL3VQdi9BSGRDMEo3NEI2STBxVVhYdjZ6di9oZktMa0NCbys2bWcwN3JETWJ4WEJyR1pDd2xBczJUc3NrQkJvN2xwdDlCNTc3TC83dTN4N3NQL1FDaUorTlRhaDJPS2xBTnV3c1BIUjhTend0a3dOV1F5WTNGb0gvZW5tdC9NRnByVDAyZVI1K3hRSzJHTTZySWZFdjdLN215c1hDRjMvQkxhM1JuUnFja3JFTjJEancrNU9IZDk3K3ltOGR2dmVtTlI3N2dTOXkwVXRycTVYeXlxUFRzNU5xamE2eTBTRVUyRUhrUFVpQ0lDc3lTbG05ZFBOSC84YXY2cXRyYzZnQzJCeVdOMlF5RkppNElCQ1ZaNUJjN2dvUnlacStSSENZL045Lys0Qit3N0RFS2UzK0U0SDE4VEpDT2NoQ2txeUZOM1BaaDZXUVVvZTZtTmZ1ZjNEL203OFB4NUdueVVkV1BxVkg0MmlBWGpzL25aam10YXRYRHZZUFhSck9LSXk0cml0UUUvbHN2amZzSnhOSklINXRiV1gvNEFod3oyYlN0WHI5MHVWZHgzTEFXeFJaZWZ2ZGQxOTU1Y1d6MDA2MzAxNWRXNTNQWjVQeGFIVnRBd0tnYVdBMW51TzZ3OEZ3TXJIZ1JHWlNDWEJUVlZhOW1aOU1hS0lxNnBvMkhKaHNjWFQrNFlQSDVJTE5nNnZYYi83aXIveHFjYlU4Y0x4bXpPMUh4UWR2M2ZuMmIzNzUzcmUrTm1nMkE5ZWlpM0o4ZkxWU2djSkQwUzg4Zi91OTl6OFlEQ0VSUG53TWRNR2YvN0VmdVhUcjFzUFQwMi84L2g5V3NxbDVaS0ZCSjJ2MHh2ZEJmeWpCZ29oS3Z6OHNGZlBkYmhkaTZYcXdRanhjRjNOc1NkdzhEaEZRTmRPeFU3SUFVMkNrMDcvN2gxL3ptRE1ENmFMTDFKSEkzZ3N2L3RWZis1OER5QnJOL3duSGx0SkRwVU9CS1QrazA2UW8rcUVCRDhGOWdZOXdpMzVBQXBvblIvL2tiLzlsbFJlZ05WemJBdGF4SzRDMW5RZW9MamNQUU9qaFRYTHMwVlpnSGJ3ZG11WDdidXpjYXd3ZVY1c0NGdzhXdE9ZTTVQYkY3VFVZdVdkLzhDZUVuVnUrbXZKbDlRSjFCSmdZMklRL2I1OGR2Zm43Lys3aGExOGI5enIrYkJibll1dWxJdmpjY2ExKzF1NlFiZm13bm5RZGlvdEdCWjVMcHRQWnRlMHYvZVcvVWJoeTNVY0RGM1JUajVyR1dvK0dJQ1hFTE4xWStraWdEbGhHV1dDSGdNejhNZzRLVTZnejZIZ1dZVlVOUDlTTHlNLzZrR1doVFNMNDlNc09JdnhIckU3cjhSdXZqczRQSG4zcjFaUHZmazJjV3pQSEhJMEdseS90Q0lIWEg0NWlIR2RPSm9tMEFhM1E3ZlFkeDAybWRNZDJVZE90elZYVG5JTEpBSy9RWjV0Ykd3L3ZQd0lkbjA0bjJXd1c4dDVzdGVPQzZET0tLZkFDT0V3Nm1lcDAya1pDTCtZTE5oUVUrSkJ0eDZHUDRqekdiRFFjZ1NlVVMvbG12VGtlUXhaTVdSSGJyUzRxREFFckZvdDhoSHZ0dGRlaElLRnUvOW92L3ZMdXBZM21hSEppdXQ5ODladi84SmYvOXUvL28vL3ArTTdiMW1pMG1KTmxUeVlOVlZZeTZlUmtPbGxiVzA5bjByNExxMDQzWU9oT0VzYkE5MzduZDM3MytPSERtOWN1bzhMUktDOUppbW01Mjl0cko4Zm5nUjhVU3prd3UzNS9rTXZuUnFNeEROMzVlUjN5REdrYkQ2ZUhSOGN3S3FWY0Jqb01wWUsvdVM2OVJBaytTUWhaZlBYcU5WRVNObS9jQm9KWTUrTkRuSjZGOEtKWE9EYkxuK1V2SmRBZjIwdHhmRUljR01tTU0vUE83NzREVGtoaXo2UUtkQWIwQmhZU0hKMDlpemNITHVsWkRkZ1pFcExZYVhlMFY4aGtrNGxHZnhTblZ5VDROa2hZRko0NjV3eTd3YVNsbHk5RlpJVVJhem9Sd3lhZEg2ejAwdk1mZitaVFg5UXkyV0czNlZwbWJ6U3VOVnVHcG0ydnJrUHJXN2E5ckJ6eEx3SWRLa1hybmpuVDZzUDdwY3BtSWw5QUlpTVRyRVI4MFljeTB6Vm1vbTEvTXBEOElCOTkwUVpjMVYraXh0UFI3RXlzYzlGb0dBNGlWcFRFeW1SbGg0RTFoTUdkSFFNcGhDTm1ObHYvNk8vODlYdXZ2OXF2SHFaa1d1akI4N3grdDZ2cEtsdzZiejdYREdNTXVzYkZmTS9oSExmV2JBTVJVSTdvNUtrNUFXblhOUVZhWmdTRXhmaEdyUTVQRkdjeFFkaHRHL2FmZ2lnQ3Q0b2s5ZHB0c0NEWTBYYW5nd3FBbDUrZG5lVnkrY0Znbk0zbFp1enFDWFNyb2dnWXByZ29ZcFJNeTRGR0FjcUJHRWpGd2NHaGFRNXp1WUtxYXBxaC9zUlAvcGxXcS9GMy84OS83K3RmK1ozLzhQLyt4NE5HbmVsUTZnNE1zS0lvMlZ5K1ZDeVhWMHBRaE9tVWNmbnFaZGZ4eXF2clVOVzZxcVRUbVhLNUhNejhmRDVMejBFd21XdDFldGV2N0Q1NWZGQmVxVUMvR1pvOEdBeWd3eWxvTWdSeU1wNG0weW13SFVHVzRKbEFIcUFDSkZXUlpLVlpiMW1PL2R6dFc1RE16YzF0eUh3bWswMm4wL2ZmZnVPbHozNEIvVDEzcGhnZWp1Z1p3WndOQ1l2QUd0QldHS2NvRFJVQ2JUMzlvUThDbXJleWVlbkJlMjh1cGxPUEtYWFNsRkQ3Qkc1YWhXWkJTcDEzYUVWVVZtaU1mQmlNWUhNOFNjdlNkcVhVSEEzSUFNM3BnbXcrbSs3MHVxUHVjUHY3ZnNTdFA0a2JXVFk3a0t3UVRnUkpBdTd4SFZmazlTczNiMy8yaC9JN2U2NXJUNGJncE9OV3Q2MUswa3FwQkZOTTY1eXg2dUZBL1Byek9jMlZOeWN6MjBwa3NrYTJnRVFVeU5xSEhLSFdwUmhENmtkK1B4TElQMkIxZ0hiLzJ4ZHVPMm1Jc0dISUVaWkJuL0RDRDFJcDA3SWUrQUxLWjZQaDhQelk2VFh2dlBwSEQ3NysrKzY0ZzhIeUhMb2dDeFE2TnF6OEFnTjVBRXBheWtLemdxaElrcHhKNVk4T2ptS0FNOVEweDZNL2RGMkhVcGNWbFY3Nlp0cUZRblk4bkNTU2hpZ0M0WFM1QUpJaml1S1VXTHNBODJvWTJtQTBTU1JTcnVOb21nN29IQnlkSUFQMm9wQktPUWZMVzJ1MDZYN05IRFJZU0VKYjZvWnBtaEFNdEJWOGxPYjl3V01UeE1Pam8xYys5YkZucmwvNXIvL3JYL3ZndlhmZFFRYzJBc2FiZ3hIbmVCbEJrVmRYMXRLcFhMYVE3ZmVHaFh3YVlpbklmTDNSYUxaN1FSREpaOUlyNVpJb2NVSmtrVXFuSmhERThkaWR3ZDhvd2Q1c2IyL0Z1V2hDbDQrT3p5emJoWjJ4YlFzMVJRTVZtQ3A2NlZKMGRhVU1mYy9Ib3JLbXM1ZlFPemkzNTRGT3U0VmlQcFhRVTZuTXpXZHV4Z1d1WENpMG5qeDQ1NDkrWjdoLzcveUR0MDE2VktKVmZYaDNiazNqQ3o4eWM3bTRHS04xa0RCU0lTUkNUY2hVRnczaVJ3T1Nvb0lvbHZhdVAzanJ0WVZuQTk0QUx0TFJiMEFtc2J4RnhBTVZGQ1dtK2Frb0dGNmZGaW1JRFUxVGpFWjIxeXY5c1NrTGZFcUJjeVFOSmhOWUEydlVtamJhUmlyQjZ4bUNIc2tRZEd3NEY0WXFoWVNZRUMrdWI5LzYxQmN1dmZ4cG1OZEJ1ejRaalVCbFFaOEt1VHg2RHdGQURxc01zZkdoNUUxejNPdGw4bVVqUTRJVU5pYlUyc3NZNFpJMW1zbkQweEFtaHlmbnZ2Qnpmd3RiMUNITHlsQnRLQmVrbktVZ3NFTG9FSHdqUUNqNElIcnduVzkvOTk5L3VmM3c3dG05dCsxK1ErWURVWkFTTENBSCtUQnhUcFpCZVhsVjRNR1ZQZDhYbGJnaUtyMGVwTG1oSjlLVDZSaWdBMjJGTm9UdVRrQWFrZ25RRGw0QUlPT0lBM1FZRDhnMmVEQVFEMFVQK01FTmpmRnNhaGJWa2RaOUp2SVE0d3dnMnREQk1OZnk0bG9oZlhUZUFZWm1mZ0NKT2ordlFrTzMyajNkMEQxd2U0dGUyOTRiakhyOWdXVTd0NSs3R3RqT2wvL3RiMmZTaVN1NzI2b2k1M0paSUJqY09wUExyYTF0UmZtNG9vaHdIbHpQQmZuRzJNTmRsaVZ4Ylgxak9yRSsrZWxQZi9EQkhUalorNGNudWVJS0YrVmg5VkUxdW1jWjQxVVZxSWlpQ2J3Z1ZtdjFCSUF2UzVCcFVaYUhVMnZPYzRxcW03YnR6ZWJaWEJiZTlQMzdEMENieThWOEZGN3ZlWDNRRyt6c2JGVTJ0czVPRGpOSkErUEJ4eUtUNFFCV3NWT3YrYVB1MloyM2cyNnRlZmlvK2VETzBadmY3RDY1SnlwcURPRHR0dVJrbHNZdEhFRWE0dkFYWDZINm90SEZSNGNPTWxLSGIzNlRBRWxxblNnTjNRRWluQUx3VWN0MTBZYzhLZHFBcHZqSGVmalFPSnk5SzgyNXRBYkVqNGpTZUM1c0dqSWUzNzluSkl4eDY0elgwMkl5eFZ4ckZNbmNhem85d1N0Z1o4ZjRhYW5NNWVjL2R1djd2cVRsaW9OT2N6em9qU2RqZXBsOUlqR2JlVVRvV1pWeGpBTTlNSjNVangvcXVwRmRXV2UxWkMzQmZvWllpQ09kaWFJZkNlem81VC9CL2VjSjdxd3lkQ1FPWkFYUW9ZaVFLYUppNlFmL2pMMHR1RVgwai8vNVA5dC80NnVBY1NLUm5BeEgwTDhyNVlMajBwdTJBSE5ZYTU2TGdacERFNEQ5S1pxOHM3V2VWdUtsbkpGTVpLSGZEZzhQd1dMY21iZXhzUVk1NXJpbzQ4NVVzR05GUmNmTmcwQVE0NjdyaTdJNDgzM1FDWEI2VUJreW1nSjBLRkc2eVhqQ0M3eXNTS2hrbzltRXBDaXFERTN2dUE0VWY3c0J0M0JDRjY2aTlOZ2xGQmJNaEtIcnczNTNwVmlvVjJ2K2ZERUY5NTdQUlVGOGZIRGNBSGt3TFFnWUxIaC9NQUNVcVh0aWNib1d3TVdqOUhKc2tDS2gzcWlYVmdxcHRENmRqUFdFYmxubTVhdVh4c1BCL3BNREtIS2dZMjkzRDV4QUV1TndUbUNYVWFYcDFKN0NGTnN1akZrNmxiYW0xcFdkamZmZWZuOGVqYVV6bWNsb0RFc0ZjQVUrc1dSRFY4NU9xZ2xEaDltRHNGWHJMY013aXNYMDJjbkpxTjFPcFJKZ0x6RDI4QmNzeTBHQjFtU2N5ZVlndk8xbXk1cE1ZTitLdWZUak43NzErTFd2UFh6dDFjMmJ6NGxhaXRwQjQ0aWVvRjgyN214ODZVT0JpMGFLYTFzSFQrNDduUlpxQWJWT1k4MHU5WlB6U3NDSWdlTGpkQkxQVy9RT0hBeEhqQll6aUVaUmwvRjBzbDJwMUlaRG45NE9TQWdCR2V2MWU0L3UzNy85cVIrRS9VUnBzQmNvaGVsNEJpdjhMMUZLYkJ2cHZLS3NYMzNtOXZmL2NISHYyblRZRzdTYWNPU2dBV0ZiZlpwRGhRclIxVjdvZHdFRElXalpZaGtDd1JxRlhWUjAyQnI4RU9laVV6RGtFb0xaR1plU1FYTm1mam5NSDJhbkhOUWpGK0dpbkxDMzBEVjhKUGJ0My9oZk8vdnZnL051YnEwZlBINHlEMmdSWjl1eXdFN0FQdUMrNFpTU0xOSExSWW1aRStHRE1VcElVVkhWNFdjT3V4MW5SbGU3UlY3QUVJNkhZNWdBZEhTTUY0ZkRvYWJKTkdXZFBUc3pud2NneDlsc2p0blNDUEtnOE9Gb2pKb0Q5K2dMOENXRTBYaEtaaVRPYTRhR1RpK1dWcUV0Y1dvdm1DVVRCdlE2SE5uS2F0bXlMVEQ3THJqaXlHeDF1ekZCU0doYU5wT0JPUFg3ZmJBbThoYWlZRW9KS0Mrb1d4QURjRzZZSUNpU2xWSWVYR0xZSDJPUWNTNDBFUDB3QzJiMTg4YURSL3VGWEE0S3FWRE1BT2l2di9ZYXlGVStuOGZ3NE5TS3BLU3pPU0FCdnJJb1NhUFJCTHhjMTlVaDZIZzZEYW1HNGNwa1VwQXFtSVdEQjQ5Z0RHZnpSYjNScXF5dnpHWUIzVThRb1UxbmtpRE5lWHFsQnlnR3ltdzJPK3ZaVkRHZnJWZnIwQWpwVEJaT0JleFNQQlpwdDlxMFRKTGpqdHV0VkZMN3pyLzdqWlh5U2x6VncrY25HRUxZYURPTnlJYVdITi9WU3pmZi9mcnZSa0NoaU5NQUVKUVRnZFE3cy94b0RsaGcyakFzMjJSYWtOZ3NVdDNBbjFqbVRuRmxPRFZwZmVFQXJpMDNtcGlCSDFVa3JyRi9ONWNxY0txMm9CZjkwUm5wYklRcVlKOEtDVkdKYlhSeUxNN25WemVlL2N3UGJEenp2T2ZhdlViVnMyMUFIa1llU0dDc2dwdGFFM2ZVOWkyclVOa1VOQTBIUTFxb0RGWTZBemRWbmlWY3RKRmhtTnBOVThSKzdwY3BIV2dPcFlEeWhKbkNRaWlGYWtWbkk3Zy8rdnEzdi9iLys2ZTdsL1pjSitpMm1zTkJPeHFqTlhlZ1dnQkd1cnVKbmwwc3lLK1VSRFFmUkFXSm9OVHRvWmxLSktmRFFWS0twZk9yZCs3ZFgxa3B6ajFmMUZTb2VRZ004T280VnI1UVBEZzRra1FobXdIYm1XS2tvWGRSR21nNk5sZFdnRnFuMStuUWxVUkY3M1o3am1uTkFwL3VVNDdHUUN4a3cwanFyak5MSkF6WGNWRUhkQmJOaXhlcE1tQTdnQmNBUFJwTlliaXZYZDZsTlVkblhpYWQ0bUpFMk9GTXgwVUptaFoyZER3eG9lYW5JMGlnQm9oYnBsbXBsQUZRMkJaRDAxd1BwU1hobzkrNWN4Y3NhblcxakE1U0ZSVU9LTmkva2NvbWtoa29iRldIVktNSGZIczYxUTNWdGx3dXRyaDZkWE13bUtEekliUXp6MDZtRW1qeTZrb08vQ3BiS3JlcTFkWFZDazFZY0dmd0hsTzZETi9kQVluMjUyZ0ZqTis0UHp3K09vYks5S09SemUwTlRaVUxoWnkwQ0dhTHlHalFoNlhnaFhnc3hsbkRYdlhlTzV4cjlnOGZtcDFXY1gxOUFabUMxZ3FIRkFFYWhkQ0Izd1g2aFRlU0IyOTlHNXdkb0NFV0FWQ1E4ME4wbmxEQmxnaFdqQVMwakd0YlhtUUJnUStZT29mMjdvNkdxN21jNjNzVG1QVDVncTZ3emJ6cS9zUCsrWWt3ZDdQcnV4RlpKV0N4TStNdnhOcXlIaXorRkxNNGFhcFF1djd4ejE1NjRST3pSZEN0bjhHSklaK05aQS9haHB1QVFRN2FFZGZObE5maXVvSGpRc2xCVVF6eEZFZU0wcWxzeE1NVSt1YSs4TE8vUkNlOWtBZWsvWW5BK29YeWt1R3h2SC8xOS84ckxoWWtFeGtmMU0wZVlieGxUZkVzRDlTaTFXcWwwcG5SYUpETDV0Qk5xcW9BbElDQ3FxcStDNlVBcys2MXUyTjdqdUhqazZtc1k3dXlycEN2c0NCR0dITDNURHJUYnJWY3k3cHg0enJnQytjU0JEMXNFQXdzZEE5NkJLcTdVQ2cwbXkyb1pIQ1BoQTcrbVVUVkZjQVRGTGxhUzZaQkhGSlFaMUM2L1c0L25VMkRUZXFxQ2xNQXN1UUhNM0I5TkFyZUJVZ1hUVVdqTjIxRU5IYlZCTTNLWlBQdFRoLzlxeXVTcHFsb0MxeEdNQzFhN1hacWdsYmlHOUtSVEtYWWJQVkVwd09ta1R3N1BZZFArZWFiYiszczdqeTgveUNiU1ZWVzh0WHpocXhvQndlUFljMVFRN2lxVjY1ZGhwQVhTM21vcm5hN1V5eG1JY20yN2ZiN0k3akZtVnlLVExpcVFxOVhWZ3FvTmhTNW5raUJMa05jQzluTVlEaEVxenZkUGhEUTZyUjBXZktDeUxqVjRlYXhLUWlBb2hXeldjZjNEL1lQcjF6YUhRNUd4WEo1TWg3NTArRzlyLy94K2QxM1o2TmV2cGlQd0FLandiUUFFME1idzBKbFkvZnM3R2phcU1Jd0loV0tCZzFISjlEd2hISVJnVVVVVkUxVFJDR0FIZzhDVVpZazhpUXBSM3M0eVNXUzlMQ2Z4NTdRamtSZzNWM0hVNkVndkZsdTd3WlNDSHNoeE9pY3k1T0hnVTdCem9GQStoYTBQcDI5OHVJclYxLytUQ3dlSHpTcUhPd0ZleHNoOHBxbUNSV1NMbStsSzZ2aHMwZE1iRkVjRlVuYlZESmFSZDlob2VGNXVDLytsVittVEdGQ21QWmhvSXc0Q20wbEFzM0YvdkNmL2ROeDQ4RHluSHd1MzJ2WDZLMUJJaWoxSExvQjV3UFdnU0pBem5GdGROTmcwRWZGTVhiUUM2WmxSNko4ZnpDYVIzalRodFBwMm80WFJEbWk1dXlSTFhCdW5HNUdWK0tUQUJNMExWb3hHQXpSWlpsc2hvL0ZSK01oVFBsMFlnSUtkSEVnRm0wMjZxZ2VDRCtVR1JSL05wc09KM0FmSDUxd0hDK0tjVkFVY01lWjU4TFJoR01BWGdRSnBKZmIwU3Z5ZUVoR1FrZmRmRGpIb0U3d2d6VmRCWWdoMm1EMWRPTjhEazhTSHVkVVZSVFFLUGE4RzFRcUowdnlvMGNQYVQ1UEpDYlMzU0d4c2xycDl3WWdUaWhOMWZUTnpSV0lIOGRIWWJWUUU4aS9xcWtZelVGLzVEcDJ2enNBS0dINVUya2p5Z3VIeCtmRDhUU1ZMYURDN3RUcWRmdUtvUURaNkhoNkViRTNndzN3WEJkMVNNSjdzMjNZYnZDVytjelBKQk93UDZXVmNvd0RucnloYlRlN2c5M2RUWHZtZ0RFaWZ6cVhCYzJUUUtFa3FkT0JKakljZEdMdCtLM2YvZTNCazN1bjczOTMrK2F6THBqeGVNUXBHbzF5TkxaNzQ0VzN2djJIdm1sQm1jUGV6aGkzZ2I0bEhCRVNJbkNySUkybGZLYlc2YXBRUnA0RmpRYm1pYzZCSGhwWnRpSXJJTERvUU1yUEx1MnI2UlNzVlBuNnMrelJEWVlvL0pOOFVSUy93RDBENUljQmlVaWh4SGxFTlJJN3o3MTg3UlBmTCt2R3ROOEZSSkFmeEdvd0h1cngyTnFsNnpFRjJFTmdra09JSi8xTWJnb0RPcDJHcWsrLytPZStTSzRxU1JxRnNBN2ZFM0FVbWt1WFkrVlkvRC8rby84aEd2TjBKY0ZIWnJSY1J4UndGNkFHZ0FVQUZKVFVweG1PUE9namNLeXBPcnhWUUJhbkJoQ1JDZndHQk5seFBDT2haSE5aSUM5WEtHSkV3YTFCR0pBQmpMUGRiZXU2UHAyYWQrL2VOUkpKZUordUIyR21hNGpybSt0UW9yQWhBczJyb1lCMndKV1JaU25MZUxEdis4QXhDaHdOeHhndEtDY2NDSlpGMHhsby9DQVgzT2xKOWZ5c2JzaUNncm9JSE5oL1NsZDBXWUFURGRkVjBYVUlHM3JEY3gwamtZRDUzdHZaZ3R0RWwwM2dGcytqWUJUd1ZxSEQwRFd3K0wxdUYzV0FCRDU2OFBqYTFhdWNBQU9DN29DckFpRDUwOUUweHZIMWVyVllLa2lTQWdFRDU1dE16RlE2bWM2a29jN0JkR09SeGJ2dnZnOUNVaTVtd1VjRUxqcnE5RWlKcXBwbjJaMUdCK2Z0TmR1dTZ3S09xcUVNdW9OMnV3dVF6ZjJBN2xJRi9uZ3d5R1NTcmU1QVZpVUJUZlVnSFI2a05GL0lOUnB0ZEhpajBjeXgyeEVFaHNWQzVPUERRUytsaUVmdmZYZi85VmZQM3ZxV3JpbUpsVTM0QlhSSnBMRDI0RHRmaGJORjR4NERqbWMwL2dRTXdnajZIUDJwQ1Z3Nm9VRnp2M0p0YzcvV25rV2ljVnJxM2tjKzluNFJqRThjNUF0d2d0M3lSa05KejVaMmRzVkVrcVlmc1ZJSTV1UytJbERaT0JkS1poc2hGa05Wald3TTk0c0lqT3o2OVdkdmZ1cEwrWTF0MjU3NjlnU1NkM2I0S0MzSjVldlBoK0lSbHN3T3B2QjBoakQ5aElVRDdsOWczSjBRVDd2cGRMVDVZYUFFMkR3WWlOTjNQbmp5NXF1eWJHQkkrSGdVV2hKNlRwSkprYUE4NUxQTUtRQ0ZldnZzcGdVTTNXZzA4dUNXQm9GdHdaM2xwNlpKSzgzeXNJbHlaVzBWblpzcjVNOU9UbUdrVUFJeW9LTjgrQ1RSQ0xRbS9ISlFkcVFSQ3pMdGREb2RGK25xSklnN0RHbTcxVEV0TTUxT3dpMGpqVEtmUWVzUUNHQnFkRDFncnlBbGZpOUpaK2Zucmh1NHJtL2JqalcxVkxySVJTNE9QQW9RNGx3K1Vjd205WVF4c1p6eHhCWmthVFFjZ1Q2QnVrekh3MlJDUXprY3V5NUVVMThXb0dFeEFEcWZUOGNpc1ZxMU5wMU93RHplZWZNZFhUYzZiV0NMcjVMdlNMZEZOVlY1K1BoZzJoODJHK0F6YWphVEFPem9GdGhpa1VpbXVEaXZHL0E5MmdlUG52Q3lBZysxV01pWk1GTHRQZ3dtMUhPdlAyaWMxdmo1SE9nRmRIZ3YwQk9hNS91TmVnTkdFdG9YNWNOWjFIVGwrS3hxV1dZK25UdzdPZ053SFgrbWFHcXhYRGsvcTJHVWVVRWNEWWNnWU5EQlFDVDRiNzZZVXd4dDFPK0Rxc21SeU01bTRkNDN2cG9wNUFmdGhqL3VybFpXUVN1cjkrNHd3MHZjSFFFMk0wUURVaURMRVQ2K2tVMmY5d2Q1VGRuT0c0UFJaQUxPeVhFaXZWTjdNYkZwckFWUmd1QkRZa2pEY3JISGIzL3J4c3ZmRDg3S1VBZ1kwK1VUQmxJR09IempGLzhoVk9rWVNnWW1rVWdmUWo2NFZEeS90blhqazUvYnZ2V3lwR3B6MTZrZlA5bTkrWHc4U1JlZ1FvSDVNSVJWcHJPRXBkSXB1Qy84L0M4VDBObSs1Y2srREdFZDZJSE9lRFQyMnBlL2JKc2RTWWdidW9RUnhhaUlFaGt5WGFmM2trZGdVeUVFdEFaVklDa3FYWTdVRk9pWVlpbVh5YVhSVFZEWTRCS3hXQVI5QVEzbldQYmpSNCtndEVEUUFVcWdpby9Ia1o4ZUpvaEVnRlF5R2ZRNmFLL1RJUVFzZ3NobzJEczVPc0pacDVhenZyYUdscUJZWkVhZmd2RFl0ZzBBd1NtRWVnWkM0RnpDRUd1NlFmZThpQmZDRGtmQW9ITEZIRnpxMFdoWVhsc1pUNmVaZEpKTlNsazhPYXJsQy9RZTZ1RmdBRzZXem1iQVcvRFg3WFJBZGtlRHdYeE9HaDNrUHBmUHdtM3Q5NGNJR05UdHpaM0c2YW1TMExkM2RtM0hCWE03UGoxSHpwZGVmT0grKzNkdlBYZHJiVzFsYXRIc2huYTdmZVA2RldEOTVQUk0wOW43WVVCYUlFdzhWUFVjeFhacmpRREVEKzUrSmcyWElKT2daM0N6K1d3RVFzYjhqTGdpUi8xRklwV0NtbWpWbTFFdUtzWTRzQWhGMVFMSGl3cWlrVFNpWEp3ZXdRVlNGeEZJTDlxMnNsSkNSMEdYWUNqcnRUcHNFYWlrUTVmSmVaUTVHbzlOMDJrZFBuNzQydGZOMXZuUk85L3gyczI5M1MwTUFlZ2ZLUyttZ1FnS0RPNUFQOUFveHVPeUpIeHdkSDVybzNSbEJiMlZPRzMyN0prUHB5ak94V3dvSkxwY0FjVERjUVZUdFp6cE5KSEs1TGIyWUREcEh1UlRwRkdwRi85UEE5UFdvWmJHRi92UUJ2SXc0WW1xcWV6bU15OWNmK1h6MjlkdlMzb3lxcWpmZS94RmNjdEVJdlBZd0xIY2wzNld1SHU0ZFJIQ0dOcEgwZ1diQXlNbFJLSi84TS8vY2NLUTVvRURYK1hzN0V5VTZUSWlkRENqYnVEVkFYUXoxQlBvQjF3dXdIMDI4NUtHY1hDd2YrdTUyODE2RTdBR2E0YUFBVWF1QTRmUUFhT2xxNGU2T2h5T2dJYnBaSUxCUmdib0ZSUUhpb0srMWxSbzRnVktodjE5OHVTSlllaWlxR0N3b0wrVGhtNGtrOEF4Nkw1bDJjbGswcmJnd25Qd2RJbmU1R2d5Rm9USVNPalFxYklpcm0ydTUzSVpubzhWaXlsbzY5SFVRWFdhN1g2TUYyUmRMeFFMdmNFQWNyVzZ1bXBCelk0bkpJRTBhejBHay9MbzRSUFR0S0hnNjQyYXBnRlMzS01IVDNaM2R6THBORVFWVEF3Y3Z0Mm0xWGNYa1lDUDg3MGVPZERkd1NCWUJGQ2xxRU5nZTVQaFVCS2hUeGNQSHo0RzVvaDBRV2I2UFh3WmhnYmZ1ZGxvN3o1ek01R2xxeC93VEJjT3dVYU14NnExQmx5Rjgxb2RYVk1zbDNxam9hN3A1VXBsTkIyTGltaUJIV1Z6ZWdJcFpXYzJRNFVsV1hSZEcrTUh5UjlQeHBEMnNIOThkRzhrS3BNYXNqTHBCQkRjNmd6bUViWUVjVDRMYVpxNTNyRFhneXRzV1ZQQXRGUXM3Kzd0cE5QWmJyY0hsS05BUW4wc0JtMENKMmFqVUdpUHhoMTQySHowMmtaeGE2UFNucGlUaVFWUVFVL01hTDVOb0tpZ2lBNkVEOVovLys2N1YyNitKS1V6ak1vd1BVbzNzMGlqRTh3SWNReDNUd00yTHo0c045Z3pnejZaR3Z4R1l3SVBtOHNwOU1LMkQ4RzdET0dSeS9KWnZZblFjei93ODc5OGdmU25oMUNFOGtZWEdBT29kb3poL2ErOTJqbDhGelNtMldyMGVqMk1LTFJSS3AyQ1RvVVNwZG5SaXdYaThJdkl2c3NTckRNVVNEYWZVU1RGU0JnZzA2QVN3S2RsV216dWFBVGFCVU5vR0FhMEtVNW8yMVl1bDRVT3dybkJlc0Z6NGtKY2thU0RnNE5NSmdFQkF6MHE1d3VneTVBV2xGT3JFd0xBWjRyRklrekVZREFDVjRHK25EazJ5alF0TUcvdDRPQUltaE9kRGphbDZwb0RWZWxBVXB4K2IvenV1L2VoTDFGTm1LTmdCdWZQSGc5SG5BQUJtMnU2RnN5ODA5T3pVcmtJQnhkOUM5Q2sweW55WXIzZzdMd0tHdzJOZDM1eXNySzJta3dsZk4rRy9QVDZYY2YyUWVXYnpiWXNLZTFHTTE4cVpVRDU4M2swTUtHRGg4eFFtZTI5UzJlUEQvdWpnV1ZiaGhqZktCVWFaK2ZQdlhSYm96WGxaSGN4ZitIbEYwNU9UdUZNNndwd0RrVTRoOWxjUUVGWWRpNlZPVzgxaStYOFlEU0dObkU5ZTlEdDEycDFWVStocjBCeUJvTkJyOS9EV2ZLRkRFeWpxc2h3aStGS3czb284SFJUV3I4M0JDZkVMc2Uya3FrVVFJQmh3bDVBQ1VybzlQUjgyT3VqNXcrT2pnYjlBWFRFN2VkdndjQm1zMWxabFNHVjVKN0pCbWdiK2hBcUNaNVBJWlU4cUxkemlteDc5a3BXKzl5blA5M3B0enJETVFZVTZwL21BdmllYXFSbVByMHJDdHF6ZlhaMC9lWFB3S0FSdko0cTJQQ0g4TXhndC95aUVFckMwODJMRU9waGl1QlFCdFpsb0RSR2dGaHB5K1BDWkFwbzVnLzh3aStUQ0xCRVJDN2k1SjdTSnJBZWlkejl3ejk2KzNmL05Rd3NkSHkzMTMvK3VWdXFvV2V5MmZGZzVNL213RHFjTUhNNkJTV2dXYUxzUmlhKzIzUjFIRDdsdk4zdXdIYjdnUThiaWk0RHdVMGtqYm0vUUFUa3Z0MW9RV3lBSndDNldDejErbjNVQkpLRGtpRURtVXdHUTRMQmdPTHZEUG9iNitzd3dLQzhhR1FobDRNb1F2WkFUQzNMaGV6Q3c5TTBGVU1GbGdYWEVKQXRyNVE5bW1FV3R5M2JuTnFtYWVHTTRFdlVZVEJIdkFnVFZLdFZ3YklrV1RrNU9JYTZnYzFwVkt2UFBQTU1UQkRjWDFUR2MyY1FoaHMzYmh6djd5dlF3Nm9LQWE2VXl5aHFPSmxPUm5DTGlUK1FuMmNreXVXeU8zTW1wdVhaenVwcUJWeW91TExpZWJZL2p5UlNTZWl6WEtWOGZuUnlkSHc2SEl3a2daNTBCcDBuOTdIZno1WExnS0trS0ZwQ2F6eDZlTlpvTFRpbzluWXFhY2lxY2x5dFBuZnJwcUtyeDhkbjRPN3BaQXErVUFJOWwwazVycnV6dGVHUEowUGJnNnV3dmJuYWFzTi9UWU1tb21tdnZ2bzExQXJhRGZUU01oMk1PeCtOaWtJVXZBNk9MQ3FQNFRnK1BzMm1rK0NFcCtmbkFzZXRyYXppRkhDc1gzdjl1M0FlOW5aM01EUzZxa0VGWExwOENiMEsvZDBiamxhU2liNXRkWWFUTkMxNXdzbWk4T0t0eXlrNE1OMGgzU1dtZVdZME1VaFZrL1Jha1VYVW1ReGMxOXE2OFNLN1VQa1VoaFNXWUEwRGk1SU5DTEZMVVFaTTlxRjA0Sk9obEZMb1FIYlRpa1hRVEZZVVF6LzdBT1NVRGJGRmxQdmluL3RwVHBSaUVHL2FSNFlDdi9qR0puMUhvc2ZmZmZQOVAvaE5RNFVmd3NQbzcrenVtU1k5TGFFb0t0QURmOUx6aUNqUEYzTjBPcUN2cUxKQTZ3ak1vUUE2N1M0MEs1Zzl1RDV3RW85SHlmMlVSSmcybUU1a29ibFEwT1dTQkEzZDYvWk15d0swNGZKQ2cxcTJEZG9OZ1dFM1phR1FITEIyNkJYd3BYd3VLNG1pNDVLT2dUMEJ1VVI5d0twSG82bXNTcENyVkNwdG1sTXV5dG0ybVV3WU9BWE5hSmdGVUg0cTZHekVsM2p1WVA4Z1g4eUljWGlsc3UvVHEwK2hoRURQd2pNSzlCMFFOV3AzWVk1UWExZ25zZyt1TXhqQ2hVMDAyNjJObmExU3NYUitlaTdLRXJncVJCbzhlR3BPMFhQTlZuZGpjeE4yejdJc1ZKaVc5M2NkK0xLT2JmZmE3YlZpNmNyVnkzeVVMdmozUjlQS1N2R2Q5KzRFc2VqYWF1V1BmdjhQNzkyNTF6aXZSeVZwT0RabmpnLzNMcFBRZWJURmNYZjNOdllQais3ZGYyeU5hWTRrU0VpU3ZSelBzMDFENUdpV2poQWZqa2ZGUWg3VVN3QnprdVIydDN2NDVHQ2xYSVFGQUgyQ3VrRzdZT1ZTMHFKUmEzWUcwMEl4UC9OY2xBWVp4ckdibXhXMHQ5NW9mT3hqTDBGZk5Cb3RqTy9od1dFNlJjRnl6TysrK1JiazRlcjFhMFl5ZFY2dEpsVzFOVFpoM1R0b2lDRmx5cFZnMm5uKzlqTW4xYnBQTDZvamJEcXVEUlVCQlFNMkMzdDAvWVZYT0xndXBKaEpOVE1zUHYxR0lHaVNXbWM3V2JabFlCQ25nR0tYNlNINEtjSytLYkFZQTNyNFlmOFU4TXNWeGJubm1OblZUYnFiQTE1RTJwa0lETW5JYlBia1c5OTQ5TTNmeWFSVlFBMnVwRWx2SGJmaDlOQk1odmtDZkJFYUdxVUVuZ2U2elc1TWN2UmFJT0ErRnR2ZTJZR2ppUzZIY29LZkNEVi9mbGJEZ0xYYmZYVGNEQkNZZWZTVVBsMnlWSEdVbmtpbzRQSDlYajZmUjlmampGREpxRGtneG5IeGJEWVR6QUxiZHVudUt4OEQ0WUZybkVxbWZKcGFNQWVZZ0hkVUNYd21tYzdNZ3JsbDJ2UjhoYXFtTW1uWDgxRWd6QUxVZnpxaFFQZk81bjQ2bTRhTlZqVjR0K1FzQUl1YVNyTzBRV2JTdWN5TVpxVFJUTEx0blMxUlZtbFpqV2lVWG5WRVN6WHhPRjIvTndDTDVRUVJqSm1QeHQ1KzYxMVZTelRyRGFBcW1VaTFHKzFJRkZnM3dhUWdHN2J0aVdJY2lOR2hKQkxHUXBRaE84ZkhoMGUxcHBLQVFjZ0xzYmlzR3hIUEsyZVNVTGZyQVA1YXlUZnRVbVZGVVhCb2ZESjFhTlZTa01sNjA1c0ZWNjVjcVpTTGMvVENqREN6UUdTK3dPQndIQTk5ajJGRlgwS0RkSnV0RDk2L2g2N2YyMWlyTjl1ajBiaFVMdG5XRkNSV010THNpZXNZMmdMZEpTa1MrRDNJeC9IQlViR1VCOXZHcWJ1OWJxdlpXYW1zdE9EaTlIdjM3dDNYTmVYbGo3Mzh3UWNmQ0xFb0tINHFDWGZhNkl5R3pjNUlFUVY2OTVqQXcxTENDY2dhUnQ2UUc2UEpITTRCemE1eHdkZWdsUDJaTzI3VnN5dnJVaXI5VVdneUhVc1JTbVRZeEo2blFFZWc3V1V5UlppS1p4SDZwUmpqNzlENm9WQ1FOV0JaMkUwamtoL2F5MTI3dk52YWYxeC9mS2YrNVA3RGIzL1ZHalFXOEpLbTR5ZXZmK3Zydi81UHE0L2U4eDMzeVpQSHFnb3ZuMVlHUkJWd05EaVphOC9tY3g5RUE3UXlvUHZHTkJ0T0VzUW5CNGNySzJYUWQ5dXlvRWpnNHNCcWl4UWt1SFRKWkZwVk5iQ0ZSTW9BcEdBZlFNRUx4ZUo0Tk9uMXVzUGhFQ1E3THNCVmNzQU5RS2M0UHQ1dGQ5QVNRQWZmNE9WMFlSbHVYTENRRkJsQ09YTjlLTlMxOVRYQVBwdE5UeVlZVFJQOUMzMFBqUTc5Q2hwUUttWmRGKzBnY2cvams2K1VUQXl5TzZOSkxEUkxCMElyRm9vWnlPUXNFdTExdXJsMEFsako1SExvUFpDNnM3UHpVaUVQUFkzYVFycGdSa0N4WUJNQWJ0ajNneWNQMDFsczZpdWI2MFRQQm1QYkJETk9ycXlVYXVmVjFmVUt0VzQ4aE1RbVV4blZVQ2RUaTY2SG1OTktNVS9QT0dsS2RPYWxrb3FhaEFQUVQrVXlrazZ1Y0RxcGlZcmtCQkMvaERPMTBybHNwOU1WRmd0RmtGZlcxbUQ5T3AyMklDdW1ZNmxpUENseStmVzFNUnhzeTRUclh6MDZyVlpyeDhjbk1LT3BYR0Y3ZTZleXRUV1pUSkxKRkx3ZENJTVFGMXFOWnJsY2d1MUZTNEh5ZzRmNzFtUUVNcE9EMDVwUG95dTRPRGVhVE92MWV1RFBocU14RkVjY1dPYTU4N1BUbXpldVA3ejNZTzVCYVhocG5NL1FtcjFlTlBBbmpyK2FGTE9sdFdHbmxxSDFDS3lQMzc3KzhMVHF6Z0paa0Z3MlpSS3lPZXpVQi9YR2xZOS9QNXMrQTB3aUFLT0VUWUprbUlCQUd1WWpnYmFYZWZDOVRBdUZoSDNDSEN5UjVWZ0c4aXJ4RTBvT3Q1Sk1qd2FEbENiYTNWNnZXbTBmNzU5LzhINzkzbnZ0bzhkSkhUMHBnRjNBSlQ0NVBxZkhxR2ZCb044dkZMSnhEbDZkSDRuT2RWV2ZXZzZaS2xZZ1VLN0tDbUFFbWc2b29ZTmN5TFhqOVFjOThtaTVLQy9BS0lPWVdIQVFXNjAyNEFRaTJHZzI2VWEzNzZlVFNiQWdRMCtnaHBQSktHRm84RlpWV2U5MHU0YWh4L200Ym1pdVkrZnpSU0ZPMXhtQmU1Z2FxTTljcVJEbmhmRjREQUdEQlFmM2haekJKd05HTzUzT1pFd0VnNjVVNmpSbWptWFg2bTBjQzNtb3JKY2gzWFJ4eVRLUFFCUU9qc2FqMFpWclZ5UlpBS2RDZTN2UTRwRllwVktDYm9NUENobmUzdDBDOGtEbUlzRjg5OUxXWkdqQ2Y0WEJtZEc5NU1YNVNSMUdBMjdjc04wQmV6WlNDVW1RM252M3p1cHEwZlU4MkFQMGRpd0dKVGNiOS91NkFSK0dGam5JNTFJd2RQQVErdDB4dkNQNE44VmliZ0p1M2gvQ3NJcUd1b2lDKzNLcUpIa1l1U2g1VUpYMURjKzJHbWUxK1NLcXlIcXozWDczdlRzWUMwVUV0YVI1Q0ZFL3lDU1M4SDFCbjhiVFNmWDhQSk5Ld25zMEpMSGZhUlpMWmRRSEtzejNmRW1TZS8zQlpEeDBiUnRBbjlDRmRITTJNVmRXaXN6QUxtRFRZRURoMk1EWldBVHpacU5aTU5EcmVnUXVkU0VQOWVRSGkyYW5Kd3Z4bkNwandPSFhlWlBCYk1IeGMvL1AvWmsvOWVhakEydGlRd2RCOTBIc0Y3U3FQbi81dVk5emRObU5LQVY5RXo2ZllwVGdHMzZJMW9USitBNm5seTAzbm42STI3QkVGajdDOHNOdDlyME0zR2F4Z0Y1VTBQRkdFa3c2a1VoaGtNQUowR0hRMXlMTXZ4QlhFeHE4THBxWUNoOWYxWXhFb3RWb254d0RHV011TGtDOEFWOW9DR1NGMW9kWkJFc20yWUJ2eXZRclZQN0I0UUZHclZacjNMdDdINnlqV20xQVR4VHpCVC93d09XNzdUN29NaWdqcUFYVXFlZlRaR0JkMTlEMTBMdFFTQ3E5NUdRT2k5UnN0b3ZGQWkxZkZGMFlSZ0xlSjBSck9KcDB1eDNQQVJTbjBQeWdOT1BSRUFNSnRNQUpqZ3YwQURFc2J5YWRIWTlIcFVySmNVQlVQTGdLTzNTVkxRbFpldmVkOTJDamprN1B0cmUyNENraVEvVzhZUmdLdkRTTURWcEVVK2RuNkJWWUsxcFhFV2RodlRmM1hDZVZTRnk3ZWMweFJ5ZW5aOG1rQWVXOXNySnlmbnlNN0Z3YzFnUE16cjc5M0xOQlJFQjNnQXBCa0FKNkpVYVVycC80TTV4b05sKzBlZ05WbDZIMWxSaDNjbFk5T0R4NjVaVlBUMGRqZU9GQXRtT2FtV0krb1dtME9LbHRnMXd4aDhTN2YvOVJPWnNDcFRRUzZ2NytJU3FIMGJsKzZ3Ym9INlJSVDJxRlF1N281R1JzV2pUWk14S2hWd2tJb2oxaHI5NmJ6MXUxNm5BOFNTWFRoNGNIRG54WTI0WUFnOWc4ZWJ3dngyTFZWaHZjOFBUc1BHdWt4cE1KYkZva3huVUhnOVgxRmRqZVZyY25jTHlXMEcxUVVzK0Q4WUV6RTQ5eEU5c3NHNUtlS2d5NzlZU2ViUFlIYWp6eXdtYys5ZFd2dlVGM01hSVlSYUtjOE1VRXlTaGZ1VFluTkJMYzZYZXB2Yi8zZzY5bEpFd0J1Q25DdERodC9oOEVDQURVUWlnSkgyYmpucmw2dmJpMmR2em9VRXRyY0l5Z3BESEdrRmNVWitncWNrL05NUncxbm8vS0FnZFZ4NHR4bXVVNUR6TDVYRHFkSVVEZ21FVU1VckdncFhpQUFKb0wzZS8xOEtPekFKTHRPazZ4VUVoQ2VmdVJacXNaWWdqS3liWXRlSGVlRDNiTzA3WG5XTXlnbFh4Vm5BQzlLQ3ZLWUREMlBJZWVocU9iZ29GdXFORGE4QlJvUG5oY21uaytmRXJITVdmdWJOQ0R4cVhKVlNLb296Y0Q4WUQ0VFUwYitRRVN5Q1N0eWVjNDQvR2sxZWptZ0I1RFI2Y04rb05jTnRzNFBZTlpoMkFra2daSWNMNVlwSXN0ODRBdTIvbHpFQzFWVTNSTlJYNjQ1dERRb0FFUXZHcjFEUDJTemlSUXZXcnRyTmVid2w1ZHZyUXg5LzEycDF0WjI0RFZLcFVMcldaelBCbU0rejJJSFEvY0NYeXRWczFsTWpCZjZNbmowK3A2WldYcXVIVEZkQkZUWkFGMDRyeGF2M2Z2WHE4L1NxZDB1TUsxVnNlMEhiQ01rOU5xWlcwdG5UUE9Ucy9CdDBWSlBqZys2UTM2emhScTNkM2QzaW10cnNUZ3YycnhSRGJYYlhmVlpMSS9uRUxJeVZwT3A1dTdtME1BVnhFWDNPTCt2Y2VaUWg0Z2t0Qm5oakZxdGpSSlJNL1BQUytiU3NkaHJ6V3RQeGg1cm5mMStoNHZ5WEJieVRqekhIcmp1UnMzVVJyZ0N3djU2UEN3WHE4RmNJSjVubDFIanhWVm9UbnNRNWRGL2FtUnlqVmJuZHRYTjUvMEJ2V3pKam9LMEFQcVlWaHlwZldWeTllamdrVFFCREFaZkFtaE1NVHMraU1vZjVpSWIwSTRSUWl5aEhTa0xCVTZ5OEFpNFVYTGNDUGtMbUVLMjZhQUdQZnl4eitoZ0RTQWhHb0dQT2RldDNOOGVvVFJUYVhTNExjZ0dPQjJ3RFNVQWJwcE1yVWg0bk9mQ0RHNE5VQi9kbnFXemFYUmJEK1lRWDlER2FOY1NSU0FiSFFOTUFrL0NYMkFYWWh6SE5CTUYvTFFjUmhwZUQvSUFsZFNWZlRSRUNTaVQ3ZWlnZ0JrT2s0dkk0MzJlLzF1ZHpDZFRydTlkamFUaHNMR2VTUkpnWmFGdVp4QTU0ekhFRENZZ3Nsd1VsNnR3T21FS3ZWcFhTL2dLbzZ6UU8zUlNxdGlIQjBFYVFHSXA1UHB6czRtYkFpYkUwbVRJbTNYM2RyWlNpWVRvTkhnU0tERmFCeW9MVmgrK0ZFVkZid2RGQXcrTXF3V3VnVWFPcE5Obnh5ZFE2WHQ3dTNPSStDM0FVckdzYVBSTkRLUGJlNXVqOGJqd1BkN25mWUFndGp0QWt1RllobTl3WEh6Uk1Ld2JWTlhWQ2lWNFdpNHQ3c3puWnFCYldtR1dtMTNKcGIxcFUvZG52UW5FWUVIbVZaa0NaanpMSmZuUVExODBKN3hjSUxCVHFRU3ZYbzlyV3N3YXMvZXVvV2hWUks2SVBLT09YN3crR0JyYjgvUUZXZ3J5RC9NV3NSeDQ3SUM2aWhLWW04NFF2ZENrb2ZqS1VaQk4zUjBUV1R1SjBtZTRUS0xjbElmRENlZWE4WG1pMXlwK1BvYjcvUzd2WVNDY3BJUUxZeTBPWjJnSmlpcTFtZ0s4VGc4K242L244NWt3Y2NFam10MGUydHBXT2QwTkRBMVdYUVdmSzkyL3VNLytlTmYvc29mUlB3WUtBTzZCVkJvVjQrUDdyNXovY1hQUkVXZWNNbUFHc0tUcmduUzVoS3psSTdBZ0V2L1lhQWtsdm8waVk3RUp4UU5sajI4a2htV1FGOFI3c1hiTHg0OGZMemc1bkQ2RkNGeTF1aVBSa056YXA2Y25ZSXV6eGNBWHdLa0JWSTdHSm9CTGZaQktuWnJheDI2RWxZTUpBaDBrQmFEcFNmOEowQURZQXVXVERlZWdubGNnQ1RIL0xsL2RuS1dTaG1XN2FDUGlvVWNwQWh1S3pvSXZBZ3dvcWxUa3BCTXBRQXNkcWw3L3VqUlB0UXpWRGpvVFNhZEF0R0gzS1V5cVpPVGN4Z0tlSmtRRWtBa21ValNOVXA2Z3dyZHBJVExhTnNlZGs4dGsxN2NHNHVDcTZBVlVKbGdJNDRGUDhMZjN0NFlEQWNRVEZpaDA1T1RiQzUxZEhDQy9pMlZpdkMxNzl5NUN5ekNMQUJQbzlFRVhZWGlrRkt2TnlIZTU5VkdMQXBOUnkrbnp1WVNwVkp1UERhenVTeXdEbkVBUVFEeDBMVTBEQlFVcDJOWmFIeTNDWG5ZZ1VFWWpzZDhuRmRVV29sb09CeUxvdG9mRENDU3VxSlVxL1ZCdndzM2ppNll5RnEzMVlYdlBKMDZVVW5LWktFMXlDQjNPMzNZL05GZ21ORzBWcjBKeFFIdEVjeDgxQVlNbTR2T3p4dk5CNC8yb2RvUGpxRHZUUS9LL3ZJbGFCa0lKK1N3VUZuRDJSbnZtTW15ZW54MC9PanhFNmdNUmRQYTdXYWpWc3NZT2dSUFR5U2d6c0Mxd0RZbXB0M3U5aTVmdTd4V0thUVNxVGpvRU1aK0VSa01SNHNnb05kbno0SWtyUVBzd1RTaGlqUlBBUndBdFlwRVZ3MmwydXJDSXM3dGNUWmZPbTkwQ3BwMDlmYnRiNzcyeHVidWM0RWdnazNDTk1VVzhiMFhQaEdIbWYwZVRGNkVDNlFpTUFpSEN2eHBIc2JSR2Q2WnBtZXdwMFB3dndUNzh2dXBXTUJKdjNidG1qV2VDTEtjMEtWaUtqV2NBaTAyN0tvc3lHZm5aeEJFYUNsRFQ5TDdIU0tnaGdvT1FrY0QwRGdjS2grTi9NNTN2dU1IdnE0WjlLQ05yQXlIUTNNeVJZL0I2YWRMRUYwNFhuUnREdDBONnEvcUV2Q0tkTG90SndyQUdUaERQcGVBSVNjM1FSU0h3ejZMdzNkUVlCQ2d2SUVQV1pIWTdUOTZWaHFlSlQxeHNJakFVSXduMDFna0JuS2ZnRzVXWlpCNEtOOVpNTk5seWJLdGZMN0F3MXlBSDFmUFVCUlFPeHFQVE5ORXZXSDhZUnh3MUdSa3laS0dOck9yS3hMTVFncituT2VEWjRHR3Fhb0NnMTZxRkRPWmJMM2VWbld0c3JveUdrL2c1V1l5S2ZUTTJ0cmE2ZkU1U0tta3FIRkpXbHRmVlZVOW1Ic1NSajBJSDIvejRGMXc1QlFaUUI2R0pwM0p4U0xrU3dCcXFFbW1tSHZuemwySUNGdzlBWVlyR3FzMVcwcUNudE5kcWF5b2toQ0xjRVl5YzM1ZVhjUVc1WFIrT0JpaXpETjQrZDRjOUxyYWFtVU1JeXFLdTN0N01GYk5XbU5rT3BWeUNYUWVvK082czhsd01MVnNISjR3REVtVmFyVzZDTlVpU2ZsOHFkUHJ0QnFOVHFzMTdQWnVYcnBrQnpUL2pKYkVrYVhCY0F6TjFZRjFiYmRjdXN3Y1BIbHlrQlFGMjV2Wm5nZm95MkljNURBcWlNM1JrQUVwQ3ZWbkpKSXdJQmkyODNZbnE4U1RtZUpabzU3VDRuS3FjSDV3OFAyZi9qZ2ZqejA4T1A1UC9zNS9kM2g4ZjlyclFsTTl2dlBHbFJjK3c4bENTRHd3c0lUWWtLbXdwQXZBc3hEdVhnWUNBYnRBRWg0YXByQi9oR1ZLbU1yUzJCZTNzNzJEWm0vdDdKeWZOalE0cWZOWXY5KzFUQXYrRDNpRlAvTnBlaUR4bGprdGMwaFBVdlBnRmJQQXoyUnljQTZocHhWUkFmbEdENEIrWUZ4QnZUSnBRNVZGSE9MN0FiMkRPUTVmRVhTQ0NFYlVkODN4MkFKcGQwQ1FhTEdvT2VRMHhvTWlTMks4M2U2V3l5dGdoelR2Rk5LN21JT3VtT1lFNkVDNWRFRlRFblZEQTRFRytDR1RDU01CUmlSSkVtbzJtOUdsR0dnMVNZemxDemxRWkk2blp4UkFtRzNUWTJPTUpBR3NGL0lHdDNnOEhOKzQ4WXh0V3J1WGRnZURZWXlQMkk2ZFNpYzh6MFo3SzVXU0VKZEE3ZUp4c2J4YWdtMUo2SHIxdkZZcDU0REMvVWY3cFhJSnJoaFVPRmhSdTlNRGxacU96RUd2VHpOL2FLWlV0TmNibW5DWm9Td01tQXVSYWlJSTVVSm1jNnNDckNjU0tTTnA5TnV0Mm1uOS9zUEhzQTh2UFA4YzJ0WHI5amMyVnFHaVBNZHJkenJwWEJwRm5SeWVWTnZkZENvdHltS1VpNmFFQ0Z4VldNU2pXdlhtcFQwNWtXZzNtbWRuWitOdS8rcmVycTRucmp4enJkZnZKMU5wMkRHNFFzZkhwMEFFeERnSVpqaHJsSXZ0SHh5TUJqMzBRN2ZkZ1hvR0RuZytCdGJYSGszYVhWcEdiWDE5WlI2TmxzdGxmeDQwNnUxZXF3dGtBZldRR2FpcWpiVktzYndSS1Bwd1BJUlJKUmVlWnRRUXRrQkRBTEk0SHlzbDFlTkdONllsWXE2bDZWS25OL1p0OHpOZitHdzZQb3NLaWVkKy9PZXFad2ZqWnMyZGpMaVl1SGI5Rmc1anNNWFBndDBqWlZoZGdwY0Z4T2tVTE05RldDcHRTb1NvNEVDVzh1SEZtVEFnc2t6aHJ1MWRPajg5aTNCenVGeWU3Y25vOFU0UEh0aHNIZ0NGeFZJUkpCV01aVEFZUUp1Q3hvcjBmb3lvcXNtQXNNZGVlQUlPQUlOUUtCUWMyMG1sVTlQcFdGYmk4SFpBSWtCSU1FSlExUENxU0xmUjhyajA4RGFvZGlxZHBtdnEzUjRNWkR3dXFScUpSeHhCRUdxd3JZWGNiT1pydWdZL0VtMkg4d0FEa3M1azNuM25mWkJSZXBVS3JRMExqV0tDR0tESEoxTVRvQWRWV0N3Q3VqZkFadGlqUlpBcmtDaWNnaGVnUVVUd1R2Z1E0SThRbFh3K2gyK01QUXc4QnZ0Zy8yQXludEtkcGtVRWJCaFV2bFp2NmdtajIrbVJEZmZuc0NGUWpTdVZDbXIxMXB2ZlhWMWZSNU5yMVhvdWx4ejJSNkJrN1Jaa3RZaDZ3cVY0ODd0djhaRjVMcW4xaGxNSVR6YWJnNENoRDdONXVwMitpSUNEaUsxVzgrMDMzbElNclZxcmIyNnNsVmRLR0pGR3ZkVnV0K0hXeHlWQjA1UkJ1Mk83OHpSTWc2YURLNkQzazZCbjBjblVtbzhtMWl3U3MyYXpZaTRueExta3BpY3phU2dTQ0o2bzBKeEhLS2JweFBaY0I5aTVjdlVLT3VyR3pSdjM3OStEQzlocnRTVkJ4SW5RYWNROE9SNXRMSllMbFhJNWw2Rm41OTk3NzI0bWx3VjdoS0lCT3dMU3dQSUZJMWU2OXVMcC91TlVmdjFMZisxWHIzem1CNVZVN3VUKzJ4R3k1RFJkRklZVUJRb1kvbGlrM3UyalZqZjNkci95NWdjYk9teG1wdFhybDNLNTdaMWQxZTlPa3pzN0wzMm1lbjR3YVZYbjN1enFLNStmY3pTNWRZbnYwTzJrTGNJNFM2SXBONVFTU3RWSHdqSUhobzJoSGo5L0lnczJtQXhRNEo1Lzl0bWtrWEFzRDg3cXhKb0s5TVRLZkhWM281REx6VUZKYlFzWWdpcVZKZGxmMEVRQTBEK2NBS0NIUXdHTlpUc09IQ3hJUXJQUktwYUxJRDlNbXdPN0hzMEFTeVRodjJjTHFTdVh0K3UxTm1yczA0dGFvbk5nTjV1RjljQjVVNmtFSHhmb1ByTkNGK3loRk1rM1pJL2h3YWpWNEkybDAyQ1ROQ2RuRWFTUzZTd3FOcC9MaWdZMkFpOXdBYjgweHNFOUFCV0daQ1lNdGROc2dRcEJuWTlIQTlpVFJUQWZqSWJnSHYxT1g1REVZWS9XWjB1a1V0QzRSNGVIOEFYSkZaL1I5QmhVWURJYU41cHRSZEVnWTZnZVJBdnFDcjcxNmRIeC92NUJyZFpRZGJYVDZZNXBUZFlrcEVMZ0Y1S3VvSm5qMGJSUXloOGZuVUc4WVdHMmQzZmlnZ1JscjZYU2lxb2JTVnFOSG0yUlJJV1BTNTQvQTZ4cm9MUzFCaCtsNVc0cWErVkVLdjN3d2FQNVBPTDUwWFovSU9zR3JNM201aG8waXp1ZW1xTlJqT2Q4MjVuWmRvYjMrN09ZbHNuRFU0UWR6aWVONlhqcUJnSDgwR0tsSE9ONDlCZzBybVc3bGRVeVRkNTg5QkFvdEt4cHE5V1NGbEdvOWpRc1ZiMkI0VU5BSjlQU1JiUEFCYUtqa1h3WlVwd1hlUDY5OTk0ZkRJZm4xUnBvMTQvL3RWL2R1dlh4SC91Vi84dXRMLzdRNVk5LzdtTS85cDl3bVpTb2FaVkwxMll4N3ZqdVd4R2E2RUZyb1FaQkFQRUczY1RtcFZMdTRkRXBldGdjVDlaTHlXUmg0L0RneVpXYk4wUitiZzk2czh6MjFxMlAxV3VuNXcvZXZmYkNaK0xKNUp4NE56UTdFSUlQUXlwcDdEQVdmZ1BJUzZaRE9oMkJubXdLY2I3OFVKYi9uUUR0VG9IYjJ0d3FybFVzMTVIai9EdHZ2eWVLOUlxU3NlbndJZ2VyeXZOaXM5R1FKQms0QTIzUU5YYVhwNUFCOTFWVnRkOGJBSm5nR3pnTHhoc2FOeGFKZ21IUEl6NVFQdmNYMDZrTGZBT1hyWFlMNmdTa0U3UUI2TXBtcy9Ccmd3VmRvNEQ3Q0FtVHBVaTkza2xsRERocUZsdDBnVXhuTXBuTlpCeDZRTlNDSzRtbUIzUXRoWWh2cDlVYmo4Y1FRbzdlSHpOLytPangxTFRwMnZCaUxvZ2c3bmF4aEZPTXg4TlJPbU9FOTdIQitFM0x6dVF5Z3hFOVlvc2V5R1p5WjZkVjlJOE83MXVEMFlCMmx4UzBGaDRDclRrQkI3R0xqMDRYWjhTOTNWM0hCdGc4N01ybnN0aWJ6dWl4UlNDSjR1V3JsMFpEb3JDeUtnTjVVQ0syN1Y2NnZIdDRlSlJPWjBIM3UrMTJxOWxlVzEvdjlYdmdOb1BCQk5RaWw4MG9pZ1RuKytxMW5lRmdmTy8rZ3hhdElxYkRwWUZkbFVVT21uWXlkUllCZXpNZXpRVG1UVmdyYzRndW1QSEtiRDdIV2Nyd2w5UEpWcjlmeHhsYW5aVlNzZFhzUUZBaHo1N24yTGFsSi9SK3IzZjBaSjh1bnZsK3Q5R3dYYWN6Nk1ONFF1eERFSVIrMFhneWFZQVVuVmJYeWdWVlU4NGJyVzZ2QjMvME16L3lVNS84bVo5ZnVYWXpJc1NoOGhUZ0VoNFhIVWN3MjlpN25sL2QyNy8zcG0rWlNFSTY3QmlDQ25JL2dVOG9iQllLZi9UZW82dWxGRTJzaXZLeG1WUFkyaldDbnNjWnRwTGV1dlhTK2ZGajMvWXExMjUrRk9oaEFIS1g3QnlCZlRFc2Z3am9wN05vS0NCRzRrSlJmSDBFOTdTRHhDWWE0WlE0M3h2MElqUGZISTYyTjFhTlpEb0FaTkF4L3NJMDdYd3gzMmwySUFQMEtFQXNDaFJPeHlZd0J4Vk9qM2h5U0tHTEdDZzdUYnlmVGtYVDNCTTZkTllZQXg5YndQaTZ6Z3lTTUoyWUxpMU01TVhCUGtFdzVyVHVNN2c0cUE3c08veFl1SVpnOUdCSDhBZ3gvTUF1TGJFVWo4WDV1S0twOEhkUlk0Z1piSjdydWhCeXFDUlZsWktHZXYvZUF6aW9FbnhiVVM0VWM1Q05nTjdaYjJFN21UVFFkbFhSYlFlTUpRNjNMSnZQYUlxUnk2eUE1aU9QcHFrZytpNGNTbEhRRGIxUmE0Q0E3ZTd0QW9XTzYycXFmUFg2RmRmeHdaUE96OCszTDErWmpNMTBLdm53NFNQSUhoQ1pMYVR0cWRWdXRpRVArL3VuTTljN09UbUJjb1ZsRTBWNVozdTcwV3BpbHpXeHN0bjBjRFNFSU1sdzV5VUpydk9kOTk2amVadDZvdGNiakh0REtOcFNxUXl3b0txYUxBSnoxNjd2SnBQNms4ZkhaK2VuTzl1YkhyMUVNK0E0d1FsaWhxS2NuSng1TUJsekh6d2JUT2JKNGJFZ3lyQ3hlNWYyTE1lK2YvZGVPcEhCMlNiREVSemltZWVhdGcycTVuak9jR0tDM2NKQ0VoRFluYzVRWVdMNEFIdHNvbHZnTGcvNkkreUdtdmk1di92L1hDZ0tVQUdlc0tBcEtBU3E4QXZ4R01jVk43ZlRLK3NQMy9qNllnWUZId1YwZ0JPVWhzRzlsRS9mUHo0dDVqT1BUNXRyS2FsUUtwOVVxK1Y4UVZJVXdXNFBwY3BjRVBadWZZS0xTenBZSzBxRmUwOUYwMmQ1a2pCUU1pV3dzMU50TDVLSjVyUDZYQndReGtLc1V3WUtMQWY5UUlVVVI0UGgxSUZiblpnTTRhTkQ5dzFCYjRKSVpOQ2Z3QWZOcE5PeFdBVDlDc0REQklOclFqUFM1VWhObjA0blVJck0xNHk1am9jT0FkYlJZTHBuRnlBTzk0WHVEMW1rZHhYVUVmMEtwejR1aW9QaENOV0JDTUZiMGhJNkgrTk1jd2dGZzV6SWhrNDNqS1JsMHd1YVhjZkNxV0VLbXJXR05UWEpOWXhHWnU1TU03UkVRaDRPaCtzYjY0N2pxNnFjUjhpQjNvT2xjRGhkTUkra1VxbE9wdzlTWVNTVVJESjFkbksrdGJtMnZyRTU3UTgvOGNuUERFWjlxRHZvSWRNMGpZUWVpOGFPSHgyREFLTWFFRW9vYVdBZE5MM2Y3YXh2YjZMbk11bnNlKysrdDA0emtCZUQvdEJJcElLQTN1TmxXMU9vL0wycmx3NzJ6NGdtR1Faa1Q0ZkVBaTZ4T1hoNU1wbGtUM1VWam8vUEFBSkQxOG5abUpod2s5QlJIQnlYYU15MHBwZXY3RUh4enp4NGhFNEIvcEpLVTErZ3FpZmVyTlpvSjFKSkE1NUFwMWRjWFlHMHA1TEp3K016R0Jrd1R5aGdnTDdhYU1JWHl1V3lNQURsU3BrOEgwMlorUzd0bkMvQWkrREhROHBHa3dtNkhjTWtBNHpRMXJTQ0ZUMWNUNkNmTHpCWWhxSkJ0OUVqNkJ3dnhvWG5Qdkg5ei8zSVQvb2tFTVFzbUZ5RWVuWUpMV0FJNmNYS1preFNUKzU4QjBJRU9LSTBVVmJBZTlId1JFSXJhdHEzSGh4dnBQV283eGpabFU2enRyNTltVjlZUU5WSXpFV0Z1QTQvaWhYSmdIengrV2dJRVhzUkdKb1pqcGZmSWVqRG85Zy9FNURsSWZCY2wza2ozSldkclVLdXNIOTRDbjhEb0trVUMvbHNYbzZMN29KZTNqRHovSWtKWjB1aTZ6T3FQQndNVlZsMmFHM1JnamViaVlJUW8wZkZxRkJSRkt2bjFVUXlnUzRSSkpqajJBd21ndGJKUUhQaWx1T2cveFJaQXJGRzE4dWlBcE1OUUU4bnNBRFJaSUplVlFES2dqclJ4SEY2a1NFUFJUNlBSZXlwRFpxRS9vTk9qSEV4amE0WHpTZTJ4Y2NXZFAzZEM2RFRqdzdQWUcwdzBvSHZoUmRKVlUwZkRVZFBIdTlENVdNVTRmNENrWFE5Snk0OHV2dEFGdVBOWGhPQWFEUWFsZFVLS0FlNnk3WGRuL29MUDlYdDlua3BCZ3loSytCNHdlSEQrS0dxSVBlZ2NBL3UzYWU3c0JtOVhnTzJwSGEzblU1cWdGRkNTNWlXMnh0T2ZEQ0dPWWhjREk0NDdFYTMwMjYxdW5FK1lpUmhxL1R4eUZRMHVkMXVwcElKbUE1U3FtRHFqcFBPMElKN2RFbGtzYURYOENsU05wZHhSNlB4WUZ3dUZHZTJDVDhkbkNybXpzNGFEU2p2d0tkMys2cXFCc1ZrR0hxNWtIdm4zb05pb1Z3cTVQcmowWGhpd3JoQmVRMzZ2VzY3RzRsRmgrTUpmRERvZUpBVGFCRG84NjIxdFU2L0J4WHIweENSS1NkOHNHdm42K3VWYTFmMk1va1VZY0NmWVdodmZ2b3pDNTZlcUF5eFF6a3BzZ3pFcmhtU3dHcmN1Vjk3ZUJkYURYREhjS1A4ZzdQcXM3c2JCOVYyUHFXOWUxRGJLOUpkUmowUERkdFpXZC8xdWs4Q3RXVEdDRUpobWNBb25ZYkF1WXdoa2ZaZHBGT21FTHFVZFFsajZOdUxIVFNSTjB4algvUU96YkJrU29TeEVubkJudnVHcXBiTEpjakkydG9LdUNrOXVrWXY1WUVmRS9XY2VWeUl3bjhCY1lUU0JtaDhhQTRWTUpPSGZlQi9vQktoaHdoNE9CV0FGWS9INlgzUjlLZzFvclF1QUhrd1Bxa3hkS2hqbXVXVkV0Q1F6K1ZCakRjMnQ2WWpVMHRxbC9ZdTFldm5zbUo0bnEwYmhIZVlEc2FDRE5EaWRyc3RhcW9IMXVsNnRTWVI0Y2dpZ0l1WlNNRE41Y0Y1aXNXaUlQRzJCWU1nMDh4QlVlaTFlOURPVzFzYm5WNFA3QUlTMjJrMGlRQllMbG9oYXhoTkRsTFI3L1R5eFFJWDVVRDBEdzczQjJONlprZFI2Um9PV2dLSkxhOFVSSkhqWTlGT3N3NVArdDdkQjkxT2YrL3ExVnd1S1V2S2NOaFBHSW1ydDI1c1hYc0dPa1NJQStyd0MrYVNKS1l5YVRBM2JCY0wyY25JdkhmLy9zYld1bVBSZ3Qzd09qS3AxSGd5ZmZqb1lTYWJQVGs5aFFvdUZFdG82ZXBxZVRJYStqYk5HNFB4Y1FQM3lqTlhpN21rRC9VVGpaelU2OWxjQ3BXM2huYTcxNGRvd1JzQnk2eTNPMkFCUU5oMFNrdlg4MFFPTkc4OGhWUEJKckZHRDUvc0E0UVdQWDQrVFJrSlVIUDRBN1RZTWd0TE5MREYzV0dsNmVIMFNHejc4azQyYWZEUitYZi8rQnUzZitoSG54TDlFSHNmQmh3WlhpNkpSblp1dk9DNFZ2WHhCOUFYd0FNYy9mNW9paUhURTVyQmMwK2F2WVVmVkZJeUdQek1Yd0JDaHE0RWcrWllYNStobExBMHBqcy9jaVVSbjFDZExnUE90TnhpdjhzdGZJZWJUN015bExQbk5aWUpZUWJ1KzcvdkUvM3VjRzE5NWZqc2RITjlBd2liVENmdzdoYzBjTEhaekkxSG9yMTJLOG90UklIdVp2T2lBQWtkOVBvZytKNDNnOUoxWFJ0cUc2QUhoWUIzQW03cXVUT0FGWlpCcEVzMGMvQ1FLUzFTd0dVemFVV1ZkRU5HZDV5ZFYzSDZZakVQMXcrTXFKalB3M0NEcGtObEs1SUNGZ0ZMQ01ZL1lOTUdKNlBwWU5DSGRXMjErdk01TFR3cFN5TFVLZ2tiVFVtZ2kvdVdPUUdWaHhYQ21PWHltVUlwaDQ0R0wvSm5YcjBKYnh0bDgzb2ltY21tVWRmcWVRdk5wS250MlJ4VFVKRk9wMFV6ZkUwelZ5aDRKcXdSbWdBZUZZbnhVWlFNQkEwSGRFSGRtazZ1MzN6bS9Pek05OGxGd1NkWG9PZGYzM2o5N1kydEZmZ0ZOSGtRdm15aC9PWWJiN2kybmM3bFFJS2hHOXF0enU3ZU5sZ0h2QXFvODNmZWVSOWNDMTQxVFFXZEJiZWV2UUhIQjVLalNFSXFrd0xReDdiemhSLysvTW5qbzN3aEZZc0VpMWdVNmFlbnRlcDV6YWVIQythQjZ6VTcwQmNiVURIbjFlb25QL1VwNURrOU9ZSDdEc1V2OExTVWlLYkpwWVRLd2FGYXdPZzVWNjljZ1VkeC9mcFY4TWx1dHdlT0RqR0RNZ0lRSU9TUVFIcTBrZHdybjR2SEVrbGpNWStlbnAxZGYrWjIrZm1QTFFrK3dZY2dSL2dLZndsV0RGUGdQN0hvenMwWFVMdlRCKy83Yk80SlVOSHVEVGZMNWNaZ2xOUGxkNDlieFlRcVJnTXRtUjMyKzRYU2lqczhCYUJHVXBJcGVJSXJreDBHVTZwWGlHTlcvdkliZ2VTTDB0bkpRMWdUMlFxclFZRjJoUnlHYmRCWGlIOU9FK0pKVllOWENraXRiNE9ZeHJtNGtDdm1qVlFDV2h5RnlUeS9tTTFwQWZWQ3B0Y2R4Z1VvYnpvY2pRUE93dnVqYUJwVUp0QVB4T01vMTZWYkQ1SWtvNHZnWGhtYWZPUEdyV3ExQmxqak9MQ0kwWGg2Y25JS0QrSGUzWHVhSWI5NCsvYmpoL3M0Y0RnYWUzNEFRMC92TE9kOWZJMUdGb1lUdUVRMzhKeU1ER0EzNld5cVhNb0IxcmJyUTdUUVpNZ2EzUW1XYVc1WktndmViNUx3S1hLTW5vcmtHVGxSVVdGVmlSdndQV2lORUNlWHorcTZnVUllUDM2VXpXWWdKNURiZXEwT1pabk9aZldFMFdxMlVhVm12YW5yYXFsY1J2UFdON2U4bWRmcDlkR1ZLQjQyYld0bnZkbm9MT1l6OUp1aGNKNXZwNUlaWFlPdmtFZ2xFdjFlLzlHang2OTg2aFhOU0p5Zm5kTlVJc093eldreUJROUJVSFVkYk5DMlhJd0xqQTlxMjJoQVNVZjZneEg4Z1hxekI5a281RE9xSnBvd1c5NXNaM3VyM1dqRFpTcVVpcFB4RkFqRldIQmNyTmZyeGpnSnBBUlV1MWF2clpiTE5BSGJtK1VMZVVtUjNXQnVUaWVTbnNSUlVCQmx1R0s1Vk1UM3Nwa012Ylo2YW1LTVlCQTBoUmExQTlQSDBHSkFrVjRvWkRIQ0syc1ZhUHF0bDc5dlJxUE8vc1BoWDhZdndnWFVvbHlNVnNMUUVrZjMzZ1pQWTlNT0lvQkhNZzJoalV4czU5NTVlN3VVQVVPbHh5ZGk4V3l4TU9zZHpoS2JUa3drVElZUGF5OHBDU0dhY1B0aGxNNFFKaXhUV1FqaFRYS0NId2dKMlp2UVBqd040YjRJOTdsWFB0MXBkMHVsSW9RNm5jM1NyWi9Cd0hUbzlmK09ZOU10K3RFRVJMRFg2UXV5NEtMendGUnNKMWdzRkdDWG5UdGtieGdBdXVjWGpVMmhJSE81dUNDQys2SkpOSGxxdnZqazV6NFZkV2NqazB4dHdLNlVEN3JEMGtxcDN4NW9odnJjclZzcksydDBINHJqek9rWTlNNmZvNC9vTmJZMGNXMUJUM0tBcTlCelBRS3M2eUtoRzcwdVVSU1ljbEFPS0YxQnBtZEhlcjBScmNrb3lvUGVBUHErMCt1Z3V6SEdjQmFoWXVNaUx5dnE2Y2s1ZXNaSXB6M0hCVXVHTGdNUmgyeFVxOVgxalEzYjhhL2Z2STdlSXVzMG04T2s1UEo1Y0lCR3JiRzV2UUwzWWpBYUk2VmViNUlXcERVbzQzUy9UWlFlUDNoMDljYTFUcVBkNll4YnpUcE5iZ0dINlE5cTFmclluTDc4OFkvMWV6MHdQeWlSL2FQVDFkVVY5TnZCL2dtSVQ0NnR5YXJyaVU2bnQ3VzlBYldhenRCQzhsdmIyNFBCWkRaZmRIcVRPVDFVeWJjN3ZRWmtUOVZCUllhaktRWnZNcDFDMzlEMGprVVVySTlIQytOY3Y5ZUJJd1M3Q28wSG94VGg2RDNKblhaYkZnWFFJODl5SGovZVB6ODZVeE9KM1d1WEhqNTRHQUlIYWg1bUdiZ2taTEJsbkZPUTJoUk5sVkVMMi9scno0YmFuVUdjQWVmRFFGc2htSmFTQUFmZzhzM3k3dlg5OTk2WU9UWVhqVm5lckp6UERVMUxrL2dlM1ZMM1JvUCt6bHJaOFNQRjhvbzFibWlMK1ZpckJGUUlWWWVkZ2hWSVgrRGZwT3daWUtISHd4TmRuUEtDN05PSDlpL2pZUWd6TG85a2dkdmVXaSt0cnlxYWxrMmxRVVZnZ1JTTkZsd1BuQmxkbzRJMmkzaDBLMVdTZ1RWQURVcjYwdFZMZlhxQ2swOURRMWowUkNrNkhSb1VNa21yTklwaU1xbkF0WkpsMGFISG9tblpzSzkvOWV0NVloZDBSMGRXTlZqMjFmVTErSlNGY2hIRTd2ck5tNEJVakl2QUE1dlJFdGx6amx0b2hnRWNISUIwenVtT0poZWo1MGZwY1NGNk1pZ0N4VU9YVUZ3WEtrclhOVGhiRyt0YjUrZk5Vam1EVm5WYTNXcTFYaXptaExnNEdrMUJIbUJWSjJOckVRbkd3eEhvK0NLZzE4b0pBcGZRNGZCTlc4M1c5dTQyUmhRV1liNElWbGJ6N1FaZGZ0VTF0Vkd2b2VXbGNnV2FsZWVqRUhnb3JVcWxyR3NTeUFET1dLa1VJVlNvdDZRbFNwVzF5bXJKOHlLTlJyMVRiNmg4WEJWRTJEUzJtQjg5WExlL2Y1Uk5KdUQvb0ZHeUFxTnFWakRxcmdzamtFam9IbHRKM1RiTlFybkNzZW12WUpRNHV0OGRXTk5wcnBqYzNOcVlXdlpnTUNya2FaMUhrNjNNZ1c1OC9vVVhUR3VpU2tLelh1TnBuZTRaQkJYOVB4ME5kRm9TZ3BZcDFUV0ZqOFZLYStWVUtubjkyUnVlUDN2dDI2L1B2TVd0bHorZEtsUVVQVk5hMy8xVFAvODMxM2R2UW00ZnZQK09Kc3V3QkltMTY4LyttYi9nOFVzOGhXcDNDWHU2ZDdPRUZFdkVCbFJmbUJBcHJtN28yZnpoMjk5YzBOU2hLQWhTdVZoYzBHeEN2enVpSy9SWkliSldxUVNMYUxteU5qaDVWOHRzanVNR20wSjhjU0w4VU1FVVF2YUNmenJITXNMSXlrWEdqOFNXSEFhQkpWL0VXYVc1dkpHRmczL2xtUnUyN2NJVXFZWTI2dlpsVll6TGFtL1FoMFVlOVNjSkEweEFnSDRTWXZTMC85MFA3c1o0VHBCRXFFNGl4TG9CMWdFRkxNczA0eFFlZml6R3d6Z29CSjJvcHVtU0lrTDF3cnlDSUFMOUlKR05hbU43ZHdkeU1wbE1xcWVudzlFSXBybmQ3Z3o2UFgvbVRNWmpzSFk0T21jbjU0QkZ2ZGJ3TUtvek1Jc1o2RFUwSzV4UndIYzhIcUZBbkJBR0oxZklRNUxnK3NBaU5ldXR6YTNWMFhEU2FuVjNkdFl4QWdtTmUvVHc2TXFWSFRDMWJxY0hSeGtNR0xZRmJvQkkxbVpleUJiaE5iTEozQU5KRWxyMUZuUXRmRHh3RFBRWE9CSjZLNTB5UE1kNzhPZ0puRnE0OVpxaDU5STZIRjRRUGowaDVmS2xoL2VlaURBZm1wQkkwdlBkZ2lDLzkvNzduS1NzckJXM2R0ZUI5MjY3Qno2RFRvYjI0S0xSL1lPakNGcFhoU2tZSk9tdUVGMDdBb2REazZlVDZjeXpXMjBJR09kYVZua0YvQVFPcnVsNkN6QU5hMnJqMjlCVldCZ3dQZGYySUJ1dVpZTWJXVk1yWDh4Wms4a3JuLzdVblEvdXJ4V0s0MDR2aU16SHBvbmVQcXVlTDRMWmRESzY5LzZqMjEvOHM1bTF2Uy8rNU0vODJILytmM3J1QjM3MEV6Lys1NS81d2c4bFZyZlhidDFldlhuci9NNjdxcEgveEUvOTljM3YrMXpBWGdkQ0F4dWlqSDRJUlV1OGZTUXdXSVc0SXB0ZlhOL3B0R3FqNmdsYUJGV1NTeWVoVGJYNFltZzZBNHVlSjlrcWFJSnFDS0pDc3orNkowRjYyNG1oZjFBMFFmY2pFQSsvd2dqVU85dTdUS0l2MUlpU1dBWkVMM0IrQWZSbG5IWnpuL3YwSzdxUmdzYUNhUjROUnJ4SWorcWhOemxCaEJ3TngrTkVnZ2p4UEloQUtyWjJOb2tmKzhIVWRjQWFNZnpKY1Bvcm5CNzJmRHYwSEd3aWlBVEFPdk9BUTdwR0Q2VUNwT0tvR0JlRkRyTXQrOGJOR3pBQ2NDS2h2Mm1BZlg4dzZORks2ajVOb0gvKytlY1BEdzVSb1NDZ2FZK1A5NCtCODNRNjQxZzJYTjdOelMwbzliMjlQYy96RGNPQWxLRW8yTzV1cHdQeURZNHVTTUtUaC9zTzNJTnFMWk5QUTByQWE3TzVBczJzbE5YcGNBVHVFZWY0cU8vSEJSNGtCd3o3aTUvLzRzeWFseXJsU3E3eStuZmVnS05LTjMyREJjUXBueStBbGNHVTlRZER3TkdjbWp0YmE1bGM1ai84KzkvTkZ6S3FJZ2V6V2JzOVFQbGczNWw4YnVhQS9pNjRCWWk5MytrTkV5bjk5dTBia2NpOFdtMnhtell4TUt0Q01RdnlNQnBOMkgzcjJPSFI2U0l5dDF5N2tNNU1Ca05CbFdGbVUya0R2UTdmbXVlRm5iM0xHMnVWMm5uVjhmeWtJbFhXSzdDNmE2dmxoS0dmbko2aTg0R3ZDUzF0T2Q5WUtXUGs4OW1zdHdqZ2FOSE5xY2c4WmVpY0VQY3NVeElFRERHTXc4ZC81QysvOUJkL2R2T0ZseE1iMnk3ZHJBckFPR2NZWTlnZ0RGbVVlK2I3ZitEMkQveHBJVnRnNUNIMFIvR0hYK0lWdEhIeDg3MkIwb0U4Z2hheDZOamE1V2NldmZPMXlOU0NyWUppeDZreXlSUXFiTS9tZmRPMUpuWXBwNEpBbHN1Vlh2MUpXbGFIV3BtdDN2U2hobDZlaW0wdUxRZmJaTlZoSjJLYlJHcENheE9tc0xBRSt0TEhwbnhjcFZ5U0RNM3pQUjZHbjR2MSt3T1hGbjJOOGlMTkVZL0h1Rkd2QjkwYWlYT2Fxa1FsY2NIRmtwbDB1OTNPWk5LU0xFUEJFMU9rbTZNWWVpVXV4bkd5NFhBbzB2S0RDNml4ZXIyMnRab2NqY3pKMUpIcFJjSHhRckdrMGhPTndCRGRvb09VMDNVeHg0clQ5ZGNJSkgxQlMrZENUQllnMENoYzRPUHdVUE9GSE5pRktzdmcvZEFjY0NoQlo4Rmh3TDh6MlN5UUFUbzBuVTduODFrc3dodTZEa0lONmpRZWpYWG80V1RhRDJiUXJQMytFRzUwTHA4cFZ5b3pjTEJZZExXeUJRWlhXUzlhdHZ2Qm5UdS8vQ3UvNUV6bW5WNUxVelZKcENkVDZmNkFaU1VOVUhRZVlFWDg2bzJyb0tmZFR2L0ovbUV5bllaaWp2UHg5WTNLdzRlUFc2MU9vVmc0T1Q3ZVB6aXVySzhyc2pxZlJ6WjMxbEg1d3ljbjZUUXRDQU83TlJxUDF0YldtczEyb1pnbmN4RG5WVVdMeHZqTGw3YmhVZHk1KzBEWDlVd21SUnFMTHNqazMzN256YzMxemVyeEdmeXJqZTBkU0RmRUhFVUZpL25kQjArZ3B4Q1FpSEZkV2EzY3VYdi81ck0zNFdkcnVpckVvNDVyNzUrYzhhS3lVaW1mSHgvTkZ0R1AvOWd2dlBLWGZnN2dKaStTc1ErQ0EwMnl3SERnUTJvMXlzVjloaHRnQkp1VWdhTDBJU3d4R0NFblVMblV3UVEzL0pDZnlESlQzYkZmVk5STVpmZkpkLzZJQXlPRk9uUmRUVXNrTkFYK0RQcS9PNWtJUkNDbEpPaG1LbUUySGlxWm5VbGNJODFOeFlWYW5LSUE4dkxNeXdqOWgxeUsxWkxWZ1FrSjhyUGRGT2hRRm1jRlVFYnU0N2VmRitKU0hCeDNZZ284bkRrRjJrazNFdEQzb3FwZ2JOb2d3U3VWSjArZXJLNnYzUDNnd2RReW9leGhqTmRXSzRQK2dGelBnRlpCOGp3WHhSS1pRY2Y1Y0dYcFZxdGxXcXFpRHNaangxblFSV2g2dmtsVU5IRytpUFFHNW5BOFVCUXRRalBhNDlDamtDNGdFMm9lQmFJYUVpVEg5KzQvZXZMSlQ3OHNDVW9raUVBeFpVdUZicThMWnl2dy9iVzExVmlVbTVvV3V3SDBLSi9QUXN6QW9HeHJBZ01EdmtwTGRNZG93aVBVTTZ3TDZGYWM1eUVWL1Y0M3hzZHN4d1loWHQwQTQ2KysrOVo3MFRnSGtyQ3h1VjR1bHE3c1BQUGcwYjFnTWRNTkhWb2E5Z1BPekpYclc5T3BIZkhuSmx1NktLRW5EbzVPZ0pUeGFPclAzSVNSdUhQbkhqcWhWQ3o2cm51NGY2QWxrMWV1WFpaVWNURVBZQ2tEOWl3aVhCM2ZYM2llazhuUTBnYlQ4UVExZzJYbEJRNDFoNE9yeXNxZ04vems5MzNhU0NxRmxWVWVqTDgvZUhqM2tSQWpYM0Y3WjJmLytHalk3YzFNeHd2Y3gvY2VlUkIwSUhJUjNkcGNuWmdnUVNhazZOYXRLKzNPTU03RkFhOWhiN1MrdlkwYzltVFlIa3grK0QvOXI1NzdpWitrRlJ3dndNQ3dUbWdnb0REYzRpOVVpQWhNSE1Lc0RFWDB1NFFVYlZFQ1N3L2piSXZpNFZGc00xdW96QmJ6K3FQMzJSWXROYmUxdHRZZERzam1MaUlncmpNeU8vRkNybUJOaDZMVjgvSlgvQ2l0NWtMWkwwcW1zbGk1K0FvdERPSmtlYUowSTJtWjRTS0VHZW5EekZLWUZ2NXd6Nzl3RzJRREZCQzRBUUxpNENHYUN2cEx4RVBYSHQ1N2tFeW94ZFZLWU0wc3p5RnJUSk5oQTBWVG9GM0pxVVIvZ1B4NEhoaHQ0TTBVVlJIcE9kY1lFTWFhek5IVTBBVXZncFd5RituUFo4SHIzM210RC9YUDNqQmhhTnJoZ3djQUgveFhrSHVvS01jMlpSbDFnTHhoc0R4NHZuQ0M0d0szdFZyODRONmpnLzJEUnIwQng2R1l5OSs3OTlCSWF1Qk9jSVdUQ1gwOG9zdmJ0bTJDdU10U1hORlZQZ1loNGxFTjM1dURCY0Zub091dEUzTXlOajAvcUt5dURnYmprNlBqZENhNXVyWjZlWGY3cDMvcXAvL2gvL1NQLzdOZi9LdWYvdHduMy96Mit4T3pBMzBFaTVGTkp6RTJhRXk3M3RtN2VuVXhuOVZPVzVXTjlmclpPZFRxZEFwM29qdWVqdUFHUUQybmM4VW5IOXoxNTlIVmpZMTVKT2gzTzNBMjd0NjVIK0g0Ykw3Y2JYVmcyZTdkdmYvNUgvZ2krQkx3anIxMEozWk9ienFZeldZYjZ5dkJJb2F6dEJxZDZ1RXhYT2ZlY014Rk9UMlJDQUpQRXhhdmZlZWRaMjg5a3k4Vm5od2NCN1lyYWRBbWt3aGRWNUdhalhaL01JWnIyT3NOMFc5N2wzYnUzYjIzc3JFR0cvWHd3UVBUdEQ3eGd6L3o0ay8vRFB4V3dzRVNDQVNOVUw4VGpKWlJoQkF4OUVXeGk4Q3lVNFJwNzZVdWg0aUF0NFJrR2g5R2QxZzJ3aVhKMWRydTFkYjU0Ymh4RHBtZEJRRmxYZ1JvbERjTFBIOE9oYkl3eDdsMHVyeGE2ZFllWjdUc1NDc3hhOEhxRXdaMlh2cGxKWk1hSjl4VENrc01mK2pzVkM5V3F6Qk9OWVhKWWovWTRDNWR2c3h6a1pQOUozUUgxUFVYWE1TMkhEaUFubVBDd2MrQU1iUEZIUDNaYkcxcis2MjMzazRtRFF4TTdid2VRQWxISXNQQkdBeVlya0txY2k2ZmhkakFmektuVTU5ZURRaDNTb094SmhkemF2THhPTGl2SXNtdFJnLzJGN1pWMWZST285MXJ0U2I5ZnIzVnlPWHlZUFBKWkFKOCt2RGdhSDE3YXp3Y0IzT3YzeHNsazNveWtYUW45UFlXMjNGdVBuTWRybUNUSHBXbnEvdHdmK3ZuNTRXVkF1Z0s2cmE1dlRZZFczUzN5NXVoMmNBUWZPaEdzNEZtbzJkVHFTVGFsU3ZrUUtYYXJUYTlDaytSa1BQbzZBZ0hmdkRCZzg5Ky82ZlJvbmZmZjZkV3E2SENzRHp1ekQwOFBJR05LQlV6a1JnSDZNczhaNXFPVE5mOTZHSGNjcmtNU0sxdmJjQllvYXB3V1VBZXdPOE5YUnAwaC9WcWN6QTBhUkFpQzFDMXlscWwzeDNkdWZOQklxbkRodCs1Yzk4UGZGbVNkVldGK3FpZW5qLzMzRTA5YldCNDNuanRPOGZWNnJQUFBSZmx1RlRLZ0lrNmZud0ErcDR0NWpSWmZ2czdiKzl1YjNmNy9kRjRBc1ZmekJlZ1RYeDZuaUNHWGcvbS9zbkpxVzJpSDhUSGp3OSs0R2QrcVh6OVk2Lzh4Yjg4bzBWUnlRalBROTZDd0pEeUZEcFB3M0lQUXcwaGlZVWx6VmdLQmI0b0FhaEVYaklMWVRheURVakhOakVkWklEU1didnkzTkc5TithV1NmT3h6UWtHVVJKZzVHbnU4U0pZUURORkEzdDlmWXV1M0hXT3BmSlZNNjZ3ODRRbnVnak1zRURTMklrL0RHRU5xUXBJWlVKQ3B5V0FVNHord21PZ2ZWOTQ0ZmFnMDFjMEhjb21sVWdjN2gvSm1nd0ZtRW5ucDZhWlNXclR3U0MzV281R29EK0VrN1B6VkRyWjdRN0FvV2tXSWFFQnNHdU54bVBMbkFKSjlHUWRQYlFMaGsxeUxkRnllVFBxdDBVRWRnUGdhRFRiVjI5ZUt4YnlqdWRvT2toMUJxRGZYQzNjdlB4Y3M5c0Z2c0hwWGR1bmxWc0VWSnlEVXNhQkZyU3liUmxKQXltYlc5dWo0WVE5cnlRVkNsbklHeDhIWXdtR2d6N05jSlNrem1EVXFEZVBqMCtKUE5qMEFveHNJWXVlQnk2aDdnWDJUbE4wTjBRTzhnblhFNVFISUI2UHgvL3hQMzVGb01VbDVmLzdyLzEzOXJBanFRYVVhejZmaGw4NE1SMDJ1ZHdHS2FKcUVFK3pZN0hJZU5DZngyTEE2MHN2dnZEZzRXTm9MempzclU1M3dhWVlRYWNJQXIreHNYbDBjTHgzYVF0azZkS1ZIZmpKOE16ZWVmUGRaRHFWemVVYTlUcDB5bVE2TFpVTHFQQm9hbmZhTFYzUjlqKzRpMjRiMjI3MTlOUWM5U3VyS3lzcldSaEU2QjAwOXNxTkszTVA3dWdjUG81RHl5NllsbVB0N0c3WGF3MHV6dmY2UFNnZ3VvQXpBeWVOL01Ldi9iOXUvUENQcnR4NEpsZys0MDhqandnREtEQ0FmMUtYQkp3UUlPenpOSVQ1b1JrdnRHcW9WNlB3S1JtbzJXRUVMa3BrQ2psTVEyRGxzSStvS01XdGE5WDdiODVkRjRmQjhJS002ZXc5c3FBMHJ1K1hVL3IyOW5aK2JhdmQ3MlFXbHBmYWRPbTFMblFzc01vaXJNVHdseXJ4WVdDbUlQeGpNWllqL0JDM3BrcUZPYUxjNWQwZE1IUm9CU2htSTJVa0V1bE91K1BhZGk2Zm1ydlVqN0E5cm1XZkhwMExVdVQrdmYxc0poVlowSXYxNE5TS2NRR2FBalRHZHVDQmFkRE5RRFJVSTgyc0R1QUt6V3FOdXVjNlFIK24zVjdmQU5XbTk2Uld6OC96aFR5a0Fma1ZTUUNoSDQ2bmhiVXkyQlI0TnNnUFdHeTczVHV2VlM5ZHVxU29lcmZUV1YrdlFCTG1ITlFCdlg2WTUzbFViRGdlcFpQMGlnR01CejM0TStqRFlpaHFBa1I4dFZLQ3MwVnZvbFJwRVFGVWhTZFd3MDNHa3lpYkVRVFdQcDVNUU5nOGR3WTNZWDF0NS9qNG5GNkdNZmZiblRiNjE3SW1Xc0tvVklxS3F0YXJ0Y0Z3ako1RXQ2SFVtZTFldm5ZRm5YZi93VVBZb25tdzBGUWRTaFphZjN1ajBxcTNFVm5mMmVwMWhzVkNGbHdJak1WejZJb2h4OGZnOUQ5ODhBamlkZlBXTXpBN2pVWXprVWljbnA3d2dyUlN6SElNTklWc0FlQjQ5T0RoYUdLdFZpcTVWRElXVjN4cndrdThxT3ViOEMxV1MyZlZXbVdsMkt0MzRQK2hKOTJaRHpjcGxhUkxwYm9LREZrWThHSStKNm5aLy9KZi93ZGphNXM1VTRzUW9JUUpBaTZERHJIYkR6SHlmeEMrWno5aVMvZDBHWkJFZ0NPTnpyUThFeVhLd0lTRERrRWlkaGpaUXE2OE5qaDVNSGNzbEVMcU5nb2xLS0R5Y0QrQ21aOVBhWlgxeXRyVjIvdnYvVkZPejB5MGxUbkJsZkdtc0NBVzJFbS9KMURhaHpXa2xORFVVQkwrU1ZyRHJ3aTN0N2VIWVJERk9EdzVSR2hHTlMrV1N2bCttMWJ6cWJlN0QvY1BDa25OTVowSXoyMVcxZ2hrOUU0OHUxZ296aTIzMWUra2tpbU4zcGFZZFdnWkFoZ0pNNUdrdDk3aERPKy8rWGE3M2JKc0M2Zk81WE5RZU9ncXozWnYzWDYyMis1cW1ncDJnUXBCb1RZYjlkRm9TSmNVNC9URWU4SklzY3ZTUWJ0RGQwL0JvY0U2N254dzMwZ1lLRXJSbGNyS3lzTjdqK0tLR0psSDY3V3FFQmNPajA3b1JYeXVsY3ZuWVRFTUkvSEdkOTZNQkVHejBZUVRMTXJnV2ptZ09adEtvWjZPWjlNTnkzWVBSQ1V5ajFWcjFYeTVFSGpPNmZFcHBQVDA5QlFuc2gycmRYWnVwT2plTFFoREtwbkk1NUxENFhUMzh1NTBQRzYzT2pBSVhaaStRZ25VWUd0N2RYT2pZbzhuaFdJbW04dC84TUVIQUgxY0V1cm5WVERIOGtwbDdzOTJydTY1bGhYbkJQVFAzYnQzMGFoaXVhaUkwc0grTVpRRGZBbWNxTnZ0cnF5dndGZkIwSUFzR2lrZHZPdnhreWUyNnlXUzJZU2g2aW1TLzFuZ0NySTY3blRHY0MyU3llWmdBQVJEbXp6N3pNMmQ3VldvVE04WHJuL3lCMy9pVi85dVBJL3FrVXJBeU5NM0RUOVRsd3dYSVRnWVd0Z3YrM2thS0oxU0NIQlBzM3lZaThWREFXSnFmWmxDcFJQYzZBdUNIUUlOMlFINlJHRzF0TFUzYnA4RTFvU0x4VjNpeVFxY2JTK1l3Nk1Rb3hGUmlHMXRiTWo1eXVqUnQ3VE11aVVsYVRvQUNselc5dW5QaDRHcXlENTBab3F3VTVOcW9zcUV0YU9kTEhBM3JsNkR2Z1RSN25mNzFwaGU2QVVlTmV4MWJsNjd0UEFqanVzMk9wMU1LckZhTEkxSDQ1RTE3ZmI2Zkp4SEdUQUkyV1JpTWpWZFVIemQ2RFJiY1puV0R3aDhmOUFmd0ZXaVZYTXQxNXFZTUFXMlRUTkRVSEd3OTBReUNScFF5R2M3N2E2cTArcDI4Q2dCUWJTY3ZZWTFJb29DekRUNGQzODhMT1h5eVhTVzR5SWc2TWVISi8xZTEvTmNzS2FUazNOQUJHM2EyRmlGZmM4Vjh1ZytTQjNQY1FEVG9EZEdDeVZCeUJnYUxQV2NSS0xlN3JSdTNyd0I2Z0xwYXJYcERWQndMZUl4RHBJQkZad3c2Tmc0clVqc2RmdEQyelJiOWVaNGJQWUhnN1cxRlhNOHpXVnAwWFM0dVlWaWJreExkNERJMGZzZldjM3Bsdk93MTh0bGMvMTZlemdhblZScnNFaUdwTFhxclVLbHZITnBiekRzSEQ3ZUw1Yks0RGVvNTluWkdTeGdLcFgrNWplL2xjN2tUTXNFU3A0OGZwSklKR0c0SUU2cVRtdnZwSFQ5Zy9mdmduUkIzczVPemlDbU9EV01iYlBXS3E2dndaa2ZqdUhRMEF1Qi9NVWNJbkw5NXNmYXByRDcwdWQvN3YveEQ2NTg5bk84Umd2dFlxeVhlR2YvaEFDR0J2b1FlQmdjYUJmaEl3d01Lb3p5VW1DQVk4SVNIaFQrZ3E0aU9jeEprUXM1WXYrc05Jb1IycEhNRHFiRDVFeGg5ZEp0cTNteWNLYzBUOG56MHJxTytrZm5DOWR6NUVna2xjOFYxNitPUmsxdGVPYWxkbHhlQ2c5RldKN21UNFN3YmZpbHM3SDY0SmVkUEt4T1dCVVNlWGdSTjI3Y0dFL3BoY3R3czh5SkNXeUFrQUI1a1VWd2ZsNkhzbkg5MmVGNVRkYVVScVBWN3ZiR3BrbW80amxSbEJHSDRteldtL2xpVnFlbmN2cUFJS2cyRkp0dDI1bGM2dllMTDNiT214RXUwdXYzNlNiSXhvWnVKT2pHa0JDSG9vM0ZlTEFUOXRnMVVSL0VKVTNsSTFISUZWU1ZBd1J3c1d3aFV5aGtEZzhQRkZscHRWcURBUkduV3JXNnZiTUp3NTB2Rm9BRG5vOERFR0RqbVV3cW5VNjV0bm45K2g0MFhFS1RVcm1NdjFpazA4bnQ3YTE2dlRVZTlUTzVkSVNMNVhLRjJ1a3BWR2F1a0lYc2dUMWpVRStPRHVGS3B6SXBjQjY0dk9CZGwzYjNUcXUxUkVLRml0VU1PY3JSbXhiWmpORVkzZVZsczVIaEtwZktPYlFDcms1aGRTVVdsK3ExMnNwNnBUOFkzWDd4NXVyV1JxdlJHUTM3RHZRNnlCTUhUYkdBM3dBVGQzWldYU21EZEVYRHgrcHlGRExENGFDUXkwRmlwNVlMTnBMT0poNDhlTEJhV1ltRHdNVzRXcU5kUGErQmkwbjA4dGZJd2ZIcDVzNUdiMENMVDhGQ3IrNjkrS1cvOVN1M2Yvd25Lcy9jZ2tjS2lvQVJYbUtCa01BZ2dKU0xHL1drRFNscCtXRVpnT3p3UTRlRWljc3YrcVVTRU1MaUFPTUxPV0JiSkVNNGtoV3o1Q0FzSi8xUUVRQWMyMTdFZFdQdHl2TXFQUzNoZyt0Q3ZTcXlTazk1Um1NS0g3VW53MGpFdi9YeUYvWS8rR01qd2szVG0zUVlLL2dpMFBZeWloZ3JuNm9Sbm9qVzVXTUorS1pUTHM4ZTd1TXVYNzRNbUVMVmdZY0lzamlaVE1HbDZBWk5zN04vZUtUS2FtODhpWERSODJxTjVnYndYQ3FSUkd2QVdJZ3BlclN5KzBhNWNuQjBCTmVUWG00S3Y3dlhBNk1wNXZPMDJDY2YzYjYwMisvUSt3VndUdGg3amxhTDlqdTlUcjVRaEZCeFVjRTJIYURIc3FieGVCeE1DR1NHRitKc1ZxRFRHdzZzcVhsNGRBQW9kMXFOZkM0REtnOWJsRTJuNGREQ1VMamVURlBrVVgvQUNieEh0ekRvZVQ5VmtTVmE3bWJNOHdKc0VXb05seHArZ2trTDlJMTlmMlpvOUlBNVNVWTZDYzRBTitPbGw1OS84K3R2ckt5dG54MmZvaTN3T1BPMHRFd2VCMWFyVlVqaTJjbDV0OXVIWnpHZDJsRG53VHdDTHhhRUI5MnB5eUxPb3RDTHdUZ29sS2x0SlhYMWpUZmV3bmtYQVRrLzZDNjRHNjEySHpMWmFqWmM5Sy92UTQrMG11MmQzUTFhWmNTRGFnNjJkN2ZQejJxd25JVmlnZWJoT2g3eU5Gc2RBRWNXSlJzR3lISGg2ZXFxY25vR1AwclVFM3ExV2dkUU5NMVlMWmQvOGovLysxLzhwVjhDendOSm82dkRTekFnUWxHNHpqVGdiT0FaZXBqbFowb1hXeGZwbENNTVR4UHBFNG9NbXZxUllwK0dzQVNteEovdUptU3hLTzFCWkE0UG1Ra0RneVU3UkZiVE85ZFc5cDdOSkZPK001VjFBOUl4bndkVGU2ckdvbkN6NHFKVTJiMWVmKzhQdGN5T282VHBlRlk3MUpGK0xzNkxnRyt5TW1IemlNNkVhWlNSblJXN1BwUktibU5ySzUwd1FEU2dZdWtCUFBac2tUbXhNcGtNZk1wME5nM2ZjV3R6WFpHVWRyZnZBRFNXUll2OFJlWlFRdERpSXdBb01xdVVLNnBHNEZNMEpadk5jVEdhZkJJWCtXUXlaVHV6RjE1NndScFBZSWhWVFVWcEFoOS9kUDlCT3A4emt1bDBOdVhSU3J6MEJCek4rY1dSOFRpQUMvY3hrODNTckYyNlhoWVpEUWVaYkVaUzZOR2t5NWQzZEFWc3BKWE1aTTVQemhkOFZPZUY0YUFQTFk1eTRJNnhTK3dXc0FqMWZINWVoU1NqWUtpU09WeWllYVRSYnB1VENiUTRVQXRMQ29FRWdYSTllL3ZTSmoyZUxVdWwwb29BWjFqa3diTGdUVUorVml0ckVoOGZqTVljRjVOcGZTODRnbEV3SlNPWlFQNVd0UWI4RGtiMExxZUVMbHU5WHFQVmEvY0hLNnVWY3JtWXllVlBUbXZ3ZDBHY3VxM3VyZHZQb2RPYko5WER3eFBJemZidVRyY3oyTm5ab2psQnJpZEs5TURiNXU3bXllRVpMQkxrRUdwbFphVW9pQktxT3JFY1lLS1NUUVdtRjh6bVR3NlBVbW13b2R4Z05QQm5RYXEwazc1OG5SbDJOdVJMVkNBZ1JoZWUyWkF6WXNGQ3VJKzJHRExvbHgxemNSaUVBbVhSaDZVc3dpTG9NaWJMR21yeDhFTTRKaXl4VXBoYVoxdjBPRHdya0RJeHdOTldtQkVmZXBXQWxraHY3T1czYnlqcFBEMnB3RXRtRUIzMHVzVzB6a1hubGMzTFEzc1k3K3dIK1Jzelh2aUlOTEpmUWpZN0g0cTYySEVSUHR4Rk1Ub2ZTNEoyeitmeUl0MTlYRGgwUldqQmMxR1ppMlowcFg1ZTgxMHZKZ3FYdHJZTlF5NFZDOVlJd3d3WnA3Y2VZQXp5Mlp6ajBtSi9QQ2QwT2wzb1Rod09EakJmQkpQeENLMmptMUR6YUs2WXplUXltcUx6c1VXTUZ4NCtmRGlQK3VzckZWcjRIaGpxZG9lRFlhdlQydHphNlBjSElCRXdrRExVc3dRNFNUQXpPa21STStpUEM0WHNISUxsUXQ3TWxkVThWQ25FWmdUUHdUUm5RVUIyVU5ISGs0bW0wVUl4M1RhdHNVRVBpMWlXVE03UUFwUkRab3RhS3JJR0R4V0VCTDJpcWxxMzM3ZE1laml3MSttZm50ZkJtRUd2MEtKbXE0M21BQ2lnV0JBTFdSTFJJdmdZc2l6QkZjYXVWRklmOVhxU3dKMDMycDNSQ0d5azJ4dXVGYkl3Wlp6STlVYlRVakZiS0tSbkFXZFpGczlITkVPdjExcjVRcTdUNmlSeStVUTZWYTgzSlNHK2QyVTNtVXA5OXp0dmFrbURFMkp3SWN5cEJUUVBhUVh3R2NULzVQUzBVaXd1Z29DVDRPaEhDcVVNUFhpYmh4U2R3ZXNRWlhyd0tpYVV2dkNmL3Mwb1crWTNERXZ2bEkweEczdENMbTAreGN4SFFwaUVEQ0Vzd2tENTJUYWxZSU4xQjdCTXZ5eGM3TC80V1o0cDNJMUlxRlBaaC9MUUR4a0krcVdzck1qSWd1UGppVlNpc3FYbFYxZXV2Ymo3c1MvY2YvQlc4K3hrZDdVa0tlTFY1Ny92ZlArTnBDaFBFMnNrSjJFSUMveHdtd0lyZEJrUW9hb3Vvd2pocVlqQ2NaLzc5Q2VUY2E3YW9VVXZSSTdQYWhMODAvRUVtbGdCWE1XRU1SME9zOW5VdUQvMEFyOC9HY04wRG9ZRHovVlN5ZFIwT3EyQXJVWmptV3k2ZWxhRlFRZUErcjBCWkFCR2dHWWV6V2RRbnBQSmlKNENjVDJRcFh3bTkvcnJieFJMQmR1YTZib1NqY1NIbzk2TUhvVWVBdWlCdjRBbmtDc1UwRm1PWlVkanZHMTU1NmZuSEIvNTFLYy9ybXNhbk1rQnZMUEpkSE96UXBQamFSM3FlWUh1R1FFWXNkT1RzMUtwQU1kZ1kyTWRvcmJ3QTlPbVNXT2FybWR6ZEVGRzRqbDZlWUVvTFlJRnFEWUVrbDZRSkFtR29ZTmN1VFl0bmc1M0ZZVmIweEgwNjVNbmg5RGxpcWFCYk1EaEJ1NGhoTEJnOSs3ZWg3V1pUcWJvbHBTaGR2c1R1a0RwT3RWYXM1elBjM0s4Mnh0bE1ta1MwWG1rMysvTmc4WFplUTI4YStmeTVmR2dyNnBpTXFuSE9CRjZJWmRQUGJqNzhPWXoxMS8venB1amJ1L1NwY3M0aEsyOUV6MDlyZDYrL1V5dDJ0UU5HZFMyMmVtQjZ1YnlSUkVNVXBFU0JqMEpNTzcwTG4vaVIzL3E3LythVDFpbjBVVWlEUytpQktud2x3SURBS0dQTWZmbGgzYXpTQmlBU1J5THdCN1VXMjZSWWw0V2RJSDFpMFB3SGViLzhLbzhJRVU1bURabmUrZ1RIa3ZIVUFaeW5FUEloandKbVdOUktaR1NNaGtsazFtOS9OeDdyNy82Nk5Hank1dHJLNVhWaGFyT2FuZTR4TFl0cU1qTVRBY1pHanFPdmxpQUVuNWFFL3pnUTltVzlWeW1zMk80dGZWMUxpNkNqRVpqdE83WHBEL0tyVlltZEY5bm1pbW1NZmlEd1RCZkx0UlBHazlPajIzUEJjckJnQjJYRnFSRit5UlZOdWx0aHBQMWpYVWZoSnF1Y01jbFZZbEJoeS9tcG1uQi8rcFVHM0JxTCsxZWFkWHErVUttM2VpTnpFa3FtVTJtRFhwaHRDNWdnS0E0YVRZWTFMb2d3Nk1iRFllSlRBcTlQcHBPTCszc2pRZmpxV1d4Q1F0Z0xMUWVkeUtsZ21zSWNaRFZKTndHbUViNHJCLzcrQXRnN1lmN0IyQktnMjQvRmhkMHVLdlE4and0RTBJY1NkZUhvNUVmekdoYXZpeW5NMWxaRUJWVmZ2YTVTNTF1TDVsT3pXYWVyaHZ6eUd3eEN5cnJsZHA1QXd3STNnS015YURmZDJIT0ZndjRGdWxreHJTSnhaOVU2NFlrQk5FWStJd05taGZsaWl2RlpyY0x4d09FQ3FoOWNPOXhzWkRURThiWjBlbDRPcmw4NDBhdjEyblhtdTdFN3ZWNzVaVVZjTHgydXdkNERibzl1a2tMTHVmNXM3bUwra050QjhFc2tTQytoekh6WjVGZzVwVlhpbU56QXFXUXlhYlFTeC83dmgvODFILzJLN041akMyTVFhQ2swYjBBQW9OZnVNWFlCNlVzRlQvaElNeU1lUGh6RVo1bUlOZ3pKWXB5a01SS1l4aGFSc0lvaFZCMzRnK1FRRTZDMmpKUWN2aWhZeTdLcGRMb1E4eWF0aWxwV1FrdG1hN3MzSGovdTE5NzlSdmZqQzVtMTU1OS9zbjlkOHBTMUU1dXp5QlV3RUNZai8xQ2hsaENtUGEwZUFSVWdacDhrWm5PVFRDN2Vlc0dhTXpFTk5OWkEvbzFWeXFodDN1TnBzQno1dGdhZC92MC91OEZuQzNoNFBqTTlUMW9OS0FIaDNkN0dLUTVOTFR2enJ6WmJERG9GZ3ZGWHE4SDNROE9EWVVLV3d3MTFHNjFSVkgwM0ZseHBaUklwM3YwWU1jNkhOQWYrcEVmZ3BmMjZoKzh5aTM4YjM3ajI0VlNRUkNJeGVRTFdUYXB5M2ZOS1R3Mm1wa29jNmxVNm5qLzFITTh5NkczSk5DVlRkUHF0b2U4Q0kzcjBCT3g5R1pRV3NJT1ZDZGZLSUNaMExNZElxMityU21pcHRLQ1pQMytFQjBBSGc4UWNYd014Q2J3M09Gb1hGbk5aZE02eURISVBWeUhScTE1ZGxUTlY4cG5SdzFOVDZhVFNkaUpjckcwc3JLaUNYS3YzODhWOG9JWWh5YU9jckZndmhoT3A1bHNydDNwWW15QjFuYTNOK2dOZkZwR2E5N3BEalJOa3lTNm9UenFkUStPVDFkV3lyQkQ0WTAyU0dDdjIwMW5NKzFXSjVYU0pab0ZGbE0wL2Z6MDVPVG9DRDBNQXd2UFdDSEpsT2dka1lrRXpNSmcwTHQ4YVEvcHg0ZUhwdVZjL2VRUDVhN2VwRmxpYUNycE9EYmtBQUcyYVlUREZNUVk4R2dudmhrTTJYKzR3ZFF5MjhjQ3haYmdvK01SYUM5bFlULzRNQmtJclFUVHROakJmQUpXSU10SlVFUDZoYkJRS25NamFjZkY5VXJhaFMwNmhNVW9QNkYzWVdRTDVlMmJKL2ZlZnYzYnI3LzkzVGZPVDg1dWJwWjBWWjNJK1ZDeDB6ODFrQjN6Rk5KVVo0cXpIR3dmaTZBdnNCRm00dGJYMW9GeXVubzRDeHJuTFhodWdpUlpZNHVMTFRoSnpHVnlSa0tqNWFEbytmbkoyREp4SEQzcXp0SGtXMEF0bjAvSkNyMk83T1M4M2g4TTZRbFJWZWU0cUNJSjBIWXVQY002bjB5bkNkMFk5bnV5S2lWemFUWUhPRGVQQkpQSmVHVmw5WjMzN3J6NC9JdHdWT0FIdzc4OFA2dTVyZ1dQTFoxSkVyNHQyelROUlN4V0xKWDlZQUVMTUJvUFgzenBPVVVVcDlNSm5CczRlYUR1TTM5MjgrYlZ4bmw3TnZObFVmQThPeDZuNjZIUlJWRE1wWUlaUFZsQ2I4V3o2QjBWNkNCUkZHeHdHemJMWUlwMGN5Skx5dGJ1cG1uWnp6M3piQ1pYTk0zcDFLU1hGWE1pbnlVeEhzQ29DeUp2MnpiWVR2aWdreHM0NkVram1Vb2FLcmcrcUpza2lXZ2R4TlZJSk1DMUFJazVyWTJzRDN2OXdLVjdWV2xOU2VRems5SFVCVDJmKzBJOE5oeU0rLzArTGFiSExTNWYyWVZmVWNqbGRDMUp0OEptczZsbEZ3cjVUcXU5dDdXMXRiTmhqcVpCaE5ZV1B0Zy9RSXV5cGVzLy9Ldi9GYjNKWkRub0dGWkNFaHRaQk5xOCtOQzRQNDBqaENxY3dSSEhzNFBEUURzdjRwU2RJWmdPKzVNRkEwUk1HZ0JlWXZRZjdsM0dLTk9IWWhDbVBDMlJtUXNrNER2OElMQkkrQmRKNUlycjE1NC9QN2pYUGEyaXEwUStzcG1USWxyRmlzdVVlU2tqNFVIaDcwV0VCV3pRYVVoMmlIMkZLYVRkVndwNWRCd3FCZjZ0YW1yejdCeG96bVZUTThkTjVyTzBwTzJZSnRsRlloejgwYW5sMEMxWWVvNEp2aFBzWnlTVHpEUTZuV2VldlFuQnJLeFdJTGtRWU95U1JRbTBCOFo5TnZjckt4WHdBWERaWHFmSDh3TFFEK2xxdC9vUUJzdVpibTl2R2FrMGhwQmtZekdYNCtMcHlibXFhZDF1enpBU0xqaUJaY0o1Mk5yZU9qdzR6dVV5c095eGlBL2ZtcGNWUFpXQ1N3QXR2Ylc5aWxaVTZHM29hQmI4emg3c0FNZ1Y2TFdpQ0pEZUdBZU1pcElpSncwRDhnT0Q0TEoxZ05Id1FqSGZhclp1M0x3c0Nqd2NjY3R5SHR5OVoxdjJlRFFhVFVabko2ZFFTNVZLcWROczI1WUpLRDk2dU45c3RPWlJPTEhCY0FDWm5keTRlUTArQU9ESmx0eVFQY2NwbFFzelNCN05QQTZTZXRLazJacUdyT2tyNnl2OVRxOTJmSUlSUUMrMU96MzRBNmhYT3FWUHBsWmt3Y04xejVYeTVVcmhnenQzNTlFWVhleUN6K0RNSkQ1MmZIeTBVaTd2SHh4TkhSUGE1NW52K3pOLzdyLzV0Um1iL1IrT01RdHNoRW1WVWlCY0VhaVdPY0psUlRGQ2lMUDlwR3RKU2JOQTJDV0k0RDg4amgwWlJ0Z2VkbGk0OVdGZ3NLWGZqKzVDV2xqbVVxcFlJR0wwZEdPWmpHL0tpKzhZNldCS0RJdEJaaldkS2UxZXYvL2E3ODNkK1hnMHZycXpwbkx6bWJFQjhRNXpvV3c2NENOQXB3UW1nbUVJWStFNXdremNlcWxNTDVZQjlYUmRPR1NnSEVESmVEZ1NkWTJQeFFpQ1VkNGNUZ3hOaVVkajBGN0RDUzFuQi91T3pEeThMZGhwU1FRSW9BaDcvUUY0anVlNTRVUXJLT1pMbC9ZNnpVNjMzd2M3eVJkejV0VE9yK1RucnRkc052azQzMnEyVStra0RoeDJPbEIxOEhRQmQvRFhWRG9OT2pNYVRuRTZWTG5iQm5ZQnZuR3hVSmlNeDlDeSsvY2ZjWXVGckNjZjMzc0FRdytIYnpnY1p3c1pETEk3YzNsT0FDbUgvb09DTDVSTHNxbzU4Q0c2dlhCcFlHaHlSZEU5UHdBZ3dLMGhKTTdVZkx4L29tdHlMcDlwdHJyVDRTQ3BKK0t5ck1UNGg0LzNnVm13bmthem1XYXZDb1RncjYrVWdBbmJ0U0V6aFVKcE1wblFLOWswclhyZWtEUU5CQXc5NjhBVEIrc1A1a0tjbzZXbVBHL2p4dlg3OXgvczc4TURPazFuTXVnMzE1L0I3NjgzMjVJb2dCTkNrbS9jZnZIK3ZYdXh4ZHcyblZhN0RVYWtTTkpHZVNVU0xBeERnN214Sitaekx6em5XYk4wT3AzS3IyOTgvSk9raVNnUXdsbUVnSVl2U2czQlFFa1hBODkrUW9DR2dBNEJFOGFYWWFsMlE3elNFU1FleUxERSs1OE15MFQyd3c2aHNOeThTTDhJYk5leUxtSEF1ZkJCQ2pNelRHU2VDZ2ppZWlMbFRrZk53MGRJOVdmZWpjdHJpNWh1U2FrbHpyKzNyREF3RWFZMi9JbHpzUXVwRWU3V2plc1JOK0NqRVY0UVJGbWsrVENqcVM3eEdPYVlQNGV5MUROSlhSUWNrKzZTS3RGWUF5NGdjQk9KcnBWTHhYeFMxZ3o0Y0drbzQxNXZPckdtMWdTR0RVeUFuUzhHM0src1ZHYk9iQXkwamtmUXhQVnFRNU1sY0o1NnZRbHVVQ3dWb1hlbjQwazBIbE5rWlRTQ0xHbkJuRlpQTHBYeWdlKzMyelR4aTR2eGRFMDlFaW1VYzAvdVArNE1ocUtpRHdiOTNkMXRPSmRQOWc5aERkQThsQStObXkya0lUbXU2WUJuYTdvMkhvd0tsVEs4aURrSDcwQmMrSE5hR29HOWdIYzRIQjBmbjZUVGROOStIb2xkdi9Hc0hFbDFXZzA0SThpMXVyVUJwMlJNajQzU2xHWm80czJOTmR2eFJxUHBTcmxRUGErQy9qVnBQbG5NTVBSTGwzWk9UczlSTGkxOWl3TzhHYkNPVnNBbnprSlFWTGwyZHRKdU5kRHRTTy8wZWdsYWFQTHh4c2FHWlpyRlFoYWVReWFYSG5UYXJ1MkE2V1h6R1FoTG85Rk1hL3I2NWpyUGM2UCs0S1JleFFpbk1CcndpTHJ0UkRhOTkvSFAwc3VvcWF0eHFxZDRwQWdOTGcwMy9STm1MekNJRDAwVVk2RDRFRmpoZ1IvQkdRc2YyV1JKRitrVW9Uakx6M2cvdGtuWUVGc2V3K0xoSGlJVExDelR3Mk9YbStGT2lySHJQOHVqbDBLSS8xaHNiZS9XcE44WTFzOGp3VHliVHF4azFFREoyMUdleEJ4blFFNUdiSEJpS2lnc0N5NXdqTXdiSzROU2tZZUtCOXhmZXVrRlZhZFZHa0d5T1o2RDg1VE1wckVISGlUQU1SNFIzWVVlUlJXc3lUU1hUTUx5N3ArZjZ3bk5zVDFBT0ZqTTRaVml0RFJkMlZwZGUvemtRSklrbkNPUjBIMzJpc2t4clZjZjFWUWxtVXd4L3NBUFIwT0FLWkZJSHg0Y3lLcE1EMXV3OXdrUGh3T1pYblFScFdkOFppNDRGV29PUGxNN3J4VXJSWmgrc0Fzb00ydHM3bDI1cEd2R3BEOEd1R3ZuRFJpK1pyTjE2ZkpPTEFxQ0k3dTI2OWd1N0F3OFJ6UWIzQmRrYmVxNFlCYm14SVpuVXF2WGdYV1VEMGtvNXJQMWFqMFM0dzA5a1RDVWJENzkxaHR2WEx0Mk9mQzg5ejY0NTFoV1BwZURkWUtJZ3FORGtWY3FaVGltc0RiZ0ZjUEJFRDczQUI3M2VETG85L2dZRDJhRG5wNzdjeTRXZ3h5aUg4Qy9iV3VhTkRSVUc0ZWcvS1NSZ0E4TlZZMjZEWWZEVkRJdHhubnlxaGV4WWpsSFRaRGl3RGRZNHRIUkNYeGkyekZielVaQ2xjZERzejBjQ1FJTUVteGIwS3llUC8vNUgxeUlDa0FSVW1RYTZEQ0VzZEEzcE1Gbm83NGtPUGhsRVVacXcvQVU5MkdndzBKNDBMVXdIQWw1Q1RPQURUSHNMQU5GVUQ1U21RVmdhZUhKdzMwc1F2SHZLVDg4S2d6TDlGQktjSnJ2elV5UldKeXZBUEh0MDdrNUFyTzlkdU9xSXZKRHpnaFlHVS9Mb2dQWnFjTXUrTjRHSVZEWjJNMUJFNHE2Q3NPcTBucWNNeU5wZEp1dEdCUndJalVlRGpHRWFqcXRKZldZeEVmOEJYVGtlaUVOME5SN0EwVVdERjNIZWJ5WnJ4dmFaRGcyRW5wQzBhcXRsdWV6QlhWMW8xUmFpZnFSWnJNQkJpL3ljWGNHeUU2Zyt4OCtlckt5dGhLTDhJMW1BK3BXRXVIaGNhN3JRR1ltZEh1U3orZXk5UG9OanQ3WmhMRWZEeWV5cHJRYnJYUW1WU2l0UUk3Z0gyYnkrZEpLd1I2YjdlN0E4MmVDQ0xHQzRlR0pXRUdCUjZPVzdhWlRLZGV5ZkhxZzFvYWtRVm9Hby9GcHRZcGlrWGw5WTdWY0tTWjFKYUhwbDI5Y2ZYai9zVG5wWHI5MmF6aTFhcWRua0tKTU9qbWdXWlpldmxDWWVXNndvR2ZQZ21DR25vWERtazJsWVFNMVJRTWJLWmNML1JIUmQ4Z1lpQ2ViNWU5ajVJQVhJSjY0SDl5VmJ1KzhXc3NWc25FK2ZucGFaZTcrL05uclYxUlJpaUlwTHRMVmdtckw4Unc0cndlSFI2MVdHOFJTNVBuZVlEQ1ptdGVmdVZhdFY4ZmpNWVp6TUJpSWNmbWxQLzNURVNGOHpRdjlBODh3MlV6aHNsRm5sL2tBYlJwbzlxRTBOdXI0c0Y4R2tXVXFDNFFNN0VXdEdaQ1lZU0F3THA2KzBUUThHNFdsQldGZnlNQnlobnZJSDZBOTdGQTZoSjBzeEhFb0xSOWltbnBvR1htYWh4S1hnVXJuSlduMThtMXZPb3k0RTBrUU56ZlhaZ3QrRWhFajZGWjJTbmFxQzdpenJiQUxubjZRRk9iaExtOXRRcWRDWjBjRldoWERtZmxrMmVlKzU5Z3F6eWR6YVk4ZVlZNjF6bXNMUHFaei9KdHZ2Zm5LeTllNWhSakVvek1IQU5WYzR2cURVcW1JUGxrRVBueklUcitucWpKWUxKUVdqalduNWlLNnFCVEx3OGxrYlcxMTBoOU5wbmE5VWYvMFoxNnloOU5VTnJtK3ZnYWZEZ1FibEJRMW9VVmtBTnM0OUJqNWMzRWtnWXJBNTBzbUFBaGF3RDVZT0lBZG5BY0loQ0E0amplWlROR2V0Zld0WnJPNm1FY2dmdkFSRlhpcDlJUmdEQ1FlUHhoTnNLTjZvMk1vNnQ3T25tTlBWVlU2T3pzTlpnSGNXQU9ld01NbjI3dmJjWmt2Rkl1T2FWa1RzOTVxZ21lMzJyM3Q3WFdNQkFZWTlVa1pHbEFGeHhkR3hMYmR0UzI0NHVYejgzcTczU1Vsd2hBMkQ0QjFkbm1RRGNnVUl1ZlBRTDFBY2xCVjNUQmdqaUIrYUZtMlFMWWl5a0hEaUVoLy83MzNEdytQVGsrcThFYWcvbUVxYVdta2FIUmlUaytyWnhJOEh2amNjVjRTcGVMT05TbXAyWEJxem82VDVWVTJuQ0hDZ1JWV0RUYjRpQzYzOFNFT1EwcWZNZ0hMbEJqaTRDbThLTEFqbGlraGhHZ2pUQWdMQ2dQeVVaeGxvWUxDSFhRc1RrMk9hYmlmSW1SQXd0MVI5bXh0cU03RENLVVR2Z240Ri9HbkFidFI3Z0lka2QrOHFva3lOM2VUMld4R2w0ZCszS0h6ZkhnYXFnOXloMGVqa0tmbm9GTXZVN2xQZlB3NVhveTdKcTA0NndZV0Y0MFY4Z1dCNHhWZGk4VVdJQzJLYnN5Q0djajkwZUdKYktqWGsxS0czcGdWYmJYNmFsSXJadE8yYVVIWGpjZm1QRXJ2YjZpc2xSdk5ydS83c0F4Z0U1b3NrMDRkRHRXazRWb2VYVXFuTmVoS2xmTHEvdjdCM3Q0dUw4U25VMHRVNkJJZTlDalFjSHB5bGl2bWFYM0dDSWROVkxQYjdnSVozVzdYYzJlUWFDNGVUeVFTOFBiQVl2czlXdGV6MzZkVk1UWTNOeGJCQWgxNmZITDg1T0N3MDJsbk1qa29mbnJ5elpzTk9sMGpuUUE1enVWU0lOKzVUTnF4elc1N1VHdDJraGxnempRTXBWbXZUVWNXU0YyRW96V05YWXRXR29PcGFMYmJVT1RwakE0SGRIVnR4VExCNFIyY3NUY2NIaCtmOHh3dHA5UHA5SWdRc210RDhOZGhhVVJhRnc2eVMyODZnV0JNSmtNNDlyWk5kNkRZcTZubWtNbDJwNk5wR3VoTHY5dWw5U0lkTjV0SW9nTHdIcUM4ZkZyc2w5NzlEU2NlbzFySVpqYzNOZ0FBU0VHM1ZiMzc3VmNiZDk1TTU4dWNBcW5BdU02bXJWTkpUVVlnMjJ4NGtaT1FmUkVQRXdoZzdJOEZRaHVMTC9PRW1TRVNURUVTOUpaRnNXL2t1TWlPRDFvYTNrT2xNbGtTaFREejhxUjBNa0NmTm1rSGtJZHM3SXR0VXA1UW83T3ZFSllYNEtROGxJdEt3WjhRbDNNVlBaRkJUMlNUaHNoSHUxNlUxRHM3R1JXSVBPekE4Q2hFMmNtWHNoQnVRTHV2eDBSQlZwUmhiN2kvZnp5ZGpvRVhMYUZQUjZZWCtPQWs1bWdNTDhFd0FGYXIybWdYTThtNExENDhPQzBtMDBCU1RvczZ0Zzh6UDVwT1pGR3B0OW9qbXJpaVF1OUJZNEhzcm05dHVxNmJTbVc2UFpvU0NJaEN2Y0NQUzZZVHNxZzFhZzA5bFVSZEFDQjZMcFp1MXNicDlaRXpnR01LbGduME9KWU5zd1dsY1AvdXZkMHJsMWRXVmlCRjlGNC8xK1hpL1BIaDhmcEdPWlZLb2JtOVZoTUNvQU42bXQ3ckQ5SXBlcTBBRzRFRnZjU20xVGs4T2dGZUFUVlZWY1M0QU4vRFNCbmQ3bkIzWjN2WTYvVGJuWVNXOEtPTEIzZnZ3Z0tBT25QUlJTR2ZnUm1obDQ3TXZCeThHbnByckNURzQ0dUFYa1ZFejVpTFVxL1hSK3ZnMzhLTVFLbWowMEZONEJ1ZytxZzNsSDB1bHdPQ3NaMVFkWkhqY1ZTbzdIaEJRQWE0TklhcXdrK1lqRWFGZkxGWXlJL2d2UVEwQ1NPeW1BdUNBTmRJbGVVWG5ydU45dUxUNmZaY3o4MUNSRTFUVTVUVHc0Y1B2dlo3ci8vMmIzencrLy91OUszWDlwNzdHSzhsTWRnTWVRUUhGc2ZaMkQrTDBUYlQ5S0hlWThpbS9ld0FGbVBvV0tZQ01YUVlmVkhheFRkTkpHYlI1ZWNpTFBPRysxZzZ6Y2o5TUF1bEUrQnBMM1hETWhQVkJlSGkvUFJoZXlnbkF6TE1laXptQzJvZ3FoaitvaUhiODloNFJnMmtUUFJOUjFHaEZLT0F4ckhVRHdQM1RDSFhxaldEU0dCUG5Xd21DOC9yOVBSYzFtUUZSRVFDVmlJWVZWR0t3MlpHblNCZkxzRG5PenpyZG13M3U1RTJtNzJ4NTNyUmlPMTZtcW9PUnlNTUI3ZzJVQTZDQkRVMmM5MlQwMVBmOTZEL29KL0FNZWFMQUdyU2RoeVppNllTR2oxaU9SNVBwdE1jdllzWXFsUTJERGlSSElZWjdGd1NKTGluWU43MFRpeEp6R2J6a2tMdnFkUTFGVmJlY2h5d21ucjF2SDFlZTNKOEROVU9DZ1p0bUMvbDRRSnVia0xNSEp3WGdqZUhlbTUxVDg1cHhlcHNKblYrWGtzYmVqcVRoaElUNHRFbkI2ZXFMb0h1Z0dWSFpSRytxV003K1VxNWVWNjdlZU42b1p4Zlg5KzRkKzhSRkRJWVJUQmZDQktmTCtUQnpIdGRlbUVPcXMveGhIS2EwY256b1BpZ1luTndkOUtSd0JTb1NBVHNFeUN1TjVvd0NKYzJOMmZPYkdMWnNTaW5HRHJnRG91cUtyVEdKZFNPQTdvVHpQSmx1ai90ZVE0SzhIMWZpZ3ZYcmx5Snk5Sm9QSlFsWlR5Wk5GdHRJQjd0UXVmVXprN2xHTitvbmhVektRencrY0hqRzUvNi9EeEMxK05EOVViRGo0Sm82R24wUThaRGVHWXpXMEtFTU5TRVVBc0RwWklQdXR5aTZ6bHNGeDBiZnJPOGRBUkYySm5DVk1yQWR0R0g5dUh6dEJnNk9JeXc2b1Q3UC94ZUhzWmk3SnNsWE9BWHYwRTA2aTQ0Yng1VHVIbE9rK3MyUFJHMEROOTc0Tk9BN2FkSjNLZDJOc0JJWmpHeFhLbFVHNDNWcmRWY0luTnljakt4VFNna3k1eXM1ZlArb0IvOC84djYwaWJIamZSTTRpSnVBcnpKSXV2dXF1NGFxWFc1TmRKb2QyTEd1ek1Sbmc5ZU8relkvZVl2OW43YkNFZjRoL2xYT0dKamR5M05qS1RwbGpSZDNYV1J4WnNFaVlzZ0FIS2ZONEdxbHNKWkxDRHp6Uk9aVDc3NXZDQ1lrT1dGQzBKaXVRNXRxeUtKOHJjdkw5ODdhcjk2ZlJlR2NSQnRFbTVicjFaaEJVQWxvL1BvV2ZEdEZtczNiWXJrdWl0dkNaN2pPc3NwR01ab0JMWFU2L2MzY1hDdzN6bHROZi92bDMvd3dvQytGZklEbU11TG1RTzlDTXhKOUMxbWdDR0ZQc1hrd2VWNG5vc0NzZlJEUTZOenQrdE5TNVZMUXNFd3k3QUhiU3daZG5reG53TndnZThWd2R4cHF6TXNBOG5ld2RHZlhuNWZxNVdBa0ZxbER0eGNYMTJQSnVQemkvTS9mdld5dWRjczJ6YVpMc0c2M3FwSGZnalY1Y0dHNFFxU3VQdmpsMStYcTVXRC9XNVJWb2FEQ1lpNElBdWRnM2JvQm1BWW4vL0ZSNWl2czlrQ014bThCYURCdkJYRklyUThLa1pYUXdmNm51ZlFzeFgwK0RTbWVydFJReUcwdXl3U1lmQjN1NzEyY3pDZTBONU1yMTVpY0w3NzRYVklDZEtpVEE4VTdYZTdtTjY0RG5ybFdCZ29LdGxGN1hhVGR1TDNQSmdUc0ZJWVhMamJmdDhaRDVIbDZLTlBNUXJzVGtvR0wzWmdhWWpVVTJyaTAwekFTQW1MWk1mY3l6SlJrQWd5ODJSRnNFUUFIakxUTVU5UENiSXdDekFaS1hYeXMxeFp2a2RIaGJIRklVOU5UQ1F2UDRza0J5K1Y5M0Jram5ramp2TTJ1NFplWE1HS2l6TXhzZ01SVkJaVDZmUlB0SklpM3puaHYvenlGNmtvRGlhTGFCTU9ld052RTNiMjk3UUNQYTRMYTh0ei9NdnJ0MXBSVEtKdHNGcnZCQUZRNkxRYmhxcGI0UFdXdm82U0ZVWkZLZGFBQ04xd2hoT1FnUUs5djREMmprUEZXSk5CUE1JSUp0b0tRbFhWYWphNHFYaCsvdlRxNnZiNnRtZnZ0WTg2M2ZuZEtPRXdINXh5bzJaWkpWQUJOTGgvTjRUeU96ZzVBRnNBRjFpdlExVlJZWnRpUXFlRkxYUThGMGRyMTRYRkFIWG9ybUV4dTVJaVFNV3J1clp5bGttOEFhc0JxZ0F5WkllK2hPV01hMGFMWVBOMURnNUVVWUhGY25KODlQcUhOK2ttbHNUaStYdm52ZHQ3MWRDZyt5ZERldHFITHdwN3plcGl1blNDMVg1M2p5c0ludXNPK2tQZmQ1TWtYVytpU2syM05HV2JjRjRZWVlhRDRRalE3bHZhUlJwMVlRb2xiQTkxQUx0aTIydGdGb3RkZ2lsWDFsUVphRVk3UWRpZ0hXelZ1TDI3Vy9rQjJDQkdPazVpaFN4OXFXU1llNjIycGhwdjM3NDUyTjhQb3hBOHA5bHN6cDFGMlM1bi9VeFBvbW9HcnFWYXRoZUw1YS8vN24vYSswYzU4cGdEOC9nUml1aVR5UmtzRUdTb29LaUhVKzdQME1MU3MrSVl1a25iTWhFK3VaeVZUcVNGSkRpd3lEekpvMjVuam1ZWXhWQWh1VU9TN01nQVQvKzV5ejFaMG96aWsyTXBveDIzakxiSmpxZm4xdk9rTENmTG4rV2s0N3RzNUlRa3BKLzUxR1d4R0VWV28rNzVtNTN2MWp2TmNwMFdYMVVVSitQRjN0SCtNZzVQbnAwSnNtVFpCbGxOZ3FDVTVPRm8xaHRPcHN0bHVvTlJhM3BZRU9nNzBYSUFpcklPd2FlaG56Uk5yMVpycURLS05wOSsva0lXaW54UmJIZTZxOVVTTnF1SVlZakRKRmpiamJJaXdmUWsvSUhibEd0bEtIVk5WMEZPME9RNGpvRkNESCs5V1Uvb1c2SzBnbHBDWDVIQnY5MjVGMEY1ZHc2NjlKUUt2ZXRHcFVWRjRENzQrUGxzNW9BQisrd0pHTnFZR2p4NEhmbUJYMnZXSGRBempqTjBFOVlFZ0Y2clYwSHJmY2VCWGRucjNXMjUzZWRmdkJpUDVudXRtdTh1WDcvdFRXZEx2a0FnVnRRaVNsT1Y0dG5aL21HN0R1c2JmUHJpK2M4bTR6bnJjR290WnVuRHlHMWhOMklPSUdOS3o4bFFDVDdNWEVtaWpSZ01zMWFyZ0o2QnQwQmx3UHlsZGhicGhiVTFRSG03ZlhaNnFzcXlZWllrV1FxRGRicExNZk50eXdKdlJQOGNIQnlPUnNPcVhiN3I5MDlQVHpSVkJXZDcvdEdudi82bi94VXphRElGekJ5REFLTTN1MXdIWm1ETU5Dd2xld0RhUXc2b3FreGZrK0prbWlzTHN4U01lMmRwa1lzdWxXR1ZGVWRhOXFjT1FxUmtPU2o5dzVsaWZ1UW9rTmVReTZraUNwR1V5WC9pdUdoYjJMQjdrUS9Gb0FsQU4wSVBKZWNSZElJWUZ5NVVqWEs0Y290OGV2THNhYm9UMm8wMktBY25DRGZEa2UrNUV2MVFXam8rUGZqKzVhV3VTcVArbmJ0eXpMSzFuTTAwUldzMjJrcTh1eGtPb29SK2pMTmNlWVBKZERLYmdvcWdBa1dXSS9xbDBqb013TzFoYnRFdXpBZUhCNzRmMUtwVkVZeEVGRXVXWGxKMVd4SzNDNGNUc1BpS0hqMW5aZ0x5QVBUU1dZSzV3RkNlemhiZGd5NXdYSzNYNXRPNVhTN1RjeSt5N1BwaHVkR0dTVjFwVkF4VDYvY0g3WFo5elY3MFIxWWcvYjRKMWNacHNvVVdCQ01DbzZEN0xWRUVkUnRIc0N6V2l3VzlLN1BYdTBkUDhieUloSXFoM056Y1lrR1FWUW02MkNxYk1EbnNjdFdaTHl0bEV5UWJQS1RkYW81bk15aGdVeTg2WUNkeGlrNEwxMkdhN2hKNnVRTTRERXdldWhlSmpvZDJrRFVOeXdzV090bzZrK2RoeHh3ZUhwUXN6TmdRTTJFeW5oUUVmamdjc1cyT1k3QkJqSmNrOFVmMFlnTGtnQ2s4VzNsZTFhYTd0R0J5V0VIc1NuazJHTWtDYityNmNESnBOUm9XN1ppdzNqL290aTgrNjM3NkMvYVZMdHdER0RMdHpqNkUzM2ZnWVhoaWFDS1k1SnFVT1JLeEVJR0g0TXlVTHlSNUVvWXArakFQVHZrQ2tzZlNqR0FWUHFaaDU4ei9rSW9jRmZjWXpBMVc4dnhJK2hQSDhJd1Rhd2JOYVdvKzZzNEtwdFdEVlpNbEEvcHhacEdVV1BpckwxNUlKVjJwMWNaZUJPNnBHYktFNFZpdjNhVURiZHB0MW5sUnhKRG9zZ3FXc3ZhVDhXVG1qdWFybFZlSTQvNWdnTlcySUFoWW5hSFVRVncyYVdwb3BpRFJ2VVVNYTZWY0JxWTNNYjJpSzZiM2ZLN3BabUpDRHdNR1hyaUVHdmY4TkZodnd3QU05SFk0NmQvZnkwVUo2M1duMi9iZFFGVmxBU05xR1lBdkdBN1A4YUFRUUpVb3dMRGtzdDhyMFhPODlGWkFIaXpCOHoyRTFtSG9CNkZaTWpIVGNKbU5SZ01qQVkzTGNTQVZJbnJKb3BkMnhDSVBaaThCRnNDbExHdXdKWXBGTkZ5WWpjZGJ1cnZQTHgwWERVWS9qVWFMZHJlOW1reGRmL1hzNGtRVkZEN2RSdXY0dU51R1lyNzhjdzhMaUU1YndIS0xwUU9ERlJkTFBVM2RqMzZtRFFraHhNSVZCZlNsTXNZREYwSTBTZUFOWFVQZnpCY09tZzNKTHQzV3lqYm9mN0NPc1R3ZEhoK2hoMEQvc0pyYWR0V3FWS3JWQ20wTmdyVWpqbmhpTzhYQ2RuYzdHQ2lxSm9uSy9tRzNxR3EvL3NkL3djd21WREpzc2xGbWtDS1hlZW5ERkM1MElSMXpFazFCeExGOEVPZnBLUlZkUjE0ZVNlamVVKzVvQ2pCRTRmd1RwVTVGNWw2V20xeVdMSk5ReGl6bVhWbDBRQ1cwTURLWXNvSXpJZnZMWEg1bVplR2ZNU2tLWkVmV0RCU1Z0Wm1rV1d1emF4VDJqNC92SjQ0b1NzMTZDVE5sZm4zbk90UDFkbWVicGQwdUFWTmV4TkZvTmdXcWRtRjA4ZjVGdlZtekZiVmlWMHVWU3NyeDFiMUdBb3luU2JKTm1xMDYzYklzZzZHR1VKa3dMcU1vbEFUUnBZMC82ZDF1SUx1c0NienZlcnFwV3lVejlOeXlhVVJKQWZ4SDRnUkRWVzlHbzZvaTg2SHoyeTgrK1ByVlZialpLSXJhNlhSSGcxR3hLQTRHdzFxMWhxa0Q5WXhKZVAzMldsRkFrWGNoZTB1WkNOYk1pMVhhVnJkRWQ3NEw2ZUh4SVNiUEp0azBHcTF0dXNWeWI1Wkt0QkVDYllLd2xla0Y5aXJBK3Y2SDc2OFdyc2h6bUlLZ2NIYTFyTXRnRkp1RG8zM0g4WjQ4T1IzMWVuYmRjaFlyUWVNalhGZ1E3OFJ0dmFFMm1wWGpzNVBWYUc3cjVuTGxDOUFYT3UxN0NvM092alRGSE1QMWd0TEQxaWlnc29TOS93Zjl2c0hrMzZ5RElIQWNlcU1xTGdkRXExbXZBWVNxb2hXMlc2QmZaNXZpWTFuRXJJYVNYOGViMjdkdnU1Mk80enBTWWZ2MC9HenNPUFZHYzdKd3V2dGRnNXpwTy9PenYvenJ3Z1BjMmZBelRKQVA5Yko3SjlRQTBvZzBGaXd1YTFJbXllSE94RWdGRVdXaDlObDlIRXFUc1hGS1NJVlNiT2JKRUU5QnBHTWVTRmx0OUtGeXMxYmtFaXFJUEd6K1U3R1VnU1ZsY3ZKbUVoWmk0bHlPRTBQNVQ2WlkxaXFJSGdwQ2ZZOTlnQUJWS0hUSzVhcGw4SkUvdXU1UFFyOXNGZzJZUFpidEo0Vi8rei8vN3NWaFRkQ3VlL2UvK3MxZkdrWE5hdFdNY2tVdjZVdmZXNjZDWUJ2Z0FtYmppYW5LVjNmOWVKY1NhVWtTMS9XYnJRYllBa0RQQ1Z5Y3dBNGsreGx3eEJHalc3THNYdisrMys5ak1HSFd0U28yMm5YeFpOOVN4Y25VV3dSK21oWXNMUlcwV3FsYXBpL2dWYm5SYUs2OEFEekg4MXpNcU9YQ3diS1R4aWtZTGE0RkMxckpzZ0l2S0FqMGZTZUdhYm4wcFNMLzZ1dmZyOWRPcmRhbWwrZ2FCcW9HZ3hmRWdpRHlvOUg0dm5ldkdmcnR6WjJxaWMxNi9lNzIxdkZjZWhDZ3dJdEZ3YkNNWG04d256dVZtbmx5ZGppaUZ5ZWxQL3o1cmlncm9CdnhPcjIvbTFScTlyZmZ2SkoxVFZTS0FFSzlYcDdPRjVabFhWeWMrejc5MkJ5ekRxWUdsRHJIMCs2dzFOVHNiZ3hYbU5QUG8raTJFYkFPYXhWNkhUR3J3SGRXcThPOVBheUFCbTNDUTVhQWJwbTZZUVp1c05mdHV2NDZnbzRvVzBtYW1KalYwY1lzV2E3ckFxYUtJaDgvLzd6NTRwZG9DZm96MDJvTW5vUVQ1cWNZZU5ndlRtbjQyWWRzTVNDRFVqQkpmcUF6Q2JNQUdrNUpLUVBMeERCS3NNdnZ2ait5aVR3dnpSaUk4eXpaaDZWakU0RlY5akFCSGlySk03TnNsT2h4emxCNjVtSEhoNVl5R2Z0L2NGa0J1UlNwSHFyT0xBb3FWdmpkaTA5U1ZkbTUvbURpdkwzcWc0WnV0cnY1WkJhRmJrUFZBVkpZalU5L2RqWjMzWUtpUUNlQnYvYXVicEx0ZGptYUFDdWJhQTN0TG9nN1V6ZnZCMk42SGpDaUJ3SURhUGd3dEd4VFZ4U01kQUJXUU84SGx0QlcvSUZtSE8zdjd6WnhxMVZIZFF2UE4xUTlqRmJQVCtvZkhyYXZiK2VXclY2K21mNzJsK2YzOCtpN1AzeGJWTVhwZEdaWjlGd1hhWEF1RllzeUZnMFFHK0FBWkxmZGJxeVd5K2xrYnBSVVRWY2FyUnJQNzc3NTZ2ZGFjVGVkdXFkUHp6RHBvV1ByOWZweVB2dit1KytUemFha0cxYXBkTnZyQVNYOTNqMEFpZm5wTGh4RkxLcTZvbXZhNEg0SXdzMEovR1F5K2VHSFM5ZjFCSjUreGxWSVlHSndod2NIaGlHVzY4Wm5uMzN5M2Jkdm96RDU3UFBQLy8zM1g4TW1HVS9tZDMwVVd3VHRodm1MWHNmU2lIem9jWkNXN080TkZpaEFISWdoVEdOOWlaUHpvOFBwWWdIWXdkcVFlVTdTVkZHVzVyUHBjYmVyR2haQTN0N3YzTjdlTEplTHFtbE1uRVduMWJwOC9lYkprNU5WR0g3dzBZY3dOclpSMkR4OVdydjRoR0NVNFJvdUgvTXNSQm94QXpISjRMSXB3WkprZ2tmYzV5NERGWXVuRHdHUWdFNk1BVUltb3p1WkxCR1RrUzFNQmJLNkVQMGpwREs5bXdkekQ1WC9DSGdtcFZPV2hENFpCMEVRaWpMWDIzbHM1cWNHd3JHNktKNitLNEFYMlI0dU12dmduenpDMy83cVJaV1BwdU9sb0duUE8rMmI0Umk2cnhBbllyU3A2M0pzYU4xSzFWMzVyNzY3bkRwenRBNzBkem9ZNlliYzduU0hnOGx3TUFZRHdTQWVIeHlFVVF5YXJlc2FqU05RS1lqenhSeXRVRFVOb3g2dFF4cGc5QVU3cHRzWWFGTjBWUlJsK0cxSnFwZk15V2dCcGdBRkpuQ2NacWo5UHMybzgvMXU3K3FxVkt1QTZZOUhJMmhIMy9NdnYzOTljM3RiS2huMWRrdFNaRmdhSUFPU0xJSWIzRjdmRFBxOTJQVXhjUDNKNUg0NEgvZjZ5OVdxM3F6RFZvN1hZZG15VkYyak4zRFQ3U042Ny9Ga05OdXMxMy94eWNmTHhiTGI3YXczUWExUlRiWlE4eHpNMzlDUFBDOHlUYjFxMlJ0NlI3SFdhRlZyVlFPVDRZZlgxMUhndC9lYVJhZ01WQzhvYnk4djBibWFia0I1WXhTd3NxbUtBdTBOSFFBa29mRmtSVEFmUEJ0SUk5b1pGRHp0N1BUMHpadXJTdGt1Rm90MnhZcGkyaXN6OEh4ZDFZQ3U5U2FkVFNZdzhkMzVuRGJ0NGVsV0xKcjZoNWZmYXFYUzJ6ZHZKRkI1VmVtY1hKU2ZmWXlScGxIUEhJRW05ekpzNU0rck1FVFNYUnJFUXdDaWdpWkI5QzR0ZzJKK1pvNHlzOW1RVHlkRUV1d0loQ3dxeS90b0hMSklPdEVCaWZMblk5Z0hmMGovenRHY3ljUXNOUVdZWXhFUGxJWEFSNHRKbmp5TFkvT0JYUVpiYlBKaXM3WmxtNFV3QVlYd0w2aGE4ZS8vKys5U0p6Qmo3NU5ENWVmMTBwZjloV25TTjN5Yk5CRjF0V09JOVdaRk5XdGYvdjZQalZiRlVNelpiTDUzc0NlcUtwUVY4RjF2TlUvUG4remkxRjBzYi9wOXUyeER2NE8vZ25adXQ3VHBiaEQ0Yk10c3V1OEFLd3QxNjdxdXlDQUZDdENnNjJyZ2duc0hvejY0cUhjMWNaYlFpTUlPNWtCUk43d29BcCtvTmxxenlkZ1BYRXdiekJWWWxtQ3I4OGswaXRaU2RrZFAwVDAvbUVQcHplZ0gxREJpOTQvMlJMb0ZTSytsaGdHZ0tmS3JQNzNhSmFrR3JTdUlYMzcxUjNmbHdlQW1IclZOUHZ2NEE0NlRqazRPeHpNbmpEZVlPTEJieHFNWkNBa1Vzd0Nyc2R1QllWdHZndmlaZzlFVThJWHB2RndFdTFTU0plbkowek5NTmNmekN0dTRFRVIyeVlTZVJ2L0dFVDM0Z3ZwSmpmTThmUVVCdmdMdWdONm5ZQXFFb1pHMlpXSEZ1cnE1UVJyYkx0RytERjZvcXlvdWJiZE5sNTdiYmpTQ2RhS3B5djNkN2RIeFNZZ1pJb3VhS3ZjR1dNOVdzQ1ZBbGk3T1R3UkprYXoyM29lZm9vSWNxWVRCZkx6aEh2Q1dRWjJPN0o4bC9ROVl6dzRNVW8rWUFXcFo4RWNPdVZrbEpBZlBZR2lqZkNTamxad1NaLzkwM1FnaklXck5FbElpY3BtSHlxRXpXem15QWtsS3Zxd0k0UGt4Z3ZhVVp4OU1BQUl5WmFkWlNKa1JvQXdVcEF3Z3VOUndrZ2dmblo0V25NdmYvUFlMdHcra3VZZnZILzN3ZWxFNzZCUUxTVUhpZTcyUnY5bDBPazB3MTlGNDRxMGpqSUZxNkZqV0Z3dllXR21Gdldib3pkdEwwZFNiN1dwVnMzdy9rSGhlS2RETEMyREVvamFvTVdneFRBTU1jTVJlSkkwMUhRczZPSThvRXBzM0RFV000NnBHQnRZMmlyU1NEbWFsaUp4U2xFRjFLcFVLL1VJdDVyQ1krSUVuaVdLdDBmS1dNMW1nUnk4bDZNNGRGaEI2M2dIRVlEcVpLTEtJcHFxUzJPOE5NTk82ZS9YUVc4OFhEbFRqMGVFK3VxeldibW9GM2pKQWpialRzeE83WnFWY1ltZ3EybnQ5ZFlNV0ZpVWg5Q0pOTlNJL0REQ2xOcHZwZkQ2WnpOMWdKY2hpdFZhNXVycUR1YnJsNG5nWC91ekYyV0x1RG5yRDE2OStRTExuejUrcVVDR1l5WnRFMTFUWW1oaFpYRCtRZ0ZtRUpRL1h5NHRzeDZFZFBRb0VVNzY3MSs3M2gxZ013ZkZvejU4Q0Q5SzFXTTVoQm1oYXlUUXNzQ0pPS0s1OTcramt4QXNDclNpZzh6Q1RUanVkQUV0cVJLOFQ5TUtRVitTRDU1L2JUeTdZR05QbzB0aG45MVhvbjFRc08wUEdnRUFIcHV3WjFES1hKK0FJbXpsNFdWT1Jqa1d4UE9SaGNrclBUajkxa0RDczBYNm1PTEp0VVFtTkJGaXlGRmltSCtmTC9GbE5lZmdoT3NNdWllbWNTWmlRQklSdU5KNmFsa256RkZrcExBdVQwWm1TQ3YvcHN4ZGVJTHo5MCtYazNwOTQ0dlVpcVlvN2c5djk3MWR2RkZIUnVlMW5INyszNFFUSHcwaUl5eURFMk1neTNmK3FOR3F2TDI5d09WRVFjNXlTY29YUmFGSnYxd1ZGU2VMWU1MUnFoWDVidmZUOWVxMm15SEtjMEJOVUVYdnJMeHhHdXQxc0Jpc1BpbS90ZWhjSEhSbGxiUXU2eENlYkhTZEs3bWJ6NHRsUnloZXhVbXgyVzl1MnNlQXNGeXZNcFZaM3oxdjZnZU1NYUlNa3IyUVlBTkFDdXQyWmxjd1N0RjEzdjYzd0hOWW8vRzI1N2RNblI4UHhiUCtvTXhuUGZIb3BpTi9xN3ErVzNyWVErK3YxWXVYM2U4Tk5Fb05JeUFVT2JmWUN2OUZ1bE96UysrOWRTSHhCa09SeXVVeDNWM2FGK3o2bTBoeTI1WGc4QmVtNnZoNTk5ZjllOWZ1Z1dMdGR1aFdsSWhSdXJkTkF5SU85M215d0c3RDBUUmwxTzRnZzNkVk5kSU5lTVlsdWFEWWFJR2FCSCt5MTI4dmxFcXRpRGVyZE1JZVRDYlIreWJTZlBqM2ZiR01WUm5hYXdtUngzVldqMlFiQVc1WU9LeGZxQTRWM0R2ZGhEZmhZVGwzL1YvL3d6NUpsb1RLR1ZHcFVQdXhNQ2FNSlRKTEZaVEhrcUcwNVVISUhmT1hBb1FQNTgvUUUydnlEYkhTZ1lpbUkrRWNoQzFHeDdKeUZzakJMQzNFbWVYQlpIbko1ZGxZaS9hUDR4NlR3WkMwaENjUDVZejVXS2lzN3kwVWhGc2lDN0VNSmhJdmpZOU95Vjl1aVVkS2xrdTZHbTNhOU9uUGNENStjdk4rcFBEdHBDVUo4UDUwVmRGczJyVXExREphcGFIcTBTZnU5L21ycEZFWFpNTFhyMkFhakFBQUZJVWxFUVZUMllXZDRkNDlPTDFlcnk1VmJZOXU4N0hWYjNXclZDOElCdlNTajVLOThOZ3pBT2ZVUUZuVjN0UktMeFpKVlVrUjVNcDFJcW9ybHdFOHdycGd5VWhpbm5BZ2R3eFYxU1Nyd3Z1ZFY5dmJhaHdmdC9UM2EzdEV5MUpKKzh1UU1CTUZaT29vcUEyNTduWTVHTHhHeHNWeTB1cTErdnkvRHRFMXBFM2ZUTE5uMUNsaVN0M0FsU1FHNzJPKzJiMjU2aXFhRmJsQVVlTmpLczhsTXR6UTBEUHA4T0JyUFp3dlhXZDcxQjZXS2RYdDdDeHNVQ0lNZHVWNXZhSnVBVFpMR1dLTlNRTjl4d0tpWGdpaHVkN0RhNVQ5OTg5MTBDdk03dUIvY1o4KzAwRFZqa0hpT2Zxb05qRWIwZEpjc3l6QlM2UW81THRsRXNsVEVVdWlIYS9ybFY3a1NiM2QxV3pWMUV5cHhNQnh1b3JWQVQ5dHp0V2JsenkrL2tZV0NKb3E3dENESTJ0ZmZ2RXkzaWVmNzczLzJYei84bS8rQkVyY0VrcDhDS25jUHdvZllEQkZNR3pJTkNUOUZaUi82WjNDRGlJSndCTENIVHlhaUxPUm5SSVA4K1RtTGdhTkNVQXlsb1hJeVZzRm1UZTRlNTJUbVdDeE9lVHNRcEtRcys3czhwQmpmdVN4L2htL0dmV2dPVWozc1EzSkc2eEV0SEhUMzlrNmFTOGR6QWw4dUtRbGZWTVN0NTdqLyt1VWZNSkJmM3czU1ZPdlBQYnVtUThPNW8zbEVQK0RZM2QzMXgvVEtxdzhxRlRzSXc5N2RIVlRwMGZtcFhqSzVIZFJRWEc0MnBLSUVxdTNTcnNKOFFEOVZqc1VpdmZnWFN3OW9PMW9BZGZqRkp4L0JqaFFMc1k3QjV2bUtiVXFpZkRjZXlhWUNiSTJuUzhnVE4yeWJuQ3B1Qnd0d0dmWXFUT291dG91cW90UnE5ZWw0S2dvN05PUDY2dHFnQjVYOWFzTjY5ZlYzMDhrU25XYVd5L3ZuSitzMEhVNm1ZUkNjUHp1YnpxYXdSS0hPVysxSzU2RFI3VFoxM2JMTHBjUGoxdVhydDFDVEY2ZEhwOGVIcXFJZEhSMUVVZkw5NjBzbzBVeWJBcmpvV0hnd1lZb1NmZTJLSU5pamFacnBOZ1VMeDNTMjdVcXhpUFlIN0hzdWN1QXdLajNYRllLNkkwZ2NoajFSZzZIRzBvNTFUNUdLcDZjbkhDOUdtd1RGc3ZkWEprV09HL1dIZHJrNm5DM0NsU2VJdkdMcVBtajlObW0xMm1ObktTcUtHd2JucDRkelo0VVd2dmp0ZjJ1OC94RXFJQ2hrRUhqbkVNNUVSQzJZa2ljSlJ6WXQ0WkJoamtrb1ZaYVNzTTZnaG1DR0lEam14ei9MbkRtV2hzR2ZJdkxZQjVkRnN1T1A1S3lVUEFROWpTQktlNHpOWEhhUEUwbXpHUHJQV3djdlB1UkYzMmN4ekxIZnUxS1F3TTBrang3bXdPSi8vdDZKTzNCSHkrWEYwODU5ZitYNnJsYllqVmUrTE1tN2RMZmZiajM1NEt4YXJzOXZlbDk5L1ZJeTFBRHEydmUxb3RScU42RFhWeXYzNXMxVkdLN3Z4c08xNSttR3FKZ2F4NG12WG4yZjdNQll0eHpXL2RFRTFZSzAwTXNqcWF1M1o1MTI5bXVkdmJLNkNUMDBzbDIyQm82N2huR0hOaFY0bUo4VncxQlZwVlFxVlVybWFnbTlHZ1Zidmtqdm9VL1g2N1JrR1lPN0hpOFdvamdwMjlaOE52WThmK240N3NLNUg0NDEySTlKb1dTWGk2cG1Hc1ljSEg5RTM4VER5SlpFZnJWMDA4SzJmejljSjhGeTVZRTRXWmFCeWZuZHkrK0J2b3RuUDdPclpRY01UeEtnbTZISnA3TUZ5QklBQVNyQytJZ0F3d085QjFXZmZVMExnQUZ0QURIc1lGamdNOGZCakFKTHdRVm1aQjFSU1VLL055ZXpDdDJPRHFKaXhDSjlMY1p2NGxqVDljUGpJOUN3NCs1ZW1NVGp3YkJUcTRkKzJHbzNlVjBUUktuVnFrTkRvb2VEYU4zYTc4QW1CdzJMdDNIWk1BUitDN1BiQzliLytlLy9vZFE5UUh2UXp4a1lVUkhPVkdVR0F1WmhNNDVoaGM2VUxrdExmb0FGT2ZJRU5GU1pKNGM2SEVIeklmcWRCQzdiT1lQQ2RIaU0vYWw3aEhoZUlDc3NnenNFRDNWa2p0cWVOWTg1U2tsek1zdVhoUjlxZVN3V0RqNEtVTUxIdkErdVVQai8xMDRaRFFScnRub0FBQUFBU1VWT1JLNUNZSUk9XCI7IiwiaW1wb3J0IHsgUXVldWUgfSBmcm9tIFwiLi9RdWV1ZVwiO1xyXG5pbXBvcnQgeyBSYXRpb25hbE51bWJlciB9IGZyb20gXCIuL1JhdGlvbmFsTnVtYmVyXCI7XHJcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSBcIi4vU3RhY2tcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBBcml0aG1ldGljRXZhbHVhdG9yIHtcclxuXHRwdWJsaWMgc3RhdGljIHRvUmV2ZXJzZVBvbGlzaE5vdGF0aW9uKGNvZGU6IHN0cmluZyk6IHN0cmluZ1tdIHtcclxuXHRcdGNvbnN0IHRva2Vuczogc3RyaW5nW10gPSBjb2RlLm1hdGNoKC9cXCh8XFwpfFxcZCsoXFwuXFxkKyk/fFxcdyt8W1xcK1xcLVxcKlxcL1xcXl0vZyk7XHJcblx0XHRsZXQgaTogbnVtYmVyID0gMDtcclxuXHRcdGNvbnN0IG91dHB1dFF1ZXVlOiBRdWV1ZTxzdHJpbmc+ID0gbmV3IFF1ZXVlPHN0cmluZz4oKTtcclxuXHRcdGNvbnN0IG9wZXJhdG9yU3RhY2s6IFN0YWNrPHN0cmluZz4gPSBuZXcgU3RhY2s8c3RyaW5nPigpO1xyXG5cdFx0d2hpbGUgKGkgPCB0b2tlbnMubGVuZ3RoKSB7XHJcblx0XHRcdGlmICh0aGlzLmlzTnVtYmVyKHRva2Vuc1tpXSkpIHtcclxuXHRcdFx0XHRvdXRwdXRRdWV1ZS5lbnF1ZXVlKHRva2Vuc1tpXSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5pc09wZXJhdG9yKHRva2Vuc1tpXSkpIHtcclxuXHRcdFx0XHRsZXQgb3AxOiBzdHJpbmcgPSB0b2tlbnNbaV07XHJcblx0XHRcdFx0d2hpbGUgKCFvcGVyYXRvclN0YWNrLmlzRW1wdHkoKSAmJiB0aGlzLmlzT3BlcmF0b3Iob3BlcmF0b3JTdGFjay5wZWVrKCkpKSB7XHJcblx0XHRcdFx0XHRpZiAoKHRoaXMuaXNMZWZ0QXNzb2NpYXRpdmVPcGVyYXRvcihvcDEpICYmICh0aGlzLnByZWNlZGVuY2Uob3AxKSA8PSB0aGlzLnByZWNlZGVuY2Uob3BlcmF0b3JTdGFjay5wZWVrKCkpKSkgfHxcclxuXHRcdFx0XHRcdFx0KHRoaXMuaXNSaWdodEFzc29jaWF0aXZlT3BlcmF0b3Iob3AxKSAmJiAodGhpcy5wcmVjZWRlbmNlKG9wMSkgPCB0aGlzLnByZWNlZGVuY2Uob3BlcmF0b3JTdGFjay5wZWVrKCkpKSkpIHtcclxuXHRcdFx0XHRcdFx0b3V0cHV0UXVldWUuZW5xdWV1ZShvcGVyYXRvclN0YWNrLnBvcCgpKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRvcGVyYXRvclN0YWNrLnB1c2gob3AxKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0b2tlbnNbaV0gPT09IFwiKFwiKSB7XHJcblx0XHRcdFx0b3BlcmF0b3JTdGFjay5wdXNoKHRva2Vuc1tpXSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW5zW2ldID09PSBcIilcIikge1xyXG5cdFx0XHRcdHdoaWxlICghb3BlcmF0b3JTdGFjay5pc0VtcHR5KCkgJiYgb3BlcmF0b3JTdGFjay5wZWVrKCkgIT09IFwiKFwiKSB7XHJcblx0XHRcdFx0XHRvdXRwdXRRdWV1ZS5lbnF1ZXVlKG9wZXJhdG9yU3RhY2sucG9wKCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoIW9wZXJhdG9yU3RhY2suaXNFbXB0eSgpICYmIG9wZXJhdG9yU3RhY2sucGVlaygpID09PSBcIihcIikge1xyXG5cdFx0XHRcdFx0b3BlcmF0b3JTdGFjay5wb3AoKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBwYXJlbnRoZXNlcy5cIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGkrKztcclxuXHRcdH1cclxuXHRcdHdoaWxlICghb3BlcmF0b3JTdGFjay5pc0VtcHR5KCkpIHtcclxuXHRcdFx0aWYgKG9wZXJhdG9yU3RhY2sucGVlaygpID09PSBcIihcIikge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgcGFyZW50aGVzZXMuXCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG91dHB1dFF1ZXVlLmVucXVldWUob3BlcmF0b3JTdGFjay5wb3AoKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBvdXRwdXRRdWV1ZS50b0FycmF5KCk7XHJcblx0fVxyXG5cdHB1YmxpYyBzdGF0aWMgZXZhbHVhdGVGcm9tUlBOKHRva2Vuczogc3RyaW5nW10pOiBudW1iZXIge1xyXG5cdFx0Y29uc3Qgc3RhY2s6IFN0YWNrPG51bWJlcj4gPSBuZXcgU3RhY2s8bnVtYmVyPigpO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAoIXRoaXMuaXNPcGVyYXRvcih0b2tlbnNbaV0pKSB7XHJcblx0XHRcdFx0c3RhY2sucHVzaChwYXJzZUZsb2F0KHRva2Vuc1tpXSkpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBvcDE6IG51bWJlciA9IHN0YWNrLnBvcCgpO1xyXG5cdFx0XHRcdGxldCBvcDI6IG51bWJlciA9IHN0YWNrLnBvcCgpO1xyXG5cdFx0XHRcdHN3aXRjaCAodG9rZW5zW2ldKSB7XHJcblx0XHRcdFx0XHRjYXNlIFwiK1wiOiBzdGFjay5wdXNoKG9wMiArIG9wMSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBcIi1cIjogc3RhY2sucHVzaChvcDIgLSBvcDEpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgXCIqXCI6IHN0YWNrLnB1c2gob3AyICogb3AxKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIFwiL1wiOiBzdGFjay5wdXNoKG9wMiAvIG9wMSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBcIl5cIjogc3RhY2sucHVzaChvcDIgKiogb3AxKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RhY2sucG9wKCk7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIGlzTnVtYmVyKGNvZGU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIC9eXFxkLy50ZXN0KGNvZGUpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBpc09wZXJhdG9yKGNvZGU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIC9bXFwrXFwtXFwqXFwvXFxeXS8udGVzdChjb2RlKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgaXNMZWZ0QXNzb2NpYXRpdmVPcGVyYXRvcihvcGVyYXRvcjogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gL1tcXCtcXC1cXCpcXC9dLy50ZXN0KG9wZXJhdG9yKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgaXNSaWdodEFzc29jaWF0aXZlT3BlcmF0b3Iob3BlcmF0b3I6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIC9bXFxeXS8udGVzdChvcGVyYXRvcik7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIHByZWNlZGVuY2Uob3BlcmF0b3I6IHN0cmluZyk6IG51bWJlciB7XHJcblx0XHRpZiAoL1tcXCtcXC1dLy50ZXN0KG9wZXJhdG9yKSkge1xyXG5cdFx0XHQgcmV0dXJuIDE7XHJcblx0XHR9XHJcblx0XHRpZiAoL1tcXCpcXC9dLy50ZXN0KG9wZXJhdG9yKSkge1xyXG5cdFx0XHQgcmV0dXJuIDI7XHJcblx0XHR9XHJcblx0XHRpZiAoL1tcXF5dLy50ZXN0KG9wZXJhdG9yKSkge1xyXG5cdFx0XHQgcmV0dXJuIDM7XHJcblx0XHR9XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIFRva2VuVHlwZSB7IFBsdXMsIE1pbnVzLCBNdWx0aXBseSwgRGl2aWRlLCBFeHBvbmVudCwgTnVtYmVyLCBMUGFyZW4sIFJQYXJlbiwgRW5kLCBVbmtub3duIH1cclxuZXhwb3J0IGNsYXNzIFRva2VuIHtcclxuXHRwdWJsaWMgdHlwZTogVG9rZW5UeXBlO1xyXG5cdHB1YmxpYyB2YWx1ZTogbnVtYmVyO1xyXG5cdGNvbnN0cnVjdG9yKHR5cGU6IFRva2VuVHlwZSwgdmFsdWU/OiBudW1iZXIpIHtcclxuXHRcdHRoaXMudHlwZSA9IHR5cGU7XHJcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0fVxyXG59XHJcbmV4cG9ydCBjbGFzcyBMZXhlciB7XHJcblx0cHJpdmF0ZSB0b2tlbnM6IHN0cmluZ1tdO1xyXG5cdHByaXZhdGUgdG9rZW5JbmRleDogbnVtYmVyO1xyXG5cdGNvbnN0cnVjdG9yKGlucHV0OiBzdHJpbmcpIHtcclxuXHRcdHRoaXMudG9rZW5zID0gaW5wdXQucmVwbGFjZShcIiBcIiwgXCJcIikubWF0Y2goL1xcKHxcXCl8XFxkKyhcXC5cXGQrKT98W1xcK1xcLVxcKlxcL1xcXl0vZyk7XHJcblx0XHR0aGlzLnRva2VuSW5kZXggPSAwO1xyXG5cdH1cclxuXHRwdWJsaWMgZ2V0TmV4dFRva2VuKCk6IFRva2VuIHtcclxuXHRcdGlmICh0aGlzLnRva2Vucy5sZW5ndGggPT09IHRoaXMudG9rZW5JbmRleCkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRva2VuKFRva2VuVHlwZS5FbmQpO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGlucHV0OiBzdHJpbmcgPSB0aGlzLnRva2Vuc1t0aGlzLnRva2VuSW5kZXgrK107XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRUb2tlbihpbnB1dCk7XHJcblx0fVxyXG5cdHB1YmxpYyBnZXRDdXJyZW50VG9rZW4oKTogVG9rZW4ge1xyXG5cdFx0aWYgKHRoaXMudG9rZW5zLmxlbmd0aCAtIDEgPT09IHRoaXMudG9rZW5JbmRleCkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRva2VuKFRva2VuVHlwZS5FbmQpO1xyXG5cdFx0fVxyXG5cdFx0bGV0IGlucHV0OiBzdHJpbmcgPSB0aGlzLnRva2Vuc1t0aGlzLnRva2VuSW5kZXhdO1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VG9rZW4oaW5wdXQpO1xyXG5cdH1cclxuXHRwdWJsaWMgcmV2ZXJ0KCk6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMudG9rZW5JbmRleCA8PSAwKSB7IHRocm93IEVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpOyB9XHJcblx0XHR0aGlzLnRva2VuSW5kZXgtLTtcclxuXHR9XHJcblx0cHJpdmF0ZSBnZXRUb2tlbihpbnB1dDogc3RyaW5nKTogVG9rZW4ge1xyXG5cdFx0aWYgKC9cXCsvLnRlc3QoaW5wdXQpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLlBsdXMpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9cXC0vLnRlc3QoaW5wdXQpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLk1pbnVzKTtcclxuXHRcdH1cclxuXHRcdGlmICgvXFwqLy50ZXN0KGlucHV0KSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRva2VuKFRva2VuVHlwZS5NdWx0aXBseSk7XHJcblx0XHR9XHJcblx0XHRpZiAoL1xcLy8udGVzdChpbnB1dCkpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBUb2tlbihUb2tlblR5cGUuRGl2aWRlKTtcclxuXHRcdH1cclxuXHRcdGlmICgvXFxeLy50ZXN0KGlucHV0KSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRva2VuKFRva2VuVHlwZS5FeHBvbmVudCk7XHJcblx0XHR9XHJcblx0XHRpZiAoL1xcZCsoXFwuXFxkKyk/Ly50ZXN0KGlucHV0KSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRva2VuKFRva2VuVHlwZS5OdW1iZXIsIHBhcnNlRmxvYXQoaW5wdXQpKTtcclxuXHRcdH1cclxuXHRcdGlmICgvXFwoLy50ZXN0KGlucHV0KSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRva2VuKFRva2VuVHlwZS5MUGFyZW4pO1xyXG5cdFx0fVxyXG5cdFx0aWYgKC9cXCkvLnRlc3QoaW5wdXQpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVG9rZW4oVG9rZW5UeXBlLlJQYXJlbik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IFRva2VuKFRva2VuVHlwZS5Vbmtub3duKTtcclxuXHR9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFBhcnNlciB7XHJcblx0cHJpdmF0ZSBsZXg6IExleGVyO1xyXG5cdHB1YmxpYyBwYXJzZShjb2RlOiBzdHJpbmcpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHR0aGlzLmxleCA9IG5ldyBMZXhlcihjb2RlKTtcclxuXHRcdGNvbnN0IGV4cHJlc3Npb246IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5mb3VydGhPcmRlck9wZXJhdG9ycygpO1xyXG5cdFx0Y29uc3QgdG9rZW46IFRva2VuID0gdGhpcy5sZXguZ2V0Q3VycmVudFRva2VuKCk7IC8vIGlzIGFscmVhZHkgYWR2YW5jZWQgYmVjYXVzZSBvZiBudW1iZXIoKVxyXG5cdFx0aWYgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5FbmQpIHtcclxuXHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XHJcblx0XHR9XHJcblx0XHR0aHJvdyBFcnJvcihcIkVuZCBleHBlY3RlZFwiKTtcclxuXHR9XHJcblx0Ly8gYWRkaXRpb24gYW5kIHN1YnN0cmFjdGlvblxyXG5cdHByaXZhdGUgZm91cnRoT3JkZXJPcGVyYXRvcnMoKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0bGV0IGNvbXBvbmVudDE6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy50aGlyZE9yZGVyT3BlcmF0b3JzKCk7XHJcblx0XHRsZXQgdG9rZW46IFRva2VuID0gdGhpcy5sZXguZ2V0TmV4dFRva2VuKCk7XHJcblx0XHR3aGlsZSAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLlBsdXMgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk1pbnVzKSB7XHJcblx0XHRcdGxldCBjb21wb25lbnQyOiBSYXRpb25hbE51bWJlciA9IHRoaXMudGhpcmRPcmRlck9wZXJhdG9ycygpO1xyXG5cdFx0XHRpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLlBsdXMpIHtcclxuXHRcdFx0XHRjb21wb25lbnQxID0gY29tcG9uZW50MS5hZGQoY29tcG9uZW50Mik7XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk1pbnVzKSB7XHJcblx0XHRcdFx0Y29tcG9uZW50MSA9IGNvbXBvbmVudDEuc3ViKGNvbXBvbmVudDIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRva2VuID0gdGhpcy5sZXguZ2V0TmV4dFRva2VuKCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmxleC5yZXZlcnQoKTtcclxuXHRcdHJldHVybiBjb21wb25lbnQxO1xyXG5cdH1cclxuXHQvLyBtdWx0aXBsaWNhdGlvbiBhbmQgZGl2aXNpb25cclxuXHRwcml2YXRlIHRoaXJkT3JkZXJPcGVyYXRvcnMoKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0bGV0IGZhY3RvcjE6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5zZWNvbmRPcmRlck9wZXJhdG9ycygpO1xyXG5cdFx0bGV0IHRva2VuOiBUb2tlbiA9IHRoaXMubGV4LmdldE5leHRUb2tlbigpO1xyXG5cdFx0d2hpbGUgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5NdWx0aXBseSB8fCB0b2tlbi50eXBlID09PSBUb2tlblR5cGUuRGl2aWRlKSB7XHJcblx0XHRcdGxldCBmYWN0b3IyOiBSYXRpb25hbE51bWJlciA9IHRoaXMuc2Vjb25kT3JkZXJPcGVyYXRvcnMoKTtcclxuXHRcdFx0aWYgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5NdWx0aXBseSkge1xyXG5cdFx0XHRcdGZhY3RvcjEgPSBmYWN0b3IxLm11bHQoZmFjdG9yMik7XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLkRpdmlkZSkge1xyXG5cdFx0XHRcdGZhY3RvcjEgPSBmYWN0b3IxLmRpdihmYWN0b3IyKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0b2tlbiA9IHRoaXMubGV4LmdldE5leHRUb2tlbigpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5sZXgucmV2ZXJ0KCk7XHJcblx0XHRyZXR1cm4gZmFjdG9yMTtcclxuXHR9XHJcblx0Ly8gZXhwb25lbnRzIGFuZCByb290c1xyXG5cdHByaXZhdGUgc2Vjb25kT3JkZXJPcGVyYXRvcnMoKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0bGV0IGZhY3RvcjE6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5maXJzdE9yZGVyT3BlcmF0b3JzKCk7XHJcblx0XHRsZXQgdG9rZW46IFRva2VuID0gdGhpcy5sZXguZ2V0TmV4dFRva2VuKCk7XHJcblx0XHR3aGlsZSAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLkV4cG9uZW50KSB7XHJcblx0XHRcdGxldCBmYWN0b3IyOiBSYXRpb25hbE51bWJlciA9IHRoaXMuZmlyc3RPcmRlck9wZXJhdG9ycygpO1xyXG5cdFx0XHRmYWN0b3IxID0gZmFjdG9yMS5leHAoZmFjdG9yMik7XHJcblx0XHRcdHRva2VuID0gdGhpcy5sZXguZ2V0TmV4dFRva2VuKCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmxleC5yZXZlcnQoKTtcclxuXHRcdHJldHVybiBmYWN0b3IxO1xyXG5cdH1cclxuXHQvLyBudW1iZXJzIGFuZCBwYXJhbnRoZXNlc1xyXG5cdHByaXZhdGUgZmlyc3RPcmRlck9wZXJhdG9ycygpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRsZXQgdmFsdWU6IFJhdGlvbmFsTnVtYmVyID0gbmV3IFJhdGlvbmFsTnVtYmVyKDEpO1xyXG5cdFx0bGV0IHRva2VuOiBUb2tlbiA9IHRoaXMubGV4LmdldE5leHRUb2tlbigpO1xyXG5cdFx0aWYgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5QbHVzIHx8IHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5NaW51cykge1xyXG5cdFx0XHRpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk1pbnVzKSB7XHJcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5tdWx0KC0xKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0b2tlbiA9IHRoaXMubGV4LmdldE5leHRUb2tlbigpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRva2VuLnR5cGUgPT09IFRva2VuVHlwZS5MUGFyZW4pIHtcclxuXHRcdFx0dmFsdWUgPSB2YWx1ZS5tdWx0KHRoaXMuZm91cnRoT3JkZXJPcGVyYXRvcnMoKSk7XHJcblx0XHRcdHRva2VuID0gdGhpcy5sZXguZ2V0TmV4dFRva2VuKCk7XHJcblx0XHRcdGlmICh0b2tlbi50eXBlICE9PSBUb2tlblR5cGUuUlBhcmVuKSB7XHJcblx0XHRcdFx0dGhyb3cgRXJyb3IoXCJVbmJhbGFuY2VkIHBhcmVudGhlc2lzXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk51bWJlcikge1xyXG5cdFx0XHRcdHZhbHVlID0gdmFsdWUubXVsdCh0b2tlbi52YWx1ZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgRXJyb3IoXCJOb3QgYSBudW1iZXJcIik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9XHJcbn1cclxuXHJcbi8qXHJcblx0cHVibGljIHN0YXRpYyBldmFsdWF0ZShleHByZXNpb246IHN0cmluZyk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHR2YXIgZGlnaXRQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnMCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDcgfCA4IHwgOScpO1xyXG5cdHZhciBzaWduUGF0dGVybiA9IG5ldyBSZWdFeHAoJ1xcK3xcXC0nKTtcclxuXHR2YXIgbnVtYmVyUGF0dGVybiA9IG5ldyBSZWdFeHAoJ1snICsgc2lnblBhdHRlcm4gKyAnXScgKyAneycgKyBkaWdpdFBhdHRlcm4gKyAnfScpO1xyXG5cdHZhciBmYWN0b3JQYXR0ZXJuID0gbmV3IFJlZ0V4cChudW1iZXJQYXR0ZXJuICsgJ3xcXCgnICsgZXhwcmVzc2lvblBhdHRlcm4gKyAnXFwpJyk7XHJcblx0dmFyIGNvbXBvbmVudFBhdHRlcm4gPSBuZXcgUmVnRXhwKGZhY3RvclBhdHRlcm4gKyAnW3soIFxcKiB8IFxcLyApJyArIGZhY3RvclBhdHRlcm4gKyAnfV0nKTtcclxuXHR2YXIgZXhwcmVzc2lvblBhdHRlcm4gPSBuZXcgUmVnRXhwKGNvbXBvbmVudFBhdHRlcm4gKyAnW3soIFxcKyB8IFxcLSknICsgY29tcG9uZW50UGF0dGVybiArICd9XScpO1xyXG59Ki9cclxuXHJcbi8qXHJcbmV4cHJyOiA0dGhPUkRFUis7XHJcbjR0aE9SREVSOiBjb21wb25lbnQxPTNyZE9SREVSICgoUExVU3xNSU5VUykgY29tcG9uZW50Mj0zcmRPUkRFUikrO1xyXG4zcmRPUkRFUjogZmFjdG9yMT0yTkRPUkRFUiAoKE1VTFRJUExZfERJVklERSkgZmFjdG9yMT0ybmRPUkRFUikrXHJcbjJuZE9SREVSOiBmYWN0b3IxPTFzdE9SREVSIChFWFBPTkVOVCBmYWN0b3IyPTFzdE9SREVSKStcclxuMXN0T1JERVI6IChQTFVTfE1JTlVTfGVtcHR5KSAoTFBBUkVOIHZhbHVlPTR0aE9SREVSIFJQQVJFTnwgTlVNQkVSKVxyXG4qLyIsImltcG9ydCB7IFJhdGlvbmFsTnVtYmVyIH0gZnJvbSBcIi4vUmF0aW9uYWxOdW1iZXJcIjtcclxuaW1wb3J0IHsgQ29sdW1uVmVjdG9yLCBWZWN0b3IgfSBmcm9tIFwiLi9WZWN0b3JcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBNYXRyaXgge1xyXG5cdHB1YmxpYyBzdGF0aWMgYXVnbWVudChBOiBNYXRyaXgsIEI6IE1hdHJpeCB8IFZlY3Rvcik6IE1hdHJpeCB7XHJcblx0XHRpZiAoQS5tICE9PSBCLm0pIHsgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHR3byBtYXRyaWNlcyAodmVjdG9yKSBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHJvd3MgKGVsZW1lbnRzKS5cIik7IH1cclxuXHRcdGxldCByZXQ6IE1hdHJpeCA9IG51bGw7XHJcblx0XHRpZiAoQiBpbnN0YW5jZW9mIE1hdHJpeCkge1xyXG5cdFx0XHRyZXQgPSBuZXcgTWF0cml4KEEubSwgQi5uICsgQS5uKTtcclxuXHRcdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IEEubTsgaSsrKSB7XHJcblx0XHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IEEubjsgaisrKSB7XHJcblx0XHRcdFx0XHRyZXQuZWxlbWVudHNbaV1bal0gPSBBLmVsZW1lbnRzW2ldW2pdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgQi5tOyBpKyspIHtcclxuXHRcdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgQi5uOyBqKyspIHtcclxuXHRcdFx0XHRcdHJldC5lbGVtZW50c1tpXVtBLm4gKyBqXSA9IEIuZWxlbWVudHNbaV1bal07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoQiBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG5cdFx0XHRcdHJldCA9IG5ldyBNYXRyaXgoQS5tLCBBLm4gKyAxKTtcclxuXHRcdFx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgQS5tOyBpKyspIHtcclxuXHRcdFx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBBLm47IGorKykge1xyXG5cdFx0XHRcdFx0XHRyZXQuZWxlbWVudHNbaV1bal0gPSBBLmVsZW1lbnRzW2ldW2pdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgQi5tOyBqKyspIHtcclxuXHRcdFx0XHRcdHJldC5lbGVtZW50c1tqXVtBLm5dID0gQi5lbGVtZW50c1tqXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG5cdC8vIHJvdy1tdWx0aXBseWluZyB0cmFuc2Zvcm1hdGlvbnNcclxuXHRwdWJsaWMgc3RhdGljIG11bHRpcGxpY2F0aW9uKG46IG51bWJlciwgcm93MTogbnVtYmVyLCByb3cyOiBudW1iZXIsIG11bHQ6IG51bWJlcik6IE1hdHJpeCB7XHJcblx0XHRpZiAobiA8IHJvdzEgfHwgbiA8IHJvdzIpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ29sdW1uIGluZGV4IG11c3QgYmUgbGVzcyBvciBlcXVhbHQgdGhhbiBtYXRyaXggc2l6ZS5cIik7IH1cclxuXHRcdGNvbnN0IG1hdHJpeDogTWF0cml4ID0gbmV3IE1hdHJpeElkZW50aXR5KG4pO1xyXG5cdFx0bWF0cml4LmVsZW1lbnRzW3JvdzFdW3JvdzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKG11bHQpO1xyXG5cdFx0cmV0dXJuIG1hdHJpeDtcclxuXHR9XHJcblx0cHVibGljIHN0YXRpYyByYW5kb21TcXVhcmUoKTogTWF0cml4IHtcclxuXHRcdGNvbnN0IG1hdHJpeDogTWF0cml4ID0gbmV3IE1hdHJpeChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KSArIDMsIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpICsgMyk7IC8vIG1pbmltdW0gc2l6ZSAzeDMgbWF0cml4XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgbWF0cml4Lm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgbWF0cml4Lm47IGorKykge1xyXG5cdFx0XHRcdG1hdHJpeC5lbGVtZW50c1tpXVtqXSA9IG5ldyBSYXRpb25hbE51bWJlcihNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAgLSA1MCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbWF0cml4O1xyXG5cdH1cclxuXHRwdWJsaWMgc3RhdGljIHJhbmRvbTIoKTogTWF0cml4IHtcclxuXHRcdGNvbnN0IG51bWJlck9mVW5rbm93bnM6IG51bWJlciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQgKyAzKTsgLy8gYmV0d2VlbiAzIGFuZCA3IHVua25vbndzXHJcblx0XHRjb25zdCB1bmtub3duczogbnVtYmVyW10gPSBbXTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBudW1iZXJPZlVua25vd25zOyBpKyspIHtcclxuXHRcdFx0dW5rbm93bnNbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCAtIDEwKTtcclxuXHRcdH1cclxuXHRcdC8vIHRvZG86IGNoYW5nZSBiZWxvd1xyXG5cdFx0Y29uc3QgbWF0cml4OiBNYXRyaXggPSBuZXcgTWF0cml4KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpICsgMywgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCkgKyAzKTtcclxuXHRcdHJldHVybiBtYXRyaXg7XHJcblx0fVxyXG5cdHB1YmxpYyBtOiBudW1iZXI7IC8vIHJvd3NcclxuXHRwdWJsaWMgbjogbnVtYmVyOyAvLyBjb2x1bW5zXHJcblx0cHVibGljIGVsZW1lbnRzOiBSYXRpb25hbE51bWJlcltdW107XHJcblx0Y29uc3RydWN0b3IobTogbnVtYmVyLCBuOiBudW1iZXIpIHtcclxuXHRcdHRoaXMubSA9IG07XHJcblx0XHR0aGlzLm4gPSBuO1xyXG5cdFx0dGhpcy5lbGVtZW50cyA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbaV0gPSBbXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGVxdWFscyhNOiBNYXRyaXgpOiBib29sZWFuIHtcclxuXHRcdGlmICh0aGlzLm0gIT09IE0ubSB8fCB0aGlzLm4gIT09IE0ubikge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdFx0aWYgKCF0aGlzLmVsZW1lbnRzW2ldW2pdLmVxdWFscyhNLmVsZW1lbnRzW2ldW2pdKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHB1YmxpYyBhZGQoeDogTWF0cml4KTogTWF0cml4IHtcclxuXHRcdGlmICh0aGlzLm0gIT09IHgubSB8fCB0aGlzLm4gIT09IHgubikgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGRpbWVuc2lvbnMuXCIpOyB9XHJcblx0XHRjb25zdCByZXM6IE1hdHJpeCA9IG5ldyBNYXRyaXgodGhpcy5tLCB0aGlzLm4pO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHJlcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHJlcy5uOyBqKyspIHtcclxuXHRcdFx0XHRyZXMuZWxlbWVudHNbaV1bal0gPSB0aGlzLmVsZW1lbnRzW2ldW2pdLmFkZCh4LmVsZW1lbnRzW2ldW2pdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblx0cHVibGljIHN1Yih4OiBNYXRyaXgpOiBNYXRyaXgge1xyXG5cdFx0aWYgKHRoaXMubSAhPT0geC5tIHx8IHRoaXMubiAhPT0geC5uKSB7IHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgZGltZW5zaW9ucy5cIik7IH1cclxuXHRcdGNvbnN0IHJlczogTWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLm0sIHRoaXMubik7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgcmVzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgcmVzLm47IGorKykge1xyXG5cdFx0XHRcdHJlcy5lbGVtZW50c1tpXVtqXSA9IHRoaXMuZWxlbWVudHNbaV1bal0uc3ViKHguZWxlbWVudHNbaV1bal0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHRwdWJsaWMgbXVsdCh4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlciB8IE1hdHJpeCk6IE1hdHJpeCB7XHJcblx0XHRsZXQgcmVzOiBNYXRyaXggPSBudWxsO1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJlcyA9IG5ldyBNYXRyaXgodGhpcy5tLCB0aGlzLm4pO1xyXG5cdFx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgcmVzLm07IGkrKykge1xyXG5cdFx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCByZXMubjsgaisrKSB7XHJcblx0XHRcdFx0XHRyZXMuZWxlbWVudHNbaV1bal0gPSB0aGlzLmVsZW1lbnRzW2ldW2pdLm11bHQoeCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBSYXRpb25hbE51bWJlcikge1xyXG5cdFx0XHRyZXMgPSBuZXcgTWF0cml4KHRoaXMubSwgdGhpcy5uKTtcclxuXHRcdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHJlcy5tOyBpKyspIHtcclxuXHRcdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgcmVzLm47IGorKykge1xyXG5cdFx0XHRcdFx0cmVzLmVsZW1lbnRzW2ldW2pdID0gdGhpcy5lbGVtZW50c1tpXVtqXS5tdWx0KHgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKHggaW5zdGFuY2VvZiBNYXRyaXgpIHtcclxuXHRcdFx0XHRpZiAodGhpcy5uICE9PSB4Lm0pIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBkaW1lbnNpb25zLlwiKTsgfVxyXG5cdFx0XHRcdHJlcyA9IG5ldyBNYXRyaXgodGhpcy5tLCB4Lm4pO1xyXG5cdFx0XHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCByZXMubTsgaSsrKSB7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgcmVzLm47IGorKykge1xyXG5cdFx0XHRcdFx0XHRsZXQgc3VtOiBSYXRpb25hbE51bWJlciA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgazogbnVtYmVyID0gMDsgayA8IHRoaXMubjsgaysrKSB7XHJcblx0XHRcdFx0XHRcdFx0c3VtID0gc3VtLmFkZCh0aGlzLmVsZW1lbnRzW2ldW2tdLm11bHQoeC5lbGVtZW50c1trXVtqXSkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHJlcy5lbGVtZW50c1tpXVtqXSA9IHN1bTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cdHB1YmxpYyB2ZWN0b3JQcm9kdWN0KHY6IENvbHVtblZlY3Rvcik6IENvbHVtblZlY3RvciB7XHJcblx0XHRpZiAodGhpcy5uICE9PSB2Lm0pIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBkaW1lbnNpb25zLlwiKTsgfVxyXG5cdFx0Y29uc3QgcmVzOiBDb2x1bW5WZWN0b3IgPSBuZXcgQ29sdW1uVmVjdG9yKHYubSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0bGV0IHN1bTogUmF0aW9uYWxOdW1iZXIgPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm47IGorKykge1xyXG5cdFx0XHRcdHN1bSA9IHN1bS5hZGQodGhpcy5lbGVtZW50c1tpXVtqXS5tdWx0KHYuZWxlbWVudHNbal0pKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXMuZWxlbWVudHNbaV0gPSBzdW07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHRwdWJsaWMgdHJhbnNwb3NlKCk6IE1hdHJpeCB7XHJcblx0XHRjb25zdCByZXQ6IE1hdHJpeCA9IG5ldyBNYXRyaXgodGhpcy5uLCB0aGlzLm0pO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm47IGorKykge1xyXG5cdFx0XHRcdHJldC5lbGVtZW50c1tqXVtpXSA9IHRoaXMuZWxlbWVudHNbaV1bal07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG5cdHB1YmxpYyBkZWVwQ29weSgpOiBNYXRyaXgge1xyXG5cdFx0Y29uc3QgcmV0OiBNYXRyaXggPSBuZXcgTWF0cml4KHRoaXMubSwgdGhpcy5uKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0XHRyZXQuZWxlbWVudHNbaV1bal0gPSB0aGlzLmVsZW1lbnRzW2ldW2pdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH1cclxuXHRwdWJsaWMgc3dpdGNoUm93cyhpZHgxOiBudW1iZXIsIGlkeDI6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMubSA8IGlkeDEgfHwgdGhpcy5tIDwgaWR4MikgeyByZXR1cm47IH1cclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm47IGkrKykge1xyXG5cdFx0XHRjb25zdCB0bXA6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5lbGVtZW50c1tpZHgxXVtpXTtcclxuXHRcdFx0dGhpcy5lbGVtZW50c1tpZHgxXVtpXSA9IHRoaXMuZWxlbWVudHNbaWR4Ml1baV07XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbaWR4Ml1baV0gPSB0bXA7XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyBtdWx0aXBseVJvdyhpZHg6IG51bWJlciwgc2NhbGFyOiBSYXRpb25hbE51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMubSA8IGlkeCkgeyByZXR1cm47IH1cclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm47IGkrKykge1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzW2lkeF1baV0gPSB0aGlzLmVsZW1lbnRzW2lkeF1baV0ubXVsdChzY2FsYXIpLnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHB1YmxpYyBhZGRSb3dzKGlkeDE6IG51bWJlciwgaWR4MjogbnVtYmVyLCBzY2FsYXI6IFJhdGlvbmFsTnVtYmVyKTogdm9pZCB7XHJcblx0XHRpZiAodGhpcy5tIDwgaWR4MSB8fCB0aGlzLm0gPCBpZHgyKSB7IHJldHVybjsgfVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbaWR4MV1baV0gPSB0aGlzLmVsZW1lbnRzW2lkeDJdW2ldLm11bHQoc2NhbGFyKS5hZGQodGhpcy5lbGVtZW50c1tpZHgxXVtpXSkuc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGFkZFJvdzFUb1JvdzIoaWR4MTogbnVtYmVyLCBzY2FsYXIxOiBSYXRpb25hbE51bWJlciwgaWR4MjogbnVtYmVyLCBzY2FsYXIyOiBSYXRpb25hbE51bWJlcik6IHZvaWQge1xyXG5cdFx0aWYgKHRoaXMubSA8IGlkeDEgfHwgdGhpcy5tIDwgaWR4MikgeyByZXR1cm47IH1cclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm47IGkrKykge1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzW2lkeDJdW2ldID0gdGhpcy5lbGVtZW50c1tpZHgyXVtpXS5tdWx0KHNjYWxhcjIpLmFkZCh0aGlzLmVsZW1lbnRzW2lkeDFdW2ldLm11bHQoc2NhbGFyMSkpLnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vIGEgc3F1YXJlIG1hdHJpeCBpcyBhIG1hdHJpeCB3aXRoIHRoZSBzYW1lIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zXHJcblx0cHVibGljIGlzU3F1YXJlKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMubSA9PT0gdGhpcy5uO1xyXG5cdH1cclxuXHQvLyBhIGRpYWdvbmFsIG1hdHJpeCBpcyBhIG1hdHJpeCBpbiB3aGljaCB0aGUgZW50cmllcyBvdXRzaWRlIHRoZSBtYWluIGRpYWdvbmFsIGFyZSBhbGwgemVyb1xyXG5cdHB1YmxpYyBpc0RpYWdvbmFsKCk6IGJvb2xlYW4ge1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm47IGorKykge1xyXG5cdFx0XHRcdGlmIChpID09PSBqKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCF0aGlzLmVsZW1lbnRzW2ldW2pdLmVxdWFscyhuZXcgUmF0aW9uYWxOdW1iZXIoMCkpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0Ly8gdGhlIGlkZW50aXR5IG1hdHJpeCBvZiBzaXplIG4gaXMgdGhlIG4gw5cgbiBzcXVhcmUgbWF0cml4IHdpdGggb25lcyBvbiB0aGUgbWFpbiBkaWFnb25hbCBhbmQgemVyb3MgZWxzZXdoZXJlXHJcblx0Ly8gW0FMSUFTRVNdOiB1bml0IG1hdHJpeFxyXG5cdHB1YmxpYyBpc0lkZW50aXR5KCk6IGJvb2xlYW4ge1xyXG5cdFx0aWYgKHRoaXMubSAhPT0gdGhpcy5uKSB7IHRocm93IG5ldyBFcnJvcihcIk5vdCBhIHNxdWFyZSBtYXRyaXguXCIpOyB9XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGkgPT09IGopIHtcclxuXHRcdFx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tpXVtqXS5lcXVhbHMobmV3IFJhdGlvbmFsTnVtYmVyKDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbaV1bal0uZXF1YWxzKG5ldyBSYXRpb25hbE51bWJlcigwKSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHQvLyBhIG1hdHJpeCBpcyBub3JtYWwgaWYgaXQgY29tbXV0ZXMgd2l0aCBpdHMgY29uanVnYXRlIHRyYW5zcG9zZVxyXG5cdHB1YmxpYyBpc05vcm1hbCgpOiBib29sZWFuIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcclxuXHR9XHJcblx0Ly8gdGhlIGNvbmp1Z2F0ZSB0cmFuc3Bvc2Ugb2YgYW4gbS1ieS1uIG1hdHJpeCBBIHdpdGggY29tcGxleCBlbnRyaWVzIGlzIHRoZSBuLWJ5LW0gbWF0cml4IEHiiJcgb2J0YWluZWQgZnJvbSBBXHJcblx0Ly8gYnkgdGFraW5nIHRoZSB0cmFuc3Bvc2UgYW5kIHRoZW4gdGFraW5nIHRoZSBjb21wbGV4IGNvbmp1Z2F0ZSBvZiBlYWNoIGVudHJ5XHJcblx0Ly8gW0FMSUFTRVNdOiBIZXJtaXRpYW4gdHJhbnNwb3NlXHJcblx0cHVibGljIHRvQ29uanVnYXRlVHJhbnNwb3NlKCk6IE1hdHJpeCB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XHJcblx0fVxyXG5cdHB1YmxpYyBpc1VwcGVyVHJpYW5ndWxhcigpOiBib29sZWFuIHtcclxuXHRcdC8vIHRvZG86IGNoZWNrIGlmIGRlZmluaXRpb24gaXMgdmFsaWQgZm9yIGEgbm9uIHNxdWFyZSBtYXRyaXhcclxuXHRcdC8vIGlmICh0aGlzLm0gIT09IHRoaXMubikgeyB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBzcXVhcmUgbWF0cml4LlwiKTsgfVxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMTsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBpOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbaV1bal0uZXF1YWxzKG5ldyBSYXRpb25hbE51bWJlcigwKSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRwdWJsaWMgaXNMb3dlclRyaWFuZ3VsYXIoKTogYm9vbGVhbiB7XHJcblx0XHQvLyB0b2RvOiBjaGVjayBpZiBkZWZpbml0aW9uIGlzIHZhbGlkIGZvciBhIG5vbiBzcXVhcmUgbWF0cml4XHJcblx0XHQvLyBpZiAodGhpcy5tICE9PSB0aGlzLm4pIHsgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgc3F1YXJlIG1hdHJpeC5cIik7IH1cclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSBpICsgMTsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdFx0aWYgKCF0aGlzLmVsZW1lbnRzW2ldW2pdLmVxdWFscyhuZXcgUmF0aW9uYWxOdW1iZXIoMCkpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0Ly8gYSBzeW1tZXRyaWMgbWF0cml4IGlzIGEgc3F1YXJlIG1hdHJpeCB0aGF0IGlzIGVxdWFsIHRvIGl0cyB0cmFuc3Bvc2VcclxuXHRwdWJsaWMgaXNTeW1tZXRyaWMoKTogYm9vbGVhbiB7XHJcblx0XHRpZiAodGhpcy5tICE9PSB0aGlzLm4pIHsgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgc3F1YXJlIG1hdHJpeC5cIik7IH1cclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbaV1bal0uZXF1YWxzKHRoaXMuZWxlbWVudHNbal1baV0pKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0Ly8gYW4gb3J0aG9nb25hbCBtYXRyaXggaXMgYSBzcXVhcmUgbWF0cml4IHdpdGggcmVhbCBlbnRyaWVzIHdob3NlIGNvbHVtbnMgYW5kIHJvd3MgYXJlIG9ydGhvZ29uYWwgdW5pdCB2ZWN0b3JzXHJcblx0Ly8gW0FMSUFTRVNdOiByZWFsIG9ydGhvZ29uYWwgbWF0cml4XHJcblx0cHVibGljIGlzT3J0aG9nb25hbCgpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IE1UOiBNYXRyaXggPSB0aGlzLnRyYW5zcG9zZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXMubXVsdChNVCkuaXNJZGVudGl0eSgpO1xyXG5cdH1cclxuXHRwdWJsaWMgaXNSb3dFY2hlbG9uRm9ybSgpOiBib29sZWFuIHtcclxuXHRcdGxldCBmb3VuZFplcm9Sb3c6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHRcdC8vIGFsbCBub256ZXJvIHJvd3MgKHJvd3Mgd2l0aCBhdCBsZWFzdCBvbmUgbm9uemVybyBlbGVtZW50KSBhcmUgYWJvdmUgYW55IHJvd3Mgb2YgYWxsIHplcm9lc1xyXG5cdFx0Ly8gKGFsbCB6ZXJvIHJvd3MsIGlmIGFueSwgYmVsb25nIGF0IHRoZSBib3R0b20gb2YgdGhlIG1hdHJpeClcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5pc1plcm9Sb3coaSkpIHtcclxuXHRcdFx0XHRmb3VuZFplcm9Sb3cgPSB0cnVlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmIChmb3VuZFplcm9Sb3cpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdH0vLyBpZiBjdXJyZW50IHJvdyBpcyBub3QgemVybywgYnV0IGEgcHJldmlvdXMgcm93IGlzIHplcm8sIHRoZW4gbWF0cml4IGlzIG5vdCBpbiByb3cgZWNoZWxvbiBmb3JtXHJcblx0XHR9XHJcblx0XHQvLyB0aGUgbGVhZGluZyBjb2VmZmljaWVudCAodGhlIGZpcnN0IG5vbnplcm8gbnVtYmVyIGZyb20gdGhlIGxlZnQsIGFsc28gY2FsbGVkIHRoZSBwaXZvdCkgb2YgYSBub256ZXJvIHJvd1xyXG5cdFx0Ly8gaXMgYWx3YXlzIHN0cmljdGx5IHRvIHRoZSByaWdodCBvZiB0aGUgbGVhZGluZyBjb2VmZmljaWVudCBvZiB0aGUgcm93IGFib3ZlIGl0XHJcblx0XHRsZXQgcHJldmlvdXNJZHg6IG51bWJlciA9IC0xO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IGN1cnJlbnRQaXZvdElkeDogbnVtYmVyID0gdGhpcy5yb3dQaXZvdFBvc2l0aW9uKGkpO1xyXG5cdFx0XHRpZiAoMCA+IGN1cnJlbnRQaXZvdElkeCkgeyBjb250aW51ZTsgfS8vIHRoaXMgaXMgYSB6ZXJvIHJvdywgbm8gcGl2b3RcclxuXHRcdFx0Ly8gbGVhZGluZyBjb2VmZmljaWVudCBtdXN0IGJlIDFcclxuXHRcdFx0aWYgKCF0aGlzLmVsZW1lbnRzW2ldW2N1cnJlbnRQaXZvdElkeF0uZXF1YWxzKG5ldyBSYXRpb25hbE51bWJlcigxKSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdGlmIChwcmV2aW91c0lkeCA8IGN1cnJlbnRQaXZvdElkeCkge1xyXG5cdFx0XHRcdHByZXZpb3VzSWR4ID0gY3VycmVudFBpdm90SWR4O1xyXG5cdFx0XHR9IGVsc2UgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRwdWJsaWMgaXNSZWR1Y2VkUm93RWNoZWxvbkZvcm0oKTogYm9vbGVhbiB7XHJcblx0XHRpZiAoIXRoaXMuaXNSb3dFY2hlbG9uRm9ybSgpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0Ly8gZWFjaCBsZWFkaW5nIGNvZWZmaWNpZW50IGlzIHRoZSBvbmx5IG5vbnplcm8gZW50cnkgaW4gaXRzIGNvbHVtblxyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IHBpdm90UG9zaXRpb246IG51bWJlciA9IHRoaXMucm93UGl2b3RQb3NpdGlvbihpKTtcclxuXHRcdFx0aWYgKDEgPCB0aGlzLm51bWJlck9mTm9uWmVyb0VsZW1lbnRGb3JDb2x1bW4ocGl2b3RQb3NpdGlvbikpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0cHVibGljIHRvUmVkdWNlZFJvd0VjaGVsb25Gb3JtKCk6IE1hdHJpeCB7XHJcblx0XHRjb25zdCByZXM6IE1hdHJpeCA9IHRoaXMuZGVlcENvcHkoKTtcclxuXHRcdGxldCBsZWFkOiBudW1iZXIgPSAwO1xyXG5cdFx0Zm9yIChsZXQgcjogbnVtYmVyID0gMDsgciA8IHJlcy5tOyByKyspIHtcclxuXHRcdFx0aWYgKHJlcy5uIDw9IGxlYWQpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgaTogbnVtYmVyID0gcjtcclxuXHRcdFx0d2hpbGUgKHJlcy5lbGVtZW50c1tpXVtsZWFkXS5lcXVhbHMoMCkpIHtcclxuXHRcdFx0XHRpKys7XHJcblx0XHRcdFx0aWYgKHJlcy5tID09PSBpKSB7XHJcblx0XHRcdFx0XHRpID0gcjtcclxuXHRcdFx0XHRcdGxlYWQrKztcclxuXHRcdFx0XHRcdGlmIChyZXMubiA9PT0gbGVhZCkge1xyXG5cdFx0XHRcdFx0XHRsZWFkLS07XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXMuc3dpdGNoUm93cyhpLCByKTtcclxuXHRcdFx0aWYgKCFyZXMuZWxlbWVudHNbcl1bbGVhZF0uZXF1YWxzKDApKSB7XHJcblx0XHRcdFx0cmVzLm11bHRpcGx5Um93KHIsIHJlcy5lbGVtZW50c1tyXVtsZWFkXS5yZWNpcHJvY2FsKCkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCByZXMubTsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGogIT09IHIpIHtcclxuXHRcdFx0XHRcdHJlcy5hZGRSb3dzKGosIHIsIHJlcy5lbGVtZW50c1tqXVtsZWFkXS5vcHBvc2l0ZSgpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0bGVhZCsrO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblx0cHVibGljIGRldGVybWluYW50KCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdC8vIHRvZG86IGltcGxlbWVudCBhbiBvcHRpbWl6ZWQgdmVyc2lvbiwgbGlrZSBBPVBMVVxyXG5cdFx0aWYgKHRoaXMubSAhPT0gdGhpcy5uKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkRldGVybWluYW50IGNhbiBvbmx5IGJlIGNhbGN1bGF0ZWQgb24gYSBzcXVhcmUgbWF0cml4XCIpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMubSA9PT0gMSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50c1swXVswXTtcclxuXHRcdH1cclxuXHRcdGxldCByZXQ6IFJhdGlvbmFsTnVtYmVyID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubjsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IG1pbm9yOiBSYXRpb25hbE51bWJlciA9IHRoaXMuZWxlbWVudHNbMF1baV0ubXVsdCh0aGlzLmNvZmFjdG9yKDAsIGkpLmRldGVybWluYW50KCkpO1xyXG5cdFx0XHRyZXQgPSByZXQuYWRkKG1pbm9yLm11bHQoKC0xKSAqKiBpKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH1cclxuXHRwdWJsaWMgY29udm9sdXRlKGtlcm5lbDogTWF0cml4KTogTWF0cml4IHtcclxuXHRcdGlmIChrZXJuZWwubSAhPT0ga2VybmVsLm4pIHsgdGhyb3cgbmV3IEVycm9yKFwiS2VybmVsIGlzIG5vdCBhIHNxdWFyZSBtYXRyaXguXCIpOyB9XHJcblx0XHRpZiAoa2VybmVsLm0gJSAyID09PSAwKSB7IHRocm93IG5ldyBFcnJvcihcIktlcm5lbCBpcyBub3QgYW4gZXZlbiBzaXplIG1hdHJpeC5cIik7IH1cclxuXHRcdGNvbnN0IHN6ID0gTWF0aC5mbG9vcihrZXJuZWwubSAvIDIpO1xyXG5cdFx0Y29uc3QgcmVzOiBNYXRyaXggPSBuZXcgTWF0cml4KHRoaXMubSwgdGhpcy5uKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uOyBqKyspIHtcclxuXHRcdFx0XHRyZXMuZWxlbWVudHNbaV1bal0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRcdFx0Zm9yIChsZXQgdGk6IG51bWJlciA9IDA7IHRpIDwga2VybmVsLm07IHRpKyspIHtcclxuXHRcdFx0XHRcdGlmIChpICsgdGkgLSBzeiA8IDAgfHwgaSArIHRpIC0gc3ogPj0gdGhpcy5tKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Zm9yIChsZXQgdGo6IG51bWJlciA9IDA7IHRqIDwga2VybmVsLm47IHRqKyspIHtcclxuXHRcdFx0XHRcdFx0aWYgKGogKyB0aiAtIHN6IDwgMCB8fCBqICsgdGogLSBzeiA+PSB0aGlzLm4pIHtcclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRyZXMuZWxlbWVudHNbaV1bal0gPSByZXMuZWxlbWVudHNbaV1bal0uYWRkKHRoaXMuZWxlbWVudHNbaSArIHRpIC0gc3pdW2ogKyB0aiAtIHN6XS5tdWx0KGtlcm5lbC5lbGVtZW50c1t0aV1bdGpdKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBpc1plcm9Sb3cocm93SWQ6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tyb3dJZF1bal0uZXF1YWxzKG5ldyBSYXRpb25hbE51bWJlcigwKSkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0cHJpdmF0ZSByb3dQaXZvdFBvc2l0aW9uKHJvd0lkOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubjsgaisrKSB7XHJcblx0XHRcdGlmICghdGhpcy5lbGVtZW50c1tyb3dJZF1bal0uZXF1YWxzKG5ldyBSYXRpb25hbE51bWJlcigwKSkpIHsgcmV0dXJuIGo7IH1cclxuXHRcdH1cclxuXHRcdHJldHVybiAtMTtcclxuXHR9XHJcblx0cHJpdmF0ZSBudW1iZXJPZk5vblplcm9FbGVtZW50Rm9yQ29sdW1uKGNvbHVtbklkOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0bGV0IGFjYzogbnVtYmVyID0gMDtcclxuXHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm07IGorKykge1xyXG5cdFx0XHRpZiAoIXRoaXMuZWxlbWVudHNbal1bY29sdW1uSWRdLmVxdWFscyhuZXcgUmF0aW9uYWxOdW1iZXIoMCkpKSB7IGFjYysrOyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYWNjO1xyXG5cdH1cclxuXHRwcml2YXRlIGNvZmFjdG9yKHJvd0lkOiBudW1iZXIsIGNvbHVtbklkOiBudW1iZXIpOiBNYXRyaXgge1xyXG5cdFx0Y29uc3QgcmV0OiBNYXRyaXggPSBuZXcgTWF0cml4KHRoaXMubSAtIDEsIHRoaXMubiAtIDEpO1xyXG5cdFx0bGV0IHJvd09mZnNldDogbnVtYmVyID0gMDtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm0gLSAxOyBpKyspIHtcclxuXHRcdFx0aWYgKGkgPT09IHJvd0lkKSB7XHJcblx0XHRcdFx0cm93T2Zmc2V0ID0gMTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgY29sdW1uT2Zmc2V0OiBudW1iZXIgPSAwO1xyXG5cdFx0XHRmb3IgKGxldCBqOiBudW1iZXIgPSAwOyBqIDwgdGhpcy5uIC0gMTsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGogPT09IGNvbHVtbklkKSB7XHJcblx0XHRcdFx0XHRjb2x1bW5PZmZzZXQgPSAxO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXQuZWxlbWVudHNbaV1bal0gPSB0aGlzLmVsZW1lbnRzW2kgKyByb3dPZmZzZXRdW2ogKyBjb2x1bW5PZmZzZXRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE1hdHJpeElkZW50aXR5IGV4dGVuZHMgTWF0cml4IHtcclxuXHRjb25zdHJ1Y3RvcihtOiBudW1iZXIpIHtcclxuXHRcdHN1cGVyKG0sIG0pO1xyXG5cdFx0dGhpcy5lbGVtZW50cyA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbaV0gPSBbXTtcclxuXHRcdFx0Zm9yIChsZXQgajogbnVtYmVyID0gMDsgaiA8IHRoaXMubTsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGkgPT09IGopIHtcclxuXHRcdFx0XHRcdHRoaXMuZWxlbWVudHNbaV1bal0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMSk7XHJcblx0XHRcdFx0fSBlbHNlIHsgdGhpcy5lbGVtZW50c1tpXVtqXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTsgfVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBlbGltaW5hdGlvbiAtIG11bHRpcGx5IG9uIHRoZSBsZWZ0IChFKkEpOyBSb3ctYWRkaXRpb24gdHJhbnNmb3JtYXRpb25zXHJcbi8vIHRvIG11bHQqKHJvdzIgb2YgTWF0cml4IEEpIGFkZCAocm93MSBvZiBNYXRyaXggQSlcclxuZXhwb3J0IGNsYXNzIE1hdHJpeEVsaW1pbmF0aW9uIGV4dGVuZHMgTWF0cml4IHtcclxuXHRwdWJsaWMgcm93MTogbnVtYmVyO1xyXG5cdHB1YmxpYyByb3cyOiBudW1iZXI7XHJcblx0Y29uc3RydWN0b3IobTogbnVtYmVyLCByMTogbnVtYmVyLCByMjogbnVtYmVyLCBtdWx0OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcikge1xyXG5cdFx0aWYgKG0gPCByMSB8fCBtIDwgcjIpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ29sdW1uIGluZGV4IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBtYXRyaXggc2l6ZS5cIik7IH1cclxuXHRcdHN1cGVyKG0sIG0pO1xyXG5cdFx0dGhpcy5yb3cxID0gcjE7XHJcblx0XHR0aGlzLnJvdzIgPSByMjtcclxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzW2ldID0gW107XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm07IGorKykge1xyXG5cdFx0XHRcdGlmIChpID09PSBqKSB7XHJcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDEpO1xyXG5cdFx0XHRcdH0gZWxzZSB7IHRoaXMuZWxlbWVudHNbaV1bal0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHR5cGVvZiBtdWx0ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHRoaXMuZWxlbWVudHNbcjFdW3IyXSA9IG5ldyBSYXRpb25hbE51bWJlcihtdWx0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmIChtdWx0IGluc3RhbmNlb2YgUmF0aW9uYWxOdW1iZXIpIHsgdGhpcy5lbGVtZW50c1tyMV1bcjJdID0gbXVsdDsgfVxyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gcGVybXV0YXRpb24gLSBtdWx0aXBseSBvbiB0aGUgcmlnaHQgKEEqUCk7IFJvdy1zd2l0Y2hpbmcgdHJhbnNmb3JtYXRpb25zXHJcbmV4cG9ydCBjbGFzcyBNYXRyaXhQZXJtdXRhdGlvbiBleHRlbmRzIE1hdHJpeCB7XHJcblx0Y29uc3RydWN0b3IobTogbnVtYmVyLCByb3cxOiBudW1iZXIsIHJvdzI6IG51bWJlcikge1xyXG5cdFx0aWYgKG0gPCByb3cxIHx8IG0gPCByb3cyKSB7IHRocm93IG5ldyBFcnJvcihcIkNvbHVtbiBpbmRleCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbWF0cml4IHNpemUuXCIpOyB9XHJcblx0XHRzdXBlcihtLCBtKTtcclxuXHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLm07IGkrKykge1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRzW2ldID0gW107XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCB0aGlzLm07IGorKykge1xyXG5cdFx0XHRcdGlmIChpID09PSBqKSB7XHJcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnRzW2ldW2pdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDEpO1xyXG5cdFx0XHRcdH0gZWxzZSB7IHRoaXMuZWxlbWVudHNbaV1bal0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5lbGVtZW50c1tyb3cxXVtyb3cxXSA9IG5ldyBSYXRpb25hbE51bWJlcigwKTtcclxuXHRcdHRoaXMuZWxlbWVudHNbcm93MV1bcm93Ml0gPSBuZXcgUmF0aW9uYWxOdW1iZXIoMSk7XHJcblx0XHR0aGlzLmVsZW1lbnRzW3JvdzJdW3JvdzJdID0gbmV3IFJhdGlvbmFsTnVtYmVyKDApO1xyXG5cdFx0dGhpcy5lbGVtZW50c1tyb3cyXVtyb3cxXSA9IG5ldyBSYXRpb25hbE51bWJlcigxKTtcclxuXHR9XHJcbn0iLCJleHBvcnQgY2xhc3MgUXVldWU8VD4ge1xyXG5cdHByaXZhdGUgcXVldWU6IFRbXTtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHRoaXMucXVldWUgPSBbXTtcclxuXHR9XHJcblx0cHVibGljIGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZS5sZW5ndGggPT09IDA7XHJcblx0fVxyXG5cdHB1YmxpYyBlbnF1ZXVlKGVsZW1lbnQ6IFQpOiB2b2lkIHtcclxuXHRcdHRoaXMucXVldWUucHVzaChlbGVtZW50KTtcclxuXHR9XHJcblx0cHVibGljIGRlcXVldWUoKTogVCB7XHJcblx0XHRpZiAodGhpcy5pc0VtcHR5KCkpIHsgdGhyb3cgbmV3IEVycm9yKFwiUXVldWUgaXMgZW1wdHlcIik7IH1cclxuXHRcdHJldHVybiB0aGlzLnF1ZXVlLnNoaWZ0KCk7XHJcblx0fVxyXG5cdHB1YmxpYyBwZWVrKCk6IFQge1xyXG5cdFx0aWYgKHRoaXMuaXNFbXB0eSgpKSB7IHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIGlzIGVtcHR5XCIpOyB9XHJcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZVswXTtcclxuXHR9XHJcblx0cHVibGljIHRvQXJyYXkoKTogVFtdIHtcclxuXHRcdHJldHVybiB0aGlzLnF1ZXVlO1xyXG5cdH1cclxufSIsImltcG9ydCB7IFBhcnNlciB9IGZyb20gXCIuL0FyaXRobWV0aWNFdmFsdWF0b3JcIjtcclxuaW1wb3J0IHsgUXVldWUgfSBmcm9tIFwiLi9RdWV1ZVwiO1xyXG5pbXBvcnQgeyBTdGFjayB9IGZyb20gXCIuL1N0YWNrXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgUmF0aW9uYWxOdW1iZXIge1xyXG5cdHB1YmxpYyBzdGF0aWMgdG9SZXZlcnNlUG9saXNoTm90YXRpb24oY29kZTogc3RyaW5nKTogc3RyaW5nW10ge1xyXG5cdFx0Y29uc3QgdG9rZW5zOiBzdHJpbmdbXSA9IGNvZGUubWF0Y2goL1xcKHxcXCl8XFxkKyhcXC5cXGQrKT98XFx3K3xbXFwrXFwtXFwqXFwvXFxeXS9nKTtcclxuXHRcdGxldCBpOiBudW1iZXIgPSAwO1xyXG5cdFx0Y29uc3Qgb3V0cHV0UXVldWU6IFF1ZXVlPHN0cmluZz4gPSBuZXcgUXVldWU8c3RyaW5nPigpO1xyXG5cdFx0Y29uc3Qgb3BlcmF0b3JTdGFjazogU3RhY2s8c3RyaW5nPiA9IG5ldyBTdGFjazxzdHJpbmc+KCk7XHJcblx0XHR3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHtcclxuXHRcdFx0aWYgKHRoaXMuaXNOdW1iZXIodG9rZW5zW2ldKSkge1xyXG5cdFx0XHRcdG91dHB1dFF1ZXVlLmVucXVldWUodG9rZW5zW2ldKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmlzT3BlcmF0b3IodG9rZW5zW2ldKSkge1xyXG5cdFx0XHRcdGNvbnN0IG9wMTogc3RyaW5nID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRcdHdoaWxlICghb3BlcmF0b3JTdGFjay5pc0VtcHR5KCkgJiYgdGhpcy5pc09wZXJhdG9yKG9wZXJhdG9yU3RhY2sucGVlaygpKSkge1xyXG5cdFx0XHRcdFx0aWYgKCh0aGlzLmlzTGVmdEFzc29jaWF0aXZlT3BlcmF0b3Iob3AxKSAmJiAodGhpcy5wcmVjZWRlbmNlKG9wMSkgPD0gdGhpcy5wcmVjZWRlbmNlKG9wZXJhdG9yU3RhY2sucGVlaygpKSkpIHx8XHJcblx0XHRcdFx0XHRcdCh0aGlzLmlzUmlnaHRBc3NvY2lhdGl2ZU9wZXJhdG9yKG9wMSkgJiYgKHRoaXMucHJlY2VkZW5jZShvcDEpIDwgdGhpcy5wcmVjZWRlbmNlKG9wZXJhdG9yU3RhY2sucGVlaygpKSkpKSB7XHJcblx0XHRcdFx0XHRcdG91dHB1dFF1ZXVlLmVucXVldWUob3BlcmF0b3JTdGFjay5wb3AoKSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0b3BlcmF0b3JTdGFjay5wdXNoKG9wMSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodG9rZW5zW2ldID09PSBcIihcIikge1xyXG5cdFx0XHRcdG9wZXJhdG9yU3RhY2sucHVzaCh0b2tlbnNbaV0pO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2Vuc1tpXSA9PT0gXCIpXCIpIHtcclxuXHRcdFx0XHR3aGlsZSAoIW9wZXJhdG9yU3RhY2suaXNFbXB0eSgpICYmIG9wZXJhdG9yU3RhY2sucGVlaygpICE9PSBcIihcIikge1xyXG5cdFx0XHRcdFx0b3V0cHV0UXVldWUuZW5xdWV1ZShvcGVyYXRvclN0YWNrLnBvcCgpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKCFvcGVyYXRvclN0YWNrLmlzRW1wdHkoKSAmJiBvcGVyYXRvclN0YWNrLnBlZWsoKSA9PT0gXCIoXCIpIHtcclxuXHRcdFx0XHRcdG9wZXJhdG9yU3RhY2sucG9wKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgcGFyZW50aGVzZXMuXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpKys7XHJcblx0XHR9XHJcblx0XHR3aGlsZSAoIW9wZXJhdG9yU3RhY2suaXNFbXB0eSgpKSB7XHJcblx0XHRcdGlmIChvcGVyYXRvclN0YWNrLnBlZWsoKSA9PT0gXCIoXCIpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIHBhcmVudGhlc2VzLlwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvdXRwdXRRdWV1ZS5lbnF1ZXVlKG9wZXJhdG9yU3RhY2sucG9wKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb3V0cHV0UXVldWUudG9BcnJheSgpO1xyXG5cdH1cclxuXHRwdWJsaWMgc3RhdGljIGZyb21TdHJpbmcoY29kZTogc3RyaW5nKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0Y29uc3QgcDogUGFyc2VyID0gbmV3IFBhcnNlcigpO1xyXG5cdFx0cmV0dXJuIHAucGFyc2UoY29kZSk7XHJcblx0fVxyXG5cdHB1YmxpYyBzdGF0aWMgZ3JlYXRlc3RDb21tb25EaXZpc29yKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBiID8gUmF0aW9uYWxOdW1iZXIuZ3JlYXRlc3RDb21tb25EaXZpc29yKGIsIGEgJSBiKSA6IGE7XHJcblx0fVxyXG5cdHB1YmxpYyBzdGF0aWMgbGVhc3RDb21tb25NdWx0aXBsZShhOiBudW1iZXIsIGI6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoYSAqIGIgLyBSYXRpb25hbE51bWJlci5ncmVhdGVzdENvbW1vbkRpdmlzb3IoYSwgYikpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBpc051bWJlcihjb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAvXlxcZC8udGVzdChjb2RlKTtcclxuXHR9XHJcblx0cHJpdmF0ZSBzdGF0aWMgaXNPcGVyYXRvcihjb2RlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAvW1xcK1xcLVxcKlxcL1xcXl0vLnRlc3QoY29kZSk7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIGlzTGVmdEFzc29jaWF0aXZlT3BlcmF0b3Iob3BlcmF0b3I6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIC9bXFwrXFwtXFwqXFwvXS8udGVzdChvcGVyYXRvcik7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIGlzUmlnaHRBc3NvY2lhdGl2ZU9wZXJhdG9yKG9wZXJhdG9yOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAvW1xcXl0vLnRlc3Qob3BlcmF0b3IpO1xyXG5cdH1cclxuXHRwcml2YXRlIHN0YXRpYyBwcmVjZWRlbmNlKG9wZXJhdG9yOiBzdHJpbmcpOiBudW1iZXIge1xyXG5cdFx0aWYgKC9bXFwrXFwtXS8udGVzdChvcGVyYXRvcikpIHtcclxuXHRcdFx0cmV0dXJuIDE7XHJcblx0XHR9XHJcblx0XHRpZiAoL1tcXCpcXC9dLy50ZXN0KG9wZXJhdG9yKSkge1xyXG5cdFx0XHRyZXR1cm4gMjtcclxuXHRcdH1cclxuXHRcdGlmICgvW1xcXl0vLnRlc3Qob3BlcmF0b3IpKSB7XHJcblx0XHRcdHJldHVybiAzO1xyXG5cdFx0fVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGVyYXRvci5cIik7XHJcblx0fVxyXG5cdHByaXZhdGUgc3RhdGljIGV2YWx1YXRlRnJvbVJQTih0b2tlbnM6IHN0cmluZ1tdKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0Y29uc3Qgc3RhY2s6IFN0YWNrPFJhdGlvbmFsTnVtYmVyPiA9IG5ldyBTdGFjazxSYXRpb25hbE51bWJlcj4oKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKCF0aGlzLmlzT3BlcmF0b3IodG9rZW5zW2ldKSkge1xyXG5cdFx0XHRcdHN0YWNrLnB1c2gobmV3IFJhdGlvbmFsTnVtYmVyKHBhcnNlRmxvYXQodG9rZW5zW2ldKSkpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnN0IG9wMTogUmF0aW9uYWxOdW1iZXIgPSBzdGFjay5wb3AoKTtcclxuXHRcdFx0XHRjb25zdCBvcDI6IFJhdGlvbmFsTnVtYmVyID0gc3RhY2sucG9wKCk7XHJcblx0XHRcdFx0c3dpdGNoICh0b2tlbnNbaV0pIHtcclxuXHRcdFx0XHRcdGNhc2UgXCIrXCI6IHN0YWNrLnB1c2gob3AyLmFkZChvcDEpKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIFwiLVwiOiBzdGFjay5wdXNoKG9wMi5zdWIob3AxKSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBcIipcIjogc3RhY2sucHVzaChvcDIubXVsdChvcDEpKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIFwiL1wiOiBzdGFjay5wdXNoKG9wMi5kaXYob3AxKSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSBcIl5cIjogc3RhY2sucHVzaChvcDIuZXhwKG9wMS50b051bWJlcigpKSk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0YWNrLnBvcCgpLnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0fVxyXG5cdHB1YmxpYyBudW1lcmF0b3I6IG51bWJlcjtcclxuXHRwdWJsaWMgZGVub21pbmF0b3I6IG51bWJlcjtcclxuXHRjb25zdHJ1Y3RvcihuOiBudW1iZXIsIGQ6IG51bWJlciA9IDEpIHtcclxuXHRcdGlmIChkID09PSAwKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkRpdmlzaW9uIGJ5IHplcm8hXCIpO1xyXG5cdFx0fVxyXG5cdFx0Ly8gdG9kbzogcG90ZW50aWFsIGZvciBvdmVyZmxvdy4gV2hlbiBNYXRoLnNpZ24gYmVjb21lcyBhdmFpbGFibGUgaW4gVHlwZVNjcmlwdCB1c2UgaXQgaW5zdGVhZCBvZiB0aGUgbXVsdGlwbGljYXRpb25cclxuXHRcdGNvbnN0IHNpZ246IG51bWJlciA9IG4gKiBkID49IDAgPyAxIDogLTE7XHJcblx0XHR0aGlzLm51bWVyYXRvciA9IHNpZ24gKiBNYXRoLmFicyhuKTtcclxuXHRcdHRoaXMuZGVub21pbmF0b3IgPSBNYXRoLmFicyhkKTtcclxuXHR9XHJcblx0cHVibGljIHNpbXBsaWZpZWRGb3JtKCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGNvbnN0IGdjZDogbnVtYmVyID0gUmF0aW9uYWxOdW1iZXIuZ3JlYXRlc3RDb21tb25EaXZpc29yKHRoaXMubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yKTtcclxuXHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIodGhpcy5udW1lcmF0b3IgLyBnY2QsIHRoaXMuZGVub21pbmF0b3IgLyBnY2QpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGVxdWFscyh4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3Qgcm4xOiBSYXRpb25hbE51bWJlciA9IHRoaXMuc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gcm4xLm51bWVyYXRvciA9PT0geCAmJiBybjEuZGVub21pbmF0b3IgPT09IDE7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBybjI6IFJhdGlvbmFsTnVtYmVyID0geC5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0XHRyZXR1cm4gcm4xLm51bWVyYXRvciA9PT0gcm4yLm51bWVyYXRvciAmJiBybjEuZGVub21pbmF0b3IgPT09IHJuMi5kZW5vbWluYXRvcjtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGx0KHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBybjE6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yIDwgeCAqIHJuMS5kZW5vbWluYXRvcjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IHJuMjogUmF0aW9uYWxOdW1iZXIgPSB4LnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yICogcm4yLmRlbm9taW5hdG9yIDwgcm4yLm51bWVyYXRvciAqIHJuMS5kZW5vbWluYXRvcjtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGxlKHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBybjE6IFJhdGlvbmFsTnVtYmVyID0gdGhpcy5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yIDw9IHggKiBybjEuZGVub21pbmF0b3I7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBybjI6IFJhdGlvbmFsTnVtYmVyID0geC5zaW1wbGlmaWVkRm9ybSgpO1xyXG5cdFx0XHRyZXR1cm4gcm4xLm51bWVyYXRvciAqIHJuMi5kZW5vbWluYXRvciA8PSBybjIubnVtZXJhdG9yICogcm4xLmRlbm9taW5hdG9yO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgZ3QoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IHJuMTogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIHJuMS5udW1lcmF0b3IgPiB4ICogcm4xLmRlbm9taW5hdG9yO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3Qgcm4yOiBSYXRpb25hbE51bWJlciA9IHguc2ltcGxpZmllZEZvcm0oKTtcclxuXHRcdFx0cmV0dXJuIHJuMS5udW1lcmF0b3IgKiBybjIuZGVub21pbmF0b3IgPiBybjIubnVtZXJhdG9yICogcm4xLmRlbm9taW5hdG9yO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgZ2UoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IHJuMTogUmF0aW9uYWxOdW1iZXIgPSB0aGlzLnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIHJuMS5udW1lcmF0b3IgPj0geCAqIHJuMS5kZW5vbWluYXRvcjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IHJuMjogUmF0aW9uYWxOdW1iZXIgPSB4LnNpbXBsaWZpZWRGb3JtKCk7XHJcblx0XHRcdHJldHVybiBybjEubnVtZXJhdG9yICogcm4yLmRlbm9taW5hdG9yID49IHJuMi5udW1lcmF0b3IgKiBybjEuZGVub21pbmF0b3I7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlXHJcblx0cHVibGljIHJlY2lwcm9jYWwoKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0aWYgKHRoaXMuZGVub21pbmF0b3IgPT09IDApIHsgdGhyb3cgbmV3IEVycm9yKFwiRGl2aXNpb24gYnkgemVybyFcIik7IH1cclxuXHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIodGhpcy5kZW5vbWluYXRvciwgdGhpcy5udW1lcmF0b3IpO1xyXG5cdH1cclxuXHQvLyBhZGRpdGl2ZSBpbnZlcnNlXHJcblx0cHVibGljIG9wcG9zaXRlKCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIodGhpcy5udW1lcmF0b3IgKiAoLTEpLCB0aGlzLmRlbm9taW5hdG9yKTtcclxuXHR9XHJcblx0cHVibGljIGFkZCh4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKCh0aGlzLm51bWVyYXRvciArIHggKiB0aGlzLmRlbm9taW5hdG9yKSwgdGhpcy5kZW5vbWluYXRvcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBsY206IG51bWJlciA9IFJhdGlvbmFsTnVtYmVyLmxlYXN0Q29tbW9uTXVsdGlwbGUodGhpcy5kZW5vbWluYXRvciwgeC5kZW5vbWluYXRvcik7XHJcblx0XHRcdGNvbnN0IG4xOiBudW1iZXIgPSB0aGlzLm51bWVyYXRvciAqIGxjbSAvIHRoaXMuZGVub21pbmF0b3I7XHJcblx0XHRcdGNvbnN0IG4yOiBudW1iZXIgPSB4Lm51bWVyYXRvciAqIGxjbSAvIHguZGVub21pbmF0b3I7XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIobjEgKyBuMiwgbGNtKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIHN1Yih4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKCh0aGlzLm51bWVyYXRvciAtIHggKiB0aGlzLmRlbm9taW5hdG9yKSwgdGhpcy5kZW5vbWluYXRvcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBsY206IG51bWJlciA9IFJhdGlvbmFsTnVtYmVyLmxlYXN0Q29tbW9uTXVsdGlwbGUodGhpcy5kZW5vbWluYXRvciwgeC5kZW5vbWluYXRvcik7XHJcblx0XHRcdGNvbnN0IG4xOiBudW1iZXIgPSB0aGlzLm51bWVyYXRvciAqIGxjbSAvIHRoaXMuZGVub21pbmF0b3I7XHJcblx0XHRcdGNvbnN0IG4yOiBudW1iZXIgPSB4Lm51bWVyYXRvciAqIGxjbSAvIHguZGVub21pbmF0b3I7XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIobjEgLSBuMiwgbGNtKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIG11bHQoeDogbnVtYmVyIHwgUmF0aW9uYWxOdW1iZXIpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcigodGhpcy5udW1lcmF0b3IgKiB4KSwgdGhpcy5kZW5vbWluYXRvcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKCh0aGlzLm51bWVyYXRvciAqIHgubnVtZXJhdG9yKSwgeC5kZW5vbWluYXRvciAqIHRoaXMuZGVub21pbmF0b3IpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgZGl2KHg6IG51bWJlciB8IFJhdGlvbmFsTnVtYmVyKTogUmF0aW9uYWxOdW1iZXIge1xyXG5cdFx0aWYgKHR5cGVvZiB4ID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIoKHRoaXMubnVtZXJhdG9yKSwgdGhpcy5kZW5vbWluYXRvciAqIHgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBSYXRpb25hbE51bWJlcigodGhpcy5udW1lcmF0b3IgKiB4LmRlbm9taW5hdG9yKSwgeC5udW1lcmF0b3IgKiB0aGlzLmRlbm9taW5hdG9yKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cHVibGljIGV4cCh4OiBudW1iZXIgfCBSYXRpb25hbE51bWJlcik6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKHRoaXMubnVtZXJhdG9yICoqIHgsIHRoaXMuZGVub21pbmF0b3IgKiogeCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAodGhpcy5kZW5vbWluYXRvciAhPT0gMSkgeyB0aHJvdyBFcnJvcihcIkV4cG9uZW50aWF0aW9uIHdpdGggcmF0aW9uYWwgcG93ZXJzIG5vdCBzdXBwb3J0ZWQuXCIpOyB9XHJcblx0XHRcdHJldHVybiBuZXcgUmF0aW9uYWxOdW1iZXIodGhpcy5udW1lcmF0b3IgKiogeC5udW1lcmF0b3IsIHRoaXMuZGVub21pbmF0b3IgKiogeC5udW1lcmF0b3IpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgdG9OdW1iZXIoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLm51bWVyYXRvciAvIHRoaXMuZGVub21pbmF0b3I7XHJcblx0fVxyXG5cdHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMubnVtZXJhdG9yLnRvU3RyaW5nKCkgKyAoMSA9PT0gdGhpcy5kZW5vbWluYXRvciA/IFwiXCIgOiBcIi9cIiArIHRoaXMuZGVub21pbmF0b3IudG9TdHJpbmcoKSk7XHJcblx0fVxyXG5cdHB1YmxpYyBkZWVwQ29weSgpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRyZXR1cm4gbmV3IFJhdGlvbmFsTnVtYmVyKHRoaXMubnVtZXJhdG9yLCB0aGlzLmRlbm9taW5hdG9yKTtcclxuXHR9XHJcbn0iLCJleHBvcnQgY2xhc3MgU3RhY2s8VD4ge1xyXG5cdHByaXZhdGUgc3RhY2s6IFRbXTtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHRoaXMuc3RhY2sgPSBbXTtcclxuXHR9XHJcblx0cHVibGljIGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGFjay5sZW5ndGggPT09IDA7XHJcblx0fVxyXG5cdHB1YmxpYyBwdXNoKGVsZW1lbnQ6IFQpOiB2b2lkIHtcclxuXHRcdHRoaXMuc3RhY2sucHVzaChlbGVtZW50KTtcclxuXHR9XHJcblx0cHVibGljIHBvcCgpOiBUIHtcclxuXHRcdGlmICh0aGlzLmlzRW1wdHkoKSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJTdGFjayBpcyBlbXB0eVwiKTsgfVxyXG5cdFx0cmV0dXJuIHRoaXMuc3RhY2sucG9wKCk7XHJcblx0fVxyXG5cdHB1YmxpYyBwZWVrKCk6IFQge1xyXG5cdFx0aWYgKHRoaXMuaXNFbXB0eSgpKSB7IHRocm93IG5ldyBFcnJvcihcIlN0YWNrIGlzIGVtcHR5XCIpOyB9XHJcblx0XHRyZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xyXG5cdH1cclxuXHRwdWJsaWMgdG9BcnJheSgpOiBUW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RhY2s7XHJcblx0fVxyXG59IiwiaW1wb3J0IHsgTWF0cml4IH0gZnJvbSBcIi4vTWF0cml4XCI7XHJcbmltcG9ydCB7IFJhdGlvbmFsTnVtYmVyIH0gZnJvbSBcIi4vUmF0aW9uYWxOdW1iZXJcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBWZWN0b3Ige1xyXG5cdHB1YmxpYyBzdGF0aWMgYXJlTGluZWFybHlJbmRlcGVuZGVudCh2ZWN0b3JzOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgbTogbnVtYmVyID0gdmVjdG9ycy5sZW5ndGg7XHJcblx0XHRpZiAoMCA9PT0gbSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0Y29uc3QgbjogbnVtYmVyID0gdmVjdG9yc1swXS5tO1xyXG5cdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMTsgaSA8IHZlY3RvcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKG4gIT09IHZlY3RvcnNbaV0ubSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGRpbWVuc2lvbnMuXCIpOyB9XHJcblx0XHR9XHJcblx0XHRpZiAobSA+IG4pIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xyXG5cdH1cclxuXHRwdWJsaWMgbTogbnVtYmVyO1xyXG5cdHB1YmxpYyBlbGVtZW50czogUmF0aW9uYWxOdW1iZXJbXTtcclxuXHRjb25zdHJ1Y3RvcihuOiBudW1iZXIgfCBudW1iZXJbXSk7XHJcblx0Y29uc3RydWN0b3IobjogYW55KSB7XHJcblx0XHRpZiAodHlwZW9mIG4gPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0dGhpcy5tID0gbjtcclxuXHRcdFx0dGhpcy5lbGVtZW50cyA9IFtdO1xyXG5cdFx0fSBlbHNlIGlmIChuIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuXHRcdFx0dGhpcy5tID0gbi5sZW5ndGg7XHJcblx0XHRcdHRoaXMuZWxlbWVudHMgPSBbXTtcclxuXHRcdFx0Zm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMubTsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5lbGVtZW50c1tpXSA9IG5ldyBSYXRpb25hbE51bWJlcihuW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRwdWJsaWMgYWRkKHg6IFZlY3Rvcik6IFZlY3RvciB7XHJcblx0XHRpZiAodGhpcy5tICE9PSB4Lm0pIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBkaW1lbnNpb25zLlwiKTsgfVxyXG5cdFx0Y29uc3QgcmVzOiBWZWN0b3IgPSBuZXcgVmVjdG9yKHRoaXMubSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgcmVzLm07IGkrKykge1xyXG5cdFx0XHRyZXMuZWxlbWVudHNbaV0gPSB0aGlzLmVsZW1lbnRzW2ldLmFkZCh4LmVsZW1lbnRzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG5cdHB1YmxpYyBzdWIoeDogVmVjdG9yKTogVmVjdG9yIHtcclxuXHRcdGlmICh0aGlzLm0gIT09IHgubSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGRpbWVuc2lvbnMuXCIpOyB9XHJcblx0XHRjb25zdCByZXM6IFZlY3RvciA9IG5ldyBWZWN0b3IodGhpcy5tKTtcclxuXHRcdGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCByZXMubTsgaSsrKSB7XHJcblx0XHRcdHJlcy5lbGVtZW50c1tpXSA9IHRoaXMuZWxlbWVudHNbaV0uc3ViKHguZWxlbWVudHNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblx0cHVibGljIG11bHQoeDogUmF0aW9uYWxOdW1iZXIpOiBWZWN0b3Ige1xyXG5cdFx0Y29uc3QgcmVzOiBWZWN0b3IgPSBuZXcgVmVjdG9yKHRoaXMubSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgcmVzLm07IGkrKykge1xyXG5cdFx0XHRyZXMuZWxlbWVudHNbaV0gPSB0aGlzLmVsZW1lbnRzW2ldLm11bHQoeCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxuXHQvLyBbQUxJQVNFU106IGlubmVyUHJvZHVjdCwgcHJvamVjdGlvblByb2R1Y3QsIHNjYWxhclByb2R1Y3RcclxuXHRwdWJsaWMgZG90UHJvZHVjdCh4OiBWZWN0b3IpOiBSYXRpb25hbE51bWJlciB7XHJcblx0XHRpZiAodGhpcy5tICE9PSB4Lm0pIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBkaW1lbnNpb25zLlwiKTsgfVxyXG5cdFx0bGV0IHJlczogUmF0aW9uYWxOdW1iZXIgPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgeC5tOyBpKyspIHtcclxuXHRcdFx0cmVzID0gcmVzLmFkZCh0aGlzLmVsZW1lbnRzW2ldLm11bHQoeC5lbGVtZW50c1tpXSkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcblx0Ly8gW0FMSUFTRVNdOiBkaXJlY3RlZEFyZWFQcm9kdWN0LCB2ZWN0b3JQcm9kdWN0XHJcblx0cHVibGljIGNyb3NzUHJvZHVjdCh4OiBWZWN0b3IpOiBWZWN0b3Ige1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcclxuXHR9XHJcblx0Ly8gW0FMSUFTRVNdOiBtYWduaXR1ZGUsIG5vcm1cclxuXHRwdWJsaWMgbGVuZ3RoKCk6IFJhdGlvbmFsTnVtYmVyIHtcclxuXHRcdGNvbnN0IGxlbmd0aDogUmF0aW9uYWxOdW1iZXIgPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0bGVuZ3RoLmFkZCh0aGlzLmVsZW1lbnRzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBsZW5ndGg7XHJcblx0fVxyXG5cdHB1YmxpYyBkZWVwQ29weSgpOiBWZWN0b3Ige1xyXG5cdFx0Y29uc3QgcmV0OiBWZWN0b3IgPSBuZXcgVmVjdG9yKHRoaXMubSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0cmV0LmVsZW1lbnRzW2ldID0gdGhpcy5lbGVtZW50c1tpXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG5cdHB1YmxpYyB0b01hdHJpeCgpOiBNYXRyaXgge1xyXG5cdFx0Y29uc3QgcmV0OiBNYXRyaXggPSBuZXcgTWF0cml4KHRoaXMubSwgMSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0cmV0LmVsZW1lbnRzW2ldWzBdID0gdGhpcy5lbGVtZW50c1tpXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXQ7XHJcblx0fVxyXG59XHJcbmV4cG9ydCBjbGFzcyBDb2x1bW5WZWN0b3IgZXh0ZW5kcyBWZWN0b3Ige1xyXG59XHJcbmV4cG9ydCBjbGFzcyBSb3dWZWN0b3IgZXh0ZW5kcyBWZWN0b3Ige1xyXG5cdHB1YmxpYyBtYXRyaXhQcm9kdWN0KG06IE1hdHJpeCk6IFJvd1ZlY3RvciB7XHJcblx0XHRpZiAodGhpcy5tICE9PSBtLm4pIHsgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBkaW1lbnNpb25zLlwiKTsgfVxyXG5cdFx0Y29uc3QgcmVzOiBSb3dWZWN0b3IgPSBuZXcgUm93VmVjdG9yKHRoaXMubSk7XHJcblx0XHRmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgdGhpcy5tOyBpKyspIHtcclxuXHRcdFx0bGV0IHN1bTogUmF0aW9uYWxOdW1iZXIgPSBuZXcgUmF0aW9uYWxOdW1iZXIoMCk7XHJcblx0XHRcdGZvciAobGV0IGo6IG51bWJlciA9IDA7IGogPCBtLm47IGorKykge1xyXG5cdFx0XHRcdHN1bSA9IHN1bS5hZGQobS5lbGVtZW50c1tpXVtqXS5tdWx0KHRoaXMuZWxlbWVudHNbaV0pKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXMuZWxlbWVudHNbaV0gPSBzdW07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxufSJdLCJzb3VyY2VSb290IjoiIn0=